// Code generated by scripts/generate_stdpkg_candidates/main.go; DO NOT EDIT.
// Version: go1.25.1

package completer

import "github.com/kakkky/gonsole/types"

var stdPkgCandidates = &candidates{
	Pkgs: []types.PkgName{
		"goarch",
		"unsafe",
		"abi",
		"unsafeheader",
		"cpu",
		"bytealg",
		"byteorder",
		"chacha8rand",
		"rtcov",
		"godebugs",
		"goexperiment",
		"goos",
		"profilerecord",
		"atomic",
		"exithook",
		"gc",
		"asan",
		"msan",
		"race",
		"math",
		"sys",
		"maps",
		"strconv",
		"stringslite",
		"tracev2",
		"runtime",
		"reflectlite",
		"errors",
		"atomic",
		"sync",
		"synctest",
		"sync",
		"io",
		"iter",
		"bits",
		"unicode",
		"utf8",
		"bytes",
		"cmp",
		"itoa",
		"math",
		"strconv",
		"reflect",
		"slices",
		"fmtsort",
		"oserror",
		"path",
		"bisect",
		"godebug",
		"syscall",
		"time",
		"fs",
		"filepathlite",
		"unix",
		"poll",
		"execenv",
		"testlog",
		"os",
		"fmt",
		"maps",
		"strings",
		"user",
		"filepath",
		"tar",
		"bufio",
		"sort",
		"flate",
		"binary",
		"hash",
		"crc32",
		"zip",
		"bzip2",
		"gzip",
		"lzw",
		"adler32",
		"zlib",
		"heap",
		"list",
		"ring",
		"context",
		"crypto",
		"godebug",
		"fips140",
		"alias",
		"byteorder",
		"cpu",
		"impl",
		"sha256",
		"subtle",
		"sha3",
		"sha512",
		"hmac",
		"check",
		"aes",
		"sysrand",
		"entropy",
		"rand",
		"randutil",
		"drbg",
		"gcm",
		"fips140only",
		"subtle",
		"cipher",
		"sig",
		"boring",
		"aes",
		"des",
		"rand",
		"big",
		"dsa",
		"fiat",
		"nistec",
		"ecdh",
		"field",
		"ecdh",
		"elliptic",
		"bbig",
		"bigmod",
		"ecdsa",
		"weak",
		"fips140cache",
		"sha3",
		"fips140hash",
		"sha512",
		"utf16",
		"asn1",
		"ecdsa",
		"edwards25519",
		"ed25519",
		"rand",
		"ed25519",
		"fips140",
		"hkdf",
		"hkdf",
		"hmac",
		"bcache",
		"encoding",
		"base64",
		"json",
		"flag",
		"cfg",
		"platform",
		"exec",
		"sysinfo",
		"debug",
		"trace",
		"testing",
		"testenv",
		"testhash",
		"cryptotest",
		"checktest",
		"mlkem",
		"pbkdf2",
		"rsa",
		"ssh",
		"tls12",
		"tls13",
		"fipsdeps",
		"fipstest",
		"hpke",
		"seccomp",
		"md5",
		"mlkem",
		"pbkdf2",
		"rc4",
		"rsa",
		"sha1",
		"sha256",
		"fips140tls",
		"macOS",
		"hex",
		"pkix",
		"pem",
		"nettrace",
		"unique",
		"netip",
		"routebsd",
		"singleflight",
		"net",
		"url",
		"x509",
		"tls",
		"driver",
		"sql",
		"dwarf",
		"saferio",
		"zstd",
		"elf",
		"macho",
		"pe",
		"plan9obj",
		"xcoff",
		"buildinfo",
		"gosym",
		"embed",
		"embedtest",
		"ascii85",
		"base32",
		"csv",
		"gob",
		"xml",
		"internal",
		"log",
		"textproto",
		"mime",
		"quotedprintable",
		"multipart",
		"httptrace",
		"internal",
		"ascii",
		"httpcommon",
		"http",
		"expvar",
		"token",
		"scanner",
		"ast",
		"constraint",
		"comment",
		"syntax",
		"regexp",
		"lazyregexp",
		"doc",
		"parser",
		"buildcfg",
		"goroot",
		"goversion",
		"syslist",
		"build",
		"constant",
		"tabwriter",
		"printer",
		"format",
		"gover",
		"version",
		"errors",
		"types",
		"scanner",
		"gccgoimporter",
		"exportdata",
		"pkgbits",
		"gcimporter",
		"srcimporter",
		"importer",
		"crc64",
		"fnv",
		"maphash",
		"html",
		"parse",
		"template",
		"template",
		"color",
		"image",
		"palette",
		"imageutil",
		"draw",
		"gif",
		"jpeg",
		"png",
		"suffixarray",
		"copyright",
		"coverage",
		"calloc",
		"cmerge",
		"cformat",
		"slicereader",
		"uleb128",
		"stringtab",
		"decodecounter",
		"decodemeta",
		"slicewriter",
		"encodecounter",
		"encodemeta",
		"pods",
		"cfile",
		"test",
		"dag",
		"diff",
		"fuzz",
		"lazytemplate",
		"obscuretestdata",
		"profile",
		"cgroup",
		"wasi",
		"testpty",
		"version",
		"tracev1",
		"trace",
		"raw",
		"txtar",
		"testgen",
		"testtrace",
		"format",
		"traceviewer",
		"ioutil",
		"internal",
		"buffer",
		"slog",
		"benchmarks",
		"syslog",
		"asmgen",
		"cmplx",
		"cgi",
		"cookiejar",
		"fcgi",
		"testcert",
		"httptest",
		"httputil",
		"pprof",
		"pprof",
		"cgo",
		"cgotest",
		"socktest",
		"mail",
		"rpc",
		"jsonrpc",
		"smtp",
		"fdtest",
		"signal",
		"plugin",
		"example1",
		"example2",
		"coverage",
		"metrics",
		"race",
		"structs",
		"iotest",
		"fstest",
		"testdeps",
		"quick",
		"slogtest",
		"synctest",
		"tzdata",
	},
	Funcs: map[types.PkgName][]funcSet{
		"time": []funcSet{
			funcSet{
				Name:        "After",
				Description: "After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to [NewTimer](d).C. Before Go 1.23, this documentation warned that the underlying [Timer] would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call [Timer.Stop] if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "<-chan time.Time",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AfterFunc",
				Description: "AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a [Timer] that can be used to cancel the call using its Stop method. The returned Timer's C field is not used and will be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Timer",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "Date",
				Description: "Date returns the year, month, and day in which t occurs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "FixedZone",
				Description: "FixedZone returns a [Location] that always uses the given zone name and offset (seconds east of UTC). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Location",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "LoadLocation",
				Description: "LoadLocation returns the Location with the given name. If the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local. Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\". LoadLocation looks for the IANA Time Zone database in the following locations in order: - the directory or uncompressed zip file named by the ZONEINFO environment variable - on a Unix system, the system standard installation location - $GOROOT/lib/time/zoneinfo.zip - the time/tzdata package, if it was imported ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Location",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadLocationFromTZData",
				Description: "LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Location",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewTicker",
				Description: "NewTicker returns a new [Ticker] containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Before Go 1.23, the garbage collector did not recover tickers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTicker, to make the ticker recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the ticker for other reasons.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ticker",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "NewTimer",
				Description: "NewTimer creates a new Timer that will send the current time on its channel after at least duration d. Before Go 1.23, the garbage collector did not recover timers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTimer, to make the timer recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced timers, even if they haven't expired or been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the timer for other reasons.) Before Go 1.23, the channel associated with a Timer was asynchronous (buffered, capacity 1), which meant that stale time values could be received even after [Timer.Stop] or [Timer.Reset] returned. As of Go 1.23, the channel is synchronous (unbuffered, capacity 0), eliminating the possibility of those stale values. The GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors: when set, unexpired timers won't be garbage collected, and channels will have buffered capacity. This setting may be removed in Go 1.27 or later. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Timer",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "Now",
				Description: "Now returns the current local time. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses a formatted string and returns the time value it represents. See the documentation for the constant called [Layout] to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument. The example for [Time.Format] demonstrates the working of the layout string in detail and is a good reference. When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision. Elements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored. For layouts specifying the two-digit year 06, a value NN >= 69 will be treated as 19NN and a value NN < 69 will be treated as 20NN. The remainder of this comment describes the handling of time zones. In the absence of a time zone indicator, Parse returns a time in UTC. When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location ([Local]), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset. When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use [ParseInLocation]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseDuration",
				Description: "ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"Âµs\"), \"ms\", \"s\", \"m\", \"h\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseInLocation",
				Description: "ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Since",
				Description: "Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "Sleep",
				Description: "Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Tick",
				Description: "Tick is a convenience wrapper for [NewTicker] providing access to the ticking channel only. Unlike NewTicker, Tick will return nil if d <= 0. Before Go 1.23, this documentation warned that the underlying [Ticker] would never be recovered by the garbage collector, and that if efficiency was a concern, code should use NewTicker instead and call [Ticker.Stop] when the ticker is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. There is no longer any reason to prefer NewTicker when Tick will do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "<-chan time.Time",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unix",
				Description: "Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "UnixMicro",
				Description: "UnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "UnixMilli",
				Description: "UnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "Until",
				Description: "Until returns the duration until t. It is shorthand for t.Sub(time.Now()). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
		},
		"hmac": []funcSet{
			funcSet{
				Name:        "MarkAsUsedInKDF",
				Description: "MarkAsUsedInKDF records that this HMAC instance is used as part of a KDF. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new HMAC hash using the given [hash.Hash] type and key. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "HMAC",
						TypePkgName: "hmac",
					},
				},
			},
			funcSet{
				Name:        "Equal",
				Description: "Equal compares two MACs for equality without leaking timing information. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new HMAC hash using the given [hash.Hash] type and key. New functions like [crypto/sha256.New] can be used as h. h must return a new Hash every time it is called. Note that unlike other hash implementations in the standard library, the returned Hash does not implement [encoding.BinaryMarshaler] or [encoding.BinaryUnmarshaler]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
		},
		"testlog": []funcSet{
			funcSet{
				Name:        "Getenv",
				Description: "Getenv calls Logger().Getenv, if a logger has been set. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Logger",
				Description: "Logger returns the current test logger implementation. It returns nil if there is no logger. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "testlog",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open calls Logger().Open, if a logger has been set. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "PanicOnExit0",
				Description: "PanicOnExit0 reports whether to panic on a call to os.Exit(0). This is in the testlog package because, like other definitions in package testlog, it is a hook between the testing package and the os package. This is used to ensure that an early call to os.Exit(0) does not cause a test to pass. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetLogger",
				Description: "SetLogger sets the test logger implementation for the current process. It must be called only once, at process startup. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetPanicOnExit0",
				Description: "SetPanicOnExit0 sets panicOnExit0 to v. SetPanicOnExit0 should be an internal detail, but alternate implementations of go test in other build systems may need to access it using linkname. Do not remove or change the type signature. See go.dev/issue/67401. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Stat",
				Description: "Stat calls Logger().Stat, if a logger has been set. ",
				Returns:     []returnSet{},
			},
		},
		"net": []funcSet{
			funcSet{
				Name:        "CIDRMask",
				Description: "CIDRMask returns an [IPMask] consisting of 'ones' 1 bits followed by 0s up to a total length of 'bits' bits. For a mask of this form, CIDRMask is the inverse of [IPMask.Size]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPMask",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "Dial",
				Description: "Dial connects to the address on the named network. Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\". For TCP and UDP networks, the address has the form \"host:port\". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions [JoinHostPort] and [SplitHostPort] manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds. Examples: Dial(\"tcp\", \"golang.org:http\") Dial(\"tcp\", \"192.0.2.1:http\") Dial(\"tcp\", \"198.51.100.1:80\") Dial(\"udp\", \"[2001:db8::1]:domain\") Dial(\"udp\", \"[fe80::1%lo0]:53\") Dial(\"tcp\", \":80\") For IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a literal protocol number or a protocol name, and the address has the form \"host\". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as \"0\" or \"255\". Examples: Dial(\"ip4:1\", \"192.0.2.1\") Dial(\"ip6:ipv6-icmp\", \"2001:db8::1\") Dial(\"ip6:58\", \"fe80::1%lo0\") For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for TCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is assumed. For Unix networks, the address must be a file system path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialIP",
				Description: "DialIP acts like [Dial] for IP networks. The network must be an IP network name; see func Dial for details. If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialTCP",
				Description: "DialTCP acts like [Dial] for TCP networks. The network must be a TCP network name; see func Dial for details. If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialTimeout",
				Description: "DialTimeout acts like [Dial] but takes a timeout. The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. See func Dial for a description of the network and address parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialUDP",
				Description: "DialUDP acts like [Dial] for UDP networks. The network must be a UDP network name; see func [Dial] for details. If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UDPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialUnix",
				Description: "DialUnix acts like [Dial] for Unix networks. The network must be a Unix network name; see func [Dial] for details. If laddr is non-nil, it is used as the local address for the connection. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FileConn",
				Description: "FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FileListener",
				Description: "FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Listener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FilePacketConn",
				Description: "FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PacketConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IPv4",
				Description: "IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "IPv4Mask",
				Description: "IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPMask",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "InterfaceAddrs",
				Description: "InterfaceAddrs returns a list of the system's unicast interface addresses. The returned list does not identify the associated interface; use Interfaces and [Interface.Addrs] for more detail. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.Addr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InterfaceByIndex",
				Description: "InterfaceByIndex returns the interface specified by index. On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use [InterfaceByName]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InterfaceByName",
				Description: "InterfaceByName returns the interface specified by name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Interfaces",
				Description: "Interfaces returns a list of the system's network interfaces. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.Interface",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "JoinHostPort",
				Description: "JoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"[host]:port\". See func Dial for a description of the host and port parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Listen",
				Description: "Listen announces on the local network address. See func Listen for a description of the network and address parameters. The ctx argument is used while resolving the address on which to listen; it does not affect the returned Listener. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Listener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenIP",
				Description: "ListenIP acts like [ListenPacket] for IP networks. The network must be an IP network name; see func Dial for details. If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenMulticastUDP",
				Description: "ListenMulticastUDP acts like [ListenPacket] for UDP networks but takes a group address on a specific network interface. The network must be a UDP network name; see func [Dial] for details. ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen. ListenMulticastUDP is just for convenience of simple, small applications. There are [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] packages for general purpose uses. Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UDPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenPacket",
				Description: "ListenPacket announces on the local network address. See func ListenPacket for a description of the network and address parameters. The ctx argument is used while resolving the address on which to listen; it does not affect the returned PacketConn. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PacketConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenTCP",
				Description: "ListenTCP acts like [Listen] for TCP networks. The network must be a TCP network name; see func Dial for details. If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPListener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenUDP",
				Description: "ListenUDP acts like [ListenPacket] for UDP networks. The network must be a UDP network name; see func [Dial] for details. If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UDPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenUnix",
				Description: "ListenUnix acts like [Listen] for Unix networks. The network must be \"unix\" or \"unixpacket\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixListener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenUnixgram",
				Description: "ListenUnixgram acts like [ListenPacket] for Unix networks. The network must be \"unixgram\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupAddr",
				Description: "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom [Resolver]. LookupAddr uses [context.Background] internally; to specify the context, use [Resolver.LookupAddr]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupCNAME",
				Description: "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call [LookupHost] or [LookupIP] directly; both take care of resolving the canonical name as part of the lookup. A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records. The returned canonical name is validated to be a properly formatted presentation-format domain name. LookupCNAME uses [context.Background] internally; to specify the context, use [Resolver.LookupCNAME]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupHost",
				Description: "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. LookupHost uses [context.Background] internally; to specify the context, use [Resolver.LookupHost]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupIP",
				Description: "LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IP",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupMX",
				Description: "LookupMX returns the DNS MX records for the given domain name sorted by preference. The returned mail server names are validated to be properly formatted presentation-format domain names, or numeric IP addresses. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. LookupMX uses [context.Background] internally; to specify the context, use [Resolver.LookupMX]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.MX",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupNS",
				Description: "LookupNS returns the DNS NS records for the given domain name. The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. LookupNS uses [context.Background] internally; to specify the context, use [Resolver.LookupNS]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.NS",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupPort",
				Description: "LookupPort looks up the port for the given network and service. LookupPort uses [context.Background] internally; to specify the context, use [Resolver.LookupPort]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupSRV",
				Description: "LookupSRV tries to resolve an [SRV] query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority. LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]*net.SRV",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupTXT",
				Description: "LookupTXT returns the DNS TXT records for the given domain name. If a DNS TXT record holds multiple strings, they are concatenated as a single string. LookupTXT uses [context.Background] internally; to specify the context, use [Resolver.LookupTXT]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCIDR",
				Description: "ParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291. It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address 192.0.2.1 and the network 192.0.2.0/24. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "IPNet",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseIP",
				Description: "ParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv4-mapped IPv6 (\"::ffff:192.0.2.1\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. The returned address is always 16 bytes, IPv4 addresses are returned in IPv4-mapped IPv6 form. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "ParseMAC",
				Description: "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats: 00:00:5e:00:53:01 02:00:5e:10:00:00:00:01 00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01 00-00-5e-00-53-01 02-00-5e-10-00-00-00-01 00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01 0000.5e00.5301 0200.5e10.0000.0001 0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "HardwareAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pipe",
				Description: "Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the [Conn] interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "ResolveIPAddr",
				Description: "ResolveIPAddr returns an address of IP end point. The network must be an IP network name. If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. See func [Dial] for a description of the network and address parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResolveTCPAddr",
				Description: "ResolveTCPAddr returns an address of TCP end point. The network must be a TCP network name. If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. See func [Dial] for a description of the network and address parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResolveUDPAddr",
				Description: "ResolveUDPAddr returns an address of UDP end point. The network must be a UDP network name. If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. See func [Dial] for a description of the network and address parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResolveUnixAddr",
				Description: "ResolveUnixAddr returns an address of Unix domain socket end point. The network must be a Unix network name. See func [Dial] for a description of the network and address parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitHostPort",
				Description: "SplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone and port. A literal IPv6 address in hostport must be enclosed in square brackets, as in \"[::1]:80\", \"[::1%lo0]:80\". See func Dial for a description of the hostport parameter, and host and port results. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TCPAddrFromAddrPort",
				Description: "TCPAddrFromAddrPort returns addr as a [TCPAddr]. If addr.IsValid() is false, then the returned TCPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPAddr",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "UDPAddrFromAddrPort",
				Description: "UDPAddrFromAddrPort returns addr as a [UDPAddr]. If addr.IsValid() is false, then the returned UDPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
				},
			},
		},
		"gosym": []funcSet{
			funcSet{
				Name:        "NewLineTable",
				Description: "NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment, with the exact value stored in the 'runtime.text' symbol. This value may differ from the start address of the text segment if binary was built with cgo enabled. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "LineTable",
						TypePkgName: "gosym",
					},
				},
			},
			funcSet{
				Name:        "NewTable",
				Description: "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Table",
						TypePkgName: "gosym",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"mail": []funcSet{
			funcSet{
				Name:        "ParseAddress",
				Description: "ParseAddress parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\" ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Address",
						TypePkgName: "mail",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseAddressList",
				Description: "ParseAddressList parses the given string as a list of addresses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/mail.Address",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseDate",
				Description: "ParseDate parses an RFC 5322 date string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadMessage",
				Description: "ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Message",
						TypePkgName: "mail",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sys": []funcSet{
			funcSet{
				Name:        "Bswap32",
				Description: "Bswap32 returns its input with byte order reversed 0x01020304 -> 0x04030201 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Bswap64",
				Description: "Bswap64 returns its input with byte order reversed 0x0102030405060708 -> 0x0807060504030201 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DITEnabled",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DisableDIT",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "EnableDIT",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetCallerPC",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetCallerSP",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetClosurePtr",
				Description: "GetClosurePtr returns the pointer to the current closure. GetClosurePtr can only be used in an assignment statement at the entry of a function. Moreover, go:nosplit directive must be specified at the declaration of caller function, so that the function prolog does not clobber the closure register. for example: //go:nosplit func f(arg1, arg2, arg3 int) { dx := GetClosurePtr() } The compiler rewrites calls to this function into instructions that fetch the pointer from a well-known register (DX on x86 architecture, etc.) directly. WARNING: PGO-based devirtualization cannot detect that caller of GetClosurePtr requires closure context, and thus must maintain a list of these functions, which is in cmd/compile/internal/devirtualize/pgo.maybeDevirtualizeFunctionCall. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros64",
				Description: "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros8",
				Description: "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len64",
				Description: "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0. nosplit because this is used in src/runtime/histogram.go, which make run in sensitive contexts. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len8",
				Description: "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount64",
				Description: "OnesCount64 returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Prefetch",
				Description: "Prefetch prefetches data from memory addr to cache AMD64: Produce PREFETCHT0 instruction ARM64: Produce PRFM instruction with PLDL1KEEP option ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "PrefetchStreamed",
				Description: "PrefetchStreamed prefetches data from memory addr, with a hint that this data is being streamed. That is, it is likely to be accessed very soon, but only once. If possible, this will avoid polluting the cache. AMD64: Produce PREFETCHNTA instruction ARM64: Produce PRFM instruction with PLDL1STRM option ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TrailingZeros32",
				Description: "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros64",
				Description: "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros8",
				Description: "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"jsonrpc": []funcSet{
			funcSet{
				Name:        "Dial",
				Description: "Dial connects to a JSON-RPC server at the specified network address. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewClient",
				Description: "NewClient returns a new [rpc.Client] to handle requests to the set of services at the other end of the connection. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "NewClientCodec",
				Description: "NewClientCodec returns a new [rpc.ClientCodec] using JSON-RPC on conn. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientCodec",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "NewServerCodec",
				Description: "NewServerCodec returns a new [rpc.ServerCodec] using JSON-RPC on conn. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ServerCodec",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "ServeConn",
				Description: "ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ",
				Returns:     []returnSet{},
			},
		},
		"os": []funcSet{
			funcSet{
				Name:        "Chdir",
				Description: "Chdir changes the current working directory to the named directory. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chmod",
				Description: "Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type [*PathError]. A different subset of the mode bits are used, depending on the operating system. On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and [ModeSticky] are used. On Windows, only the 0o200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0o400 for a read-only file and 0o600 for a readable+writable file. On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive], and [ModeTemporary] are used. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chown",
				Description: "Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type [*PathError]. On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or [syscall.EPLAN9] error, wrapped in [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chtimes",
				Description: "Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. A zero [time.Time] value will leave the corresponding file time unchanged. The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clearenv",
				Description: "Clearenv deletes all environment variables. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "CopyFS",
				Description: "CopyFS copies the file system fsys into the directory dir, creating dir if necessary. Files are created with mode 0o666 plus any execute permissions from the source, and directories are created with mode 0o777 (before umask). CopyFS will not overwrite existing files. If a file name in fsys already exists in the destination, CopyFS will return an error such that errors.Is(err, fs.ErrExist) will be true. Symbolic links in dir are followed. New files added to fsys (including if dir is a subdirectory of fsys) while CopyFS is running are not guaranteed to be copied. Copying stops at and returns the first error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Create",
				Description: "Create creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0o666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode [O_RDWR]. The directory containing the file must already exist. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CreateTemp",
				Description: "CreateTemp creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting file. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"*\", the random string replaces the last \"*\". The file is created with mode 0o600 (before umask). If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir]. Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file. The caller can use the file's Name method to find the pathname of the file. It is the caller's responsibility to remove the file when it is no longer needed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DirFS",
				Description: "DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir. Note that DirFS(\"/prefix\") only guarantees that the Open calls it makes to the operating system will begin with \"/prefix\": DirFS(\"/prefix\").Open(\"file\") is the same as os.Open(\"/prefix/file\"). So if /prefix/file is a symbolic link pointing outside the /prefix tree, then using DirFS does not stop the access any more than using os.Open does. Additionally, the root of the fs.FS returned for a relative path, DirFS(\"prefix\"), will be affected by later calls to Chdir. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content. Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links. The directory dir must not be \"\". The result implements [io/fs.StatFS], [io/fs.ReadFileFS], [io/fs.ReadDirFS], and [io/fs.ReadLinkFS]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FS",
						TypePkgName: "fs",
					},
				},
			},
			funcSet{
				Name:        "Environ",
				Description: "Environ returns a copy of strings representing the environment, in the form \"key=value\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Executable",
				Description: "Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, [path/filepath.EvalSymlinks] might help. Executable returns an absolute path unless an error occurred. The main use case is finding resources located relative to an executable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exit",
				Description: "Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. For portability, the status code should be in the range [0, 125]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Expand",
				Description: "Expand replaces ${var} or $var in the string based on the mapping function. For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ExpandEnv",
				Description: "ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FindProcess",
				Description: "FindProcess looks for a running process by its pid. The [Process] it returns can be used to obtain information about the underlying operating system process. On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists. To test whether the process actually exists, see whether p.Signal(syscall.Signal(0)) reports an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Process",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getegid",
				Description: "Getegid returns the numeric effective group id of the caller. On Windows, it returns -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getenv",
				Description: "Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use [LookupEnv]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Geteuid",
				Description: "Geteuid returns the numeric effective user id of the caller. On Windows, it returns -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgid",
				Description: "Getgid returns the numeric group id of the caller. On Windows, it returns -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgroups",
				Description: "Getgroups returns a list of the numeric ids of groups that the caller belongs to. On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package for a possible alternative. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpagesize",
				Description: "Getpagesize returns the underlying system's memory page size. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpid",
				Description: "Getpid returns the process id of the caller. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getppid",
				Description: "Getppid returns the process id of the caller's parent. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getuid",
				Description: "Getuid returns the numeric user id of the caller. On Windows, it returns -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getwd",
				Description: "Getwd returns an absolute path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them. On Unix platforms, if the environment variable PWD provides an absolute name, and it is a name of the current directory, it is returned. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Hostname",
				Description: "Hostname returns the host name reported by the kernel. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsExist",
				Description: "IsExist returns a boolean indicating whether its argument is known to report that a file or directory already exists. It is satisfied by [ErrExist] as well as some syscall errors. This function predates [errors.Is]. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrExist). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsNotExist",
				Description: "IsNotExist returns a boolean indicating whether its argument is known to report that a file or directory does not exist. It is satisfied by [ErrNotExist] as well as some syscall errors. This function predates [errors.Is]. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrNotExist). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPathSeparator",
				Description: "IsPathSeparator reports whether c is a directory separator character. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPermission",
				Description: "IsPermission returns a boolean indicating whether its argument is known to report that permission is denied. It is satisfied by [ErrPermission] as well as some syscall errors. This function predates [errors.Is]. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrPermission). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsTimeout",
				Description: "IsTimeout returns a boolean indicating whether its argument is known to report that a timeout occurred. This function predates [errors.Is], and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as [os.ErrDeadlineExceeded]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lchown",
				Description: "Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type [*PathError]. On Windows, it always returns the [syscall.EWINDOWS] error, wrapped in [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Link",
				Description: "Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupEnv",
				Description: "LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lstat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mkdir",
				Description: "Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MkdirAll",
				Description: "MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MkdirTemp",
				Description: "MkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a \"*\", the random string replaces the last \"*\" instead. The directory is created with mode 0o700 (before umask). If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewFile",
				Description: "NewFile returns a new [File] with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. NewFile's behavior differs on some platforms: - On Unix, if fd is in non-blocking mode, NewFile will attempt to return a pollable file. - On Windows, if fd is opened for asynchronous I/O (that is, [syscall.FILE_FLAG_OVERLAPPED] has been specified in the [syscall.CreateFile] call), NewFile will attempt to return a pollable file by associating fd with the Go runtime I/O completion port. The I/O operations will be performed synchronously if the association fails. Only pollable files support [File.SetDeadline], [File.SetReadDeadline], and [File.SetWriteDeadline]. After passing it to NewFile, fd may become invalid under the same conditions described in the comments of [File.Fd], and the same constraints apply. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
				},
			},
			funcSet{
				Name:        "NewSyscallError",
				Description: "NewSyscallError returns, as an error, a new [SyscallError] with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode [O_RDONLY]. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenFile",
				Description: "OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag is passed, it is created with mode perm (before umask); the containing directory must exist. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenInRoot",
				Description: "OpenInRoot opens the file name in the directory dir. It is equivalent to OpenRoot(dir) followed by opening the file in the root. OpenInRoot returns an error if any component of the name references a location outside of dir. See [Root] for details and limitations. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenRoot",
				Description: "OpenRoot opens the named directory. It follows symbolic links in the directory name. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Root",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pipe",
				Description: "Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadDir",
				Description: "ReadDir reads the contents of the directory associated with the file f and returns a slice of [DirEntry] values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory. If n > 0, ReadDir returns at most n DirEntry records. In this case, if ReadDir returns an empty slice, it will return an error explaining why. At the end of a directory, the error is [io.EOF]. If n <= 0, ReadDir returns all the DirEntry records remaining in the directory. When it succeeds, it returns a nil error (not io.EOF). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]os.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFile",
				Description: "The ReadFile method calls the [ReadFile] function for the file with the given name in the directory. The function provides robust handling for small files and special file systems. Through this method, dirFS implements [io/fs.ReadFileFS]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Readlink",
				Description: "Readlink returns the destination of the named symbolic link. If there is an error, it will be of type [*PathError]. If the link destination is relative, Readlink returns the relative path without resolving it to an absolute one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Remove",
				Description: "Remove removes the named file or (empty) directory. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RemoveAll",
				Description: "RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rename",
				Description: "Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. If newpath already exists and is a directory, Rename returns an error. OS-specific restrictions may apply when oldpath and newpath are in different directories. Even within the same directory, on non-Unix platforms Rename is not an atomic operation. If there is an error, it will be of type *LinkError. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SameFile",
				Description: "SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's [Stat]. It returns false in other cases. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setenv",
				Description: "Setenv sets the value of the environment variable named by the key. It returns an error, if any. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StartProcess",
				Description: "StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become [os.Args] in the new process, so it normally starts with the program name. If the calling goroutine has locked the operating system thread with [runtime.LockOSThread] and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state. StartProcess is a low-level interface. The [os/exec] package provides higher-level interfaces. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Process",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Stat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Symlink",
				Description: "Symlink creates newname as a symbolic link to oldname. On Windows, a symlink to a non-existent oldname creates a file symlink; if oldname is later created as a directory the symlink will not work. If there is an error, it will be of type *LinkError. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TempDir",
				Description: "TempDir returns the default directory to use for temporary files. On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp. The directory is neither guaranteed to exist nor have accessible permissions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Truncate",
				Description: "Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type [*PathError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unsetenv",
				Description: "Unsetenv unsets a single environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UserCacheDir",
				Description: "UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that. On Unix systems, it returns $XDG_CACHE_HOME as specified by https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache. If the location cannot be determined (for example, $HOME is not defined) or the path in $XDG_CACHE_HOME is relative, then it will return an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UserConfigDir",
				Description: "UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that. On Unix systems, it returns $XDG_CONFIG_HOME as specified by https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib. If the location cannot be determined (for example, $HOME is not defined) or the path in $XDG_CONFIG_HOME is relative, then it will return an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UserHomeDir",
				Description: "UserHomeDir returns the current user's home directory. On Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable. If the expected variable is not set in the environment, UserHomeDir returns either a platform-specific default value or a non-nil error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteFile",
				Description: "WriteFile writes data to the named file, creating it if necessary. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions. Since WriteFile requires multiple system calls to complete, a failure mid-operation can leave the file in a partially written state. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"entropy": []funcSet{
			funcSet{
				Name:        "Depleted",
				Description: "Depleted notifies the entropy source that the entropy in the module is \"depleted\" and provides the callback for the LOAD command. ",
				Returns:     []returnSet{},
			},
		},
		"atomic": []funcSet{
			funcSet{
				Name:        "And",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "And32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "And64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "And8",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Anduintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cas",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cas64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CasRel",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Casint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Casint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Casp1",
				Description: "NO go:noescape annotation; see atomic_pointer.go. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Casuintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Load",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Load64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Load8",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadAcq",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadAcq64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadAcquintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Loadint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Loadint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Loadp",
				Description: "NO go:noescape annotation; *ptr escapes if result escapes (#31525) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Loaduint",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Loaduintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Or",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Or32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Or64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Or8",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Oruintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Store",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Store64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Store8",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreRel",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreRel64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreReluintptr",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Storeint32",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Storeint64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StorepNoWB",
				Description: "NO go:noescape annotation; see atomic_pointer.go. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Storeuintptr",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Xadd",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xadd64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xaddint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xaddint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xadduintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchg",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchg64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchg8",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchgint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchgint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Xchguintptr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddInt32",
				Description: "AddInt32 atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone [Int32.Add] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddInt64",
				Description: "AddInt64 atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone [Int64.Add] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddUint32",
				Description: "AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&x, ^uint32(0)). Consider using the more ergonomic and less error-prone [Uint32.Add] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddUint64",
				Description: "AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&x, ^uint64(0)). Consider using the more ergonomic and less error-prone [Uint64.Add] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddUintptr",
				Description: "AddUintptr atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone [Uintptr.Add] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AndInt32",
				Description: "AndInt32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Int32.And] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AndInt64",
				Description: "AndInt64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Int64.And] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AndUint32",
				Description: "AndUint32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Uint32.And] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AndUint64",
				Description: "AndUint64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old. Consider using the more ergonomic and less error-prone [Uint64.And] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AndUintptr",
				Description: "AndUintptr atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Uintptr.And] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapInt32",
				Description: "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. Consider using the more ergonomic and less error-prone [Int32.CompareAndSwap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapInt64",
				Description: "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. Consider using the more ergonomic and less error-prone [Int64.CompareAndSwap] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapPointer",
				Description: "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. Consider using the more ergonomic and less error-prone [Pointer.CompareAndSwap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapUint32",
				Description: "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. Consider using the more ergonomic and less error-prone [Uint32.CompareAndSwap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapUint64",
				Description: "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. Consider using the more ergonomic and less error-prone [Uint64.CompareAndSwap] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareAndSwapUintptr",
				Description: "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. Consider using the more ergonomic and less error-prone [Uintptr.CompareAndSwap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadInt32",
				Description: "LoadInt32 atomically loads *addr. Consider using the more ergonomic and less error-prone [Int32.Load] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadInt64",
				Description: "LoadInt64 atomically loads *addr. Consider using the more ergonomic and less error-prone [Int64.Load] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadPointer",
				Description: "LoadPointer atomically loads *addr. Consider using the more ergonomic and less error-prone [Pointer.Load] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadUint32",
				Description: "LoadUint32 atomically loads *addr. Consider using the more ergonomic and less error-prone [Uint32.Load] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadUint64",
				Description: "LoadUint64 atomically loads *addr. Consider using the more ergonomic and less error-prone [Uint64.Load] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadUintptr",
				Description: "LoadUintptr atomically loads *addr. Consider using the more ergonomic and less error-prone [Uintptr.Load] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OrInt32",
				Description: "OrInt32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Int32.Or] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OrInt64",
				Description: "OrInt64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Int64.Or] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OrUint32",
				Description: "OrUint32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Uint32.Or] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OrUint64",
				Description: "OrUint64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Uint64.Or] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OrUintptr",
				Description: "OrUintptr atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone [Uintptr.Or] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StoreInt32",
				Description: "StoreInt32 atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Int32.Store] instead. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreInt64",
				Description: "StoreInt64 atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Int64.Store] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StorePointer",
				Description: "StorePointer atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Pointer.Store] instead. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreUint32",
				Description: "StoreUint32 atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Uint32.Store] instead. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreUint64",
				Description: "StoreUint64 atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Uint64.Store] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StoreUintptr",
				Description: "StoreUintptr atomically stores val into *addr. Consider using the more ergonomic and less error-prone [Uintptr.Store] instead. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SwapInt32",
				Description: "SwapInt32 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Int32.Swap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SwapInt64",
				Description: "SwapInt64 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Int64.Swap] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SwapPointer",
				Description: "SwapPointer atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Pointer.Swap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SwapUint32",
				Description: "SwapUint32 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Uint32.Swap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SwapUint64",
				Description: "SwapUint64 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Uint64.Swap] instead (particularly if you target 32-bit platforms; see the bugs section). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SwapUintptr",
				Description: "SwapUintptr atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone [Uintptr.Swap] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
		},
		"reflectlite": []funcSet{
			funcSet{
				Name:        "Swapper",
				Description: "Swapper returns a function that swaps the elements in the provided slice. Swapper panics if the provided interface is not a slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(i int, j int)",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TypeOf",
				Description: "TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflectlite",
					},
				},
			},
			funcSet{
				Name:        "ValueOf",
				Description: "ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflectlite",
					},
				},
			},
		},
		"slices": []funcSet{
			funcSet{
				Name:        "All",
				Description: "All returns an iterator over index-value pairs in the slice in the usual order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq2",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "AppendSeq",
				Description: "AppendSeq appends the values from seq to the slice and returns the extended slice. If seq is empty, the result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Slice",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Backward",
				Description: "Backward returns an iterator over index-value pairs in the slice, traversing it backward with descending indices. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq2",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "BinarySearch",
				Description: "BinarySearch searches for target in a sorted slice and returns the earliest position where target is found, or the position where target would appear in the sort order; it also returns a bool saying whether the target is really found in the slice. The slice must be sorted in increasing order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BinarySearchFunc",
				Description: "BinarySearchFunc works like [BinarySearch], but uses a custom comparison function. The slice must be sorted in increasing order, where \"increasing\" is defined by cmp. cmp should return 0 if the slice element matches the target, a negative number if the slice element precedes the target, or a positive number if the slice element follows the target. cmp must implement the same ordering as the slice, such that if cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chunk",
				Description: "Chunk returns an iterator over consecutive sub-slices of up to n elements of s. All but the last sub-slice will have size n. All sub-slices are clipped to have no capacity beyond the length. If s is empty, the sequence is empty: there is no empty slice in the sequence. Chunk panics if n is less than 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Clip",
				Description: "Clip removes unused capacity from the slice, returning s[:len(s):len(s)]. The result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clone",
				Description: "Clone returns a copy of the slice. The elements are copied using assignment, so this is a shallow clone. The result may have additional unused capacity. The result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Collect",
				Description: "Collect collects values from seq into a new slice and returns it. If seq is empty, the result is nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compact",
				Description: "Compact replaces consecutive runs of equal elements with a single copy. This is like the uniq command found on Unix. Compact modifies the contents of the slice s and returns the modified slice, which may have a smaller length. Compact zeroes the elements between the new length and the original length. The result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompactFunc",
				Description: "CompactFunc is like [Compact] but uses an equality function to compare elements. For runs of elements that compare equal, CompactFunc keeps the first one. CompactFunc zeroes the elements between the new length and the original length. The result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compare",
				Description: "Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair of elements. The elements are compared sequentially, starting at index 0, until one element is not equal to the other. The result of comparing the first non-matching elements is returned. If both slices are equal until one of them ends, the shorter slice is considered less than the longer one. The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareFunc",
				Description: "CompareFunc is like [Compare] but uses a custom comparison function on each pair of elements. The result is the first non-zero result of cmp; if cmp always returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2), and +1 if len(s1) > len(s2). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Concat",
				Description: "Concat returns a new slice concatenating the passed in slices. If the concatenation is empty, the result is nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Contains",
				Description: "Contains reports whether v is present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsFunc",
				Description: "ContainsFunc reports whether at least one element e of s satisfies f(e). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Delete",
				Description: "Delete removes the elements s[i:j] from s, returning the modified slice. Delete panics if j > len(s) or s[i:j] is not a valid slice of s. Delete is O(len(s)-i), so if many items must be deleted, it is better to make a single call deleting them all together than to delete one at a time. Delete zeroes the elements s[len(s)-(j-i):len(s)]. If the result is empty, it has the same nilness as s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DeleteFunc",
				Description: "DeleteFunc removes any elements from s for which del returns true, returning the modified slice. DeleteFunc zeroes the elements between the new length and the original length. If the result is empty, it has the same nilness as s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Equal",
				Description: "Equal reports whether two slices are equal: the same length and all elements equal. If the lengths are different, Equal returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first unequal pair. Empty and nil slices are considered equal. Floating point NaNs are not considered equal. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EqualFunc",
				Description: "EqualFunc reports whether two slices are equal using an equality function on each pair of elements. If the lengths are different, EqualFunc returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first index for which eq returns false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Grow",
				Description: "Grow increases the slice's capacity, if necessary, to guarantee space for another n elements. After Grow(n), at least n elements can be appended to the slice without another allocation. If n is negative or too large to allocate the memory, Grow panics. The result preserves the nilness of s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "Index returns the index of the first occurrence of v in s, or -1 if not present. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexFunc",
				Description: "IndexFunc returns the first index i satisfying f(s[i]), or -1 if none do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Insert",
				Description: "Insert inserts the values v... into s at index i, returning the modified slice. The elements at s[i:] are shifted up to make room. In the returned slice r, r[i] == v[0], and, if i < len(s), r[i+len(v)] == value originally at r[i]. Insert panics if i > len(s). This function is O(len(s) + len(v)). If the result is empty, it has the same nilness as s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSorted",
				Description: "IsSorted reports whether x is sorted in ascending order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSortedFunc",
				Description: "IsSortedFunc reports whether x is sorted in ascending order, with cmp as the comparison function as defined by [SortFunc]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Max",
				Description: "Max returns the maximal value in x. It panics if x is empty. For floating-point E, Max propagates NaNs (any NaN value in x forces the output to be NaN). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MaxFunc",
				Description: "MaxFunc returns the maximal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one maximal element according to the cmp function, MaxFunc returns the first one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Min",
				Description: "Min returns the minimal value in x. It panics if x is empty. For floating-point numbers, Min propagates NaNs (any NaN value in x forces the output to be NaN). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MinFunc",
				Description: "MinFunc returns the minimal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one minimal element according to the cmp function, MinFunc returns the first one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Repeat",
				Description: "Repeat returns a new slice that repeats the provided slice the given number of times. The result has length and capacity (len(x) * count). The result is never nil. Repeat panics if count is negative or if the result of (len(x) * count) overflows. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Replace",
				Description: "Replace replaces the elements s[i:j] by the given v, and returns the modified slice. Replace panics if j > len(s) or s[i:j] is not a valid slice of s. When len(v) < (j-i), Replace zeroes the elements between the new length and the original length. If the result is empty, it has the same nilness as s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "S",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse",
				Description: "Reverse reverses the elements of the slice in place. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Sort",
				Description: "Sort sorts a slice of any ordered type in ascending order. When sorting floating-point numbers, NaNs are ordered before other values. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SortFunc",
				Description: "SortFunc sorts the slice x in ascending order as determined by the cmp function. This sort is not guaranteed to be stable. cmp(a, b) should return a negative number when a < b, a positive number when a > b and zero when a == b or a and b are incomparable in the sense of a strict weak ordering. SortFunc requires that cmp is a strict weak ordering. See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings. The function should return 0 for incomparable items. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SortStableFunc",
				Description: "SortStableFunc sorts the slice x while keeping the original order of equal elements, using cmp to compare elements in the same way as [SortFunc]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Sorted",
				Description: "Sorted collects values from seq into a new slice, sorts the slice, and returns it. If seq is empty, the result is nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SortedFunc",
				Description: "SortedFunc collects values from seq into a new slice, sorts the slice using the comparison function, and returns it. If seq is empty, the result is nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SortedStableFunc",
				Description: "SortedStableFunc collects values from seq into a new slice. It then sorts the slice while keeping the original order of equal elements, using the comparison function to compare elements. It returns the new slice. If seq is empty, the result is nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]E",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Values",
				Description: "Values returns an iterator that yields the slice elements in order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
		},
		"bzip2": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns an [io.Reader] which decompresses bzip2 data from r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
		},
		"log": []funcSet{
			funcSet{
				Name:        "Default",
				Description: "Default returns the standard logger used by the package-level output functions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "log",
					},
				},
			},
			funcSet{
				Name:        "Fatal",
				Description: "Fatal is equivalent to l.Print() followed by a call to [os.Exit](1). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Fatalf",
				Description: "Fatalf is equivalent to l.Printf() followed by a call to [os.Exit](1). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Fatalln",
				Description: "Fatalln is equivalent to l.Println() followed by a call to [os.Exit](1). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Flags",
				Description: "Flags returns the output flags for the logger. The flag bits are [Ldate], [Ltime], and so on. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New creates a new [Logger]. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the [Lmsgprefix] flag is provided. The flag argument defines the logging properties. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "log",
					},
				},
			},
			funcSet{
				Name:        "Output",
				Description: "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Panic",
				Description: "Panic is equivalent to l.Print() followed by a call to panic(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Panicf",
				Description: "Panicf is equivalent to l.Printf() followed by a call to panic(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Panicln",
				Description: "Panicln is equivalent to l.Println() followed by a call to panic(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Prefix",
				Description: "Prefix returns the output prefix for the logger. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Print",
				Description: "Print calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Print]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Printf",
				Description: "Printf calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Printf]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Println",
				Description: "Println calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Println]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetFlags",
				Description: "SetFlags sets the output flags for the logger. The flag bits are [Ldate], [Ltime], and so on. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetOutput",
				Description: "SetOutput sets the output destination for the logger. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetPrefix",
				Description: "SetPrefix sets the output prefix for the logger. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Writer",
				Description: "Writer returns the output destination for the logger. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
		},
		"textproto": []funcSet{
			funcSet{
				Name:        "CanonicalMIMEHeaderKey",
				Description: "CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes as defined by RFC 9112, it is returned without modifications. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dial",
				Description: "Dial connects to the given address on the given network using [net.Dial] and then returns a new [Conn] for the connection. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "textproto",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewConn",
				Description: "NewConn returns a new [Conn] using conn for I/O. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "textproto",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new [Reader] reading from r. To avoid denial of service attacks, the provided [bufio.Reader] should be reading from an [io.LimitReader] or similar Reader to bound the size of responses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "textproto",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer] writing to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "textproto",
					},
				},
			},
			funcSet{
				Name:        "TrimBytes",
				Description: "TrimBytes returns b without leading and trailing ASCII space. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimString",
				Description: "TrimString returns s without leading and trailing ASCII space. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"encodemeta": []funcSet{
			funcSet{
				Name:        "HashFuncDesc",
				Description: "HashFuncDesc computes an md5 sum of a coverage.FuncDesc and returns a digest for it. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCoverageMetaDataBuilder",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageMetaDataBuilder",
						TypePkgName: "encodemeta",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCoverageMetaFileWriter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageMetaFileWriter",
						TypePkgName: "encodemeta",
					},
				},
			},
		},
		"exithook": []funcSet{
			funcSet{
				Name:        "Add",
				Description: "Add adds a new exit hook. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Run",
				Description: "Run runs the exit hooks. If an exit hook panics, Run will throw with the panic on the stack. If an exit hook invokes exit in the same goroutine, the goroutine will throw. If an exit hook invokes exit in another goroutine, that exit will block. ",
				Returns:     []returnSet{},
			},
		},
		"cmp": []funcSet{
			funcSet{
				Name:        "Compare",
				Description: "Compare returns -1 if x is less than y, 0 if x equals y, +1 if x is greater than y. For floating-point types, a NaN is considered less than any non-NaN, a NaN is considered equal to a NaN, and -0.0 is equal to 0.0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Less",
				Description: "Less reports whether x is less than y. For floating-point types, a NaN is considered less than any non-NaN, and -0.0 is not less than (is equal to) 0.0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Or",
				Description: "Or returns the first of its arguments that is not equal to the zero value. If no argument is non-zero, it returns the zero value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "T",
						TypePkgName: "",
					},
				},
			},
		},
		"alias": []funcSet{
			funcSet{
				Name:        "AnyOverlap",
				Description: "AnyOverlap reports whether x and y share memory at any (not necessarily corresponding) index. The memory beyond the slice length is ignored. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InexactOverlap",
				Description: "InexactOverlap reports whether x and y share memory at any non-corresponding index. The memory beyond the slice length is ignored. Note that x and y can have different lengths and still not have any inexact overlap. InexactOverlap can be used to implement the requirements of the crypto/cipher AEAD, Block, BlockMode and Stream interfaces. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"bbig": []funcSet{
			funcSet{
				Name:        "Dec",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			funcSet{
				Name:        "Enc",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
				},
			},
		},
		"platform": []funcSet{
			funcSet{
				Name:        "ASanSupported",
				Description: "ASanSupported reports whether goos/goarch supports the address sanitizer option. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Broken",
				Description: "Broken reports whether goos/goarch is considered a broken port. (See https://go.dev/wiki/PortingPolicy#broken-ports.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BuildModeSupported",
				Description: "BuildModeSupported reports whether goos/goarch supports the given build mode using the given compiler. There is a copy of this function in cmd/dist/test.go. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CgoSupported",
				Description: "CgoSupported reports whether goos/goarch supports cgo. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DefaultPIE",
				Description: "DefaultPIE reports whether goos/goarch produces a PIE binary when using the \"default\" buildmode. On Windows this is affected by -race, so force the caller to pass that in to centralize that choice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ExecutableHasDWARF",
				Description: "ExecutableHasDWARF reports whether the linked executable includes DWARF symbols on goos/goarch. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FirstClass",
				Description: "FirstClass reports whether goos/goarch is considered a âfirst classâ port. (See https://go.dev/wiki/PortingPolicy#first-class-ports.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FuzzInstrumented",
				Description: "FuzzInstrumented reports whether fuzzing on goos/goarch uses coverage instrumentation. (FuzzInstrumented implies FuzzSupported.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FuzzSupported",
				Description: "FuzzSupported reports whether goos/goarch supports fuzzing ('go test -fuzz=.'). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InternalLinkPIESupported",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MSanSupported",
				Description: "MSanSupported reports whether goos/goarch supports the memory sanitizer option. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MustLinkExternal",
				Description: "MustLinkExternal reports whether goos/goarch requires external linking with or without cgo dependencies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RaceDetectorSupported",
				Description: "RaceDetectorSupported reports whether goos/goarch supports the race detector. There is a copy of this function in cmd/dist/test.go. Race detector only supports 48-bit VMA on arm64. But it will always return true for arm64, because we don't have VMA size information during the compile time. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"elf": []funcSet{
			funcSet{
				Name:        "NewFile",
				Description: "NewFile creates a new [File] for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "elf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data. For an [SHT_NOBITS] section, all calls to the opened reader will return a non-nil error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "elf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_INFO",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_INFO32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_SYM32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_SYM64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_TYPE32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "R_TYPE64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ST_BIND",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SymBind",
						TypePkgName: "elf",
					},
				},
			},
			funcSet{
				Name:        "ST_INFO",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ST_TYPE",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SymType",
						TypePkgName: "elf",
					},
				},
			},
			funcSet{
				Name:        "ST_VISIBILITY",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SymVis",
						TypePkgName: "elf",
					},
				},
			},
		},
		"printer": []funcSet{
			funcSet{
				Name:        "Fprint",
				Description: "Fprint \"pretty-prints\" an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *[ast.File], *[CommentedNode], [][ast.Decl], [][ast.Stmt], or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"tracev1": []funcSet{
			funcSet{
				Name:        "Parse",
				Description: "Parse parses Go execution traces from versions 1.11â1.21. The provided reader will be read to completion and the entire trace will be materialized in memory. That is, this function does not allow incremental parsing. The reader has to be positioned just after the trace header and vers needs to be the version of the trace. This can be achieved by using version.ReadHeader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Trace",
						TypePkgName: "tracev1",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"txtar": []funcSet{
			funcSet{
				Name:        "Format",
				Description: "Format returns the serialized form of an Archive. It is assumed that the Archive data structure is well-formed: a.Comment and all a.File[i].Data contain no file marker lines, and all a.File[i].Name is non-empty. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses the serialized form of an Archive. The returned Archive holds slices of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Archive",
						TypePkgName: "txtar",
					},
				},
			},
			funcSet{
				Name:        "ParseFile",
				Description: "ParseFile parses the named file as an archive. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Archive",
						TypePkgName: "txtar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"fips140hash": []funcSet{
			funcSet{
				Name:        "Unwrap",
				Description: "Unwrap returns h, or a crypto/internal/fips140 inner implementation of h. The return value can be type asserted to one of [crypto/internal/fips140/sha256.Digest], [crypto/internal/fips140/sha512.Digest], or [crypto/internal/fips140/sha3.Digest] if it is a FIPS 140-3 approved hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "UnwrapNew",
				Description: "UnwrapNew returns a function that calls newHash and applies [Unwrap] to the return value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() hash.Hash",
						TypePkgName: "",
					},
				},
			},
		},
		"buildcfg": []funcSet{
			funcSet{
				Name:        "Check",
				Description: "Check exits the program with a fatal error if Error is non-nil. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "GOGOARCH",
				Description: "GOGOARCH returns the name and value of the GO$GOARCH setting. For example, if GOARCH is \"amd64\" it might return \"GOAMD64\", \"v2\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgoextlinkenabled",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseGOEXPERIMENT",
				Description: "ParseGOEXPERIMENT parses a (GOOS, GOARCH, GOEXPERIMENT) configuration tuple and returns the enabled and baseline experiment flag sets. TODO(mdempsky): Move to [internal/goexperiment]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ExperimentFlags",
						TypePkgName: "buildcfg",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseGoarm64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Goarm64Features",
						TypePkgName: "buildcfg",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"fuzz": []funcSet{
			funcSet{
				Name:        "CheckCorpus",
				Description: "CheckCorpus verifies that the types in vals match the expected types provided. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CoordinateFuzzing",
				Description: "CoordinateFuzzing creates several worker processes and communicates with them to test random inputs that could trigger crashes and expose bugs. The worker processes run the same binary in the same directory with the same environment variables as the coordinator process. Workers also run with the same arguments as the coordinator, except with the -test.fuzzworker flag prepended to the argument list. If a crash occurs, the function will return an error containing information about the crash, which can be reported to the user. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadCorpus",
				Description: "ReadCorpus reads the corpus from the provided dir. The returned corpus entries are guaranteed to match the given types. Any malformed files will be saved in a MalformedCorpusError and returned, along with the most recent error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/fuzz.CorpusEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResetCoverage",
				Description: "ResetCoverage sets all of the counters for each edge of the instrumented source code to 0. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RunFuzzWorker",
				Description: "RunFuzzWorker is called in a worker process to communicate with the coordinator process in order to fuzz random inputs. RunFuzzWorker loops until the coordinator tells it to stop. fn is a wrapper on the fuzz function. It may return an error to indicate a given input \"crashed\". The coordinator will also record a crasher if the function times out or terminates the process. RunFuzzWorker returns an error if it could not communicate with the coordinator process. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SnapshotCoverage",
				Description: "SnapshotCoverage copies the current counter values into coverageSnapshot, preserving them for later inspection. SnapshotCoverage also rounds each counter down to the nearest power of two. This lets the coordinator store multiple values for each counter by OR'ing them together. ",
				Returns:     []returnSet{},
			},
		},
		"checktest": []funcSet{
			funcSet{
				Name:        "PtrStaticData",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PtrStaticText",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TEXT",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"maphash": []funcSet{
			funcSet{
				Name:        "Bytes",
				Description: "Bytes returns the hash of b with the given seed. Bytes is equivalent to, but more convenient and efficient than: var h Hash h.SetSeed(seed) h.Write(b) return h.Sum64() ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Comparable",
				Description: "Comparable returns the hash of comparable value v with the given seed such that Comparable(s, v1) == Comparable(s, v2) if v1 == v2. If v != v, then the resulting hash is randomly distributed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MakeSeed",
				Description: "MakeSeed returns a new random seed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seed",
						TypePkgName: "maphash",
					},
				},
			},
			funcSet{
				Name:        "String",
				Description: "String returns the hash of s with the given seed. String is equivalent to, but more convenient and efficient than: var h Hash h.SetSeed(seed) h.WriteString(s) return h.Sum64() ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteComparable",
				Description: "WriteComparable adds x to the data hashed by h. ",
				Returns:     []returnSet{},
			},
		},
		"ioutil": []funcSet{
			funcSet{
				Name:        "NopCloser",
				Description: "NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r. Deprecated: As of Go 1.16, this function simply calls [io.NopCloser]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "ReadAll",
				Description: "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. Deprecated: As of Go 1.16, this function simply calls [io.ReadAll]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadDir",
				Description: "ReadDir reads the directory named by dirname and returns a list of fs.FileInfo for the directory's contents, sorted by filename. If an error occurs reading the directory, ReadDir returns no directory entries along with the error. Deprecated: As of Go 1.16, [os.ReadDir] is a more efficient and correct choice: it returns a list of [fs.DirEntry] instead of [fs.FileInfo], and it returns partial results in the case of an error midway through reading a directory. If you must continue obtaining a list of [fs.FileInfo], you still can: entries, err := os.ReadDir(dirname) if err != nil { ... } infos := make([]fs.FileInfo, 0, len(entries)) for _, entry := range entries { info, err := entry.Info() if err != nil { ... } infos = append(infos, info) } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]io/fs.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFile",
				Description: "ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported. Deprecated: As of Go 1.16, this function simply calls [os.ReadFile]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TempDir",
				Description: "TempDir creates a new temporary directory in the directory dir. The directory name is generated by taking pattern and applying a random string to the end. If pattern includes a \"*\", the random string replaces the last \"*\". TempDir returns the name of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see [os.TempDir]). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed. Deprecated: As of Go 1.17, this function simply calls [os.MkdirTemp]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TempFile",
				Description: "TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *[os.File]. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"*\", the random string replaces the last \"*\". If dir is the empty string, TempFile uses the default directory for temporary files (see [os.TempDir]). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed. Deprecated: As of Go 1.17, this function simply calls [os.CreateTemp]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteFile",
				Description: "WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions. Deprecated: As of Go 1.16, this function simply calls [os.WriteFile]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cmplx": []funcSet{
			funcSet{
				Name:        "Abs",
				Description: "Abs returns the absolute value (also called the modulus) of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Acos",
				Description: "Acos returns the inverse cosine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Acosh",
				Description: "Acosh returns the inverse hyperbolic cosine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Asin",
				Description: "Asin returns the inverse sine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Asinh",
				Description: "Asinh returns the inverse hyperbolic sine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atan",
				Description: "Atan returns the inverse tangent of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atanh",
				Description: "Atanh returns the inverse hyperbolic tangent of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Conj",
				Description: "Conj returns the complex conjugate of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cos",
				Description: "Cos returns the cosine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cosh",
				Description: "Cosh returns the hyperbolic cosine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cot",
				Description: "Cot returns the cotangent of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exp",
				Description: "Exp returns e**x, the base-e exponential of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Inf",
				Description: "Inf returns a complex infinity, complex(+Inf, +Inf). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsInf",
				Description: "IsInf reports whether either real(x) or imag(x) is an infinity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsNaN",
				Description: "IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log",
				Description: "Log returns the natural logarithm of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log10",
				Description: "Log10 returns the decimal logarithm of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NaN",
				Description: "NaN returns a complex ânot-a-numberâ value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Phase",
				Description: "Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Polar",
				Description: "Polar returns the absolute value r and phase Î¸ of x, such that x = r * e**Î¸i. The phase is in the range [-Pi, Pi]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pow",
				Description: "Pow returns x**y, the base-x exponential of y. For generalized compatibility with [math.Pow]: Pow(0, Â±0) returns 1+0i Pow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rect",
				Description: "Rect returns the complex number x with polar coordinates r, Î¸. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sin",
				Description: "Sin returns the sine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sinh",
				Description: "Sinh returns the hyperbolic sine of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sqrt",
				Description: "Sqrt returns the square root of x. The result r is chosen so that real(r) â¥ 0 and imag(r) has the same sign as imag(x). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Tan",
				Description: "Tan returns the tangent of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Tanh",
				Description: "Tanh returns the hyperbolic tangent of x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
				},
			},
		},
		"abi": []funcSet{
			funcSet{
				Name:        "CommonSize",
				Description: "CommonSize returns sizeof(Type) for a compilation target with a given ptrSize ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Escape",
				Description: "Escape forces any pointers in x to escape to the heap. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "T",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EscapeNonString",
				Description: "EscapeNonString forces v to be on the heap, if v contains a non-string pointer. This is used in hash/maphash.Comparable. We cannot hash pointers to local variables on stack, as their addresses might change on stack growth. Strings are okay as the hash depends on only the content, not the pointer. This is essentially if hasNonStringPointers(T) { Escape(v) } Implemented as a compiler intrinsic. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "EscapeToResultNonString",
				Description: "EscapeToResultNonString models a data flow edge from v to the result, if v contains a non-string pointer. If v contains only string pointers, it returns a copy of v, but is not modeled as a data flow edge from the escape analysis's perspective. This is used in unique.clone, to model the data flow edge on the value with strings excluded, because strings are cloned (by content). TODO: probably we should define this as a intrinsic and EscapeNonString could just be \"heap = EscapeToResultNonString(v)\". This way we can model an edge to the result but not necessarily heap. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "T",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FuncPCABI0",
				Description: "FuncPCABI0 returns the entry PC of the function f, which must be a direct reference of a function defined as ABI0. Otherwise it is a compile-time error. Implemented as a compile intrinsic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FuncPCABIInternal",
				Description: "FuncPCABIInternal returns the entry PC of the function f. If f is a direct reference of a function, it must be defined as ABIInternal. Otherwise it is a compile-time error. If f is not a direct reference of a defined function, it assumes that f is a func value. Otherwise the behavior is undefined. Implemented as a compile intrinsic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ITabTypeOff",
				Description: "ITabTypeOff returns the offset of ITab.Type for a compilation target with a given ptrSize ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewName",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Name",
						TypePkgName: "abi",
					},
				},
			},
			funcSet{
				Name:        "NoEscape",
				Description: "NoEscape hides the pointer p from escape analysis, preventing it from escaping to the heap. It compiles down to nothing. WARNING: This is very subtle to use correctly. The caller must ensure that it's truly safe for p to not escape to the heap by maintaining runtime pointer invariants (for example, that globals and the heap may not generally point into a stack). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StructFieldSize",
				Description: "StructFieldSize returns sizeof(StructField) for a compilation target with a given ptrSize ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TFlagOff",
				Description: "TFlagOff returns the offset of Type.TFlag for a compilation target with a given ptrSize ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TypeFor",
				Description: "TypeFor returns the abi.Type for a type parameter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			funcSet{
				Name:        "TypeOf",
				Description: "TypeOf returns the abi.Type of some value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			funcSet{
				Name:        "UncommonSize",
				Description: "UncommonSize returns sizeof(UncommonType). This currently does not depend on ptrSize. This exported function is in an internal package, so it may change to depend on ptrSize in the future. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UseInterfaceSwitchCache",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"flate": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. The reader returns [io.EOF] after the final block in the DEFLATE stream has been encountered. Any trailing data after the final block is ignored. The [io.ReadCloser] returned by NewReader also implements [Resetter]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewReaderDict",
				Description: "NewReaderDict is like [NewReader] but initializes the reader with a preset dictionary. The returned reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by [NewWriterDict]. The ReadCloser returned by NewReaderDict also implements [Resetter]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer] compressing data at the given level. Following zlib, levels range from 1 ([BestSpeed]) to 9 ([BestCompression]); higher levels typically run slower but compress more. Level 0 ([NoCompression]) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 ([DefaultCompression]) uses the default compression level. Level -2 ([HuffmanOnly]) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency. If level is in the range [-2, 9] then the error returned will be nil. Otherwise the error returned will be non-nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "flate",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriterDict",
				Description: "NewWriterDict is like [NewWriter] but initializes the new [Writer] with a preset dictionary. The returned [Writer] behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a reader initialized with the same dictionary (see [NewReaderDict]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "flate",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"execenv": []funcSet{
			funcSet{
				Name:        "Default",
				Description: "Default will return the default environment variables based on the process attributes provided. Defaults to syscall.Environ() on all platforms other than Windows. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"pbkdf2": []funcSet{
			funcSet{
				Name:        "Key",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Key",
				Description: "Key derives a key from the password, salt and iteration count, returning a []byte of length keyLength that can be used as cryptographic key. The key is derived based on the method described as PBKDF2 with the HMAC variant using the supplied hash function. For example, to use a HMAC-SHA-1 based PBKDF2 key derivation function, you can get a derived key for e.g. AES-256 (which needs a 32-byte key) by doing: dk := pbkdf2.Key(sha1.New, \"some password\", salt, 4096, 32) Remember to get a good random salt. At least 8 bytes is recommended by the RFC. Using a higher iteration count will increase the cost of an exhaustive search but will also make derivation proportionally slower. keyLength must be a positive integer between 1 and (2^32 - 1) * h.Size(). Setting keyLength to a value outside of this range will result in an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"crc64": []funcSet{
			funcSet{
				Name:        "Checksum",
				Description: "Checksum returns the CRC-64 checksum of data using the polynomial represented by the [Table]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MakeTable",
				Description: "MakeTable returns a [Table] constructed from the specified polynomial. The contents of this [Table] must not be modified. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Table",
						TypePkgName: "crc64",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the [Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash64",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Update",
				Description: "Update returns the result of adding the bytes in p to the crc. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
		},
		"path": []funcSet{
			funcSet{
				Name:        "Base",
				Description: "Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clean",
				Description: "Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done: 1. Replace multiple slashes with a single slash. 2. Eliminate each . path name element (the current directory). 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it. 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path. The returned path ends in a slash only if it is the root \"/\". If the result of this process is an empty string, Clean returns the string \".\". See also Rob Pike, âLexical File Names in Plan 9 or Getting Dot-Dot Right,â https://9p.io/sys/doc/lexnames.html ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dir",
				Description: "Dir returns all but the last element of path, typically the path's directory. After dropping the final element using [Split], the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ext",
				Description: "Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsAbs",
				Description: "IsAbs reports whether the path is absolute. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Join",
				Description: "Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Match",
				Description: "Match reports whether name matches the shell pattern. The pattern syntax is: pattern: { term } term: '*' matches any sequence of non-/ characters '?' matches any single non-/ character '[' [ '^' ] { character-range } ']' character class (must be non-empty) c matches character c (c != '*', '?', '\\\\', '[') '\\\\' c matches character c character-range: c matches character c (c != '\\\\', '-', ']') '\\\\' c matches character c lo '-' hi matches character c for lo <= c <= hi Match requires pattern to match all of name, not just a substring. The only possible returned error is [ErrBadPattern], when pattern is malformed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Split",
				Description: "Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"json": []funcSet{
			funcSet{
				Name:        "Compact",
				Description: "Compact appends to dst the JSON-encoded src with insignificant space characters elided. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HTMLEscape",
				Description: "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML <script> tags. For historical reasons, web browsers don't honor standard HTML escaping within <script> tags, so an alternative JSON encoding must be used. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Indent",
				Description: "Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Marshal",
				Description: "Marshal returns the JSON encoding of v. Marshal traverses the value v recursively. If an encountered value implements [Marshaler] and is not a nil pointer, Marshal calls [Marshaler.MarshalJSON] to produce JSON. If no [Marshaler.MarshalJSON] method is present but the value implements [encoding.TextMarshaler] instead, Marshal calls [encoding.TextMarshaler.MarshalText] and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of [Unmarshaler.UnmarshalJSON]. Otherwise, Marshal uses the following type-dependent default encodings: Boolean values encode as JSON booleans. Floating point, integer, and [Number] values encode as JSON numbers. NaN and +/-Inf values will return an [UnsupportedValueError]. String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML <script> tags, the string is encoded using [HTMLEscape], which replaces \"<\", \">\", \"&\", U+2028, and U+2029 are escaped to \"\\u003c\",\"\\u003e\", \"\\u0026\", \"\\u2028\", and \"\\u2029\". This replacement can be disabled when using an [Encoder], by calling [Encoder.SetEscapeHTML](false). Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value. Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below. The encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name. The \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any array, slice, map, or string of length zero. As a special case, if the field tag is \"-\", the field is always omitted. Note that a field with name \"-\" can still be generated using the tag \"-,\". Examples of struct field tags and their meanings: // Field appears in JSON as key \"myName\". Field int `json:\"myName\"` // Field appears in JSON as key \"myName\" and // the field is omitted from the object if its value is empty, // as defined above. Field int `json:\"myName,omitempty\"` // Field appears in JSON as key \"Field\" (the default), but // the field is skipped if empty. // Note the leading comma. Field int `json:\",omitempty\"` // Field is ignored by this package. Field int `json:\"-\"` // Field appears in JSON as key \"-\". Field int `json:\"-,\"` The \"omitzero\" option specifies that the field should be omitted from the encoding if the field has a zero value, according to rules: 1) If the field type has an \"IsZero() bool\" method, that will be used to determine whether the value is zero. 2) Otherwise, the value is zero if it is the zero value for its type. If both \"omitempty\" and \"omitzero\" are specified, the field will be omitted if the value is either empty or zero (or both). The \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs: Int64String int64 `json:\",string\"` The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma. Embedded struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous. The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply: 1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict. 2) If there is exactly one field (tagged or not according to the first rule), that is selected. 3) Otherwise there are multiple fields, and all are ignored; no error occurs. Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\". Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement [encoding.TextMarshaler]. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above: - keys of any string type are used directly - keys that implement [encoding.TextMarshaler] are marshaled - integer keys are converted to strings Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value. Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value. Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an [UnsupportedTypeError]. JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalIndent",
				Description: "MarshalIndent is like [Marshal] but applies [Indent] to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder returns a new decoder that reads from r. The decoder introduces its own buffering and may read data from r beyond the JSON values requested. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "json",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new encoder that writes to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoder",
						TypePkgName: "json",
					},
				},
			},
			funcSet{
				Name:        "Unmarshal",
				Description: "Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an [InvalidUnmarshalError]. Unmarshal uses the inverse of the encodings that [Marshal] uses, allocating maps, slices, and pointers as necessary, with the following additional rules: To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to. To unmarshal JSON into a value implementing [Unmarshaler], Unmarshal calls that value's [Unmarshaler.UnmarshalJSON] method, including when the input is a JSON null. Otherwise, if the value implements [encoding.TextUnmarshaler] and the input is a JSON quoted string, Unmarshal calls [encoding.TextUnmarshaler.UnmarshalText] with the unquoted form of the string. To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by [Marshal] (either the struct field name or its tag), ignoring case. If multiple struct fields match an object key, an exact case match is preferred over a case-insensitive one. Incoming object members are processed in the order observed. If an object includes duplicate keys, later duplicates will replace or be merged into prior values. To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value: - bool, for JSON booleans - float64, for JSON numbers - string, for JSON strings - []any, for JSON arrays - map[string]any, for JSON objects - nil for JSON null To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice. To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values. To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, or implement [encoding.TextUnmarshaler]. If the JSON-encoded data contain a syntax error, Unmarshal returns a [SyntaxError]. If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an [UnmarshalTypeError] describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object. The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean ânot present,â unmarshaling a JSON null into any other Go type has no effect on the value and produces no error. When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Valid",
				Description: "Valid reports whether data is a valid JSON encoding. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"multipart": []funcSet{
			funcSet{
				Name:        "FileContentDisposition",
				Description: "FileContentDisposition returns the value of a Content-Disposition header with the provided field name and file name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new multipart [Reader] reading from r using the given MIME boundary. The boundary is usually obtained from the \"boundary\" parameter of the message's \"Content-Type\" header. Use [mime.ParseMediaType] to parse such headers. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "multipart",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new multipart [Writer] with a random boundary, writing to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "multipart",
					},
				},
			},
		},
		"decodecounter": []funcSet{
			funcSet{
				Name:        "NewCounterDataReader",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterDataReader",
						TypePkgName: "decodecounter",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"godebugs": []funcSet{
			funcSet{
				Name:        "Lookup",
				Description: "Lookup returns the Info with the given name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Info",
						TypePkgName: "godebugs",
					},
				},
			},
		},
		"godebug": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new Setting for the $GODEBUG setting with the given name. GODEBUGs meant for use by end users must be listed in ../godebugs/table.go, which is used for generating and checking various documentation. If the name is not listed in that table, New will succeed but calling Value on the returned Setting will panic. To disable that panic for access to an undocumented setting, prefix the name with a #, as in godebug.New(\"#gofsystrace\"). The # is a signal to New but not part of the key used in $GODEBUG. Note that almost all settings should arrange to call [IncNonDefault] precisely when program behavior is changing from the default due to the setting (not just when the setting is different, but when program behavior changes). See the [internal/godebug] package comment for more. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Setting",
						TypePkgName: "godebug",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Setting",
						TypePkgName: "godebug",
					},
				},
			},
			funcSet{
				Name:        "Value",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"exec": []funcSet{
			funcSet{
				Name:        "Command",
				Description: "Command returns the [Cmd] struct to execute the named program with the given arguments. It sets only the Path and Args in the returned structure. If name contains no path separators, Command uses [LookPath] to resolve name to a complete path if possible. Otherwise it uses name directly as Path. The returned Cmd's Args field is constructed from the command name followed by the elements of arg, so arg should not include the command name itself. For example, Command(\"echo\", \"hello\"). Args[0] is always name, not the possibly resolved Path. On Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cmd",
						TypePkgName: "exec",
					},
				},
			},
			funcSet{
				Name:        "CommandContext",
				Description: "CommandContext is like [Command] but includes a context. The provided context is used to interrupt the process (by calling cmd.Cancel or [os.Process.Kill]) if the context becomes done before the command completes on its own. CommandContext sets the command's Cancel function to invoke the Kill method on its Process, and leaves its WaitDelay unset. The caller may change the cancellation behavior by modifying those fields before starting the command. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cmd",
						TypePkgName: "exec",
					},
				},
			},
			funcSet{
				Name:        "LookPath",
				Description: "LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. Otherwise, on success, the result is an absolute path. In older versions of Go, LookPath could return a path relative to the current directory. As of Go 1.19, LookPath will instead return that path along with an error satisfying [errors.Is](err, [ErrDot]). See the package documentation for more details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"fips140tls": []funcSet{
			funcSet{
				Name:        "Force",
				Description: "Force forces crypto/tls to restrict TLS configurations to FIPS-approved settings. By design, this call is impossible to undo (except in tests). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Required",
				Description: "Required reports whether FIPS-approved settings are required. Required is true if FIPS 140-3 mode is enabled with GODEBUG=fips140=on, or if the crypto/tls/fipsonly package is imported by a Go+BoringCrypto build. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyAbandon",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"chacha8rand": []funcSet{
			funcSet{
				Name:        "Marshal",
				Description: "Marshal marshals the state into a byte slice. Marshal and Unmarshal are functions, not methods, so that they will not be linked into the runtime when it uses the State struct, since the runtime does not need these. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unmarshal",
				Description: "Unmarshal unmarshals the state from a byte slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"rsa": []funcSet{
			funcSet{
				Name:        "DecryptOAEP",
				Description: "DecryptOAEP decrypts ciphertext using RSAES-OAEP. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptWithCheck",
				Description: "DecryptWithCheck performs the RSA private key operation and checks the result to defend against errors in the CRT computation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptWithoutCheck",
				Description: "DecryptWithoutCheck performs the RSA private key operation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encrypt",
				Description: "Encrypt performs the RSA public key operation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptOAEP",
				Description: "EncryptOAEP encrypts the given message with RSAES-OAEP. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a new RSA key pair of the given bit size. bits must be at least 32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKey",
				Description: "NewPrivateKey creates a new RSA private key from the given parameters. All values are in big-endian byte slice format, and may have leading zeros or be shorter if leading zeroes were trimmed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyWithPrecomputation",
				Description: "NewPrivateKeyWithPrecomputation creates a new RSA private key from the given parameters, which include precomputed CRT values. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyWithoutCRT",
				Description: "NewPrivateKeyWithoutCRT creates a new RSA private key from the given parameters. This is meant for deprecated multi-prime keys, and is not FIPS 140 compliant. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PSSMaxSaltLength",
				Description: "PSSMaxSaltLength returns the maximum salt length for a given public key and hash function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignPKCS1v15",
				Description: "SignPKCS1v15 calculates an RSASSA-PKCS1-v1.5 signature. hash is the name of the hash function as returned by [crypto.Hash.String] or the empty string to indicate that the message is signed directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignPSS",
				Description: "SignPSS calculates the signature of hashed using RSASSA-PSS. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPKCS1v15",
				Description: "VerifyPKCS1v15 verifies an RSASSA-PKCS1-v1.5 signature. hash is the name of the hash function as returned by [crypto.Hash.String] or the empty string to indicate that the message is signed directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPSS",
				Description: "VerifyPSS verifies sig with RSASSA-PSS automatically detecting the salt length. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPSSWithSaltLength",
				Description: "VerifyPSS verifies sig with RSASSA-PSS and an expected salt length. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptOAEP",
				Description: "DecryptOAEP decrypts ciphertext using RSA-OAEP. OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice. The random parameter is legacy and ignored, and it can be nil. The label parameter must match the value given when encrypting. See [EncryptOAEP] for details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptPKCS1v15",
				Description: "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil. Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptPKCS1v15SessionKey",
				Description: "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil. DecryptPKCS1v15SessionKey returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value. Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This also defeats the point of this function. Using at least a 16-byte key will protect against this attack. This method implements protections against Bleichenbacher chosen ciphertext attacks [0] described in RFC 3218 Section 2.3.2 [1]. While these protections make a Bleichenbacher attack significantly more difficult, the protections are only effective if the rest of the protocol which uses DecryptPKCS1v15SessionKey is designed with these considerations in mind. In particular, if any subsequent operations which use the decrypted session key leak any information about the key (e.g. whether it is a static or random key) then the mitigations are defeated. This method must be used extremely carefully, and typically should only be used when absolutely necessary for compatibility with an existing protocol (such as TLS) that is designed with these properties in mind. - [0] âChosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1â, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98) - [1] RFC 3218, Preventing the Million Message Attack on CMS, https://www.rfc-editor.org/rfc/rfc3218.html ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptOAEP",
				Description: "EncryptOAEP encrypts the given message with RSA-OAEP. OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice. The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader] as random. The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to encrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty. The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptPKCS1v15",
				Description: "EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS #1 v1.5. The message must be no longer than the length of the public modulus minus 11 bytes. The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader] as random. Note that the returned ciphertext does not depend deterministically on the bytes read from random, and may change between calls and/or between versions. WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a random RSA private key of the given bit size. If bits is less than 1024, [GenerateKey] returns an error. See the \"[Minimum key size]\" section for further details. Most applications should use [crypto/rand.Reader] as rand. Note that the returned key does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions. [Minimum key size]: https://pkg.go.dev/crypto/rsa#hdr-Minimum_key_size ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateMultiPrimeKey",
				Description: "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source. Table 1 in \"[On the Security of Multi-prime RSA]\" suggests maximum numbers of primes for a given bit size. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code. This package does not implement CRT optimizations for multi-prime RSA, so the keys with more than two primes will have worse performance. Deprecated: The use of this function with a number of primes different from two is not recommended for the above security, compatibility, and performance reasons. Use [GenerateKey] instead. [On the Security of Multi-prime RSA]: http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignPKCS1v15",
				Description: "SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability. The random parameter is legacy and ignored, and it can be nil. This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignPSS",
				Description: "SignPSS calculates the signature of digest using PSS. digest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. If opts.Hash is set, it overrides hash. The signature is randomized depending on the message, key, and salt size, using bytes from rand. Most applications should use [crypto/rand.Reader] as rand. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPKCS1v15",
				Description: "VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPSS",
				Description: "VerifyPSS verifies a PSS signature. A valid signature is indicated by returning a nil error. digest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. opts.Hash is ignored. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"expvar": []funcSet{
			funcSet{
				Name:        "Do",
				Description: "Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Get",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "expvar",
					},
				},
			},
			funcSet{
				Name:        "Handler",
				Description: "Handler returns the expvar HTTP Handler. This is only needed to install the handler in a non-standard location. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewFloat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "expvar",
					},
				},
			},
			funcSet{
				Name:        "NewInt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "expvar",
					},
				},
			},
			funcSet{
				Name:        "NewMap",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "expvar",
					},
				},
			},
			funcSet{
				Name:        "NewString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "String",
						TypePkgName: "expvar",
					},
				},
			},
			funcSet{
				Name:        "Publish",
				Description: "Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic. ",
				Returns:     []returnSet{},
			},
		},
		"mlkem": []funcSet{
			funcSet{
				Name:        "GenerateKey1024",
				Description: "GenerateKey1024 generates a new decapsulation key, drawing random bytes from a DRBG. The decapsulation key must be kept secret. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey768",
				Description: "GenerateKey768 generates a new decapsulation key, drawing random bytes from a DRBG. The decapsulation key must be kept secret. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKeyInternal1024",
				Description: "GenerateKeyInternal1024 is a derandomized version of GenerateKey1024, exclusively for use in tests. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
				},
			},
			funcSet{
				Name:        "GenerateKeyInternal768",
				Description: "GenerateKeyInternal768 is a derandomized version of GenerateKey768, exclusively for use in tests. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
				},
			},
			funcSet{
				Name:        "NewDecapsulationKey1024",
				Description: "NewDecapsulationKey1024 parses a decapsulation key from a 64-byte seed in the \"d || z\" form. The seed must be uniformly random. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecapsulationKey768",
				Description: "NewDecapsulationKey768 parses a decapsulation key from a 64-byte seed in the \"d || z\" form. The seed must be uniformly random. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewEncapsulationKey1024",
				Description: "NewEncapsulationKey1024 parses an encapsulation key from its encoded form. If the encapsulation key is not valid, NewEncapsulationKey1024 returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewEncapsulationKey768",
				Description: "NewEncapsulationKey768 parses an encapsulation key from its encoded form. If the encapsulation key is not valid, NewEncapsulationKey768 returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyExpandedBytes1024",
				Description: "TestingOnlyExpandedBytes1024 returns the decapsulation key as a byte slice using the full expanded NIST encoding. This should only be used for ACVP testing. For all other purposes prefer the Bytes method that returns the (much smaller) seed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyExpandedBytes768",
				Description: "TestingOnlyExpandedBytes768 returns the decapsulation key as a byte slice using the full expanded NIST encoding. This should only be used for ACVP testing. For all other purposes prefer the Bytes method that returns the (much smaller) seed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyNewDecapsulationKey1024",
				Description: "TestingOnlyNewDecapsulationKey1024 parses a decapsulation key from its expanded NIST format. Bytes() must not be called on the returned key, as it will not produce the original seed. This function should only be used for ACVP testing. Prefer NewDecapsulationKey1024 for all other purposes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyNewDecapsulationKey768",
				Description: "TestingOnlyNewDecapsulationKey768 parses a decapsulation key from its expanded NIST format. Bytes() must not be called on the returned key, as it will not produce the original seed. This function should only be used for ACVP testing. Prefer NewDecapsulationKey768 for all other purposes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey1024",
				Description: "GenerateKey1024 generates a new decapsulation key, drawing random bytes from the default crypto/rand source. The decapsulation key must be kept secret. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey768",
				Description: "GenerateKey768 generates a new decapsulation key, drawing random bytes from the default crypto/rand source. The decapsulation key must be kept secret. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecapsulationKey1024",
				Description: "NewDecapsulationKey1024 expands a decapsulation key from a 64-byte seed in the \"d || z\" form. The seed must be uniformly random. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecapsulationKey768",
				Description: "NewDecapsulationKey768 expands a decapsulation key from a 64-byte seed in the \"d || z\" form. The seed must be uniformly random. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DecapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewEncapsulationKey1024",
				Description: "NewEncapsulationKey1024 parses an encapsulation key from its encoded form. If the encapsulation key is not valid, NewEncapsulationKey1024 returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey1024",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewEncapsulationKey768",
				Description: "NewEncapsulationKey768 parses an encapsulation key from its encoded form. If the encapsulation key is not valid, NewEncapsulationKey768 returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey768",
						TypePkgName: "mlkem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"seccomp": []funcSet{
			funcSet{
				Name:        "DisableGetrandom",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"runtime": []funcSet{
			funcSet{
				Name:        "AddCleanup",
				Description: "AddCleanup attaches a cleanup function to ptr. Some time after ptr is no longer reachable, the runtime will call cleanup(arg) in a separate goroutine. A typical use is that ptr is an object wrapping an underlying resource (e.g., a File object wrapping an OS file descriptor), arg is the underlying resource (e.g., the OS file descriptor), and the cleanup function releases the underlying resource (e.g., by calling the close system call). There are few constraints on ptr. In particular, multiple cleanups may be attached to the same pointer, or to different pointers within the same allocation. If ptr is reachable from cleanup or arg, ptr will never be collected and the cleanup will never run. As a protection against simple cases of this, AddCleanup panics if arg is equal to ptr. There is no specified order in which cleanups will run. In particular, if several objects point to each other and all become unreachable at the same time, their cleanups all become eligible to run and can run in any order. This is true even if the objects form a cycle. Cleanups run concurrently with any user-created goroutines. Cleanups may also run concurrently with one another (unlike finalizers). If a cleanup function must run for a long time, it should create a new goroutine to avoid blocking the execution of other cleanups. If ptr has both a cleanup and a finalizer, the cleanup will only run once it has been finalized and becomes unreachable without an associated finalizer. The cleanup(arg) call is not always guaranteed to run; in particular it is not guaranteed to run before program exit. Cleanups are not guaranteed to run if the size of T is zero bytes, because it may share same address with other zero-size objects in memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees. It is not guaranteed that a cleanup will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated. Note that because cleanups may execute arbitrarily far into the future after an object is no longer referenced, the runtime is allowed to perform a space-saving optimization that batches objects together in a single allocation slot. The cleanup for an unreferenced object in such an allocation may never run if it always exists in the same batch as a referenced object. Typically, this batching only happens for tiny (on the order of 16 bytes or less) and pointer-free objects. A cleanup may run as soon as an object becomes unreachable. In order to use cleanups correctly, the program must ensure that the object is reachable until it is safe to run its cleanup. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. A function argument or receiver may become unreachable at the last point where the function mentions it. To ensure a cleanup does not get called prematurely, pass the object to the [KeepAlive] function after the last point where the object must remain reachable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cleanup",
						TypePkgName: "runtime",
					},
				},
			},
			funcSet{
				Name:        "BlockProfile",
				Description: "BlockProfile returns n, the number of records in the current blocking profile. If len(p) >= n, BlockProfile copies the profile into p and returns n, true. If len(p) < n, BlockProfile does not change p and returns n, false. Most clients should use the [runtime/pprof] package or the [testing] package's -test.blockprofile flag instead of calling BlockProfile directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Breakpoint",
				Description: "Breakpoint executes a breakpoint trap. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "CPUProfile",
				Description: "CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed. Deprecated: Use the [runtime/pprof] package, or the handlers in the [net/http/pprof] package, or the [testing] package's -test.cpuprofile flag instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Caller",
				Description: "Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and [Callers].) The return values report the program counter, the file name (using forward slashes as path separator, even on Windows), and the line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Callers",
				Description: "Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc. To translate these PCs into symbolic information such as function names and line numbers, use [CallersFrames]. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using [FuncForPC] on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CallersFrames",
				Description: "CallersFrames takes a slice of PC values returned by [Callers] and prepares to return function/file/line information. Do not change the slice until you are done with the [Frames]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Frames",
						TypePkgName: "runtime",
					},
				},
			},
			funcSet{
				Name:        "FuncForPC",
				Description: "FuncForPC returns a *[Func] describing the function that contains the given program counter address, or else nil. If pc represents multiple functions because of inlining, it returns the *Func describing the innermost function, but with an entry of the outermost function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "runtime",
					},
				},
			},
			funcSet{
				Name:        "GC",
				Description: "GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "GOMAXPROCS",
				Description: "GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n < 1, it does not change the current setting. # Default If the GOMAXPROCS environment variable is set to a positive whole number, GOMAXPROCS defaults to that value. Otherwise, the Go runtime selects an appropriate default value from a combination of - the number of logical CPUs on the machine, - the processâs CPU affinity mask, - and, on Linux, the processâs average CPU throughput limit based on cgroup CPU quota, if any. If GODEBUG=containermaxprocs=0 is set and GOMAXPROCS is not set by the environment variable, then GOMAXPROCS instead defaults to the value of [runtime.NumCPU]. Note that GODEBUG=containermaxprocs=0 is [default] for language version 1.24 and below. # Updates The Go runtime periodically updates the default value based on changes to the total logical CPU count, the CPU affinity mask, or cgroup quota. Setting a custom value with the GOMAXPROCS environment variable or by calling GOMAXPROCS disables automatic updates. The default value and automatic updates can be restored by calling [SetDefaultGOMAXPROCS]. If GODEBUG=updatemaxprocs=0 is set, the Go runtime does not perform automatic GOMAXPROCS updating. Note that GODEBUG=updatemaxprocs=0 is [default] for language version 1.24 and below. # Compatibility Note that the default GOMAXPROCS behavior may change as the scheduler improves, especially the implementation detail below. # Implementation details When computing default GOMAXPROCS via cgroups, the Go runtime computes the \"average CPU throughput limit\" as the cgroup CPU quota / period. In cgroup v2, these values come from the cpu.max file. In cgroup v1, they come from cpu.cfs_quota_us and cpu.cfs_period_us, respectively. In container runtimes that allow configuring CPU limits, this value usually corresponds to the \"CPU limit\" option, not \"CPU request\". The Go runtime typically selects the default GOMAXPROCS as the minimum of the logical CPU count, the CPU affinity mask count, or the cgroup CPU throughput limit. However, it will never set GOMAXPROCS less than 2 unless the logical CPU count or CPU affinity mask count are below 2. If the cgroup CPU throughput limit is not a whole number, the Go runtime rounds up to the next whole number. GOMAXPROCS updates are performed up to once per second, or less if the application is idle. [default]: https://go.dev/doc/godebug#default ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GOROOT",
				Description: "GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build. Deprecated: The root used during the Go build will not be meaningful if the binary is copied to another machine. Use the system path to locate the âgoâ binary, and use âgo env GOROOTâ to find its GOROOT. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Goexit",
				Description: "Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil. Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes. It crashes if called from a thread not created by the Go runtime. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "GoroutineProfile",
				Description: "GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) < n, GoroutineProfile does not change p and returns n, false. Most clients should use the [runtime/pprof] package instead of calling GoroutineProfile directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Gosched",
				Description: "Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "KeepAlive",
				Description: "KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called. A very simplified example showing where KeepAlive is required: type File struct { d int } d, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0) // ... do something if err != nil ... p := &File{d} runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) }) var buf [10]byte n, err := syscall.Read(p.d, buf[:]) // Ensure p is not finalized until Read returns. runtime.KeepAlive(p) // No more uses of p after this point. Without the KeepAlive call, the finalizer could run at the start of [syscall.Read], closing the file descriptor before syscall.Read makes the actual system call. Note: KeepAlive should only be used to prevent finalizers from running prematurely. In particular, when used with [unsafe.Pointer], the rules for valid uses of unsafe.Pointer still apply. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LockOSThread",
				Description: "LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to [UnlockOSThread] as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated. All init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread. A goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MemProfile",
				Description: "MemProfile returns a profile of memory allocated and freed per allocation site. MemProfile returns n, the number of records in the current memory profile. If len(p) >= n, MemProfile copies the profile into p and returns n, true. If len(p) < n, MemProfile does not change p and returns n, false. If inuseZero is true, the profile includes allocation records where r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime. The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector. Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MutexProfile",
				Description: "MutexProfile returns n, the number of records in the current mutex profile. If len(p) >= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false. Most clients should use the [runtime/pprof] package instead of calling MutexProfile directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NumCPU",
				Description: "NumCPU returns the number of logical CPUs usable by the current process. The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NumCgoCall",
				Description: "NumCgoCall returns the number of cgo calls made by the current process. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NumGoroutine",
				Description: "NumGoroutine returns the number of goroutines that currently exist. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadMemStats",
				Description: "ReadMemStats populates m with memory allocator statistics. The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadTrace",
				Description: "ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBlockProfileRate",
				Description: "SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked. To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate <= 0. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetCPUProfileRate",
				Description: "SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off. Most clients should use the [runtime/pprof] package or the [testing] package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetCgoTraceback",
				Description: "SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo. The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory. None of the functions may call back into Go. The context function will be called with a single argument, a pointer to a struct: struct { Context uintptr } In C syntax, this struct will be struct { uintptr_t Context; }; If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code. If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources. While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient. The traceback function will be called with a single argument, a pointer to a struct: struct { Context uintptr SigContext uintptr Buf *uintptr Max uintptr } In C syntax, this struct will be struct { uintptr_t Context; uintptr_t SigContext; uintptr_t* Buf; uintptr_t Max; }; The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code. Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value. If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero. Buf is where the traceback information should be stored. It should be PC values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that function's caller, and so on. Max is the maximum number of entries to store. The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack. Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction. No additional subtraction is required or appropriate. On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, linux/arm64, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls. The symbolizer function will be called with a single argument, a pointer to a struct: struct { PC uintptr // program counter to fetch information for File *byte // file name (NUL terminated) Lineno uintptr // line number Func *byte // function name (NUL terminated) Entry uintptr // function entry point More uintptr // set non-zero if more info for this PC Data uintptr // unused by runtime, available for function } In C syntax, this struct will be struct { uintptr_t PC; char* File; uintptr_t Lineno; char* Func; uintptr_t Entry; uintptr_t More; uintptr_t Data; }; The PC field will be a value returned by a call to the traceback function. The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls. When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero. The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero. If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack. SetCgoTraceback should be called only once, ideally from an init function. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetDefaultGOMAXPROCS",
				Description: "SetDefaultGOMAXPROCS updates the GOMAXPROCS setting to the runtime default, as described by [GOMAXPROCS], ignoring the GOMAXPROCS environment variable. SetDefaultGOMAXPROCS can be used to enable the default automatic updating GOMAXPROCS behavior if it has been disabled by the GOMAXPROCS environment variable or a prior call to [GOMAXPROCS], or to force an immediate update if the caller is aware of a change to the total logical CPU count, CPU affinity mask or cgroup quota. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetFinalizer",
				Description: "SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj. SetFinalizer(obj, nil) clears any finalizer associated with obj. New Go code should consider using [AddCleanup] instead, which is much less error-prone than SetFinalizer. The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program. Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies. The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an [os.File] object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a [bufio.Writer], because the buffer would not be flushed at program exit. It is not guaranteed that a finalizer will run if the size of *obj is zero bytes, because it may share same address with other zero-size objects in memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees. It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated. Note that because finalizers may execute arbitrarily far into the future after an object is no longer referenced, the runtime is allowed to perform a space-saving optimization that batches objects together in a single allocation slot. The finalizer for an unreferenced object in such an allocation may never run if it always exists in the same batch as a referenced object. Typically, this batching only happens for tiny (on the order of 16 bytes or less) and pointer-free objects. A finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. A function argument or receiver may become unreachable at the last point where the function mentions it. To make an unreachable object reachable, pass the object to a call of the [KeepAlive] function to mark the last point in the function where the object must be reachable. For example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters [syscall.Write]. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call KeepAlive(p) after the call to syscall.Write. A single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine. In the terminology of the Go memory model, a call SetFinalizer(x, f) âsynchronizes beforeâ the finalization call f(x). However, there is no guarantee that KeepAlive(x) or any other use of x âsynchronizes beforeâ f(x), so in general a finalizer should use a mutex or other synchronization mechanism if it needs to access mutable state in x. For example, consider a finalizer that inspects a mutable field in x that is modified from time to time in the main program before x becomes unreachable and the finalizer is invoked. The modifications in the main program and the inspection in the finalizer need to use appropriate synchronization, such as mutexes or atomic updates, to avoid read-write races. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetMutexProfileFraction",
				Description: "SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned. To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate < 0. (For n>1 the details of sampling may change.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Stack",
				Description: "Stack returns the stack trace associated with the record, a prefix of r.Stack0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StartTrace",
				Description: "StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via [ReadTrace]. StartTrace returns an error if tracing is already enabled. Most clients should use the [runtime/trace] package or the [testing] package's -test.trace flag instead of calling StartTrace directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StopTrace",
				Description: "StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ThreadCreateProfile",
				Description: "ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) < n, ThreadCreateProfile does not change p and returns n, false. Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnlockOSThread",
				Description: "UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op. Before calling UnlockOSThread, the caller must ensure that the OS thread is suitable for running other goroutines. If the caller made any permanent changes to the state of the thread that would affect other goroutines, it should not call this function and thus leave the goroutine locked to the OS thread until the goroutine (and hence the thread) exits. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Version",
				Description: "Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"unicode": []funcSet{
			funcSet{
				Name:        "In",
				Description: "In reports whether the rune is a member of one of the ranges. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Is",
				Description: "Is reports whether the rune is in the specified table of ranges. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsControl",
				Description: "IsControl reports whether the rune is a control character. The [C] ([Other]) Unicode category includes more code points such as surrogates; use [Is](C, r) to test for them. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsDigit",
				Description: "IsDigit reports whether the rune is a decimal digit. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsGraphic",
				Description: "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories [L], [M], [N], [P], [S], [Zs]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLetter",
				Description: "IsLetter reports whether the rune is a letter (category [L]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLower",
				Description: "IsLower reports whether the rune is a lower case letter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsMark",
				Description: "IsMark reports whether the rune is a mark character (category [M]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsNumber",
				Description: "IsNumber reports whether the rune is a number (category [N]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsOneOf",
				Description: "IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPrint",
				Description: "IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories [L], [M], [N], [P], [S] and the ASCII space character. This categorization is the same as [IsGraphic] except that the only spacing character is ASCII space, U+0020. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPunct",
				Description: "IsPunct reports whether the rune is a Unicode punctuation character (category [P]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSpace",
				Description: "IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is '\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP). Other definitions of spacing characters are set by category Z and property [Pattern_White_Space]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSymbol",
				Description: "IsSymbol reports whether the rune is a symbolic character. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsTitle",
				Description: "IsTitle reports whether the rune is a title case letter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsUpper",
				Description: "IsUpper reports whether the rune is an upper case letter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SimpleFold",
				Description: "SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune > r if one exists, or else the smallest rune >= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r. For example: SimpleFold('A') = 'a' SimpleFold('a') = 'A' SimpleFold('K') = 'k' SimpleFold('k') = '\\u212A' (Kelvin symbol, âª) SimpleFold('\\u212A') = 'K' SimpleFold('1') = '1' SimpleFold(-2) = -2 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "To",
				Description: "To maps the rune to the specified case: [UpperCase], [LowerCase], or [TitleCase]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLower",
				Description: "ToLower maps the rune to lower case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToTitle",
				Description: "ToTitle maps the rune to title case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToUpper",
				Description: "ToUpper maps the rune to upper case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
		},
		"fmtsort": []funcSet{
			funcSet{
				Name:        "Sort",
				Description: "Sort accepts a map and returns a SortedMap that has the same keys and values but in a stable sorted order according to the keys, modulo issues raised by unorderable key values such as NaNs. The ordering rules are more general than with Go's < operator: - when applicable, nil compares low - ints, floats, and strings order by < - NaN compares less than non-NaN floats - bool compares false before true - complex compares real, then imag - pointers compare by machine address - channel values compare by machine address - structs compare each field in turn - arrays compare each element in turn. Otherwise identical arrays compare by length. - interface values compare first by reflect.Type describing the concrete type and then by concrete value as described in the previous rules. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SortedMap",
						TypePkgName: "fmtsort",
					},
				},
			},
		},
		"filepath": []funcSet{
			funcSet{
				Name:        "Abs",
				Description: "Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls [Clean] on the result. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Base",
				Description: "Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of separators, Base returns a single separator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clean",
				Description: "Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done: 1. Replace multiple [Separator] elements with a single one. 2. Eliminate each . path name element (the current directory). 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it. 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path, assuming Separator is '/'. The returned path ends in a slash only if it represents a root directory, such as \"/\" on Unix or `C:\\` on Windows. Finally, any occurrences of slash are replaced by Separator. If the result of this process is an empty string, Clean returns the string \".\". On Windows, Clean does not modify the volume name other than to replace occurrences of \"/\" with `\\`. For example, Clean(\"//host/share/../x\") returns `\\\\host\\share\\x`. See also Rob Pike, âLexical File Names in Plan 9 or Getting Dot-Dot Right,â https://9p.io/sys/doc/lexnames.html ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dir",
				Description: "Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls [Clean] on the path and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EvalSymlinks",
				Description: "EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls [Clean] on the result. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ext",
				Description: "Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FromSlash",
				Description: "FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators. See also the Localize function, which converts a slash-separated path as used by the io/fs package to an operating system path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Glob",
				Description: "Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in [Match]. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the [Separator] is '/'). Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is [ErrBadPattern], when pattern is malformed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasPrefix",
				Description: "HasPrefix exists for historical compatibility and should not be used. Deprecated: HasPrefix does not respect path boundaries and does not ignore case when required. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsAbs",
				Description: "IsAbs reports whether the path is absolute. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLocal",
				Description: "IsLocal reports whether path, using lexical analysis only, has all of these properties: - is within the subtree rooted at the directory in which path is evaluated - is not an absolute path - is not empty - on Windows, is not a reserved name such as \"NUL\" If IsLocal(path) returns true, then Join(base, path) will always produce a path contained within base and Clean(path) will always produce an unrooted path with no \"..\" path elements. IsLocal is a purely lexical operation. In particular, it does not account for the effect of any symbolic links that may exist in the filesystem. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Join",
				Description: "Join joins any number of path elements into a single path, separating them with an OS specific [Separator]. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Localize",
				Description: "Localize converts a slash-separated path into an operating system path. The input path must be a valid path as reported by [io/fs.ValidPath]. Localize returns an error if the path cannot be represented by the operating system. For example, the path a\\b is rejected on Windows, on which \\ is a separator character and cannot be part of a filename. The path returned by Localize will always be local, as reported by IsLocal. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Match",
				Description: "Match reports whether name matches the shell file name pattern. The pattern syntax is: pattern: { term } term: '*' matches any sequence of non-Separator characters '?' matches any single non-Separator character '[' [ '^' ] { character-range } ']' character class (must be non-empty) c matches character c (c != '*', '?', '\\\\', '[') '\\\\' c matches character c character-range: c matches character c (c != '\\\\', '-', ']') '\\\\' c matches character c lo '-' hi matches character c for lo <= c <= hi Match requires pattern to match all of name, not just a substring. The only possible returned error is [ErrBadPattern], when pattern is malformed. On Windows, escaping is disabled. Instead, '\\\\' is treated as path separator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rel",
				Description: "Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, [Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls [Clean] on the result. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Split",
				Description: "Split splits path immediately following the final [Separator], separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitList",
				Description: "SplitList splits a list of paths joined by the OS-specific [ListSeparator], usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToSlash",
				Description: "ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VolumeName",
				Description: "VolumeName returns leading volume name. Given \"C:\\foo\\bar\" it returns \"C:\" on Windows. Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\". On other platforms it returns \"\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Walk",
				Description: "Walk walks the file tree rooted at root, calling fn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by fn: see the [WalkFunc] documentation for details. The files are walked in lexical order, which makes the output deterministic but requires Walk to read an entire directory into memory before proceeding to walk that directory. Walk does not follow symbolic links. Walk is less efficient than [WalkDir], introduced in Go 1.16, which avoids calling os.Lstat on every visited file or directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WalkDir",
				Description: "WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by fn: see the [fs.WalkDirFunc] documentation for details. The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory. WalkDir does not follow symbolic links. WalkDir calls fn with paths that use the separator character appropriate for the operating system. This is unlike [io/fs.WalkDir], which always uses slash separated paths. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sort": []funcSet{
			funcSet{
				Name:        "Find",
				Description: "Find uses binary search to find and return the smallest index i in [0, n) at which cmp(i) <= 0. If there is no such index i, Find returns i = n. The found result is true if i < n and cmp(i) == 0. Find calls cmp(i) only for i in the range [0, n). To permit binary search, Find requires that cmp(i) > 0 for a leading prefix of the range, cmp(i) == 0 in the middle, and cmp(i) < 0 for the final suffix of the range. (Each subrange could be empty.) The usual way to establish this condition is to interpret cmp(i) as a comparison of a desired target value t against entry i in an underlying indexed data structure x, returning <0, 0, and >0 when t < x[i], t == x[i], and t > x[i], respectively. For example, to look for a particular string in a sorted, random-access list of strings: i, found := sort.Find(x.Len(), func(i int) int { return strings.Compare(target, x.At(i)) }) if found { fmt.Printf(\"found %s at entry %d\\n\", target, i) } else { fmt.Printf(\"%s not found, would insert at %d\", target, i) } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64s",
				Description: "Float64s sorts a slice of float64s in increasing order. Not-a-number (NaN) values are ordered before other values. Note: as of Go 1.22, this function simply calls [slices.Sort]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Float64sAreSorted",
				Description: "Float64sAreSorted reports whether the slice x is sorted in increasing order, with not-a-number (NaN) values before any other values. Note: as of Go 1.22, this function simply calls [slices.IsSorted]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ints",
				Description: "Ints sorts a slice of ints in increasing order. Note: as of Go 1.22, this function simply calls [slices.Sort]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "IntsAreSorted",
				Description: "IntsAreSorted reports whether the slice x is sorted in increasing order. Note: as of Go 1.22, this function simply calls [slices.IsSorted]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSorted",
				Description: "IsSorted reports whether data is sorted. Note: in many situations, the newer [slices.IsSortedFunc] function is more ergonomic and runs faster. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse",
				Description: "Reverse returns the reverse order for data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "sort",
					},
				},
			},
			funcSet{
				Name:        "Search",
				Description: "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n). A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered. For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] >= 23 }) returns the smallest index i such that data[i] >= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately. Searching data sorted in descending order would use the <= operator instead of the >= operator. To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order: x := 23 i := sort.Search(len(data), func(i int) bool { return data[i] >= x }) if i < len(data) && data[i] == x { // x is present at data[i] } else { // x is not present in data, // but i is the index where it would be inserted. } As a more whimsical example, this program guesses your number: func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number <= %d? \", i) fmt.Scanf(\"%s\", &s) return s != \"\" && s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SearchFloat64s",
				Description: "SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by [Search]. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SearchInts",
				Description: "SearchInts searches for x in a sorted slice of ints and returns the index as specified by [Search]. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SearchStrings",
				Description: "SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Slice",
				Description: "Slice sorts the slice x given the provided less function. It panics if x is not a slice. The sort is not guaranteed to be stable: equal elements may be reversed from their original order. For a stable sort, use [SliceStable]. The less function must satisfy the same requirements as the Interface type's Less method. Note: in many situations, the newer [slices.SortFunc] function is more ergonomic and runs faster. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SliceIsSorted",
				Description: "SliceIsSorted reports whether the slice x is sorted according to the provided less function. It panics if x is not a slice. Note: in many situations, the newer [slices.IsSortedFunc] function is more ergonomic and runs faster. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SliceStable",
				Description: "SliceStable sorts the slice x using the provided less function, keeping equal elements in their original order. It panics if x is not a slice. The less function must satisfy the same requirements as the Interface type's Less method. Note: in many situations, the newer [slices.SortStableFunc] function is more ergonomic and runs faster. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Sort",
				Description: "Sort sorts data in ascending order as determined by the Less method. It makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable. Note: in many situations, the newer [slices.SortFunc] function is more ergonomic and runs faster. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Stable",
				Description: "Stable sorts data in ascending order as determined by the Less method, while keeping the original order of equal elements. It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less and O(n*log(n)*log(n)) calls to data.Swap. Note: in many situations, the newer slices.SortStableFunc function is more ergonomic and runs faster. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Strings",
				Description: "Strings sorts a slice of strings in increasing order. Note: as of Go 1.22, this function simply calls [slices.Sort]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StringsAreSorted",
				Description: "StringsAreSorted reports whether the slice x is sorted in increasing order. Note: as of Go 1.22, this function simply calls [slices.IsSorted]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"cgi": []funcSet{
			funcSet{
				Name:        "Request",
				Description: "Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RequestFromMap",
				Description: "RequestFromMap creates an [http.Request] from CGI variables. The returned Request's Body field is not populated. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Serve",
				Description: "Serve executes the provided [Handler] on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use [http.DefaultServeMux]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"crypto": []funcSet{
			funcSet{
				Name:        "RegisterHash",
				Description: "RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SignMessage",
				Description: "SignMessage signs msg with signer. If signer implements [MessageSigner], [MessageSigner.SignMessage] is called directly. Otherwise, msg is hashed with opts.HashFunc() and signed with [Signer.Sign]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"asn1": []funcSet{
			funcSet{
				Name:        "Marshal",
				Description: "Marshal returns the ASN.1 encoding of val. In addition to the struct tags recognized by Unmarshal, the following can be used: ia5: causes strings to be marshaled as ASN.1, IA5String values omitempty: causes empty slices to be skipped printable: causes strings to be marshaled as ASN.1, PrintableString values utf8: causes strings to be marshaled as ASN.1, UTF8String values numeric: causes strings to be marshaled as ASN.1, NumericString values utc: causes time.Time to be marshaled as ASN.1, UTCTime values generalized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalWithParams",
				Description: "MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unmarshal",
				Description: "Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error. After parsing b, any bytes that were leftover and not used to fill val will be returned in rest. When parsing a SEQUENCE into a struct, any trailing elements of the SEQUENCE that do not have matching fields in val will not be included in rest, as these are considered valid elements of the SEQUENCE and not trailing data. - An ASN.1 INTEGER can be written to an int, int32, int64, or *[big.Int]. If the encoded value does not fit in the Go type, Unmarshal returns a parse error. - An ASN.1 BIT STRING can be written to a [BitString]. - An ASN.1 OCTET STRING can be written to a []byte. - An ASN.1 OBJECT IDENTIFIER can be written to an [ObjectIdentifier]. - An ASN.1 ENUMERATED can be written to an [Enumerated]. - An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a [time.Time]. - An ASN.1 PrintableString, IA5String, or NumericString can be written to a string. - Any of the above ASN.1 values can be written to an interface{}. The value stored in the interface has the corresponding Go type. For integers, that type is int64. - An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can be written to the slice's element type. - An ASN.1 SEQUENCE or SET can be written to a struct if each of the elements in the sequence can be written to the corresponding element in the struct. The following tags on struct fields have special meaning to Unmarshal: application specifies that an APPLICATION tag is used private specifies that a PRIVATE tag is used default:x sets the default value for optional integer fields (only used if optional is also present) explicit specifies that an additional, explicit tag wraps the implicit one optional marks the field as ASN.1 OPTIONAL set causes a SET, rather than a SEQUENCE type to be expected tag:x specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '&'. To force other encodings, use the following tags: ia5 causes strings to be unmarshaled as ASN.1 IA5String values numeric causes strings to be unmarshaled as ASN.1 NumericString values utf8 causes strings to be unmarshaled as ASN.1 UTF8String values When decoding an ASN.1 value with an IMPLICIT tag into a time.Time field, Unmarshal will default to a UTCTime, which doesn't support time zones or fractional seconds. To force usage of GeneralizedTime, use the following tag: generalized causes time.Times to be unmarshaled as ASN.1 GeneralizedTime values If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it. If the name of a slice type ends with \"SET\" then it's treated as if the \"set\" tag was set on it. This results in interpreting the type as a SET OF x rather than a SEQUENCE OF x. This can be used with nested slices where a struct tag cannot be given. Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnmarshalWithParams",
				Description: "UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"build": []funcSet{
			funcSet{
				Name:        "ArchChar",
				Description: "ArchChar returns \"?\" and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Import",
				Description: "Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path. In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for: - .go files in package documentation - files starting with _ or . (likely editor temporary files) - files with build constraints not satisfied by the context If an error occurs, Import returns a non-nil error and a non-nil *[Package] containing partial information. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "build",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ImportDir",
				Description: "ImportDir is like [Import] but processes the Go package found in the named directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "build",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLocalImport",
				Description: "IsLocalImport reports whether the import path is a local import path, like \".\", \"..\", \"./foo\", or \"../foo\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"impl": []funcSet{
			funcSet{
				Name:        "List",
				Description: "List returns the names of all alternative implementations registered for the given package, whether available or not. The implicit base implementation is not included. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Packages",
				Description: "Packages returns the list of all packages for which alternative implementations are registered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Register",
				Description: "Register records an alternative implementation of a cryptographic primitive. The implementation might be available or not based on CPU support. If available is false, the implementation is unavailable and can't be tested on this machine. If available is true, it can be set to false to disable the implementation. If all alternative implementations but one are disabled, the remaining one must be used (i.e. disabling one implementation must not implicitly disable any other). Each package has an implicit base implementation that is selected when all alternatives are unavailable or disabled. pkg must be the package name, not path (e.g. \"aes\" not \"crypto/aes\"). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Reset",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Select",
				Description: "Select disables all implementations for the given package except the one with the given name. If name is empty, the base implementation is selected. It returns whether the selected implementation is available. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"rpc": []funcSet{
			funcSet{
				Name:        "Accept",
				Description: "Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Dial",
				Description: "Dial connects to an RPC server at the specified network address. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialHTTP",
				Description: "DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialHTTPPath",
				Description: "DialHTTPPath connects to an HTTP RPC server at the specified network address and path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HandleHTTP",
				Description: "HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke [http.Serve](), typically in a go statement. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NewClient",
				Description: "NewClient returns a new [Client] to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit. The read and write halves of the connection are serialized independently, so no interlocking is required. However each half may be accessed concurrently so the implementation of conn should protect against concurrent reads or concurrent writes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "NewClientWithCodec",
				Description: "NewClientWithCodec is like [NewClient] but uses the specified codec to encode requests and decode responses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "NewServer",
				Description: "NewServer returns a new [Server]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Server",
						TypePkgName: "rpc",
					},
				},
			},
			funcSet{
				Name:        "Register",
				Description: "Register publishes in the server the set of methods of the receiver value that satisfy the following conditions: - exported method of exported type - two arguments, both of exported type - the second argument is a pointer - one return value, of type error It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form \"Type.Method\", where Type is the receiver's concrete type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RegisterName",
				Description: "RegisterName is like [Register] but uses the provided name for the type instead of the receiver's concrete type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ServeCodec",
				Description: "ServeCodec is like [ServeConn] but uses the specified codec to decode requests and encode responses. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServeConn",
				Description: "ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use [ServeCodec]. See [NewClient]'s comment for information about concurrent access. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServeRequest",
				Description: "ServeRequest is like [ServeCodec] but synchronously serves a single request. It does not close the codec upon completion. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"decodemeta": []funcSet{
			funcSet{
				Name:        "NewCoverageMetaDataDecoder",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageMetaDataDecoder",
						TypePkgName: "decodemeta",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCoverageMetaFileReader",
				Description: "NewCoverageMetaFileReader returns a new helper object for reading the coverage meta-data output file 'f'. The param 'fileView' is a read-only slice containing the contents of 'f' obtained by mmap'ing the file read-only; 'fileView' may be nil, in which case the helper will read the contents of the file using regular file Read operations. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageMetaFileReader",
						TypePkgName: "decodemeta",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gif": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode reads a GIF image from r and returns the first embedded image as an [image.Image]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeAll",
				Description: "DecodeAll reads a GIF image from r and returns the sequential frames and timing information. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GIF",
						TypePkgName: "gif",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeConfig",
				Description: "DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Config",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode writes the Image m to w in GIF format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeAll",
				Description: "EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"des": []funcSet{
			funcSet{
				Name:        "NewCipher",
				Description: "NewCipher creates and returns a new [cipher.Block]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewTripleDESCipher",
				Description: "NewTripleDESCipher creates and returns a new [cipher.Block]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"hkdf": []funcSet{
			funcSet{
				Name:        "Expand",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Extract",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Key",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Expand",
				Description: "Expand derives a key from the given hash, key, and optional context info, returning a []byte of length keyLength that can be used as cryptographic key. The extraction step is skipped. The key should have been generated by [Extract], or be a uniformly random or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3. Most common scenarios will want to use [Key] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Extract",
				Description: "Extract generates a pseudorandom key for use with [Expand] from an input secret and an optional independent salt. Only use this function if you need to reuse the extracted key with multiple Expand invocations and different context values. Most common scenarios, including the generation of multiple keys, should use [Key] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Key",
				Description: "Key derives a key from the given hash, secret, salt and context info, returning a []byte of length keyLength that can be used as cryptographic key. Salt and info can be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"ssh": []funcSet{
			funcSet{
				Name:        "Keys",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"tls": []funcSet{
			funcSet{
				Name:        "CipherSuiteName",
				Description: "CipherSuiteName returns the standard name for the passed cipher suite ID (e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback representation of the ID value if the cipher suite is not implemented by this package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CipherSuites",
				Description: "CipherSuites returns a list of cipher suites currently implemented by this package, excluding those with security issues, which are returned by [InsecureCipherSuites]. The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list, and might not match those returned by this function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*crypto/tls.CipherSuite",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Client",
				Description: "Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "tls",
					},
				},
			},
			funcSet{
				Name:        "Dial",
				Description: "Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DialWithDialer",
				Description: "DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole. DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of [Config] for the defaults. DialWithDialer uses context.Background internally; to specify the context, use [Dialer.DialContext] with NetDialer set to the desired dialer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InsecureCipherSuites",
				Description: "InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues. Most applications should not use the cipher suites in this list, and should only use those returned by [CipherSuites]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*crypto/tls.CipherSuite",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Listen",
				Description: "Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Listener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LoadX509KeyPair",
				Description: "LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be populated. Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in the GODEBUG environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewLRUClientSessionCache",
				Description: "NewLRUClientSessionCache returns a [ClientSessionCache] with the given capacity that uses an LRU strategy. If capacity is < 1, a default capacity is used instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientSessionCache",
						TypePkgName: "tls",
					},
				},
			},
			funcSet{
				Name:        "NewListener",
				Description: "NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with [Server]. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Listener",
						TypePkgName: "net",
					},
				},
			},
			funcSet{
				Name:        "NewResumptionState",
				Description: "NewResumptionState returns a state value that can be returned by [ClientSessionCache.Get] to resume a previous session. state needs to be returned by [ParseSessionState], and the ticket and session state must have been returned by [ClientSessionState.ResumptionState]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientSessionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseSessionState",
				Description: "ParseSessionState parses a [SessionState] encoded by [SessionState.Bytes]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SessionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QUICClient",
				Description: "QUICClient returns a new TLS client side connection using QUICTransport as the underlying transport. The config cannot be nil. The config's MinVersion must be at least TLS 1.3. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "QUICConn",
						TypePkgName: "tls",
					},
				},
			},
			funcSet{
				Name:        "QUICServer",
				Description: "QUICServer returns a new TLS server side connection using QUICTransport as the underlying transport. The config cannot be nil. The config's MinVersion must be at least TLS 1.3. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "QUICConn",
						TypePkgName: "tls",
					},
				},
			},
			funcSet{
				Name:        "Server",
				Description: "Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "tls",
					},
				},
			},
			funcSet{
				Name:        "VersionName",
				Description: "VersionName returns the name for the provided TLS version number (e.g. \"TLS 1.3\"), or a fallback representation of the value if the version is not implemented by this package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "X509KeyPair",
				Description: "X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be populated. Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in the GODEBUG environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"iter": []funcSet{
			funcSet{
				Name:        "Pull",
				Description: "Pull converts the âpush-styleâ iterator sequence seq into a âpull-styleâ iterator accessed by the two functions next and stop. Next returns the next value in the sequence and a boolean indicating whether the value is valid. When the sequence is over, next returns the zero V and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return the zero V and false. Stop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should âdefer stop()â. It is an error to call next or stop from multiple goroutines simultaneously. If the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() (V, bool)",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "func()",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pull2",
				Description: "Pull2 converts the âpush-styleâ iterator sequence seq into a âpull-styleâ iterator accessed by the two functions next and stop. Next returns the next pair in the sequence and a boolean indicating whether the pair is valid. When the sequence is over, next returns a pair of zero values and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return a pair of zero values and false. Stop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should âdefer stop()â. It is an error to call next or stop from multiple goroutines simultaneously. If the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() (K, V, bool)",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "func()",
						TypePkgName: "",
					},
				},
			},
		},
		"bytes": []funcSet{
			funcSet{
				Name:        "Clone",
				Description: "Clone returns a copy of b[:len(b)]. The result may have additional unused capacity. Clone(nil) returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compare",
				Description: "Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a == b, -1 if a < b, and +1 if a > b. A nil argument is equivalent to an empty slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Contains",
				Description: "Contains reports whether subslice is within b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsAny",
				Description: "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsFunc",
				Description: "ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsRune",
				Description: "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Count",
				Description: "Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cut",
				Description: "Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false. Cut returns slices of the original slice s, not copies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutPrefix",
				Description: "CutPrefix returns s without the provided leading prefix byte slice and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty byte slice, CutPrefix returns s, true. CutPrefix returns slices of the original slice s, not copies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutSuffix",
				Description: "CutSuffix returns s without the provided ending suffix byte slice and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty byte slice, CutSuffix returns s, true. CutSuffix returns slices of the original slice s, not copies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Equal",
				Description: "Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EqualFold",
				Description: "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fields",
				Description: "Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by [unicode.IsSpace], returning a slice of subslices of s or an empty slice if s contains only white space. Every element of the returned slice is non-empty. Unlike [Split], leading and trailing runs of white space characters are discarded. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FieldsFunc",
				Description: "FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. Every element of the returned slice is non-empty. Unlike [SplitFunc], leading and trailing runs of code points satisfying f(c) are discarded. FieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FieldsFuncSeq",
				Description: "FieldsFuncSeq returns an iterator over subslices of s split around runs of Unicode code points satisfying f(c). The iterator yields the same subslices that would be returned by [FieldsFunc](s), but without constructing a new slice containing the subslices. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "FieldsSeq",
				Description: "FieldsSeq returns an iterator over subslices of s split around runs of whitespace characters, as defined by [unicode.IsSpace]. The iterator yields the same subslices that would be returned by [Fields](s), but without constructing a new slice containing the subslices. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "HasPrefix",
				Description: "HasPrefix reports whether the byte slice s begins with prefix. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasSuffix",
				Description: "HasSuffix reports whether the byte slice s ends with suffix. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexAny",
				Description: "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexByte",
				Description: "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexFunc",
				Description: "IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexRune",
				Description: "IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is [utf8.RuneError], it returns the first instance of any invalid UTF-8 byte sequence. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Join",
				Description: "Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndex",
				Description: "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexAny",
				Description: "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexByte",
				Description: "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexFunc",
				Description: "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lines",
				Description: "Lines returns an iterator over the newline-terminated lines in the byte slice s. The lines yielded by the iterator include their terminating newlines. If s is empty, the iterator yields no lines at all. If s does not end in a newline, the final yielded line will not end in a newline. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Map",
				Description: "Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewBuffer",
				Description: "NewBuffer creates and initializes a new [Buffer] using buf as its initial contents. The new [Buffer] takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a [Buffer] to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero. In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is sufficient to initialize a [Buffer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Buffer",
						TypePkgName: "bytes",
					},
				},
			},
			funcSet{
				Name:        "NewBufferString",
				Description: "NewBufferString creates and initializes a new [Buffer] using string s as its initial contents. It is intended to prepare a buffer to read an existing string. In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is sufficient to initialize a [Buffer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Buffer",
						TypePkgName: "bytes",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new [Reader] reading from b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "bytes",
					},
				},
			},
			funcSet{
				Name:        "Repeat",
				Description: "Repeat returns a new byte slice consisting of count copies of b. It panics if count is negative or if the result of (len(b) * count) overflows. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Replace",
				Description: "Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n < 0, there is no limit on the number of replacements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReplaceAll",
				Description: "ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Runes",
				Description: "Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Split",
				Description: "Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. To split around the first instance of a separator, see [Cut]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfter",
				Description: "SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfterN",
				Description: "SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return: - n > 0: at most n subslices; the last subslice will be the unsplit remainder; - n == 0: the result is nil (zero subslices); - n < 0: all subslices. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfterSeq",
				Description: "SplitAfterSeq returns an iterator over subslices of s split after each instance of sep. The iterator yields the same subslices that would be returned by [SplitAfter](s, sep), but without constructing a new slice containing the subslices. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "SplitN",
				Description: "SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return: - n > 0: at most n subslices; the last subslice will be the unsplit remainder; - n == 0: the result is nil (zero subslices); - n < 0: all subslices. To split around the first instance of a separator, see [Cut]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitSeq",
				Description: "SplitSeq returns an iterator over all subslices of s separated by sep. The iterator yields the same subslices that would be returned by [Split](s, sep), but without constructing a new slice containing the subslices. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Title",
				Description: "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case. Deprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLower",
				Description: "ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLowerSpecial",
				Description: "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToTitle",
				Description: "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToTitleSpecial",
				Description: "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToUpper",
				Description: "ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToUpperSpecial",
				Description: "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToValidUTF8",
				Description: "ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Trim",
				Description: "Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimFunc",
				Description: "TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimLeft",
				Description: "TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimLeftFunc",
				Description: "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimPrefix",
				Description: "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimRight",
				Description: "TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimRightFunc",
				Description: "TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimSpace",
				Description: "TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimSuffix",
				Description: "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"tabwriter": []funcSet{
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter allocates and initializes a new [Writer]. The parameters are the same as for the Init function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "tabwriter",
					},
				},
			},
		},
		"synctest": []funcSet{
			funcSet{
				Name:        "Acquire",
				Description: "Acquire returns a reference to the current goroutine's bubble. The bubble will not become idle until Release is called. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Bubble",
						TypePkgName: "synctest",
					},
				},
			},
			funcSet{
				Name:        "Associate",
				Description: "Associate attempts to associate p with the current bubble. It returns the new association status of p. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Association",
						TypePkgName: "synctest",
					},
				},
			},
			funcSet{
				Name:        "Disassociate",
				Description: "Disassociate disassociates p from any bubble. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "IsAssociated",
				Description: "IsAssociated reports whether p is associated with the current bubble. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsInBubble",
				Description: "IsInBubble reports whether the current goroutine is in a bubble. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Run",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Wait",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Test",
				Description: "Test executes f in a new bubble. Test waits for all goroutines in the bubble to exit before returning. If the goroutines in the bubble become deadlocked, the test fails. Test must not be called from within a bubble. The [*testing.T] provided to f has the following properties: - T.Cleanup functions run inside the bubble, immediately before Test returns. - T.Context returns a [context.Context] with a Done channel associated with the bubble. - T.Run, T.Parallel, and T.Deadline must not be called. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Wait",
				Description: "Wait blocks until every goroutine within the current bubble, other than the current goroutine, is durably blocked. Wait must not be called from outside a bubble. Wait must not be called concurrently by multiple goroutines in the same bubble. ",
				Returns:     []returnSet{},
			},
		},
		"fmt": []funcSet{
			funcSet{
				Name:        "Append",
				Description: "Append formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Appendf",
				Description: "Appendf formats according to a format specifier, appends the result to the byte slice, and returns the updated slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Appendln",
				Description: "Appendln formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice. Spaces are always added between operands and a newline is appended. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Errorf",
				Description: "Errorf formats according to a format specifier and returns the string as a value that satisfies error. If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. If there is more than one %w verb, the returned error will implement an Unwrap method returning a []error containing all the %w operands in the order they appear in the arguments. It is invalid to supply the %w verb with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatString",
				Description: "FormatString returns a string representing the fully qualified formatting directive captured by the [State], followed by the argument verb. ([State] does not itself contain the verb.) The result has a leading percent sign followed by any flags, the width, and the precision. Missing flags, width, and precision are omitted. This function allows a [Formatter] to reconstruct the original directive triggering the call to Format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fprint",
				Description: "Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fprintf",
				Description: "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fprintln",
				Description: "Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fscan",
				Description: "Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fscanf",
				Description: "Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fscanln",
				Description: "Fscanln is similar to [Fscan], but stops scanning at a newline and after the final item there must be a newline or EOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Print",
				Description: "Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Printf",
				Description: "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Println",
				Description: "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Scan",
				Description: "Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Scanf",
				Description: "Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Scanln",
				Description: "Scanln is similar to [Scan], but stops scanning at a newline and after the final item there must be a newline or EOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sprint",
				Description: "Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sprintf",
				Description: "Sprintf formats according to a format specifier and returns the resulting string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sprintln",
				Description: "Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sscan",
				Description: "Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sscanf",
				Description: "Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sscanln",
				Description: "Sscanln is similar to [Sscan], but stops scanning at a newline and after the final item there must be a newline or EOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"context": []funcSet{
			funcSet{
				Name:        "AfterFunc",
				Description: "AfterFunc arranges to call f in its own goroutine after ctx is canceled. If ctx is already canceled, AfterFunc calls f immediately in its own goroutine. Multiple calls to AfterFunc on a context operate independently; one does not replace another. Calling the returned stop function stops the association of ctx with f. It returns true if the call stopped f from being run. If stop returns false, either the context is canceled and f has been started in its own goroutine; or f was already stopped. The stop function does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. If ctx has a \"AfterFunc(func()) func() bool\" method, AfterFunc will use it to schedule the call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Background",
				Description: "Background returns a non-nil, empty [Context]. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "Cause",
				Description: "Cause returns a non-nil error explaining why c was canceled. The first cancellation of c or one of its parents sets the cause. If that cancellation happened via a call to CancelCauseFunc(err), then [Cause] returns err. Otherwise Cause(c) returns the same value as c.Err(). Cause returns nil if c has not been canceled yet. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TODO",
				Description: "TODO returns a non-nil, empty [Context]. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithCancel",
				Description: "WithCancel returns a derived context that points to the parent context but has a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first. Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this [Context] complete. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithCancelCause",
				Description: "WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc]. Calling cancel with a non-nil error (the \"cause\") records that error in ctx; it can then be retrieved using Cause(ctx). Calling cancel with nil sets the cause to Canceled. Example use: ctx, cancel := context.WithCancelCause(parent) cancel(myError) ctx.Err() // returns context.Canceled context.Cause(ctx) // returns myError ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelCauseFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithDeadline",
				Description: "WithDeadline returns a derived context that points to the parent context but has the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned [Context.Done] channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first. Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this [Context] complete. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithDeadlineCause",
				Description: "WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the returned Context when the deadline is exceeded. The returned [CancelFunc] does not set the cause. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithTimeout",
				Description: "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). Canceling this context releases resources associated with it, so code should call cancel as soon as the operations running in this [Context] complete: func slowOperationWithTimeout(ctx context.Context) (Result, error) { ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond) defer cancel() // releases resources if slowOperation completes before timeout elapses return slowOperation(ctx) } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithTimeoutCause",
				Description: "WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the returned Context when the timeout expires. The returned [CancelFunc] does not set the cause. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithValue",
				Description: "WithValue returns a derived context that points to the parent Context. In the derived context, the value associated with key is val. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WithoutCancel",
				Description: "WithoutCancel returns a derived context that points to the parent context and is not canceled when parent is canceled. The returned context returns no Deadline or Err, and its Done channel is nil. Calling [Cause] on the returned context returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
		},
		"dsa": []funcSet{
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a public&private key pair. The Parameters of the [PrivateKey] must already be valid (see [GenerateParameters]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateParameters",
				Description: "GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand. Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself. Be aware that calling Sign with an attacker-controlled [PrivateKey] may require an arbitrary amount of CPU. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Verify",
				Description: "Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid. Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"netip": []funcSet{
			funcSet{
				Name:        "AddrFrom16",
				Description: "AddrFrom16 returns the IPv6 address given by the bytes in addr. An IPv4-mapped IPv6 address is left as an IPv6 address. (Use Unmap to convert them if needed.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "AddrFrom4",
				Description: "AddrFrom4 returns the address of the IPv4 address given by the bytes in addr. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "AddrFromSlice",
				Description: "AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address. Note that a [net.IP] can be passed directly as the []byte argument. If slice's length is not 4 or 16, AddrFromSlice returns [Addr]{}, false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AddrPortFrom",
				Description: "AddrPortFrom returns an [AddrPort] with the provided IP and port. It does not allocate. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "IPv4Unspecified",
				Description: "IPv4Unspecified returns the IPv4 unspecified address \"0.0.0.0\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "IPv6LinkLocalAllNodes",
				Description: "IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast address ff02::1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "IPv6LinkLocalAllRouters",
				Description: "IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast address ff02::2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "IPv6Loopback",
				Description: "IPv6Loopback returns the IPv6 loopback address ::1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "IPv6Unspecified",
				Description: "IPv6Unspecified returns the IPv6 unspecified address \"::\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "MustParseAddr",
				Description: "MustParseAddr calls [ParseAddr](s) and panics on error. It is intended for use in tests with hard-coded strings. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "MustParseAddrPort",
				Description: "MustParseAddrPort calls [ParseAddrPort](s) and panics on error. It is intended for use in tests with hard-coded strings. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "MustParsePrefix",
				Description: "MustParsePrefix calls [ParsePrefix](s) and panics on error. It is intended for use in tests with hard-coded strings. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Prefix",
						TypePkgName: "netip",
					},
				},
			},
			funcSet{
				Name:        "ParseAddr",
				Description: "ParseAddr parses s as an IP address, returning the result. The string s can be in dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv6 with a scoped addressing zone (\"fe80::1cc0:3e8c:119f:c2e1%ens18\"). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseAddrPort",
				Description: "ParseAddrPort parses s as an [AddrPort]. It doesn't do any name resolution: both the address and the port must be numeric. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParsePrefix",
				Description: "ParsePrefix parses s as an IP address prefix. The string can be in the form \"192.168.1.0/24\" or \"2001:db8::/32\", the CIDR notation defined in RFC 4632 and RFC 4291. IPv6 zones are not permitted in prefixes, and an error will be returned if a zone is present. Note that masked address bits are not zeroed. Use Masked for that. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Prefix",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PrefixFrom",
				Description: "PrefixFrom returns a [Prefix] with the provided IP address and bit prefix length. It does not allocate. Unlike [Addr.Prefix], [PrefixFrom] does not mask off the host bits of ip. If bits is less than zero or greater than ip.BitLen, [Prefix.Bits] will return an invalid value -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Prefix",
						TypePkgName: "netip",
					},
				},
			},
		},
		"routebsd": []funcSet{
			funcSet{
				Name:        "FetchRIBMessages",
				Description: "FetchRIBMessages fetches a list of addressing messages for an interface. The typ argument is something like syscall.NET_RT_IFLIST. The argument is an interface index or 0 for all. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/routebsd.Message",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"url": []funcSet{
			funcSet{
				Name:        "JoinPath",
				Description: "JoinPath returns a new [URL] with the provided path elements joined to any existing path and the resulting path cleaned of any ./ or ../ elements. Any sequences of multiple / characters will be reduced to a single /. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses a raw url into a [URL] structure. The url may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseQuery",
				Description: "ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any. Query is expected to be a list of key=value settings separated by ampersands. A setting without an equals sign is interpreted as a key set to an empty value. Settings containing a non-URL-encoded semicolon are considered invalid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Values",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseRequestURI",
				Description: "ParseRequestURI parses a raw url into a [URL] structure. It assumes that url was received in an HTTP request, so the url is interpreted only as an absolute URI or an absolute path. The string url is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PathEscape",
				Description: "PathEscape escapes the string so it can be safely placed inside a [URL] path segment, replacing special characters (including /) with %XX sequences as needed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PathUnescape",
				Description: "PathUnescape does the inverse transformation of [PathEscape], converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits. PathUnescape is identical to [QueryUnescape] except that it does not unescape '+' to ' ' (space). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QueryEscape",
				Description: "QueryEscape escapes the string so it can be safely placed inside a [URL] query. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QueryUnescape",
				Description: "QueryUnescape does the inverse transformation of [QueryEscape], converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "User",
				Description: "User returns a [Userinfo] containing the provided username and no password set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Userinfo",
						TypePkgName: "url",
					},
				},
			},
			funcSet{
				Name:        "UserPassword",
				Description: "UserPassword returns a [Userinfo] containing the provided username and password. This functionality should only be used with legacy web sites. RFC 2396 warns that interpreting Userinfo this way âis NOT RECOMMENDED, because the passing of authentication information in clear text (such as URI) has proven to be a security risk in almost every case where it has been used.â ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Userinfo",
						TypePkgName: "url",
					},
				},
			},
		},
		"syslog": []funcSet{
			funcSet{
				Name:        "Dial",
				Description: "Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the facility and severity (from priority) and tag. If tag is empty, the [os.Args][0] is used. If network is empty, Dial will connect to the local syslog server. Otherwise, see the documentation for net.Dial for valid values of network and raddr. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "syslog",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the [os.Args][0] is used. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "syslog",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewLogger",
				Description: "NewLogger creates a [log.Logger] whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to [log.New] to create the Logger. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "log",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sha3": []funcSet{
			funcSet{
				Name:        "New224",
				Description: "New224 returns a new Digest computing the SHA3-224 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New256",
				Description: "New256 returns a new Digest computing the SHA3-256 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New384",
				Description: "New384 returns a new Digest computing the SHA3-384 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New512",
				Description: "New512 returns a new Digest computing the SHA3-512 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewCShake128",
				Description: "NewCShake128 creates a new cSHAKE128 XOF. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation. When N and S are both empty, this is equivalent to NewShake128. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewCShake256",
				Description: "NewCShake256 creates a new cSHAKE256 XOF. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation. When N and S are both empty, this is equivalent to NewShake256. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewLegacyKeccak256",
				Description: "NewLegacyKeccak256 returns a new Digest computing the legacy, non-standard Keccak-256 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewLegacyKeccak512",
				Description: "NewLegacyKeccak512 returns a new Digest computing the legacy, non-standard Keccak-512 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewShake128",
				Description: "NewShake128 creates a new SHAKE128 XOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewShake256",
				Description: "NewShake256 creates a new SHAKE256 XOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New224",
				Description: "New224 creates a new SHA3-224 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHA3",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New256",
				Description: "New256 creates a new SHA3-256 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHA3",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New384",
				Description: "New384 creates a new SHA3-384 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHA3",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "New512",
				Description: "New512 creates a new SHA3-512 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHA3",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewCSHAKE128",
				Description: "NewCSHAKE128 creates a new cSHAKE128 XOF. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation. When N and S are both empty, this is equivalent to NewSHAKE128. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewCSHAKE256",
				Description: "NewCSHAKE256 creates a new cSHAKE256 XOF. N is used to define functions based on cSHAKE, it can be empty when plain cSHAKE is desired. S is a customization byte string used for domain separation. When N and S are both empty, this is equivalent to NewSHAKE256. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewSHAKE128",
				Description: "NewSHAKE128 creates a new SHAKE128 XOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "NewSHAKE256",
				Description: "NewSHAKE256 creates a new SHAKE256 XOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			funcSet{
				Name:        "Sum224",
				Description: "Sum224 returns the SHA3-224 hash of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[28]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum256",
				Description: "Sum256 returns the SHA3-256 hash of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum384",
				Description: "Sum384 returns the SHA3-384 hash of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[48]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum512",
				Description: "Sum512 returns the SHA3-512 hash of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[64]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SumSHAKE128",
				Description: "SumSHAKE128 applies the SHAKE128 extendable output function to data and returns an output of the given length in bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SumSHAKE256",
				Description: "SumSHAKE256 applies the SHAKE256 extendable output function to data and returns an output of the given length in bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"elliptic": []funcSet{
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data. Deprecated: for ECDH, use the GenerateKey methods of the [crypto/ecdh] package; for ECDSA, use the GenerateKey function of the crypto/ecdsa package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Marshal",
				Description: "Marshal converts a point on the curve into the uncompressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined. Deprecated: for ECDH, use the crypto/ecdh package. This function returns an encoding equivalent to that of PublicKey.Bytes in crypto/ecdh. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalCompressed",
				Description: "MarshalCompressed converts a point on the curve into the compressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "P224",
				Description: "P224 returns a [Curve] which implements NIST P-224 (FIPS 186-3, section D.2.2), also known as secp224r1. The CurveParams.Name of this [Curve] is \"P-224\". Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements. The cryptographic operations are implemented using constant-time algorithms. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "elliptic",
					},
				},
			},
			funcSet{
				Name:        "P256",
				Description: "P256 returns a [Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1. The CurveParams.Name of this [Curve] is \"P-256\". Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements. The cryptographic operations are implemented using constant-time algorithms. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "elliptic",
					},
				},
			},
			funcSet{
				Name:        "P384",
				Description: "P384 returns a [Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1. The CurveParams.Name of this [Curve] is \"P-384\". Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements. The cryptographic operations are implemented using constant-time algorithms. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "elliptic",
					},
				},
			},
			funcSet{
				Name:        "P521",
				Description: "P521 returns a [Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1. The CurveParams.Name of this [Curve] is \"P-521\". Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements. The cryptographic operations are implemented using constant-time algorithms. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "elliptic",
					},
				},
			},
			funcSet{
				Name:        "Unmarshal",
				Description: "Unmarshal converts a point, serialized by [Marshal], into an x, y pair. It is an error if the point is not in uncompressed form, is not on the curve, or is the point at infinity. On error, x = nil. Deprecated: for ECDH, use the crypto/ecdh package. This function accepts an encoding equivalent to that of the NewPublicKey methods in crypto/ecdh. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			funcSet{
				Name:        "UnmarshalCompressed",
				Description: "UnmarshalCompressed converts a point, serialized by [MarshalCompressed], into an x, y pair. It is an error if the point is not in compressed form, is not on the curve, or is the point at infinity. On error, x = nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
		},
		"uleb128": []funcSet{
			funcSet{
				Name:        "AppendUleb128",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"encodecounter": []funcSet{
			funcSet{
				Name:        "NewCoverageDataWriter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageDataWriter",
						TypePkgName: "encodecounter",
					},
				},
			},
		},
		"asmgen": []funcSet{
			funcSet{
				Name:        "NewAsm",
				Description: "NewAsm returns a new Asm preparing assembly for the given architecture to be written to file. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Asm",
						TypePkgName: "asmgen",
					},
				},
			},
		},
		"fcgi": []funcSet{
			funcSet{
				Name:        "ProcessEnv",
				Description: "ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[string]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Serve",
				Description: "Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, [http.DefaultServeMux] is used. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"metrics": []funcSet{
			funcSet{
				Name:        "All",
				Description: "All returns a slice of containing metric descriptions for all supported metrics. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]runtime/metrics.Description",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "Read populates each [Value] field in the given slice of metric samples. Desired metrics should be present in the slice with the appropriate name. The user of this API is encouraged to re-use the same slice between calls for efficiency, but is not required to do so. Note that re-use has some caveats. Notably, Values should not be read or manipulated while a Read with that value is outstanding; that is a data race. This property includes pointer-typed Values (for example, [Float64Histogram]) whose underlying storage will be reused by Read when possible. To safely use such values in a concurrent setting, all data must be deep-copied. It is safe to execute multiple Read calls concurrently, but their arguments must share no underlying memory. When in doubt, create a new []Sample from scratch, which is always safe, though may be inefficient. Sample values with names not appearing in [All] will have their Value populated as KindBad to indicate that the name is unknown. ",
				Returns:     []returnSet{},
			},
		},
		"zip": []funcSet{
			funcSet{
				Name:        "FileInfoHeader",
				Description: "FileInfoHeader creates a partially-populated [FileHeader] from an fs.FileInfo. Because fs.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. If compression is desired, callers should set the FileHeader.Method field; it is unset by default. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileHeader",
						TypePkgName: "zip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new [Reader] reading from r, which is assumed to have the given size in bytes. If any file inside the archive uses a non-local name (as defined by [filepath.IsLocal]) or a name containing backslashes and the GODEBUG environment variable contains `zipinsecurepath=0`, NewReader returns the reader with an [ErrInsecurePath] error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the [ErrInsecurePath] error and use the returned reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "zip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer] writing a zip file to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "zip",
					},
				},
			},
			funcSet{
				Name:        "OpenReader",
				Description: "OpenReader will open the Zip file specified by name and return a ReadCloser. If any file inside the archive uses a non-local name (as defined by [filepath.IsLocal]) or a name containing backslashes and the GODEBUG environment variable contains `zipinsecurepath=0`, OpenReader returns the reader with an ErrInsecurePath error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the ErrInsecurePath error and use the returned reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "zip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RegisterCompressor",
				Description: "RegisterCompressor registers custom compressors for a specified method ID. The common methods [Store] and [Deflate] are built in. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RegisterDecompressor",
				Description: "RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, [Reader] will default to looking up the decompressor at the package level. ",
				Returns:     []returnSet{},
			},
		},
		"lzw": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new [io.ReadCloser]. Reads from the returned [io.ReadCloser] read and decompress data from r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression. It is guaranteed that the underlying type of the returned [io.ReadCloser] is a *[Reader]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter creates a new [io.WriteCloser]. Writes to the returned [io.WriteCloser] are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1<<litWidth. It is guaranteed that the underlying type of the returned [io.WriteCloser] is a *[Writer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
		},
		"fips140only": []funcSet{
			funcSet{
				Name:        "ApprovedHash",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ApprovedRandomReader",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"boring": []funcSet{
			funcSet{
				Name:        "DecryptRSANoPadding",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptRSAOAEP",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptRSAPKCS1",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ECDH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptRSANoPadding",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptRSAOAEP",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptRSAPKCS1",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKeyECDH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKeyECDH",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKeyECDSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKeyRSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "BigInt",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewAESCipher",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMTLS",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMTLS13",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewHMAC",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyECDH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKeyECDH",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyECDSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKeyECDSA",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyRSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKeyRSA",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKeyECDH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKeyECDH",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKeyECDSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKeyECDSA",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKeyRSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKeyRSA",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewSHA1",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewSHA224",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewSHA256",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewSHA384",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewSHA512",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "SHA1",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[20]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SHA224",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[28]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SHA256",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SHA384",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[48]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SHA512",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[64]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignMarshalECDSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignRSAPKCS1v15",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignRSAPSS",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unreachable",
				Description: "Unreachable marks code that should be unreachable when BoringCrypto is in use. It is a no-op without BoringCrypto. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "UnreachableExceptTests",
				Description: "UnreachableExceptTests marks code that should be unreachable when BoringCrypto is in use. It is a no-op without BoringCrypto. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "VerifyECDSA",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyRSAPKCS1v15",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyRSAPSS",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"tls13": []funcSet{
			funcSet{
				Name:        "ExpandLabel",
				Description: "ExpandLabel implements HKDF-Expand-Label from RFC 8446, Section 7.1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewEarlySecret",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EarlySecret",
						TypePkgName: "tls13",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyExporterSecret",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"cfile": []funcSet{
			funcSet{
				Name:        "ClearCounters",
				Description: "ClearCounters implements [runtime/coverage.ClearCounters]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "InitHook",
				Description: "InitHook is invoked from the main package \"init\" routine in programs built with \"-cover\". This function is intended to be called only by the compiler (via runtime/coverage.initHook). If 'istest' is false, it indicates we're building a regular program (\"go build -cover ...\"), in which case we immediately try to write out the meta-data file, and register emitCounterData as an exit hook. If 'istest' is true (indicating that the program in question is a Go test binary), then we tentatively queue up both emitMetaData and emitCounterData as exit hooks. In the normal case (e.g. regular \"go test -cover\" run) the testmain.go boilerplate will run at the end of the test, write out the coverage percentage, and then invoke MarkProfileEmitted to indicate that no more work needs to be done. If however that call is never made, this is a sign that the test binary is being used as a replacement binary for the tool being tested, hence we do want to run exit hooks when the program terminates. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MarkProfileEmitted",
				Description: "MarkProfileEmitted signals the coverage machinery that coverage data output files have already been written out, and there is no need to take any additional action at exit time. This function is called from the coverage-related boilerplate code in _testmain.go emitted for go unit tests. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ProcessCoverTestDir",
				Description: "ProcessCoverTestDir is called from testmain code when \"go test -cover\" is in effect. It is not intended to be used other than internally by the Go command's generated code. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Snapshot",
				Description: "Snapshot returns a snapshot of coverage percentage at a moment of time within a running test, so as to support the testing.Coverage() function. This version doesn't examine coverage meta-data, so the result it returns will be less accurate (more \"slop\") due to the fact that we don't look at the meta data to see how many statements are associated with each counter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteCounters",
				Description: "WriteCounters implements [runtime/coverage.WriteCounters]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteCountersDir",
				Description: "WriteCountersDir implements [runtime/coverage.WriteCountersDir]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteMeta",
				Description: "WriteMeta implements [runtime/coverage.WriteMeta]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteMetaDir",
				Description: "WriteMetaDir implements [runtime/coverage.WriteMetaDir]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"plan9obj": []funcSet{
			funcSet{
				Name:        "NewFile",
				Description: "NewFile creates a new [File] for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "plan9obj",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open returns a new ReadSeeker reading the Plan 9 a.out section. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "plan9obj",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"format": []funcSet{
			funcSet{
				Name:        "Node",
				Description: "Node formats node in canonical gofmt style and writes the result to dst. The node type must be *[ast.File], *[printer.CommentedNode], [][ast.Decl], [][ast.Stmt], or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt]. Node does not modify node. Imports are not sorted for nodes representing partial source files (for instance, if the node is not an *[ast.File] or a *[printer.CommentedNode] not wrapping an *[ast.File]). The function may return early (before the entire result is written) and return a formatting error, for instance due to an incorrect AST. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Source",
				Description: "Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements. If src is a partial source file, the leading and trailing space of src is applied to the result (such that it has the same leading and trailing space as src), and the result is indented by the same amount as the first line of src containing code. Imports are not sorted for partial source files. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"importer": []funcSet{
			funcSet{
				Name:        "Default",
				Description: "Default returns an Importer for the compiler that built the running binary. If available, the result implements [types.ImporterFrom]. Default may be convenient for use in the simplest of cases, but most clients should instead use [ForCompiler], which accepts a [token.FileSet] from the caller; without it, all position information derived from the Importer will be incorrect and misleading. See also the package documentation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "For",
				Description: "For calls [ForCompiler] with a new FileSet. Deprecated: Use [ForCompiler], which populates a FileSet with the positions of objects created by the importer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "ForCompiler",
				Description: "ForCompiler returns an Importer for importing from installed packages for the compilers \"gc\" and \"gccgo\", or for importing directly from the source if the compiler argument is \"source\". In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those). The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer. A lookup function must be provided for correct module-aware operation. Deprecated: If lookup is nil, for backwards-compatibility, the importer will attempt to resolve imports in the $GOPATH workspace. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "types",
					},
				},
			},
		},
		"html": []funcSet{
			funcSet{
				Name:        "EscapeString",
				Description: "EscapeString escapes special characters like \"<\" to become \"&lt;\". It escapes only five such characters: <, >, &, ' and \". [UnescapeString](EscapeString(s)) == s always holds, but the converse isn't always true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnescapeString",
				Description: "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a larger range of entities than [EscapeString] escapes. For example, \"&aacute;\" unescapes to \"Ã¡\", as does \"&#225;\" and \"&#xE1;\". UnescapeString([EscapeString](s)) == s always holds, but the converse isn't always true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"color": []funcSet{
			funcSet{
				Name:        "CMYKToRGB",
				Description: "CMYKToRGB converts a [CMYK] quadruple to an RGB triple. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ModelFunc",
				Description: "ModelFunc returns a [Model] that invokes f to implement the conversion. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			funcSet{
				Name:        "RGBToCMYK",
				Description: "RGBToCMYK converts an RGB triple to a CMYK quadruple. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RGBToYCbCr",
				Description: "RGBToYCbCr converts an RGB triple to a Y'CbCr triple. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "YCbCrToRGB",
				Description: "YCbCrToRGB converts a Y'CbCr triple to an RGB triple. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
		},
		"profile": []funcSet{
			funcSet{
				Name:        "CreateNodes",
				Description: "CreateNodes creates graph nodes for all locations in a profile. It returns set of all nodes, plus a mapping of each location to the set of corresponding nodes (one per location.Line). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nodes",
						TypePkgName: "profile",
					},
					returnSet{
						TypeName:    "locationMap",
						TypePkgName: "profile",
					},
				},
			},
			funcSet{
				Name:        "Merge",
				Description: "Merge merges all the profiles in profs into a single Profile. Returns a new profile independent of the input profiles. The merged profile is compacted to eliminate unused samples, locations, functions and mappings. Profiles must have identical profile sample and period types or the merge will fail. profile.Period of the resulting profile will be the maximum of all profiles, and profile.TimeNanos will be the earliest nonzero one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "profile",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGraph",
				Description: "NewGraph computes a graph from a profile. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Graph",
						TypePkgName: "profile",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses a profile and checks for its validity. The input must be an encoded pprof protobuf, which may optionally be gzip-compressed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "profile",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"pprof": []funcSet{
			funcSet{
				Name:        "Do",
				Description: "Do calls f with a copy of the parent context with the given labels added to the parent's label map. Goroutines spawned while executing f will inherit the augmented label-set. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ForLabels",
				Description: "ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Label",
				Description: "Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Labels",
				Description: "Labels takes an even number of strings representing key-value pairs and makes a [LabelSet] containing them. A label overwrites a prior label with the same key. Currently only the CPU and goroutine profiles utilize any labels information. See https://golang.org/issue/23458 for details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "LabelSet",
						TypePkgName: "pprof",
					},
				},
			},
			funcSet{
				Name:        "Lookup",
				Description: "Lookup returns the profile with the given name, or nil if no such profile exists. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "pprof",
					},
				},
			},
			funcSet{
				Name:        "NewProfile",
				Description: "NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "pprof",
					},
				},
			},
			funcSet{
				Name:        "Profiles",
				Description: "Profiles returns a slice of all the known profiles, sorted by name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*runtime/pprof.Profile",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetGoroutineLabels",
				Description: "SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than [Do], which should be used instead when possible. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StartCPUProfile",
				Description: "StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled. On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call [os/signal.Notify] for [syscall.SIGPROF], but note that doing so may break any profiling being done by the main program. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StopCPUProfile",
				Description: "StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WithLabels",
				Description: "WithLabels returns a new [context.Context] with the given labels added. A label overwrites a prior label with the same key. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "WriteHeapProfile",
				Description: "WriteHeapProfile is shorthand for [Lookup](\"heap\").WriteTo(w, 0). It is preserved for backwards compatibility. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cmdline",
				Description: "Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Handler",
				Description: "Handler returns an HTTP handler that serves the named profile. Available profiles can be found in [runtime/pprof.Profile]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "Index responds with the pprof-formatted profile named by the request. For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds to a request for \"/debug/pprof/\" with an HTML page listing the available profiles. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Profile",
				Description: "Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Symbol",
				Description: "Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Trace",
				Description: "Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace. ",
				Returns:     []returnSet{},
			},
		},
		"user": []funcSet{
			funcSet{
				Name:        "Current",
				Description: "Current returns the current user. The first call will cache the current user information. Subsequent calls will return the cached value and will not reflect changes to the current user. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "User",
						TypePkgName: "user",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lookup",
				Description: "Lookup looks up a user by username. If the user cannot be found, the returned error is of type [UnknownUserError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "User",
						TypePkgName: "user",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupGroup",
				Description: "LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type [UnknownGroupError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Group",
						TypePkgName: "user",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupGroupId",
				Description: "LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type [UnknownGroupIdError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Group",
						TypePkgName: "user",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupId",
				Description: "LookupId looks up a user by userid. If the user cannot be found, the returned error is of type [UnknownUserIdError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "User",
						TypePkgName: "user",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sig": []funcSet{
			funcSet{
				Name:        "BoringCrypto",
				Description: "BoringCrypto indicates that the BoringCrypto module is present. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "FIPSOnly",
				Description: "FIPSOnly indicates that package crypto/tls/fipsonly is present. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StandardCrypto",
				Description: "StandardCrypto indicates that standard Go crypto is present. ",
				Returns:     []returnSet{},
			},
		},
		"hex": []funcSet{
			funcSet{
				Name:        "AppendDecode",
				Description: "AppendDecode appends the hexadecimally decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendEncode",
				Description: "AppendEncode appends the hexadecimally encoded src to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Decode",
				Description: "Decode decodes src into [DecodedLen](len(src)) bytes, returning the actual number of bytes written to dst. Decode expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, Decode returns the number of bytes decoded before the error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeString",
				Description: "DecodeString returns the bytes represented by the hexadecimal string s. DecodeString expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, DecodeString returns the bytes decoded before the error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodedLen",
				Description: "DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dump",
				Description: "Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dumper",
				Description: "Dumper returns a [io.WriteCloser] that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode encodes src into [EncodedLen](len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always [EncodedLen](len(src)). Encode implements hexadecimal encoding. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeToString",
				Description: "EncodeToString returns the hexadecimal encoding of src. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodedLen",
				Description: "EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n * 2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder returns an [io.Reader] that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns an [io.Writer] that writes lowercase hexadecimal characters to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
		},
		"srcimporter": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new Importer for the given context, file set, and map of packages. The context is used to resolve import paths to package paths, and identifying the files belonging to the package. If the context provides non-nil file system functions, they are used instead of the regular package os functions. The file set is used to track position information of package files; and imported packages are added to the packages map. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "srcimporter",
					},
				},
			},
		},
		"traceviewer": []funcSet{
			funcSet{
				Name:        "BuildProfile",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "profile",
					},
				},
			},
			funcSet{
				Name:        "MMUHandlerFunc",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "HandlerFunc",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "MainHandler",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewEmitter",
				Description: "NewEmitter returns a new Emitter that writes to c. The rangeStart and rangeEnd args are used for splitting large traces. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Emitter",
						TypePkgName: "traceviewer",
					},
				},
			},
			funcSet{
				Name:        "SVGProfileHandlerFunc",
				Description: "SVGProfileHandlerFunc serves pprof-like profile generated by prof as svg. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "HandlerFunc",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "SplittingTraceConsumer",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "splitter",
						TypePkgName: "traceviewer",
					},
					returnSet{
						TypeName:    "TraceConsumer",
						TypePkgName: "traceviewer",
					},
				},
			},
			funcSet{
				Name:        "StaticHandler",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "TraceHandler",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "ViewerDataTraceConsumer",
				Description: "ViewerDataTraceConsumer returns a TraceConsumer that writes to w. The startIdx and endIdx are used for splitting large traces. They refer to indexes in the traceEvents output array, not the events in the trace input. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TraceConsumer",
						TypePkgName: "traceviewer",
					},
				},
			},
			funcSet{
				Name:        "WalkStackFrames",
				Description: "WalkStackFrames calls fn for id and all of its parent frames from allFrames. ",
				Returns:     []returnSet{},
			},
		},
		"cpu": []funcSet{
			funcSet{
				Name:        "Initialize",
				Description: "Initialize examines the processor and sets the relevant variables above. This is called by the runtime package early in program initialization, before normal init functions are run. env is set by runtime if the OS supports cpu feature options in GODEBUG. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Name",
				Description: "Name returns the CPU name given by the vendor if it can be read directly from memory or by CPU instructions. If the CPU name can not be determined an empty string is returned. Implementations that use the Operating System (e.g. sysctl or /sys/) to gather CPU information for display should be placed in internal/sysinfo. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"big": []funcSet{
			funcSet{
				Name:        "Jacobi",
				Description: "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewFloat",
				Description: "NewFloat allocates and returns a new [Float] set to x, with precision 53 and rounding mode [ToNearestEven]. NewFloat panics with [ErrNaN] if x is a NaN. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			funcSet{
				Name:        "NewInt",
				Description: "NewInt allocates and returns a new [Int] set to x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			funcSet{
				Name:        "NewRat",
				Description: "NewRat creates a new [Rat] with numerator a and denominator b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rat",
						TypePkgName: "big",
					},
				},
			},
			funcSet{
				Name:        "ParseFloat",
				Description: "ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"scanner": []funcSet{
			funcSet{
				Name:        "PrintError",
				Description: "PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an [ErrorList]. Otherwise it prints the err string. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TokenString",
				Description: "TokenString returns a printable string for a token or Unicode character. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"cookiejar": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new cookie jar. A nil [*Options] is equivalent to a zero Options. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Jar",
						TypePkgName: "cookiejar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gzip": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new [Reader] reading the given reader. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. It is the caller's responsibility to call [Reader.Close] when done. The Reader.[Header] fields will be valid in the [Reader] returned. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "gzip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer]. Writes to the returned writer are compressed and written to w. It is the caller's responsibility to call Close on the [Writer] when done. Writes may be buffered and not flushed until Close. Callers that wish to set the fields in Writer.[Header] must do so before the first call to Write, Flush, or Close. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "gzip",
					},
				},
			},
			funcSet{
				Name:        "NewWriterLevel",
				Description: "NewWriterLevel is like [NewWriter] but specifies the compression level instead of assuming [DefaultCompression]. The compression level can be [DefaultCompression], [NoCompression], [HuffmanOnly] or any integer value between [BestSpeed] and [BestCompression] inclusive. The error returned will be nil if the level is valid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "gzip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"byteorder": []funcSet{
			funcSet{
				Name:        "BEAppendUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEAppendUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEAppendUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEPutUint16",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEPutUint32",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEPutUint64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEAppendUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEAppendUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEAppendUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEPutUint16",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LEPutUint32",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LEPutUint64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LEUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEAppendUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEAppendUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEAppendUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEPutUint16",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEPutUint32",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEPutUint64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BEUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BEUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEPutUint64",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LEUint16",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LEUint64",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
		},
		"cryptotest": []funcSet{
			funcSet{
				Name:        "FetchModule",
				Description: "FetchModule fetches the module at the given version and returns the directory containing its source tree. It skips the test if fetching modules is not possible in this environment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NoExtraMethods",
				Description: "NoExtraMethods checks that the concrete type of *ms has no exported methods beyond the methods of the interface type of *ms, and any others specified in the allowed list. These methods are accessible through interface upgrades, so they end up part of the API even if undocumented per Hyrum's Law. ms must be a pointer to a non-nil interface. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SkipTestAllocations",
				Description: "SkipTestAllocations skips the test if there are any factors that interfere with allocation optimizations. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestAEAD",
				Description: "TestAEAD performs a set of tests on cipher.AEAD implementations, checking the documented requirements of NonceSize, Overhead, Seal and Open. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestAllImplementations",
				Description: "TestAllImplementations runs the provided test function with each available implementation of the package registered with crypto/internal/impl. If there are no alternative implementations for pkg, f is invoked directly once. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestBlock",
				Description: "TestBlock performs a set of tests on cipher.Block implementations, checking the documented requirements of BlockSize, Encrypt, and Decrypt. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestBlockMode",
				Description: "TestBlockMode performs a set of tests on cipher.BlockMode implementations, checking the documented requirements of CryptBlocks. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestHash",
				Description: "TestHash performs a set of tests on hash.Hash implementations, checking the documented requirements of Write, Sum, Reset, Size, and BlockSize. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestStream",
				Description: "TestStream performs a set of tests on cipher.Stream implementations, checking the documented requirements of XORKeyStream. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestStreamFromBlock",
				Description: "TestStreamFromBlock creates a Stream from a cipher.Block used in a cipher.BlockMode. It addresses Issue 68377 by checking for a panic when the BlockMode uses an IV with incorrect length. For a valid IV, it also runs all TestStream tests on the resulting stream. ",
				Returns:     []returnSet{},
			},
		},
		"stringtab": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a stringtab.Reader to read the contents of a string table from 'r'. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "stringtab",
					},
				},
			},
		},
		"testgen": []funcSet{
			funcSet{
				Name:        "Main",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NewTrace",
				Description: "NewTrace creates a new trace. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Trace",
						TypePkgName: "testgen",
					},
				},
			},
		},
		"list": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns an initialized list. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "List",
						TypePkgName: "list",
					},
				},
			},
		},
		"bigmod": []funcSet{
			funcSet{
				Name:        "NewModulus",
				Description: "NewModulus creates a new Modulus from a slice of big-endian bytes. The modulus must be greater than one. The number of significant bits and whether the modulus is even is leaked through timing side-channels. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Modulus",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewModulusProduct",
				Description: "NewModulusProduct creates a new Modulus from the product of two numbers represented as big-endian byte slices. The result must be greater than one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Modulus",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewNat",
				Description: "NewNat returns a new nat with a size of zero, just like new(Nat), but with the preallocated capacity to hold a number of up to preallocTarget bits. NewNat inlines, so the allocation can live on the stack. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
		},
		"sha1": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new [hash.Hash] computing the SHA1 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Sum",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[20]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"xcoff": []funcSet{
			funcSet{
				Name:        "NewArchive",
				Description: "NewArchive creates a new Archive for accessing an AIX big archive in an underlying reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Archive",
						TypePkgName: "xcoff",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewFile",
				Description: "NewFile creates a new File for accessing an XCOFF binary in an underlying reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "xcoff",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open opens the named file using os.Open and prepares it for use as an XCOFF binary. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "xcoff",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenArchive",
				Description: "OpenArchive opens the named archive using os.Open and prepares it for use as an AIX big archive. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Archive",
						TypePkgName: "xcoff",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"types": []funcSet{
			funcSet{
				Name:        "AssertableTo",
				Description: "AssertableTo reports whether a value of type V can be asserted to have type T. The behavior of AssertableTo is unspecified in three cases: - if T is Typ[Invalid] - if V is a generalized interface; i.e., an interface that may only be used as a type constraint in Go code - if T is an uninstantiated generic type ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AssignableTo",
				Description: "AssignableTo reports whether a value of type V is assignable to a variable of type T. The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an uninstantiated generic type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CheckExpr",
				Description: "CheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. [Type] information about the expression is recorded in info. The expression may be an identifier denoting an uninstantiated generic function or type. If pkg == nil, the [Universe] scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package. An error is returned if pos is not within the package or if the node cannot be type-checked. Note: [Eval] and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather than the respective context-specific type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Comparable",
				Description: "Comparable reports whether values of type T are comparable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConvertibleTo",
				Description: "ConvertibleTo reports whether a value of type V is convertible to a value of type T. The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an uninstantiated generic type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DefPredeclaredTestFuncs",
				Description: "DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Default",
				Description: "Default returns the default \"typed\" type for an \"untyped\" type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "Eval",
				Description: "Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set. The meaning of the parameters fset, pkg, and pos is the same as in [CheckExpr]. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeAndValue",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ExprString",
				Description: "ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Id",
				Description: "Id returns name if it is exported, otherwise it returns the name qualified with the package path. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Identical",
				Description: "Identical reports whether x and y are identical types. Receivers of [Signature] types are ignored. Predicates such as [Identical], [Implements], and [Satisfies] assume that both operands belong to a consistent collection of symbols ([Object] values). For example, two [Named] types can be identical only if their [Named.Obj] methods return the same [TypeName] symbol. A collection of symbols is consistent if, for each logical package whose path is P, the creation of those symbols involved at most one call to [NewPackage](P, ...). To ensure consistency, use a single [Importer] for all loaded packages and their dependencies. For more information, see https://github.com/golang/go/issues/57497. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IdenticalIgnoreTags",
				Description: "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of [Signature] types are ignored. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Implements",
				Description: "Implements reports whether type V implements interface T. The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated generic type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Instantiate",
				Description: "Instantiate instantiates the type orig with the given type arguments targs. orig must be an *Alias, *Named, or *Signature type. If there is no error, the resulting Type is an instantiated type of the same kind (*Alias, *Named or *Signature, respectively). Methods attached to a *Named type are also instantiated, and associated with a new *Func that has the same position as the original method, but nil function scope. If ctxt is non-nil, it may be used to de-duplicate the instance against previous instances with the same identity. As a special case, generic *Signature origin types are only considered identical if they are pointer equivalent, so that instantiating distinct (but possibly identical) signatures will yield different instances. The use of a shared context does not guarantee that identical instances are deduplicated in all cases. If validate is set, Instantiate verifies that the number of type arguments and parameters match, and that the type arguments satisfy their respective type constraints. If verification fails, the resulting error may wrap an *ArgumentError indicating which type argument did not satisfy its type parameter constraint, and why. If validate is not set, Instantiate does not verify the type argument count or whether the type arguments satisfy their constraints. Instantiate is guaranteed to not return an error, but may panic. Specifically, for *Signature types, Instantiate will panic immediately if the type argument count is incorrect; for *Named types, a panic may occur later inside the *Named API. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsInterface",
				Description: "IsInterface reports whether t is an interface type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupFieldOrMethod",
				Description: "LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups). T must not be nil. The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either: 1. the list of declared methods of a named type; or 2. the list of all methods (method set) of an interface type; or 3. the list of fields of a struct type. The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0. If no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning: - If index != nil, the index sequence points to an ambiguous entry (the same name appeared more than once at the same embedding level). - If indirect is set, a method with a pointer receiver type was found but there was no pointer on the path from the actual receiver type to the method's formal receiver base type, nor was the receiver addressable. See also [LookupSelection], which returns the result as a [Selection]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LookupSelection",
				Description: "LookupSelection selects the field or method whose ID is Id(pkg, name), on a value of type T. If addressable is set, T is the type of an addressable variable (this matters only for method lookups). T must not be nil. If the selection is valid: - [Selection.Obj] returns the field ([Var]) or method ([Func]); - [Selection.Indirect] reports whether there were any pointer indirections on the path to the field or method. - [Selection.Index] returns the index sequence, defined below. The last index entry is the field or method index in the (possibly embedded) type where the entry was found, either: 1. the list of declared methods of a named type; or 2. the list of all methods (method set) of an interface type; or 3. the list of fields of a struct type. The earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0. See also [LookupFieldOrMethod], which returns the components separately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Selection",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MissingMethod",
				Description: "MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type: either a pointer receiver or wrong signature. For non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewAlias",
				Description: "NewAlias creates a new Alias type with the given type name and rhs. rhs must not be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alias",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewArray",
				Description: "NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Array",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewChan",
				Description: "NewChan returns a new channel type for the given direction and element type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Chan",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewChecker",
				Description: "NewChecker returns a new [Checker] instance for a given package. [Package] files may be added incrementally via checker.Files. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Checker",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewConst",
				Description: "NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Const",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewContext",
				Description: "NewContext creates a new Context. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewField",
				Description: "NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name under which the field is accessible. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewFunc",
				Description: "NewFunc returns a new function with the given signature, representing the function's type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewInterface",
				Description: "NewInterface returns a new interface for the given methods and embedded types. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. Deprecated: Use NewInterfaceType instead which allows arbitrary embedded types. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewInterfaceType",
				Description: "NewInterfaceType returns a new interface for the given methods and embedded types. NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To avoid race conditions, the interface's type set should be computed before concurrent use of the interface, by explicitly calling Complete. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewLabel",
				Description: "NewLabel returns a new label. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Label",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewMap",
				Description: "NewMap returns a new map for the given key and element types. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewMethodSet",
				Description: "NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "MethodSet",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewNamed",
				Description: "NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewPackage",
				Description: "NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewParam",
				Description: "NewParam returns a new variable representing a function parameter. The caller must subsequently call [Var.SetKind] if the desired Var is not of kind [ParamVar]: for example, [RecvVar] or [ResultVar]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewPkgName",
				Description: "NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PkgName",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewPointer",
				Description: "NewPointer returns a new pointer type for the given element (base) type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pointer",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewScope",
				Description: "NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scope",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewSignature",
				Description: "NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type. Deprecated: Use [NewSignatureType] instead which allows for type parameters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewSignatureType",
				Description: "NewSignatureType creates a new function type for the given receiver, receiver type parameters, type parameters, parameters, and results. If variadic is set, params must hold at least one parameter and the last parameter must be an unnamed slice or a type parameter whose type set has an unnamed slice as common underlying type. As a special case, for variadic signatures the last parameter may also be a string type, or a type parameter containing a mix of byte slices and string types in its type set. If recv is non-nil, typeParams must be empty. If recvTypeParams is non-empty, recv must be non-nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewSlice",
				Description: "NewSlice returns a new slice type for the given element type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Slice",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewStruct",
				Description: "NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Struct",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewTerm",
				Description: "NewTerm returns a new union term. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Term",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewTuple",
				Description: "NewTuple returns a new tuple for the given variables. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tuple",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewTypeName",
				Description: "NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects. The typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeName",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewTypeParam",
				Description: "NewTypeParam returns a new TypeParam. Type parameters may be set on a Named type by calling SetTypeParams. Setting a type parameter on more than one type will result in a panic. The constraint argument can be nil, and set later via SetConstraint. If the constraint is non-nil, it must be fully defined. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParam",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewUnion",
				Description: "NewUnion returns a new [Union] type with the given terms. It is an error to create an empty union; they are syntactically not possible. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Union",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "NewVar",
				Description: "NewVar returns a new variable. The arguments set the attributes found with all Objects. The caller must subsequently call [Var.SetKind] if the desired Var is not of kind [PackageVar]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "ObjectString",
				Description: "ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RelativeTo",
				Description: "RelativeTo returns a [Qualifier] that fully qualifies members of all packages other than pkg. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Qualifier",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "Satisfies",
				Description: "Satisfies reports whether type V satisfies the constraint T. The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated generic type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SelectionString",
				Description: "SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil. Examples: \"field (T) f int\" \"method (T) f(X) Y\" \"method expr (T) f(X) Y\" ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SizesFor",
				Description: "SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known. Supported architectures for compiler \"gc\": \"386\", \"amd64\", \"amd64p32\", \"arm\", \"arm64\", \"loong64\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sizes",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "TypeString",
				Description: "TypeString returns the string representation of typ. The [Qualifier] controls the printing of package-level objects, and may be nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unalias",
				Description: "Unalias returns t if it is not an alias type; otherwise it follows t's alias chain until it reaches a non-alias type which is then returned. Consequently, the result is never an alias type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			funcSet{
				Name:        "WriteExpr",
				Description: "WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WriteSignature",
				Description: "WriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The [Qualifier] controls the printing of package-level objects, and may be nil. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WriteType",
				Description: "WriteType writes the string representation of typ to buf. The [Qualifier] controls the printing of package-level objects, and may be nil. ",
				Returns:     []returnSet{},
			},
		},
		"coverage": []funcSet{
			funcSet{
				Name:        "HardCodedPkgID",
				Description: "HardCodedPkgID returns the hard-coded ID for the specified package path, or -1 if we don't use a hard-coded ID. Hard-coded IDs start at -2 and decrease as we go down the list. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCounterMode",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterMode",
						TypePkgName: "coverage",
					},
				},
			},
			funcSet{
				Name:        "Round4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ClearCounters",
				Description: "ClearCounters clears/resets all coverage counter variables in the currently running program. It returns an error if the program in question was not built with the \"-cover\" flag. Clearing of coverage counters is also not supported for programs not using atomic counter mode (see more detailed comments below for the rationale here). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteCounters",
				Description: "WriteCounters writes coverage counter-data content for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails). The counter data written will be a snapshot taken at the point of the invocation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteCountersDir",
				Description: "WriteCountersDir writes a coverage counter-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist). The counter data written will be a snapshot taken at the point of the call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteMeta",
				Description: "WriteMeta writes the meta-data content (the payload that would normally be emitted to a meta-data file) for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteMetaDir",
				Description: "WriteMetaDir writes a coverage meta-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gcimporter": []funcSet{
			funcSet{
				Name:        "Import",
				Description: "Import imports a gc-generated package given its import path and srcDir, adds the corresponding package object to the packages map, and returns the object. The packages map must contain all packages already imported. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"draw": []funcSet{
			funcSet{
				Name:        "Draw",
				Description: "Draw implements the [Drawer] interface by calling the Draw function with this [Op]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "DrawMask",
				Description: "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque. ",
				Returns:     []returnSet{},
			},
		},
		"base64": []funcSet{
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder constructs a new base64 stream decoder. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoding",
				Description: "NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that contains unique byte values and does not contain the padding character or CR / LF ('\\r', '\\n'). The alphabet is treated as a sequence of byte values without any special treatment for multi-byte UTF-8. The resulting Encoding uses the default padding character ('='), which may be changed or disabled via [Encoding.WithPadding]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoding",
						TypePkgName: "base64",
					},
				},
			},
		},
		"csv": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new Reader that reads from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "csv",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new Writer that writes to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "csv",
					},
				},
			},
		},
		"bufio": []funcSet{
			funcSet{
				Name:        "NewReadWriter",
				Description: "NewReadWriter allocates a new [ReadWriter] that dispatches to r and w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadWriter",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new [Reader] whose buffer has the default size. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "NewReaderSize",
				Description: "NewReaderSize returns a new [Reader] whose buffer has at least the specified size. If the argument io.Reader is already a [Reader] with large enough size, it returns the underlying [Reader]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "NewScanner",
				Description: "NewScanner returns a new [Scanner] to read from r. The split function defaults to [ScanLines]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scanner",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer] whose buffer has the default size. If the argument io.Writer is already a [Writer] with large enough buffer size, it returns the underlying [Writer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "NewWriterSize",
				Description: "NewWriterSize returns a new [Writer] whose buffer has at least the specified size. If the argument io.Writer is already a [Writer] with large enough size, it returns the underlying [Writer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "bufio",
					},
				},
			},
			funcSet{
				Name:        "ScanBytes",
				Description: "ScanBytes is a split function for a [Scanner] that returns each byte as a token. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ScanLines",
				Description: "ScanLines is a split function for a [Scanner] that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\\r?\\n`. The last non-empty line of input will be returned even if it has no newline. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ScanRunes",
				Description: "ScanRunes is a split function for a [Scanner] that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ScanWords",
				Description: "ScanWords is a split function for a [Scanner] that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"base32": []funcSet{
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder constructs a new base32 stream decoder. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoding",
				Description: "NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 32-byte string that contains unique byte values and does not contain the padding character or CR / LF ('\\r', '\\n'). The alphabet is treated as a sequence of byte values without any special treatment for multi-byte UTF-8. The resulting Encoding uses the default padding character ('='), which may be changed or disabled via [Encoding.WithPadding]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoding",
						TypePkgName: "base32",
					},
				},
			},
		},
		"gover": []funcSet{
			funcSet{
				Name:        "CmpInt",
				Description: "CmpInt returns cmp.Compare(x, y) interpreting x and y as decimal numbers. (Copied from golang.org/x/mod/semver's compareInt.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compare",
				Description: "Compare returns -1, 0, or +1 depending on whether x < y, x == y, or x > y, interpreted as toolchain versions. The versions x and y must not begin with a \"go\" prefix: just \"1.21\" not \"go1.21\". Malformed versions compare less than well-formed versions and equal to each other. The language version \"1.21\" compares less than the release candidate and eventual releases \"1.21rc1\" and \"1.21.0\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecInt",
				Description: "DecInt returns the decimal string decremented by 1, or the empty string if the decimal is all zeroes. (Copied from golang.org/x/mod/module's decDecimal.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLang",
				Description: "IsLang reports whether v denotes the overall Go language version and not a specific release. Starting with the Go 1.21 release, \"1.x\" denotes the overall language version; the first release is \"1.x.0\". The distinction is important because the relative ordering is 1.21 < 1.21rc1 < 1.21.0 meaning that Go 1.21rc1 and Go 1.21.0 will both handle go.mod files that say \"go 1.21\", but Go 1.21rc1 will not handle files that say \"go 1.21.0\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsValid",
				Description: "IsValid reports whether the version x is valid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lang",
				Description: "Lang returns the Go language version. For example, Lang(\"1.2.3\") == \"1.2\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Max",
				Description: "Max returns the maximum of x and y interpreted as toolchain versions, compared using Compare. If x and y compare equal, Max returns x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses the Go version string x into a version. It returns the zero version if x is malformed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "gover",
					},
				},
			},
		},
		"buffer": []funcSet{
			funcSet{
				Name:        "New",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Buffer",
						TypePkgName: "buffer",
					},
				},
			},
		},
		"ecdh": []funcSet{
			funcSet{
				Name:        "ECDH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a new ECDSA private key pair for the specified curve. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "P224",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P256",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P384",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P521",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P256",
				Description: "P256 returns a [Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3), also known as secp256r1 or prime256v1. Multiple invocations of this function will return the same value, which can be used for equality checks and switch statements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P384",
				Description: "P384 returns a [Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4), also known as secp384r1. Multiple invocations of this function will return the same value, which can be used for equality checks and switch statements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "P521",
				Description: "P521 returns a [Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5), also known as secp521r1. Multiple invocations of this function will return the same value, which can be used for equality checks and switch statements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
			funcSet{
				Name:        "X25519",
				Description: "X25519 returns a [Curve] which implements the X25519 function over Curve25519 (RFC 7748, Section 5). Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdh",
					},
				},
			},
		},
		"quotedprintable": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a quoted-printable reader, decoding from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "quotedprintable",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter returns a new [Writer] that writes to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "quotedprintable",
					},
				},
			},
		},
		"io": []funcSet{
			funcSet{
				Name:        "Copy",
				Description: "Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any. A successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. If src implements [WriterTo], the copy is implemented by calling src.WriteTo(dst). Otherwise, if dst implements [ReaderFrom], the copy is implemented by calling dst.ReadFrom(src). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CopyBuffer",
				Description: "CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics. If either src implements [WriterTo] or dst implements [ReaderFrom], buf will not be used to perform the copy. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CopyN",
				Description: "CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil. If dst implements [ReaderFrom], the copy is implemented using it. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LimitReader",
				Description: "LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "MultiReader",
				Description: "MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "MultiWriter",
				Description: "MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command. Each write is written to each listed writer, one at a time. If a listed writer returns an error, that overall write operation stops and returns the error; it does not continue down the list. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewOffsetWriter",
				Description: "NewOffsetWriter returns an [OffsetWriter] that writes to w starting at offset off. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "OffsetWriter",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewSectionReader",
				Description: "NewSectionReader returns a [SectionReader] that reads from r starting at offset off and stops with EOF after n bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SectionReader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NopCloser",
				Description: "NopCloser returns a [ReadCloser] with a no-op Close method wrapping the provided [Reader] r. If r implements [WriterTo], the returned [ReadCloser] will implement [WriterTo] by forwarding calls to r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "Pipe",
				Description: "Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an [io.Reader] with code expecting an [io.Writer]. Reads and Writes on the pipe are matched one to one except when multiple Reads are needed to consume a single Write. That is, each Write to the [PipeWriter] blocks until it has satisfied one or more Reads from the [PipeReader] that fully consume the written data. The data is copied directly from the Write to the corresponding Read (or Reads); there is no internal buffering. It is safe to call Read and Write in parallel with each other or with Close. Parallel calls to Read and parallel calls to Write are also safe: the individual calls will be gated sequentially. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PipeReader",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "PipeWriter",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "ReadAll",
				Description: "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadAtLeast",
				Description: "ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns [ErrUnexpectedEOF]. If min is greater than the length of buf, ReadAtLeast returns [ErrShortBuffer]. On return, n >= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFull",
				Description: "ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns [ErrUnexpectedEOF]. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TeeReader",
				Description: "TeeReader returns a [Reader] that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "WriteString",
				Description: "WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements [StringWriter], [StringWriter.WriteString] is invoked directly. Otherwise, [Writer.Write] is called exactly once. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"bits": []funcSet{
			funcSet{
				Name:        "Add",
				Description: "Add returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Add32",
				Description: "Add32 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Add64",
				Description: "Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Div",
				Description: "Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 (division by zero) or y <= hi (quotient overflow). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Div32",
				Description: "Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 (division by zero) or y <= hi (quotient overflow). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Div64",
				Description: "Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0 (division by zero) or y <= hi (quotient overflow). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros",
				Description: "LeadingZeros returns the number of leading zero bits in x; the result is [UintSize] for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros16",
				Description: "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros32",
				Description: "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros64",
				Description: "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LeadingZeros8",
				Description: "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len",
				Description: "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len16",
				Description: "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len32",
				Description: "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len64",
				Description: "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Len8",
				Description: "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mul",
				Description: "Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mul32",
				Description: "Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mul64",
				Description: "Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount",
				Description: "OnesCount returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount16",
				Description: "OnesCount16 returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount32",
				Description: "OnesCount32 returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount64",
				Description: "OnesCount64 returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnesCount8",
				Description: "OnesCount8 returns the number of one bits (\"population count\") in x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rem",
				Description: "Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but, unlike Div, it doesn't panic on a quotient overflow. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rem32",
				Description: "Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but, unlike [Div32], it doesn't panic on a quotient overflow. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rem64",
				Description: "Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y == 0 (division by zero) but, unlike [Div64], it doesn't panic on a quotient overflow. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse",
				Description: "Reverse returns the value of x with its bits in reversed order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse16",
				Description: "Reverse16 returns the value of x with its bits in reversed order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse32",
				Description: "Reverse32 returns the value of x with its bits in reversed order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse64",
				Description: "Reverse64 returns the value of x with its bits in reversed order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Reverse8",
				Description: "Reverse8 returns the value of x with its bits in reversed order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReverseBytes",
				Description: "ReverseBytes returns the value of x with its bytes in reversed order. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReverseBytes16",
				Description: "ReverseBytes16 returns the value of x with its bytes in reversed order. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReverseBytes32",
				Description: "ReverseBytes32 returns the value of x with its bytes in reversed order. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReverseBytes64",
				Description: "ReverseBytes64 returns the value of x with its bytes in reversed order. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RotateLeft",
				Description: "RotateLeft returns the value of x rotated left by (k mod [UintSize]) bits. To rotate x right by k bits, call RotateLeft(x, -k). This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RotateLeft16",
				Description: "RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k). This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RotateLeft32",
				Description: "RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k). This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RotateLeft64",
				Description: "RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k). This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RotateLeft8",
				Description: "RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k). This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sub",
				Description: "Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sub32",
				Description: "Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sub64",
				Description: "Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros",
				Description: "TrailingZeros returns the number of trailing zero bits in x; the result is [UintSize] for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros16",
				Description: "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros32",
				Description: "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros64",
				Description: "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrailingZeros8",
				Description: "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"pem": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest. Blocks must start at the beginning of a line and end at the end of a line. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "pem",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode writes the PEM encoding of b to out. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeToMemory",
				Description: "EncodeToMemory returns the PEM encoding of b. If b has invalid headers and cannot be encoded, EncodeToMemory returns nil. If it is important to report details about this error case, use [Encode] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"cmerge": []funcSet{
			funcSet{
				Name:        "SaturatingAdd",
				Description: "Saturating add does a saturating addition of 'dst' and 'src', returning added value or math.MaxUint32 if there is an overflow. Overflows are recorded in case the client needs to track them. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"reflect": []funcSet{
			funcSet{
				Name:        "Append",
				Description: "Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "AppendSlice",
				Description: "AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "ArrayOf",
				Description: "ArrayOf returns the array type with the given length and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int. If the resulting type would be larger than the available address space, ArrayOf panics. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "ChanOf",
				Description: "ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int. The gc runtime imposes a limit of 64 kB on channel element types. If t's size is equal to or exceeds this limit, ChanOf panics. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "Copy",
				Description: "Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind [Slice] or [Array], and dst and src must have the same element type. It dst is an [Array], it panics if [Value.CanSet] returns false. As a special case, src can have kind [String] if the element type of dst is kind [Uint8]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DeepEqual",
				Description: "DeepEqual reports whether x and y are âdeeply equal,â defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal. Array values are deeply equal when their corresponding elements are deeply equal. Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal. Func values are deeply equal if both are nil; otherwise they are not deeply equal. Interface values are deeply equal if they hold deeply equal concrete values. Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values. Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values. Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal. Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator. In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content. As DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FuncOf",
				Description: "FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string. The variadic argument controls whether the function is variadic. FuncOf panics if the in[len(in)-1] does not represent a slice and variadic is true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "Indirect",
				Description: "Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MakeChan",
				Description: "MakeChan creates a new channel with the specified type and buffer size. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MakeFunc",
				Description: "MakeFunc returns a new function of the given [Type] that wraps the function fn. When called, that new function does the following: - converts its arguments to a slice of Values. - runs results := fn(args). - returns the results as a slice of Values, one per formal result. The implementation fn can assume that the argument [Value] slice has the number and type of arguments given by typ. If typ describes a variadic function, the final Value is itself a slice representing the variadic arguments, as in the body of a variadic function. The result Value slice returned by fn must have the number and type of results given by typ. The [Value.Call] method allows the caller to invoke a typed function in terms of Values; in contrast, MakeFunc allows the caller to implement a typed function in terms of Values. The Examples section of the documentation includes an illustration of how to use MakeFunc to build a swap function for different types. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MakeMap",
				Description: "MakeMap creates a new map with the specified type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MakeMapWithSize",
				Description: "MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MakeSlice",
				Description: "MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "MapOf",
				Description: "MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string. If the key type is not a valid map key type (that is, if it does not implement Go's == operator), MapOf panics. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is [PointerTo](typ). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "NewAt",
				Description: "NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "PointerTo",
				Description: "PointerTo returns the pointer type with element t. For example, if t represents type Foo, PointerTo(t) represents *Foo. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "PtrTo",
				Description: "PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo. PtrTo is the old spelling of [PointerTo]. The two functions behave identically. Deprecated: Superseded by [PointerTo]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "Select",
				Description: "Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SliceAt",
				Description: "SliceAt returns a [Value] representing a slice whose underlying data starts at p, with length and capacity equal to n. This is like [unsafe.Slice]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "SliceOf",
				Description: "SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "StructOf",
				Description: "StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler. StructOf currently does not support promoted methods of embedded fields and panics if passed unexported StructFields. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "Swapper",
				Description: "Swapper returns a function that swaps the elements in the provided slice. Swapper panics if the provided interface is not a slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(i int, j int)",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TypeAssert",
				Description: "TypeAssert is semantically equivalent to: v2, ok := v.Interface().(T) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "T",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TypeFor",
				Description: "TypeFor returns the [Type] that represents the type argument T. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "TypeOf",
				Description: "TypeOf returns the reflection [Type] that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "ValueOf",
				Description: "ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			funcSet{
				Name:        "VisibleFields",
				Description: "VisibleFields returns all the visible fields in t, which must be a struct type. A field is defined as visible if it's accessible directly with a FieldByName call. The returned fields include fields inside anonymous struct members and unexported fields. They follow the same order found in the struct, with anonymous fields followed immediately by their promoted fields. For each element e of the returned slice, the corresponding field can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]reflect.StructField",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Zero",
				Description: "Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind [Int] and value 0. The returned value is neither addressable nor settable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
		},
		"nistec": []funcSet{
			funcSet{
				Name:        "NewP224Point",
				Description: "NewP224Point returns a new P224Point representing the point at infinity point. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			funcSet{
				Name:        "NewP256Point",
				Description: "NewP256Point returns a new P256Point representing the point at infinity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			funcSet{
				Name:        "NewP384Point",
				Description: "NewP384Point returns a new P384Point representing the point at infinity point. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			funcSet{
				Name:        "NewP521Point",
				Description: "NewP521Point returns a new P521Point representing the point at infinity point. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			funcSet{
				Name:        "P256OrdInverse",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"flag": []funcSet{
			funcSet{
				Name:        "Arg",
				Description: "Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Args",
				Description: "Args returns the non-flag arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Bool",
				Description: "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BoolFunc",
				Description: "BoolFunc defines a flag with the specified name and usage string without requiring values. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "BoolVar",
				Description: "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Duration",
				Description: "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			funcSet{
				Name:        "DurationVar",
				Description: "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Float64",
				Description: "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64Var",
				Description: "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Func",
				Description: "Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Int",
				Description: "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int64",
				Description: "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int64Var",
				Description: "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "IntVar",
				Description: "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Lookup",
				Description: "Lookup returns the [Flag] structure of the named flag, returning nil if none exists. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Flag",
						TypePkgName: "flag",
					},
				},
			},
			funcSet{
				Name:        "NArg",
				Description: "NArg is the number of arguments remaining after flags have been processed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NFlag",
				Description: "NFlag returns the number of flags that have been set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewFlagSet",
				Description: "NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FlagSet",
						TypePkgName: "flag",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the [FlagSet] are defined and before flags are accessed by the program. The return value will be [ErrHelp] if -help or -h were set but not defined. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Parsed",
				Description: "Parsed reports whether f.Parse has been called. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PrintDefaults",
				Description: "PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Set",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "String",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringVar",
				Description: "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TextVar",
				Description: "TextVar defines a flag with a specified name, default value, and usage string. The argument p must be a pointer to a variable that will hold the value of the flag, and p must implement encoding.TextUnmarshaler. If the flag is used, the flag value will be passed to p's UnmarshalText method. The type of the default value must be the same as the type of p. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Uint",
				Description: "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint64",
				Description: "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint64Var",
				Description: "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "UintVar",
				Description: "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "UnquoteUsage",
				Description: "UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a `name` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Var",
				Description: "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type [Value], which typically holds a user-defined implementation of [Value]. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of [Value]; in particular, [Set] would decompose the comma-separated string into the slice. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Visit",
				Description: "Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "VisitAll",
				Description: "VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set. ",
				Returns:     []returnSet{},
			},
		},
		"zstd": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new Reader that decompresses data from the given reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "zstd",
					},
				},
			},
		},
		"token": []funcSet{
			funcSet{
				Name:        "IsExported",
				Description: "IsExported reports whether name starts with an upper-case letter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsIdentifier",
				Description: "IsIdentifier reports whether name is a Go identifier, that is, a non-empty string made up of letters, digits, and underscores, where the first character is not a digit. Keywords are not identifiers. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsKeyword",
				Description: "IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lookup",
				Description: "Lookup maps an identifier to its keyword token or [IDENT] (if not a keyword). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
				},
			},
			funcSet{
				Name:        "NewFileSet",
				Description: "NewFileSet creates a new file set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileSet",
						TypePkgName: "token",
					},
				},
			},
		},
		"suffixarray": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New creates a new [Index] for data. [Index] creation time is O(N) for N = len(data). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Index",
						TypePkgName: "suffixarray",
					},
				},
			},
		},
		"fs": []funcSet{
			funcSet{
				Name:        "FileInfoToDirEntry",
				Description: "FileInfoToDirEntry returns a [DirEntry] that returns information from info. If info is nil, FileInfoToDirEntry returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DirEntry",
						TypePkgName: "fs",
					},
				},
			},
			funcSet{
				Name:        "FormatDirEntry",
				Description: "FormatDirEntry returns a formatted version of dir for human readability. Implementations of [DirEntry] can call this from a String method. The outputs for a directory named subdir and a file named hello.go are: d subdir/ - hello.go ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatFileInfo",
				Description: "FormatFileInfo returns a formatted version of info for human readability. Implementations of [FileInfo] can call this from a String method. The output for a file named \"hello.go\", 100 bytes, mode 0o644, created January 1, 1970 at noon is -rw-r--r-- 100 1970-01-01 12:00:00 hello.go ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Glob",
				Description: "Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in [path.Match]. The pattern may describe hierarchical names such as usr/*/bin/ed. Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is [path.ErrBadPattern], reporting that the pattern is malformed. If fs implements [GlobFS], Glob calls fs.Glob. Otherwise, Glob uses [ReadDir] to traverse the directory tree and look for matches for the pattern. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lstat",
				Description: "Lstat returns a [FileInfo] describing the named file. If the file is a symbolic link, the returned [FileInfo] describes the symbolic link. Lstat makes no attempt to follow the link. If fsys does not implement [ReadLinkFS], then Lstat is identical to [Stat]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadDir",
				Description: "ReadDir reads the named directory and returns a list of directory entries sorted by filename. If fs implements [ReadDirFS], ReadDir calls fs.ReadDir. Otherwise ReadDir calls fs.Open and uses ReadDir and Close on the returned file. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]io/fs.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFile",
				Description: "ReadFile reads the named file from the file system fs and returns its contents. A successful call returns a nil error, not [io.EOF]. (Because ReadFile reads the whole file, the expected EOF from the final Read is not treated as an error to be reported.) If fs implements [ReadFileFS], ReadFile calls fs.ReadFile. Otherwise ReadFile calls fs.Open and uses Read and Close on the returned [File]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadLink",
				Description: "ReadLink returns the destination of the named symbolic link. If fsys does not implement [ReadLinkFS], then ReadLink returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Stat",
				Description: "Stat returns a [FileInfo] describing the named file from the file system. If fs implements [StatFS], Stat calls fs.Stat. Otherwise, Stat opens the [File] to stat it. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sub",
				Description: "Sub returns an [FS] corresponding to the subtree rooted at fsys's dir. If dir is \".\", Sub returns fsys unchanged. Otherwise, if fs implements [SubFS], Sub returns fsys.Sub(dir). Otherwise, Sub returns a new [FS] implementation sub that, in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)). The implementation also translates calls to ReadDir, ReadFile, ReadLink, Lstat, and Glob appropriately. Note that Sub(os.DirFS(\"/\"), \"prefix\") is equivalent to os.DirFS(\"/prefix\") and that neither of them guarantees to avoid operating system accesses outside \"/prefix\", because the implementation of [os.DirFS] does not check for symbolic links inside \"/prefix\" that point to other directories. That is, [os.DirFS] is not a general substitute for a chroot-style security mechanism, and Sub does not change that fact. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FS",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ValidPath",
				Description: "ValidPath reports whether the given path name is valid for use in a call to Open. Path names passed to open are UTF-8-encoded, unrooted, slash-separated sequences of path elements, like âx/y/zâ. Path names must not contain an element that is â.â or â..â or the empty string, except for the special case that the name \".\" may be used for the root directory. Paths must not start or end with a slash: â/xâ and âx/â are invalid. Note that paths are slash-separated on all systems, even Windows. Paths containing other characters such as backslash and colon are accepted as valid, but those characters must never be interpreted by an [FS] implementation as path element separators. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WalkDir",
				Description: "WalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by fn: see the [fs.WalkDirFunc] documentation for details. The files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory. WalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"poll": []funcSet{
			funcSet{
				Name:        "DupCloseOnExec",
				Description: "DupCloseOnExec dups fd and marks it close-on-exec. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPollDescriptor",
				Description: "IsPollDescriptor reports whether fd is the descriptor being used by the poller. This is only used for testing. IsPollDescriptor should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include: - github.com/opencontainers/runc Do not remove or change the type signature. See go.dev/issue/67401. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendFile",
				Description: "SendFile wraps the sendfile system call. It copies data from src (a file descriptor) to dstFD, starting at the current position of src. It updates the current position of src to after the copied data. If size is zero, it copies the rest of src. Otherwise, it copies up to size bytes. The handled return parameter indicates whether SendFile was able to handle some or all of the operation. If handled is false, sendfile was unable to perform the copy, has not modified the source or destination, and the caller should perform the copy using a fallback implementation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"zlib": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement [io.ByteReader], the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done. The [io.ReadCloser] returned by NewReader also implements [Resetter]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewReaderDict",
				Description: "NewReaderDict is like [NewReader] but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns [ErrDictionary]. The ReadCloser returned by NewReaderDict also implements [Resetter]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter creates a new [Writer]. Writes to the returned Writer are compressed and written to w. It is the caller's responsibility to call Close on the Writer when done. Writes may be buffered and not flushed until Close. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "zlib",
					},
				},
			},
			funcSet{
				Name:        "NewWriterLevel",
				Description: "NewWriterLevel is like [NewWriter] but specifies the compression level instead of assuming [DefaultCompression]. The compression level can be [DefaultCompression], [NoCompression], [HuffmanOnly] or any integer value between [BestSpeed] and [BestCompression] inclusive. The error returned will be nil if the level is valid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "zlib",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriterLevelDict",
				Description: "NewWriterLevelDict is like [NewWriterLevel] but specifies a dictionary to compress with. The dictionary may be nil. If not, its contents should not be modified until the Writer is closed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "zlib",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"rc4": []funcSet{
			funcSet{
				Name:        "NewCipher",
				Description: "NewCipher creates and returns a new [Cipher]. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cipher",
						TypePkgName: "rc4",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"internal": []funcSet{
			funcSet{
				Name:        "NewChunkedReader",
				Description: "NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns [io.EOF] when the final 0-length chunk is read. NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewChunkedWriter",
				Description: "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately. NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
		},
		"constraint": []funcSet{
			funcSet{
				Name:        "GoVersion",
				Description: "GoVersion returns the minimum Go version implied by a given build expression. If the expression can be satisfied without any Go version tags, GoVersion returns an empty string. For example: GoVersion(linux && go1.22) = \"go1.22\" GoVersion((linux && go1.22) || (windows && go1.20)) = \"go1.20\" => go1.20 GoVersion(linux) = \"\" GoVersion(linux || (windows && go1.22)) = \"\" GoVersion(!go1.22) = \"\" GoVersion assumes that any tag or negated tag may independently be true, so that its analysis can be purely structural, without SAT solving. âImpossibleâ subexpressions may therefore affect the result. For example: GoVersion((linux && !linux && go1.20) || go1.21) = \"go1.20\" ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsGoBuild",
				Description: "IsGoBuild reports whether the line of text is a â//go:buildâ constraint. It only checks the prefix of the text, not that the expression itself parses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPlusBuild",
				Description: "IsPlusBuild reports whether the line of text is a â// +buildâ constraint. It only checks the prefix of the text, not that the expression itself parses. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses a single build constraint line of the form â//go:build ...â or â// +build ...â and returns the corresponding boolean expression. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "constraint",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PlusBuildLines",
				Description: "PlusBuildLines returns a sequence of â// +buildâ lines that evaluate to the build expression x. If the expression is too complex to convert directly to â// +buildâ lines, PlusBuildLines returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"fnv": []funcSet{
			funcSet{
				Name:        "New128",
				Description: "New128 returns a new 128-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New128a",
				Description: "New128a returns a new 128-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New32",
				Description: "New32 returns a new 32-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash32",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New32a",
				Description: "New32a returns a new 32-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash32",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New64",
				Description: "New64 returns a new 64-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash64",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New64a",
				Description: "New64a returns a new 64-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash64",
						TypePkgName: "hash",
					},
				},
			},
		},
		"slog": []funcSet{
			funcSet{
				Name:        "Any",
				Description: "Any returns an Attr for the supplied value. See [AnyValue] for how values are treated. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "AnyValue",
				Description: "AnyValue returns a [Value] for the supplied value. If the supplied value is of type Value, it is returned unmodified. Given a value of one of Go's predeclared string, bool, or (non-complex) numeric types, AnyValue returns a Value of kind [KindString], [KindBool], [KindUint64], [KindInt64], or [KindFloat64]. The width of the original numeric type is not preserved. Given a [time.Time] or [time.Duration] value, AnyValue returns a Value of kind [KindTime] or [KindDuration]. The monotonic time is not preserved. For nil, or values of all other types, including named types whose underlying type is numeric, AnyValue returns a value of kind [KindAny]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Bool",
				Description: "Bool returns an Attr for a bool. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "BoolValue",
				Description: "BoolValue returns a [Value] for a bool. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Debug",
				Description: "Debug logs at [LevelDebug]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "DebugContext",
				Description: "DebugContext logs at [LevelDebug] with the given context. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Default",
				Description: "Default returns the default [Logger]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Duration",
				Description: "Duration returns an Attr for a [time.Duration]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "DurationValue",
				Description: "DurationValue returns a [Value] for a [time.Duration]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Error",
				Description: "Error logs at [LevelError]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ErrorContext",
				Description: "ErrorContext logs at [LevelError] with the given context. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Float64",
				Description: "Float64 returns an Attr for a floating-point number. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Float64Value",
				Description: "Float64Value returns a [Value] for a floating-point number. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Group",
				Description: "Group returns an Attr for a Group [Value]. The first argument is the key; the remaining arguments are converted to Attrs as in [Logger.Log]. Use Group to collect several key-value pairs under a single key on a log line, or as the result of LogValue in order to log a single value as multiple Attrs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "GroupAttrs",
				Description: "GroupAttrs returns an Attr for a Group [Value] consisting of the given Attrs. GroupAttrs is a more efficient version of [Group] that accepts only [Attr] values. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "GroupValue",
				Description: "GroupValue returns a new [Value] for a list of Attrs. The caller must not subsequently mutate the argument slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Info",
				Description: "Info logs at [LevelInfo]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "InfoContext",
				Description: "InfoContext logs at [LevelInfo] with the given context. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Int",
				Description: "Int converts an int to an int64 and returns an Attr with that value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Int64",
				Description: "Int64 returns an Attr for an int64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Int64Value",
				Description: "Int64Value returns a [Value] for an int64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "IntValue",
				Description: "IntValue returns a [Value] for an int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Log",
				Description: "Log emits a log record with the current time and the given level and message. The Record's Attrs consist of the Logger's attributes followed by the Attrs specified by args. The attribute arguments are processed as follows: - If an argument is an Attr, it is used as is. - If an argument is a string and this is not the last argument, the following argument is treated as the value and the two are combined into an Attr. - Otherwise, the argument is treated as a value with key \"!BADKEY\". ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "LogAttrs",
				Description: "LogAttrs is a more efficient version of [Logger.Log] that accepts only Attrs. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "New",
				Description: "New creates a new Logger with the given non-nil Handler. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "NewJSONHandler",
				Description: "NewJSONHandler creates a [JSONHandler] that writes to w, using the given options. If opts is nil, the default options are used. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "JSONHandler",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "NewLogLogger",
				Description: "NewLogLogger returns a new [log.Logger] such that each call to its Output method dispatches a Record to the specified handler. The logger acts as a bridge from the older log API to newer structured logging handlers. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "log",
					},
				},
			},
			funcSet{
				Name:        "NewRecord",
				Description: "NewRecord creates a [Record] from the given arguments. Use [Record.AddAttrs] to add attributes to the Record. NewRecord is intended for logging APIs that want to support a [Handler] as a backend. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Record",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "NewTextHandler",
				Description: "NewTextHandler creates a [TextHandler] that writes to w, using the given options. If opts is nil, the default options are used. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TextHandler",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "SetDefault",
				Description: "SetDefault makes l the default [Logger], which is used by the top-level functions [Info], [Debug] and so on. After this call, output from the log package's default Logger (as with [log.Print], etc.) will be logged using l's Handler, at a level controlled by [SetLogLoggerLevel]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetLogLoggerLevel",
				Description: "SetLogLoggerLevel controls the level for the bridge to the [log] package. Before [SetDefault] is called, slog top-level logging functions call the default [log.Logger]. In that mode, SetLogLoggerLevel sets the minimum level for those calls. By default, the minimum level is Info, so calls to [Debug] (as well as top-level logging calls at lower levels) will not be passed to the log.Logger. After calling slog.SetLogLoggerLevel(slog.LevelDebug) calls to [Debug] will be passed to the log.Logger. After [SetDefault] is called, calls to the default [log.Logger] are passed to the slog default handler. In that mode, SetLogLoggerLevel sets the level at which those calls are logged. That is, after calling slog.SetLogLoggerLevel(slog.LevelDebug) A call to [log.Printf] will result in output at level [LevelDebug]. SetLogLoggerLevel returns the previous value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Level",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "String",
				Description: "String returns an Attr for a string value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "StringValue",
				Description: "StringValue returns a new [Value] for a string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Time",
				Description: "Time returns an Attr for a [time.Time]. It discards the monotonic portion. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "TimeValue",
				Description: "TimeValue returns a [Value] for a [time.Time]. It discards the monotonic portion. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Uint64",
				Description: "Uint64 returns an Attr for a uint64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Attr",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Uint64Value",
				Description: "Uint64Value returns a [Value] for a uint64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			funcSet{
				Name:        "Warn",
				Description: "Warn logs at [LevelWarn]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WarnContext",
				Description: "WarnContext logs at [LevelWarn] with the given context. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "With",
				Description: "With returns a Logger that includes the given attributes in each output operation. Arguments are converted to attributes as if by [Logger.Log]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
		},
		"race": []funcSet{
			funcSet{
				Name:        "Acquire",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Disable",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Enable",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Errors",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadObjectPC",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadPC",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadRange",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Release",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReleaseMerge",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Write",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WriteObjectPC",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WritePC",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WriteRange",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"md5": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new [hash.Hash] computing the MD5 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Sum",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"macOS": []funcSet{
			funcSet{
				Name:        "BytesToCFData",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "CFArrayAppendValue",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "CFArrayCreateMutable",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "CFArrayGetCount",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFArrayGetValueAtIndex",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "CFDataGetBytePtr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFDataGetLength",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFDataToSlice",
				Description: "CFDataToSlice returns a copy of the contents of data as a bytes slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFDateCreate",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "CFDictionaryGetValueIfPresent",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFEqual",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFErrorCopyDescription",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "CFErrorGetCode",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFNumberGetValue",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFRelease",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "CFStringCreateExternalRepresentation",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CFStringToString",
				Description: "CFStringToString returns a Go string representation of the passed in CFString, or an empty string if it's invalid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReleaseCFArray",
				Description: "ReleaseCFArray iterates through an array, releasing its contents, and then releases the array itself. This is necessary because we cannot, easily, set the CFArrayCallBacks argument when creating CFArrays. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SecCertificateCopyData",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecCertificateCreateWithData",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecPolicyCreateSSL",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecTrustCopyCertificateChain",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecTrustCreateWithCertificates",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecTrustEvaluate",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecTrustEvaluateWithError",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SecTrustSetVerifyDate",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringToCFString",
				Description: "StringToCFString returns a copy of the UTF-8 contents of s as a new CFString. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFString",
						TypePkgName: "macOS",
					},
				},
			},
			funcSet{
				Name:        "TimeToCFDateRef",
				Description: "TimeToCFDateRef converts a time.Time into an apple CFDateRef. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CFRef",
						TypePkgName: "macOS",
					},
				},
			},
		},
		"dwarf": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new [Data] object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package [debug/elf], [debug/macho], or [debug/pe]. The []byte arguments are the data from the corresponding debug section in the object file; for example, for an ELF object, abbrev is the contents of the \".debug_abbrev\" section. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Data",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gccgoimporter": []funcSet{
			funcSet{
				Name:        "GetImporter",
				Description: "Return an importer that searches incpaths followed by the gcc installation's built-in search paths and the current directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "gccgoimporter",
					},
				},
			},
		},
		"smtp": []funcSet{
			funcSet{
				Name:        "CRAMMD5Auth",
				Description: "CRAMMD5Auth returns an [Auth] that implements the CRAM-MD5 authentication mechanism as defined in RFC 2195. The returned Auth uses the given username and secret to authenticate to the server using the challenge-response mechanism. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Auth",
						TypePkgName: "smtp",
					},
				},
			},
			funcSet{
				Name:        "Dial",
				Description: "Dial returns a new [Client] connected to an SMTP server at addr. The addr must include a port, as in \"mail.example.com:smtp\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "smtp",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewClient",
				Description: "NewClient returns a new [Client] using an existing connection and host as a server name to be used when authenticating. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "smtp",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PlainAuth",
				Description: "PlainAuth returns an [Auth] that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username. PlainAuth will only send the credentials if the connection is using TLS or is connected to localhost. Otherwise authentication will fail with an error, without sending the credentials. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Auth",
						TypePkgName: "smtp",
					},
				},
			},
			funcSet{
				Name:        "SendMail",
				Description: "SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in \"mail.example.com:smtp\". The addresses in the to parameter are the SMTP RCPT addresses. The msg parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of msg should be CRLF terminated. The msg headers should usually include fields such as \"From\", \"To\", \"Subject\", and \"Cc\". Sending \"Bcc\" messages is accomplished by including an email address in the to parameter but not including it in the msg headers. The SendMail function and the net/smtp package are low-level mechanisms and provide no support for DKIM signing, MIME attachments (see the mime/multipart package), or other mail functionality. Higher-level packages exist outside of the standard library. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"plugin": []funcSet{
			funcSet{
				Name:        "Open",
				Description: "Open opens a Go plugin. If a path has already been opened, then the existing *[Plugin] is returned. It is safe for concurrent use by multiple goroutines. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Plugin",
						TypePkgName: "plugin",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"itoa": []funcSet{
			funcSet{
				Name:        "Itoa",
				Description: "Itoa converts val to a decimal string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uitoa",
				Description: "Uitoa converts val to a decimal string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uitox",
				Description: "Uitox converts val (a uint) to a hexadecimal string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"gob": []funcSet{
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder returns a new decoder that reads from the [io.Reader]. If r does not also implement [io.ByteReader], it will be wrapped in a [bufio.Reader]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "gob",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new encoder that will transmit on the [io.Writer]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoder",
						TypePkgName: "gob",
					},
				},
			},
			funcSet{
				Name:        "Register",
				Description: "Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RegisterName",
				Description: "RegisterName is like [Register] but uses the provided name rather than the type's default. ",
				Returns:     []returnSet{},
			},
		},
		"pods": []funcSet{
			funcSet{
				Name:        "CollectPods",
				Description: "CollectPods visits the files contained within the directories in the list 'dirs', collects any coverage-related files, partitions them into pods, and returns a list of the pods to the caller, along with an error if something went wrong during directory/file reading. CollectPods skips over any file that is not related to coverage (e.g. avoids looking at things that are not meta-data files or counter-data files). CollectPods also skips over 'orphaned' counter data files (e.g. counter data files for which we can't find the corresponding meta-data file). If \"warn\" is true, CollectPods will issue warnings to stderr when it encounters non-fatal problems (for orphans or a directory with no meta-data files). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/coverage/pods.Pod",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CollectPodsFromFiles",
				Description: "CollectPodsFromFiles functions the same as \"CollectPods\" but operates on an explicit list of files instead of a directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/coverage/pods.Pod",
						TypePkgName: "",
					},
				},
			},
		},
		"bytealg": []funcSet{
			funcSet{
				Name:        "Compare",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompareString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Count",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CountString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cutover",
				Description: "Cutover reports the number of failures of IndexByte we should tolerate before switching over to Index. n is the number of bytes processed so far. See the bytes.Index implementation for details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Equal",
				Description: "Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. Equal is equivalent to bytes.Equal. It is provided here for convenience, because some packages cannot depend on bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HashStr",
				Description: "HashStr returns the hash and the appropriate multiplicative factor for use in Rabin-Karp algorithm. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HashStrRev",
				Description: "HashStrRev returns the hash of the reverse of sep and the appropriate multiplicative factor for use in Rabin-Karp algorithm. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "Index returns the index of the first instance of b in a, or -1 if b is not present in a. Requires 2 <= len(b) <= MaxLen. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexByte",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexByteString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexRabinKarp",
				Description: "IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the first occurrence of sep in s, or -1 if not present. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexString",
				Description: "IndexString returns the index of the first instance of b in a, or -1 if b is not present in a. Requires 2 <= len(b) <= MaxLen. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexByte",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexByteString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexRabinKarp",
				Description: "LastIndexRabinKarp uses the Rabin-Karp search algorithm to return the last index of the occurrence of sep in s, or -1 if not present. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MakeNoZero",
				Description: "MakeNoZero makes a slice of length n and capacity of at least n Bytes without zeroing the bytes (including the bytes between len and cap). It is the caller's responsibility to ensure uninitialized bytes do not leak to the end user. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"crc32": []funcSet{
			funcSet{
				Name:        "Checksum",
				Description: "Checksum returns the CRC-32 checksum of data using the polynomial represented by the [Table]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ChecksumIEEE",
				Description: "ChecksumIEEE returns the CRC-32 checksum of data using the [IEEE] polynomial. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MakeTable",
				Description: "MakeTable returns a [Table] constructed from the specified polynomial. The contents of this [Table] must not be modified. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Table",
						TypePkgName: "crc32",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New creates a new [hash.Hash32] computing the CRC-32 checksum using the polynomial represented by the [Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash32",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "NewIEEE",
				Description: "NewIEEE creates a new [hash.Hash32] computing the CRC-32 checksum using the [IEEE] polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash32",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Update",
				Description: "Update returns the result of adding the bytes in p to the crc. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
		},
		"xml": []funcSet{
			funcSet{
				Name:        "CopyToken",
				Description: "CopyToken returns a copy of a Token. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "xml",
					},
				},
			},
			funcSet{
				Name:        "Escape",
				Description: "Escape is like [EscapeText] but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use [EscapeText]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "EscapeText",
				Description: "EscapeText writes to w the properly escaped XML equivalent of the plain text data s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Marshal",
				Description: "Marshal returns the XML encoding of v. Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data. The name for the XML elements is taken from, in order of preference: - the tag on the XMLName field, if the data is a struct - the value of the XMLName field of type [Name] - the tag of the struct field used to obtain the data - the name of the struct field used to obtain the data - the name of the marshaled type The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions: - the XMLName field, described above, is omitted. - a field with tag \"-\" is omitted. - a field with tag \"name,attr\" becomes an attribute with the given name in the XML element. - a field with tag \",attr\" becomes an attribute with the field name in the XML element. - a field with tag \",chardata\" is written as character data, not as an XML element. - a field with tag \",cdata\" is written as character data wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element. - a field with tag \",innerxml\" is written verbatim, not subject to the usual marshaling procedure. - a field with tag \",comment\" is written as an XML comment, not subject to the usual marshaling procedure. It must not contain the \"--\" string within it. - a field with a tag including the \"omitempty\" option is omitted if the field value is empty. The empty values are false, 0, any nil pointer or interface value, and any array, slice, map, or string of length zero. - an anonymous struct field is handled as if the fields of its value were part of the outer struct. - an anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous. - a field implementing [Marshaler] is written by calling its MarshalXML method. - a field implementing [encoding.TextMarshaler] is written by encoding the result of its MarshalText method as text. If a field uses a tag \"a>b>c\", then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element. If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match. See [MarshalIndent] for an example. Marshal will return an error if asked to marshal a channel, function, or map. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalIndent",
				Description: "MarshalIndent works like [Marshal], but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder creates a new XML parser reading from r. If r does not implement [io.ByteReader], NewDecoder will do its own buffering. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "xml",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new encoder that writes to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoder",
						TypePkgName: "xml",
					},
				},
			},
			funcSet{
				Name:        "NewTokenDecoder",
				Description: "NewTokenDecoder creates a new XML parser using an underlying token stream. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "xml",
					},
				},
			},
			funcSet{
				Name:        "Unmarshal",
				Description: "Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded. Because Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names. Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above). - If the struct has a field of type []byte or string with tag \",innerxml\", Unmarshal accumulates the raw XML nested inside the element in that field. The rest of the rules still apply. - If the struct has a field named XMLName of type Name, Unmarshal records the element name in that field. - If the XMLName field has an associated tag of the form \"name\" or \"namespace-URL name\", the XML element must have the given name (and, optionally, name space) or else Unmarshal returns an error. - If the XML element has an attribute whose name matches a struct field name with an associated tag containing \",attr\" or the explicit name in a struct field tag of the form \"name,attr\", Unmarshal records the attribute value in that field. - If the XML element has an attribute not handled by the previous rule and the struct has a field with an associated tag containing \",any,attr\", Unmarshal records the attribute value in the first such field. - If the XML element contains character data, that data is accumulated in the first struct field that has tag \",chardata\". The struct field may have type []byte or string. If there is no such field, the character data is discarded. - If the XML element contains comments, they are accumulated in the first struct field that has tag \",comment\". The struct field may have type []byte or string. If there is no such field, the comments are discarded. - If the XML element contains a sub-element whose name matches the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal will descend into the XML structure looking for elements with the given names, and will map the innermost elements to that struct field. A tag starting with \">\" is equivalent to one starting with the field name followed by \">\". - If the XML element contains a sub-element whose name matches a struct field's XMLName tag and the struct field has no explicit name tag as per the previous rule, unmarshal maps the sub-element to that struct field. - If the XML element contains a sub-element whose name matches a field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal maps the sub-element to that struct field. - If the XML element contains a sub-element that hasn't matched any of the above rules and the struct has a field with tag \",any\", unmarshal maps the sub-element to that struct field. - An anonymous struct field is handled as if the fields of its value were part of the outer struct. - A struct field with tag \"-\" is never unmarshaled into. If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element. Otherwise, if the value implements [encoding.TextUnmarshaler], Unmarshal calls that value's UnmarshalText method. Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil. Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice. Unmarshal maps an attribute value to an [Attr] by saving the attribute, including its name, in the Attr. Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value. Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored. Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored. Unmarshal maps an XML element to a Name by recording the element name. Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value. A missing element or empty attribute value will be unmarshaled as a zero value. If the field is a slice, a zero value will be appended to the field. Otherwise, the field will be set to its zero value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"goroot": []funcSet{
			funcSet{
				Name:        "IsStandardPackage",
				Description: "IsStandardPackage reports whether path is a standard package, given goroot and compiler. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"fdtest": []funcSet{
			funcSet{
				Name:        "Exists",
				Description: "Exists returns true if fd is a valid file descriptor. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"sha256": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new Digest computing the SHA-256 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha256",
					},
				},
			},
			funcSet{
				Name:        "New224",
				Description: "New224 returns a new Digest computing the SHA-224 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha256",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new [hash.Hash] computing the SHA256 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New224",
				Description: "New224 returns a new [hash.Hash] computing the SHA224 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Sum224",
				Description: "Sum224 returns the SHA224 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[28]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum256",
				Description: "Sum256 returns the SHA256 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"gcm": []funcSet{
			funcSet{
				Name:        "GHASH",
				Description: "GHASH is exposed to allow crypto/cipher to implement non-AES GCM modes. It is not allowed as a stand-alone operation in FIPS mode because it is not ACVP tested. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GCM",
						TypePkgName: "gcm",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCMAC",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CMAC",
						TypePkgName: "gcm",
					},
				},
			},
			funcSet{
				Name:        "NewCounterKDF",
				Description: "NewCounterKDF creates a new CounterKDF with the given key. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterKDF",
						TypePkgName: "gcm",
					},
				},
			},
			funcSet{
				Name:        "NewGCMForSSH",
				Description: "NewGCMForSSH returns a new AEAD that works like GCM, but enforces the construction of nonces as specified in RFC 5647. This complies with FIPS 140-3 IG C.H Scenario 1.d. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GCMForSSH",
						TypePkgName: "gcm",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMForTLS12",
				Description: "NewGCMForTLS12 returns a new AEAD that works like GCM, but enforces the construction of nonces as specified in RFC 5288, Section 3 and RFC 9325, Section 7.2.1. This complies with FIPS 140-3 IG C.H Scenario 1.a. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GCMForTLS12",
						TypePkgName: "gcm",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMForTLS13",
				Description: "NewGCMForTLS13 returns a new AEAD that works like GCM, but enforces the construction of nonces as specified in RFC 8446, Section 5.3. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GCMForTLS13",
						TypePkgName: "gcm",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMWithCounterNonce",
				Description: "NewGCMWithCounterNonce returns a new AEAD that works like GCM, but enforces the construction of deterministic nonces. The nonce must be 96 bits, the first 32 bits must be an encoding of the module name, and the last 64 bits must be a counter. This complies with FIPS 140-3 IG C.H Scenario 3. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GCMWithCounterNonce",
						TypePkgName: "gcm",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SealWithRandomNonce",
				Description: "SealWithRandomNonce encrypts plaintext to out, and writes a random nonce to nonce. nonce must be 12 bytes, and out must be 16 bytes longer than plaintext. out and plaintext may overlap exactly or not at all. additionalData and out must not overlap. This complies with FIPS 140-3 IG C.H Scenario 2. Note that this is NOT a [cipher.AEAD].Seal method. ",
				Returns:     []returnSet{},
			},
		},
		"http": []funcSet{
			funcSet{
				Name:        "AllowQuerySemicolons",
				Description: "AllowQuerySemicolons returns a handler that serves requests by converting any unescaped semicolons in the URL query to ampersands, and invoking the handler h. This restores the pre-Go 1.17 behavior of splitting query parameters on both semicolons and ampersands. (See golang.org/issue/25192). Note that this behavior doesn't match that of many proxies, and the mismatch can lead to security issues. AllowQuerySemicolons should be invoked before [Request.ParseForm] is called. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "CanonicalHeaderKey",
				Description: "CanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DetectContentType",
				Description: "DetectContentType implements the algorithm described at https://mimesniff.spec.whatwg.org/ to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Error",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "FS",
				Description: "FS converts fsys to a [FileSystem] implementation, for use with [FileServer] and [NewFileTransport]. The files provided by fsys must implement [io.Seeker]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileSystem",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "FileServer",
				Description: "FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root. As a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\". To use the operating system's file system implementation, use [http.Dir]: http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\"))) To use an [fs.FS] implementation, use [http.FileServerFS] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "FileServerFS",
				Description: "FileServerFS returns a handler that serves HTTP requests with the contents of the file system fsys. The files provided by fsys must implement [io.Seeker]. As a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\". http.Handle(\"/\", http.FileServerFS(fsys)) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "Get",
				Description: "Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects: 301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect) 308 (Permanent Redirect) An error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type [*url.Error]. The url.Error value's Timeout method will report true if the request timed out. When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. Get is a wrapper around DefaultClient.Get. To make a request with custom headers, use [NewRequest] and DefaultClient.Do. To make a request with a specified context.Context, use [NewRequestWithContext] and DefaultClient.Do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Handle",
				Description: "Handle registers the handler for the given pattern. If the given pattern conflicts with one that is already registered, Handle panics. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "HandleFunc",
				Description: "HandleFunc registers the handler function for the given pattern. If the given pattern conflicts with one that is already registered, HandleFunc panics. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Head",
				Description: "Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects: 301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect) 308 (Permanent Redirect) Head is a wrapper around DefaultClient.Head. To make a request with a specified [context.Context], use [NewRequestWithContext] and DefaultClient.Do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenAndServe",
				Description: "ListenAndServe listens on the TCP network address s.Addr and then calls [Serve] to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. If s.Addr is blank, \":http\" is used. ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ListenAndServeTLS",
				Description: "ListenAndServeTLS acts identically to [ListenAndServe], except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MaxBytesHandler",
				Description: "MaxBytesHandler returns a [Handler] that runs h with its [ResponseWriter] and [Request.Body] wrapped by a MaxBytesReader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "MaxBytesReader",
				Description: "MaxBytesReader is similar to [io.LimitReader] but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-nil error of type [*MaxBytesError] for a Read beyond the limit, and closes the underlying reader when its Close method is called. MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the [ResponseWriter] to close the connection after the limit has been reached. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewCrossOriginProtection",
				Description: "NewCrossOriginProtection returns a new [CrossOriginProtection] value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CrossOriginProtection",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewFileTransport",
				Description: "NewFileTransport returns a new [RoundTripper], serving the provided [FileSystem]. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. The typical use case for NewFileTransport is to register the \"file\" protocol with a [Transport], as in: t := &http.Transport{} t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\"))) c := &http.Client{Transport: t} res, err := c.Get(\"file:///etc/passwd\") ... ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RoundTripper",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewFileTransportFS",
				Description: "NewFileTransportFS returns a new [RoundTripper], serving the provided file system fsys. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. The files provided by fsys must implement [io.Seeker]. The typical use case for NewFileTransportFS is to register the \"file\" protocol with a [Transport], as in: fsys := os.DirFS(\"/\") t := &http.Transport{} t.RegisterProtocol(\"file\", http.NewFileTransportFS(fsys)) c := &http.Client{Transport: t} res, err := c.Get(\"file:///etc/passwd\") ... ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RoundTripper",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewRequest",
				Description: "NewRequest wraps [NewRequestWithContext] using [context.Background]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewRequestWithContext",
				Description: "NewRequestWithContext returns a new [Request] given a method, URL, and optional body. If the provided body is also an [io.Closer], the returned [Request.Body] is set to body and will be closed (possibly asynchronously) by the Client methods Do, Post, and PostForm, and [Transport.RoundTrip]. NewRequestWithContext returns a Request suitable for use with [Client.Do] or [Transport.RoundTrip]. To create a request for use with testing a Server Handler, either use the [net/http/httptest.NewRequest] function, use [ReadRequest], or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the [Request] type's documentation for the difference between inbound and outbound request fields. If body is of type [*bytes.Buffer], [*bytes.Reader], or [*strings.Reader], the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to [NoBody] if the ContentLength is 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewResponseController",
				Description: "NewResponseController creates a [ResponseController] for a request. The ResponseWriter should be the original value passed to the [Handler.ServeHTTP] method, or have an Unwrap method returning the original ResponseWriter. If the ResponseWriter implements any of the following methods, the ResponseController will call them as appropriate: Flush() FlushError() error // alternative Flush returning an error Hijack() (net.Conn, *bufio.ReadWriter, error) SetReadDeadline(deadline time.Time) error SetWriteDeadline(deadline time.Time) error EnableFullDuplex() error If the ResponseWriter does not support a method, ResponseController returns an error matching [ErrNotSupported]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ResponseController",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewServeMux",
				Description: "NewServeMux allocates and returns a new [ServeMux]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ServeMux",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NotFound",
				Description: "NotFound replies to the request with an HTTP 404 not found error. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NotFoundHandler",
				Description: "NotFoundHandler returns a simple request handler that replies to each request with a â404 page not foundâ reply. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "ParseCookie",
				Description: "ParseCookie parses a Cookie header value and returns all the cookies which were set in it. Since the same cookie name can appear multiple times the returned Values can contain more than one value for a given key. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseHTTPVersion",
				Description: "ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a minor version, such as \"HTTP/2\", are not valid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseSetCookie",
				Description: "ParseSetCookie parses a Set-Cookie header value and returns a cookie. It returns an error on syntax error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cookie",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseTime",
				Description: "ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: [TimeFormat], [time.RFC850], and [time.ANSIC]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Post",
				Description: "Post issues a POST to the specified URL. Caller should close resp.Body when done reading from it. If the provided body is an [io.Closer], it is closed after the request. Post is a wrapper around DefaultClient.Post. To set custom headers, use [NewRequest] and DefaultClient.Do. See the [Client.Do] method documentation for details on how redirects are handled. To make a request with a specified context.Context, use [NewRequestWithContext] and DefaultClient.Do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PostForm",
				Description: "PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use [NewRequest] and DefaultClient.Do. When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. PostForm is a wrapper around DefaultClient.PostForm. See the [Client.Do] method documentation for details on how redirects are handled. To make a request with a specified [context.Context], use [NewRequestWithContext] and DefaultClient.Do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ProxyFromEnvironment",
				Description: "ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). Requests use the proxy from the environment variable matching their scheme, unless excluded by NO_PROXY. The environment values may be either a complete URL or a \"host[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form. A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY. As a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ProxyURL",
				Description: "ProxyURL returns a proxy function (for use in a [Transport]) that always returns the same URL. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(*net/http.Request) (*net/url.URL, error)",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadRequest",
				Description: "ReadRequest reads and parses an incoming request from b. ReadRequest is a low-level function and should only be used for specialized applications; most code should use the [Server] to read requests and handle them via the [Handler] interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadResponse",
				Description: "ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the [Request] that corresponds to this [Response]. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Redirect",
				Description: "Redirect replies to the request with a redirect to url, which may be a path relative to the request path. Any non-ASCII characters in url will be percent-encoded, but existing percent encodings will not be changed. The provided code should be in the 3xx range and is usually [StatusMovedPermanently], [StatusFound] or [StatusSeeOther]. If the Content-Type header has not been set, [Redirect] sets it to \"text/html; charset=utf-8\" and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RedirectHandler",
				Description: "RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code. The provided code should be in the 3xx range and is usually [StatusMovedPermanently], [StatusFound] or [StatusSeeOther]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "Serve",
				Description: "Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case [DefaultServeMux] is used. HTTP/2 support is only enabled if the Listener returns [*tls.Conn] connections and they were configured with \"h2\" in the TLS Config.NextProtos. Serve always returns a non-nil error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ServeContent",
				Description: "ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over [io.Copy] is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests. If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to [DetectContentType]. The name is otherwise unused; in particular it can be empty and is never sent in the response. If modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. Note that [*os.File] implements the [io.ReadSeeker] interface. If the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range. If an error occurs when serving the request (for example, when handling an invalid range request), ServeContent responds with an error message. By default, ServeContent strips the Cache-Control, Content-Encoding, ETag, and Last-Modified headers from error responses. The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent to preserve these headers. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServeFile",
				Description: "ServeFile replies to the request with the contents of the named file or directory. If the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling [ServeFile]. As a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use [filepath.Join] on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument. As another special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use [ServeContent]. Outside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServeFileFS",
				Description: "ServeFileFS replies to the request with the contents of the named file or directory from the file system fsys. The files provided by fsys must implement [io.Seeker]. If the provided name is constructed from user input, it should be sanitized before calling [ServeFileFS]. As a precaution, ServeFileFS will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use [filepath.Join] on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument. As another special case, ServeFileFS redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use [ServeContent]. Outside of those two special cases, ServeFileFS does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServeTLS",
				Description: "ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case [DefaultServeMux] is used. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. ServeTLS always returns a non-nil error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetCookie",
				Description: "SetCookie adds a Set-Cookie header to the provided [ResponseWriter]'s headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "StatusText",
				Description: "StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StripPrefix",
				Description: "StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path (and RawPath if set) and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. The prefix must match exactly: if the prefix in the request contains escaped characters the reply is also an HTTP 404 not found error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "TimeoutHandler",
				Description: "TimeoutHandler returns a [Handler] that runs h with the given time limit. The new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its [ResponseWriter] will return [ErrHandlerTimeout]. TimeoutHandler supports the [Pusher] interface but does not support the [Hijacker] or [Flusher] interfaces. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
		},
		"quick": []funcSet{
			funcSet{
				Name:        "Check",
				Description: "Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a *[CheckError]. For example: func TestOddMultipleOfThree(t *testing.T) { f := func(x int) bool { y := OddMultipleOfThree(x) return y%2 == 1 && y%3 == 0 } if err := quick.Check(f, nil); err != nil { t.Error(err) } } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CheckEqual",
				Description: "CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a *[CheckEqualError] describing the input and the outputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Value",
				Description: "Value returns an arbitrary value of the given type. If the type implements the [Generator] interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"tar": []funcSet{
			funcSet{
				Name:        "FileInfoHeader",
				Description: "FileInfoHeader creates a partially-populated [Header] from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name. Since fs.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file. If fi implements [FileInfoNames] Header.Gname and Header.Uname are provided by the methods of the interface. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new [Reader] reading from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "tar",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter creates a new Writer writing to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "tar",
					},
				},
			},
		},
		"ed25519": []funcSet{
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a new Ed25519 private key pair. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKeyFromSeed",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignCtx",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignPH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Verify",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyCtx",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyPH",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, [crypto/rand.Reader] will be used. The output of this function is deterministic, and equivalent to reading [SeedSize] bytes from rand, and passing them to [NewKeyFromSeed]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ed25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewKeyFromSeed",
				Description: "NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not [SeedSize]. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ed25519",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "Sign signs the given message with priv. rand is ignored and can be nil. If opts.HashFunc() is [crypto.SHA512], the pre-hashed variant Ed25519ph is used and message is expected to be a SHA-512 hash, otherwise opts.HashFunc() must be [crypto.Hash](0) and the message must not be hashed, as Ed25519 performs two passes over messages to be signed. A value of type [Options] can be used as opts, or crypto.Hash(0) or crypto.SHA512 directly to select plain Ed25519 or Ed25519ph, respectively. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Verify",
				Description: "Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not [PublicKeySize]. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyWithOptions",
				Description: "VerifyWithOptions reports whether sig is a valid signature of message by publicKey. A valid signature is indicated by returning a nil error. It will panic if len(publicKey) is not [PublicKeySize]. If opts.Hash is [crypto.SHA512], the pre-hashed variant Ed25519ph is used and message is expected to be a SHA-512 hash, otherwise opts.Hash must be [crypto.Hash](0) and the message must not be hashed, as Ed25519 performs two passes over messages to be signed. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"trace": []funcSet{
			funcSet{
				Name:        "IsEnabled",
				Description: "IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log",
				Description: "Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Logf",
				Description: "Logf is like [Log], but the value is formatted using the specified format spec. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NewFlightRecorder",
				Description: "NewFlightRecorder creates a new flight recorder from the provided configuration. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FlightRecorder",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "NewTask",
				Description: "NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask. The taskType is used to classify task instances. Analysis tools like the Go execution tracer may assume there are only a bounded number of unique task types in the system. The returned Task's [Task.End] method is used to mark the task's end. The trace tool measures task latency as the time between task creation and when the End method is called, and provides the latency distribution per task type. If the End method is called multiple times, only the first call is used in the latency measurement. ctx, task := trace.NewTask(ctx, \"awesomeTask\") trace.WithRegion(ctx, \"preparation\", prepWork) // preparation of the task go func() { // continue processing the task in a separate goroutine. defer task.End() trace.WithRegion(ctx, \"remainingWork\", remainingWork) }() ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "Task",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "Start",
				Description: "Start activates the flight recorder and begins recording trace data. Only one call to trace.Start may be active at any given time. In addition, currently only one flight recorder may be active in the program. Returns an error if the flight recorder cannot be started or is already started. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StartRegion",
				Description: "StartRegion starts a region and returns it. The returned Region's [Region.End] method must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is defer trace.StartRegion(ctx, \"myTracedRegion\").End() ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Region",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "Stop",
				Description: "Stop ends recording of trace data. It blocks until any concurrent WriteTo calls complete. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "WithRegion",
				Description: "WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task. The regionType is used to classify regions, so there should be only a handful of unique region types. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "IsSystemGoroutine",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MakeResourceID",
				Description: "MakeResourceID creates a general resource ID from a specific resource's ID. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ResourceID",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "MutatorUtilizationV2",
				Description: "MutatorUtilizationV2 returns a set of mutator utilization functions for the given v2 trace, passed as an io.Reader. Each function will always end with 0 utilization. The bounds of each function are implicit in the first and last event; outside of these bounds each function is undefined. If the UtilPerProc flag is not given, this always returns a single utilization function. Otherwise, it returns one function per P. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]internal/trace.MutatorUtil",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewMMUCurve",
				Description: "NewMMUCurve returns an MMU curve for the given mutator utilization function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "MMUCurve",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new trace reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "trace",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewSummarizer",
				Description: "NewSummarizer creates a new struct to build goroutine stats from a trace. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Summarizer",
						TypePkgName: "trace",
					},
				},
			},
			funcSet{
				Name:        "RelatedGoroutinesV2",
				Description: "RelatedGoroutinesV2 finds a set of goroutines related to goroutine goid for v2 traces. The association is based on whether they have synchronized with each other in the Go scheduler (one has unblocked another). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[internal/trace.GoID]struct{}",
						TypePkgName: "",
					},
				},
			},
		},
		"unique": []funcSet{
			funcSet{
				Name:        "Make",
				Description: "Make returns a globally unique handle for a value of type T. Handles are equal if and only if the values used to produce them are equal. Make is safe for concurrent use by multiple goroutines. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handle",
						TypePkgName: "unique",
					},
				},
			},
		},
		"mime": []funcSet{
			funcSet{
				Name:        "AddExtensionType",
				Description: "AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ExtensionsByType",
				Description: "ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatMediaType",
				Description: "FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseMediaType",
				Description: "ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error [ErrInvalidMediaParameter]. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "map[string]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TypeByExtension",
				Description: "TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\". Extensions are looked up first case-sensitively, then case-insensitively. The built-in table is small but on unix it is augmented by the local system's MIME-info database or mime.types file(s) if available under one or more of these names: /usr/local/share/mime/globs2 /usr/share/mime/globs2 /etc/mime.types /etc/apache2/mime.types /etc/apache/mime.types On Windows, MIME types are extracted from the registry. Text types have the charset parameter set to \"utf-8\" by default. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"lazytemplate": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New creates a new lazy template, delaying the parsing work until it is first needed. If the code is being run as part of tests, the template parsing will happen immediately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "lazytemplate",
					},
				},
			},
		},
		"httputil": []funcSet{
			funcSet{
				Name:        "DumpRequest",
				Description: "DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an [http.Request]. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations. If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new [io.ReadCloser] that yields the same bytes. If DumpRequest returns an error, the state of req is undefined. The documentation for [http.Request.Write] details which fields of req are included in the dump. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DumpRequestOut",
				Description: "DumpRequestOut is like [DumpRequest] but for outgoing client requests. It includes any headers that the standard [http.Transport] adds, such as User-Agent. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DumpResponse",
				Description: "DumpResponse is like DumpRequest but dumps a response. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewChunkedReader",
				Description: "NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns [io.EOF] when the final 0-length chunk is read. NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewChunkedWriter",
				Description: "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately. NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewClientConn",
				Description: "NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. Deprecated: Use the Client or Transport in package [net/http] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientConn",
						TypePkgName: "httputil",
					},
				},
			},
			funcSet{
				Name:        "NewProxyClientConn",
				Description: "NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. Deprecated: Use the Client or Transport in package [net/http] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientConn",
						TypePkgName: "httputil",
					},
				},
			},
			funcSet{
				Name:        "NewServerConn",
				Description: "NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1. Deprecated: Use the Server in package [net/http] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ServerConn",
						TypePkgName: "httputil",
					},
				},
			},
			funcSet{
				Name:        "NewSingleHostReverseProxy",
				Description: "NewSingleHostReverseProxy returns a new [ReverseProxy] that routes URLs to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To customize the ReverseProxy behavior beyond what NewSingleHostReverseProxy provides, use ReverseProxy directly with a Rewrite function. The ProxyRequest SetURL method may be used to route the outbound request. (Note that SetURL, unlike NewSingleHostReverseProxy, rewrites the Host header of the outbound request by default.) proxy := &ReverseProxy{ Rewrite: func(r *ProxyRequest) { r.SetURL(target) r.Out.Host = r.In.Host // if desired }, } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReverseProxy",
						TypePkgName: "httputil",
					},
				},
			},
		},
		"fstest": []funcSet{
			funcSet{
				Name:        "TestFS",
				Description: "TestFS tests a file system implementation. It walks the entire tree of files in fsys, opening and checking that each file behaves correctly. Symbolic links are not followed, but their Lstat values are checked if the file system implements [fs.ReadLinkFS]. It also checks that the file system contains at least the expected files. As a special case, if no expected files are listed, fsys must be empty. Otherwise, fsys must contain at least the listed files; it can also contain others. The contents of fsys must not change concurrently with TestFS. If TestFS finds any misbehaviors, it returns either the first error or a list of errors. Use [errors.Is] or [errors.As] to inspect. Typical usage inside a test is: if err := fstest.TestFS(myFS, \"file/that/should/be/present\"); err != nil { t.Fatal(err) } ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"aes": []funcSet{
			funcSet{
				Name:        "EncryptBlockInternal",
				Description: "EncryptBlockInternal applies the AES encryption function to one block. It is an internal function meant only for the gcm package. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "EncryptionKeySchedule",
				Description: "EncryptionKeySchedule is used from the GCM implementation to access the precomputed AES key schedule, to pass to the assembly implementation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New creates and returns a new [cipher.Block] implementation. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "aes",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCBCDecrypter",
				Description: "NewCBCDecrypter returns a [cipher.BlockMode] which decrypts in cipher block chaining mode, using the given Block. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CBCDecrypter",
						TypePkgName: "aes",
					},
				},
			},
			funcSet{
				Name:        "NewCBCEncrypter",
				Description: "NewCBCEncrypter returns a [cipher.BlockMode] which encrypts in cipher block chaining mode, using the given Block. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CBCEncrypter",
						TypePkgName: "aes",
					},
				},
			},
			funcSet{
				Name:        "NewCTR",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CTR",
						TypePkgName: "aes",
					},
				},
			},
			funcSet{
				Name:        "RoundToBlock",
				Description: "RoundToBlock is used by CTR_DRBG, which discards the rightmost unused bits at each request. It rounds the offset up to the next block boundary. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NewCipher",
				Description: "NewCipher creates and returns a new [cipher.Block]. The key argument must be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"testing": []funcSet{
			funcSet{
				Name:        "AllocsPerRun",
				Description: "AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value. To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned. AllocsPerRun sets [runtime.GOMAXPROCS] to 1 during its measurement and will restore it before returning. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Benchmark",
				Description: "Benchmark benchmarks a single function. It is useful for creating custom benchmarks that do not use the \"go test\" command. If f depends on testing flags, then [Init] must be used to register those flags before calling Benchmark and before calling [flag.Parse]. If f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BenchmarkResult",
						TypePkgName: "testing",
					},
				},
			},
			funcSet{
				Name:        "CoverMode",
				Description: "CoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Coverage",
				Description: "Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0. When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Init",
				Description: "Init registers testing flags. These flags are automatically registered by the \"go test\" command before running test functions, so Init is only needed when calling functions such as Benchmark without using \"go test\". Init is not safe to call concurrently. It has no effect if it was already called. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Main",
				Description: "Main is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use [MainStart]. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MainStart",
				Description: "MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "M",
						TypePkgName: "testing",
					},
				},
			},
			funcSet{
				Name:        "RegisterCover",
				Description: "RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RunBenchmarks",
				Description: "RunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RunExamples",
				Description: "RunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RunTests",
				Description: "RunTests is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Short",
				Description: "Short reports whether the -test.short flag is set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Testing",
				Description: "Testing reports whether the current code is being run in a test. This will report true in programs created by \"go test\", false in programs created by \"go build\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Verbose",
				Description: "Verbose reports whether the -test.v flag is set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"syntax": []funcSet{
			funcSet{
				Name:        "Compile",
				Description: "Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Prog",
						TypePkgName: "syntax",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EmptyOpContext",
				Description: "EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EmptyOp",
						TypePkgName: "syntax",
					},
				},
			},
			funcSet{
				Name:        "IsWordChar",
				Description: "IsWordChar reports whether r is considered a âword characterâ during the evaluation of the \\b and \\B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "syntax",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"doc": []funcSet{
			funcSet{
				Name:        "Examples",
				Description: "Examples returns the examples found in testFiles, sorted by Name field. The Order fields record the order in which the examples were encountered. The Suffix field is not populated when Examples is called directly, it is only populated by [NewFromFiles] for examples it finds in _test.go files. Playable Examples must be in a package whose name ends in \"_test\". An Example is \"playable\" (the Play field is non-nil) in either of these circumstances: - The example function is self-contained: the function references only identifiers from other packages (or predeclared identifiers, such as \"int\") and the test file does not include a dot import. - The entire test file is the example: the file contains exactly one example function, zero test, fuzz test, or benchmark function, and at least one top-level function, type, variable, or constant declaration other than the example function. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/doc.Example",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPredeclared",
				Description: "IsPredeclared reports whether s is a predeclared identifier. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it. To have the [Examples] fields populated, use [NewFromFiles] and include the package's _test.go files. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "doc",
					},
				},
			},
			funcSet{
				Name:        "NewFromFiles",
				Description: "NewFromFiles computes documentation for a package. The package is specified by a list of *ast.Files and corresponding file set, which must not be nil. NewFromFiles uses all provided files when computing documentation, so it is the caller's responsibility to provide only the files that match the desired build context. \"go/build\".Context.MatchFile can be used for determining whether a file matches a build context with the desired GOOS and GOARCH values, and other build constraints. The import path of the package is specified by importPath. Examples found in _test.go files are associated with the corresponding type, function, method, or the package, based on their name. If the example has a suffix in its name, it is set in the [Example.Suffix] field. [Examples] with malformed names are skipped. Optionally, a single extra argument of type [Mode] can be provided to control low-level aspects of the documentation extraction behavior. NewFromFiles takes ownership of the AST files and may edit them, unless the PreserveAST Mode bit is on. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "doc",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Synopsis",
				Description: "Synopsis returns a cleaned version of the first sentence in text. Deprecated: New programs should use [Package.Synopsis] instead, which handles links in text properly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToHTML",
				Description: "ToHTML converts comment text to formatted HTML. Deprecated: ToHTML cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API. Given the *[doc.Package] p where text was found, ToHTML(w, text, nil) can be replaced by: w.Write(p.HTML(text)) which is in turn shorthand for: w.Write(p.Printer().HTML(p.Parser().Parse(text))) If words may be non-nil, the longer replacement is: parser := p.Parser() parser.Words = words w.Write(p.Printer().HTML(parser.Parse(d))) ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ToText",
				Description: "ToText converts comment text to formatted text. Deprecated: ToText cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API. Given the *[doc.Package] p where text was found, ToText(w, text, \"\", \"\\t\", 80) can be replaced by: w.Write(p.Text(text)) In the general case, ToText(w, text, prefix, codePrefix, width) can be replaced by: d := p.Parser().Parse(text) pr := p.Printer() pr.TextPrefix = prefix pr.TextCodePrefix = codePrefix pr.TextWidth = width w.Write(pr.Text(d)) See the documentation for [Package.Text] and [comment.Printer.Text] for more details. ",
				Returns:     []returnSet{},
			},
		},
		"dag": []funcSet{
			funcSet{
				Name:        "Parse",
				Description: "Parse parses the DAG language and returns the transitive closure of the described graph. In the returned graph, there is an edge from \"b\" to \"a\" if b < a (or a > b) in the partial order. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Graph",
						TypePkgName: "dag",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"obscuretestdata": []funcSet{
			funcSet{
				Name:        "DecodeToTempFile",
				Description: "DecodeToTempFile decodes the named file to a temporary location. If successful, it returns the path of the decoded file. The caller is responsible for ensuring that the temporary file is removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFile",
				Description: "ReadFile reads the named file and returns its decoded contents. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rot13",
				Description: "Rot13 returns the rot13 encoding or decoding of its input. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"tracev2": []funcSet{
			funcSet{
				Name:        "EventNames",
				Description: "EventNames is a helper that produces a mapping of event names to event types. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[string]internal/trace/tracev2.EventType",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Experiments",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Specs",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/trace/tracev2.EventSpec",
						TypePkgName: "",
					},
				},
			},
		},
		"syscall": []funcSet{
			funcSet{
				Name:        "Accept",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Access",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Adjtime",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Bind",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfBuflen",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfDatalink",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfHeadercmpl",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfInterface",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfJump",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BpfInsn",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "BpfStats",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BpfStat",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BpfStmt",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BpfInsn",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "BpfTimeout",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Timeval",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BytePtrFromString",
				Description: "BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, [EINVAL]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ByteSliceFromString",
				Description: "ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, [EINVAL]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chdir",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CheckBpfVersion",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chflags",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chmod",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chown",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Chroot",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clearenv",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Close",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CloseOnExec",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "CmsgLen",
				Description: "CmsgLen returns the value to store in the Len field of the [Cmsghdr] structure, taking into account any necessary alignment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CmsgSpace",
				Description: "CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Connect",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dup",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dup2",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Environ",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exchangedata",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exec",
				Description: "Exec invokes the execve(2) system call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exit",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Fchdir",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fchflags",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fchmod",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fchown",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FcntlFlock",
				Description: "FcntlFlock performs a fcntl syscall for the [F_GETLK], [F_SETLK] or [F_SETLKW] command. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Flock",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FlushBpf",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ForkExec",
				Description: "Combination of fork and exec, careful to be thread safe. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fpathconf",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fstat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fstatfs",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fsync",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ftruncate",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Futimes",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getdirentries",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getdtablesize",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getegid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getenv",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Geteuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getfsstat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgroups",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpagesize",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpeername",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpgid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpgrp",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getppid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpriority",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getrlimit",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getrusage",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getsid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getsockname",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptByte",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptICMPv6Filter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ICMPv6Filter",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptIPMreq",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPMreq",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptIPv6MTUInfo",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPv6MTUInfo",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptIPv6Mreq",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPv6Mreq",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptInet4Addr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[4]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GetsockoptInt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Gettimeofday",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getwd",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Issetugid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Kevent",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Kill",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Kqueue",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lchown",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Link",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Listen",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lstat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mkdir",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mkfifo",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mknod",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mlock",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mlockall",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mmap",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mprotect",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Munlock",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Munlockall",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Munmap",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NsecToTimespec",
				Description: "NsecToTimespec converts a number of nanoseconds into a [Timespec]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Timespec",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "NsecToTimeval",
				Description: "NsecToTimeval converts a number of nanoseconds into a [Timeval]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Timeval",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseDirent",
				Description: "ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseRoutingMessage",
				Description: "ParseRoutingMessage parses b as routing messages and returns the slice containing the [RoutingMessage] interfaces. Deprecated: Use golang.org/x/net/route instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.RoutingMessage",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseRoutingSockaddr",
				Description: "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and returns the slice containing the [Sockaddr] interfaces. Deprecated: Use golang.org/x/net/route instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.Sockaddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseSocketControlMessage",
				Description: "ParseSocketControlMessage parses b as an array of socket control messages. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.SocketControlMessage",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseUnixRights",
				Description: "ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pathconf",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pipe",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pread",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PtraceAttach",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PtraceDetach",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pwrite",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RawSyscall",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "RawSyscall6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadDirent",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Readlink",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Recvfrom",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Recvmsg",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rename",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Revoke",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Rmdir",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RouteRIB",
				Description: "RouteRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters. Deprecated: Use golang.org/x/net/route instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Seek",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Select",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sendfile",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sendmsg",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendmsgN",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sendto",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpf",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfBuflen",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfDatalink",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfHeadercmpl",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfImmediate",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfInterface",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfPromisc",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetBpfTimeout",
				Description: "Deprecated: Use golang.org/x/net/bpf instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetKevent",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetNonblock",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setegid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setenv",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Seteuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setgid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setgroups",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setlogin",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setpgid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setpriority",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setprivexec",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setregid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setreuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setrlimit",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setsid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptByte",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptICMPv6Filter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptIPMreq",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptIPv6Mreq",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptInet4Addr",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptInt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptLinger",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetsockoptTimeval",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Settimeofday",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Setuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Shutdown",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SlicePtrFromStrings",
				Description: "SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, [EINVAL]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Socket",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Socketpair",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[2]int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StartProcess",
				Description: "StartProcess wraps [ForkExec] for package os. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Stat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Statfs",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringBytePtr",
				Description: "StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error. Deprecated: Use [BytePtrFromString] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringByteSlice",
				Description: "StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error. Deprecated: Use ByteSliceFromString instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringSlicePtr",
				Description: "StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error. Deprecated: Use [SlicePtrFromStrings] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Symlink",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sync",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Syscall",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Syscall6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Syscall9",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Sysctl",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SysctlUint32",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TimespecToNsec",
				Description: "TimespecToNsec returns the time stored in ts as nanoseconds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TimevalToNsec",
				Description: "TimevalToNsec returns the time stored in tv as nanoseconds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Truncate",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Umask",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Undelete",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnixRights",
				Description: "UnixRights encodes a set of open file descriptors into a socket control message for sending to another process. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unlink",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unmount",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unsetenv",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Utimes",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UtimesNano",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Wait4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Write",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"ecdsa": []funcSet{
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a new ECDSA private key pair for the specified curve. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPrivateKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewPublicKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "P224",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdsa",
					},
				},
			},
			funcSet{
				Name:        "P256",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdsa",
					},
				},
			},
			funcSet{
				Name:        "P384",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdsa",
					},
				},
			},
			funcSet{
				Name:        "P521",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Curve",
						TypePkgName: "ecdsa",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "Sign signs a hash (which shall be the result of hashing a larger message with the hash function H) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignDeterministic",
				Description: "SignDeterministic signs a hash (which shall be the result of hashing a larger message with the hash function H) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. This applies Deterministic ECDSA as specified in FIPS 186-5 and RFC 6979. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TestingOnlyNewDRBG",
				Description: "TestingOnlyNewDRBG creates an SP 800-90A Rev. 1 HMAC_DRBG with a plain personalization string. This should only be used for ACVP testing. hmacDRBG is not intended to be used directly. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "hmacDRBG",
						TypePkgName: "ecdsa",
					},
				},
			},
			funcSet{
				Name:        "Verify",
				Description: "Verify verifies the signature, sig, of hash (which should be the result of hashing a larger message) using the public key, pub. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GenerateKey",
				Description: "GenerateKey generates a new ECDSA private key for the specified curve. Most applications should use [crypto/rand.Reader] as rand. Note that the returned key does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseRawPrivateKey",
				Description: "ParseRawPrivateKey parses a private key encoded as a fixed-length big-endian integer, according to SEC 1, Version 2.0, Section 2.3.6 (sometimes referred to as the raw format). It returns an error if the value is not reduced modulo the curve's order, or if it's zero. curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or ParseRawPrivateKey returns an error. ParseRawPrivateKey accepts the same format as [ecdh.Curve.NewPrivateKey] does for NIST curves, but returns a [PrivateKey] instead of an [ecdh.PrivateKey]. Note that private keys are more commonly encoded in ASN.1 or PKCS#8 format, which can be parsed with [crypto/x509.ParseECPrivateKey] or [crypto/x509.ParsePKCS8PrivateKey] (and [encoding/pem]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseUncompressedPublicKey",
				Description: "ParseUncompressedPublicKey parses a public key encoded as an uncompressed point according to SEC 1, Version 2.0, Section 2.3.3 (also known as the X9.62 uncompressed format). It returns an error if the point is not in uncompressed form, is not on the curve, or is the point at infinity. curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or ParseUncompressedPublicKey returns an error. ParseUncompressedPublicKey accepts the same format as [ecdh.Curve.NewPublicKey] does for NIST curves, but returns a [PublicKey] instead of an [ecdh.PublicKey]. Note that public keys are more commonly encoded in DER (or PEM) format, which can be parsed with [crypto/x509.ParsePKIXPublicKey] (and [encoding/pem]). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "Sign signs a hash (which should be the result of hashing a larger message with opts.HashFunc()) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature, like [SignASN1]. If rand is not nil, the signature is randomized. Most applications should use [crypto/rand.Reader] as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions. If rand is nil, Sign will produce a deterministic signature according to RFC 6979. When producing a deterministic signature, opts.HashFunc() must be the function used to produce digest and priv.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SignASN1",
				Description: "SignASN1 signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature. The signature is randomized. Most applications should use [crypto/rand.Reader] as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Verify",
				Description: "Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid. Most applications should use VerifyASN1 instead of dealing directly with r, s. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VerifyASN1",
				Description: "VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid. The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"driver": []funcSet{
			funcSet{
				Name:        "IsScanValue",
				Description: "IsScanValue is equivalent to [IsValue]. It exists for compatibility. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsValue",
				Description: "IsValue reports whether v is a valid [Value] parameter type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"binary": []funcSet{
			funcSet{
				Name:        "Append",
				Description: "Append appends the binary representation of data to buf. buf may be nil, in which case a new buffer will be allocated. See [Write] on which data are acceptable. It returns the (possibly extended) buffer containing data or an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendUvarint",
				Description: "AppendUvarint appends the varint-encoded form of x, as generated by [PutUvarint], to buf and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendVarint",
				Description: "AppendVarint appends the varint-encoded form of x, as generated by [PutVarint], to buf and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Decode",
				Description: "Decode decodes binary data from buf into data according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes consumed from buf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode encodes the binary representation of data into buf according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes written into buf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PutUvarint",
				Description: "PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PutVarint",
				Description: "PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic. The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, Read returns [io.ErrUnexpectedEOF]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadUvarint",
				Description: "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, ReadUvarint returns [io.ErrUnexpectedEOF]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadVarint",
				Description: "ReadVarint reads an encoded signed integer from r and returns it as an int64. The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, ReadVarint returns [io.ErrUnexpectedEOF]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Size",
				Description: "Size returns how many bytes [Write] would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uvarint",
				Description: "Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 meaning: - n == 0: buf too small; - n < 0: value larger than 64 bits (overflow) and -n is the number of bytes read. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Varint",
				Description: "Varint decodes an int64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 with the following meaning: - n == 0: buf too small; - n < 0: value larger than 64 bits (overflow) and -n is the number of bytes read. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Write",
				Description: "Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"fips140": []funcSet{
			funcSet{
				Name:        "CAST",
				Description: "CAST runs the named Cryptographic Algorithm Self-Test (if operated in FIPS mode) and aborts the program (stopping the module input/output and entering the \"error state\") if the self-test fails. CASTs are mandatory self-checks that must be performed by FIPS 140-3 modules before the algorithm is used. See Implementation Guidance 10.3.A. The name must not contain commas, colons, hashes, or equal signs. If a package p calls CAST from its init function, an import of p should also be added to crypto/internal/fips140test. If a package p calls CAST on the first use of the algorithm, an invocation of that algorithm should be added to fipstest.TestConditionals. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Name",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PCT",
				Description: "PCT runs the named Pairwise Consistency Test (if operated in FIPS mode) and returns any errors. If an error is returned, the key must not be used. PCTs are mandatory for every key pair that is generated/imported, including ephemeral keys (which effectively doubles the cost of key establishment). See Implementation Guidance 10.3.A Additional Comment 1. The name must not contain commas, colons, hashes, or equal signs. If a package p calls PCT during key generation, an invocation of that function should be added to fipstest.TestConditionals. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RecordApproved",
				Description: "RecordApproved is an internal function that records the use of an approved service. It does not override RecordNonApproved calls in the same span. It should be called by exposed functions that perform a whole cryptographic alrgorithm (e.g. by Sum, not by New, unless a cryptographic Instantiate algorithm is performed) and should be called after any checks that may cause the function to error out or panic. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "RecordNonApproved",
				Description: "RecordNonApproved is an internal function that records the use of a non-approved service. It overrides any RecordApproved calls in the same span. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ResetServiceIndicator",
				Description: "ResetServiceIndicator clears the service indicator for the running goroutine. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ServiceIndicator",
				Description: "ServiceIndicator returns true if and only if all services invoked by this goroutine since the last ResetServiceIndicator call are approved. If ResetServiceIndicator was not called before by this goroutine, its return value is undefined. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Supported",
				Description: "Supported returns an error if FIPS 140-3 mode can't be enabled. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Version",
				Description: "Version returns the formal version (such as \"v1.0\") if building against a frozen module with GOFIPS140. Otherwise, it returns \"latest\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Enabled",
				Description: "Enabled reports whether the cryptography libraries are operating in FIPS 140-3 mode. It can be controlled at runtime using the GODEBUG setting \"fips140\". If set to \"on\", FIPS 140-3 mode is enabled. If set to \"only\", non-approved cryptography functions will additionally return errors or panic. This can't be changed after the program has started. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"saferio": []funcSet{
			funcSet{
				Name:        "ReadData",
				Description: "ReadData reads n bytes from the input stream, but avoids allocating all n bytes if n is large. This avoids crashing the program by allocating all n bytes in cases where n is incorrect. The error is io.EOF only if no bytes were read. If an io.EOF happens after reading some but not all the bytes, ReadData returns io.ErrUnexpectedEOF. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadDataAt",
				Description: "ReadDataAt reads n bytes from the input stream at off, but avoids allocating all n bytes if n is large. This avoids crashing the program by allocating all n bytes in cases where n is incorrect. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SliceCap",
				Description: "SliceCap is like SliceCapWithSize but using generics. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SliceCapWithSize",
				Description: "SliceCapWithSize returns the capacity to use when allocating a slice. After the slice is allocated with the capacity, it should be built using append. This will avoid allocating too much memory if the capacity is large and incorrect. A negative result means that the value is always too big. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"strconv": []funcSet{
			funcSet{
				Name:        "Atoi",
				Description: "Atoi is like Atoi64 but for integers that fit into an int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atoi32",
				Description: "Atoi32 is like Atoi but for integers that fit into an int32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atoi64",
				Description: "Atoi64 parses an int64 from a string s. The bool result reports whether s is a number representable by a value of type int64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendBool",
				Description: "AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendFloat",
				Description: "AppendFloat appends the string form of the floating-point number f, as generated by [FormatFloat], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendInt",
				Description: "AppendInt appends the string form of the integer i, as generated by [FormatInt], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuote",
				Description: "AppendQuote appends a double-quoted Go string literal representing s, as generated by [Quote], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuoteRune",
				Description: "AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by [QuoteRune], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuoteRuneToASCII",
				Description: "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by [QuoteRuneToASCII], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuoteRuneToGraphic",
				Description: "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by [QuoteRuneToGraphic], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuoteToASCII",
				Description: "AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by [QuoteToASCII], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendQuoteToGraphic",
				Description: "AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by [QuoteToGraphic], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "AppendUint",
				Description: "AppendUint appends the string form of the unsigned integer i, as generated by [FormatUint], to dst and returns the extended buffer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atoi",
				Description: "Atoi is equivalent to ParseInt(s, 10, 0), converted to type int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CanBackquote",
				Description: "CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatBool",
				Description: "FormatBool returns \"true\" or \"false\" according to the value of b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatComplex",
				Description: "FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec. The format fmt and precision prec have the same meaning as in [FormatFloat]. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatFloat",
				Description: "FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64). The format fmt is one of - 'b' (-ddddpÂ±ddd, a binary exponent), - 'e' (-d.ddddeÂ±dd, a decimal exponent), - 'E' (-d.ddddEÂ±dd, a decimal exponent), - 'f' (-ddd.dddd, no exponent), - 'g' ('e' for large exponents, 'f' otherwise), - 'G' ('E' for large exponents, 'f' otherwise), - 'x' (-0xd.ddddpÂ±ddd, a hexadecimal fraction and binary exponent), or - 'X' (-0Xd.ddddPÂ±ddd, a hexadecimal fraction and binary exponent). The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly. The exponent is written as a decimal integer; for all formats other than 'b', it will be at least two digits. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatInt",
				Description: "FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FormatUint",
				Description: "FormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsGraphic",
				Description: "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPrint",
				Description: "IsPrint reports whether the rune is defined as printable by Go, with the same definition as [unicode.IsPrint]: letters, numbers, punctuation, symbols and ASCII space. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Itoa",
				Description: "Itoa is equivalent to [FormatInt](int64(i), 10). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseBool",
				Description: "ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseComplex",
				Description: "ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value. The number represented by s must be of the form N, Ni, or NÂ±Ni, where N stands for a floating-point number as recognized by [ParseFloat], and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the Â±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat. The errors that ParseComplex returns have concrete type [*NumError] and include err.Num = s. If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax. If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = Â±Inf for the respective component. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "complex128",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseFloat",
				Description: "ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value. ParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for [floating-point literals]. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.) The errors that ParseFloat returns have concrete type *NumError and include err.Num = s. If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax. If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = Â±Inf, err.Err = ErrRange. ParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching. [floating-point literals]: https://go.dev/ref/spec#Floating-point_literals ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseInt",
				Description: "ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i. The string may begin with a leading sign: \"+\" or \"-\". If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for [integer literals]. The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned. The errors that ParseInt returns have concrete type [*NumError] and include err.Num = s. If s is empty or contains invalid digits, err.Err = [ErrSyntax] and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = [ErrRange] and the returned value is the maximum magnitude integer of the appropriate bitSize and sign. [integer literals]: https://go.dev/ref/spec#Integer_literals ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseUint",
				Description: "ParseUint is like [ParseInt] but for unsigned numbers. A sign prefix is not permitted. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Quote",
				Description: "Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by [IsPrint]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuoteRune",
				Description: "QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by [IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuoteRuneToASCII",
				Description: "QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by [IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuoteRuneToGraphic",
				Description: "QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by [IsGraphic], the returned string will use a Go escape sequence (\\t, \\n, \\xFF, \\u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuoteToASCII",
				Description: "QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by [IsPrint]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuoteToGraphic",
				Description: "QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by [IsGraphic], unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-graphic characters. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "QuotedPrefix",
				Description: "QuotedPrefix returns the quoted string (as understood by [Unquote]) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unquote",
				Description: "Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string. For an empty character literal Unquote returns the empty string.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnquoteChar",
				Description: "UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values: 1. value, the decoded Unicode code point or byte value; 2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation; 3. tail, the remainder of the string after the character; and 4. an error that will be nil if the character is syntactically valid. The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\' and disallows unescaped '. If set to a double quote, it permits \\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"tls12": []funcSet{
			funcSet{
				Name:        "MasterSecret",
				Description: "MasterSecret implements the TLS 1.2 extended master secret derivation, as defined in RFC 7627 and allowed by SP 800-135, Revision 1, Section 4.2.2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PRF",
				Description: "PRF implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5 and allowed by SP 800-135, Revision 1, Section 4.2.2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"buildinfo": []funcSet{
			funcSet{
				Name:        "Read",
				Description: "Read returns build information embedded in a Go binary file accessed through the given ReaderAt. Most information is only available for binaries built with module support. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*debug/buildinfo.BuildInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadFile",
				Description: "ReadFile returns build information embedded in a Go binary file at the given path. Most information is only available for binaries built with module support. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*debug/buildinfo.BuildInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"unix": []funcSet{
			funcSet{
				Name:        "ARC4Random",
				Description: "ARC4Random calls the macOS arc4random_buf(3) function. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Eaccess",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fchmodat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fchownat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fcntl",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Freeaddrinfo",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Fstatat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GaiStrerror",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getaddrinfo",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getgrgid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Getgrnam",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Getgrouplist",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getnameinfo",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Getpwnam",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "Getpwuid",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Errno",
						TypePkgName: "syscall",
					},
				},
			},
			funcSet{
				Name:        "GoString",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Grantpt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasNonblockFlag",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsNonblock",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "KernelVersion",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Linkat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mkdirat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Openat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PosixOpenpt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ptsname",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Readlinkat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RecvfromInet4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RecvfromInet6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RecvmsgInet4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RecvmsgInet6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Renameat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResNclose",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ResNinit",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ResNsearch",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendmsgNInet4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendmsgNInet6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendtoInet4",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SendtoInet6",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Symlinkat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sysconf",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Tcsetpgrp",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unlinkat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unlockpt",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Utimensat",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"strings": []funcSet{
			funcSet{
				Name:        "Clone",
				Description: "Clone returns a fresh copy of s. It guarantees to make a copy of s into a new allocation, which can be important when retaining only a small substring of a much larger string. Using Clone can help such programs use less memory. Of course, since using Clone makes a copy, overuse of Clone can make programs use more memory. Clone should typically be used only rarely, and only when profiling indicates that it is needed. For strings of length zero the string \"\" will be returned and no allocation is made. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compare",
				Description: "Compare returns an integer comparing two strings lexicographically. The result will be 0 if a == b, -1 if a < b, and +1 if a > b. Use Compare when you need to perform a three-way comparison (with [slices.SortFunc], for example). It is usually clearer and always faster to use the built-in string comparison operators ==, <, >, and so on. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Contains",
				Description: "Contains reports whether substr is within s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsAny",
				Description: "ContainsAny reports whether any Unicode code points in chars are within s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsFunc",
				Description: "ContainsFunc reports whether any Unicode code points r within s satisfy f(r). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ContainsRune",
				Description: "ContainsRune reports whether the Unicode code point r is within s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Count",
				Description: "Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cut",
				Description: "Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, \"\", false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutPrefix",
				Description: "CutPrefix returns s without the provided leading prefix string and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty string, CutPrefix returns s, true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutSuffix",
				Description: "CutSuffix returns s without the provided ending suffix string and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty string, CutSuffix returns s, true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EqualFold",
				Description: "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fields",
				Description: "Fields splits the string s around each instance of one or more consecutive white space characters, as defined by [unicode.IsSpace], returning a slice of substrings of s or an empty slice if s contains only white space. Every element of the returned slice is non-empty. Unlike [Split], leading and trailing runs runs of white space characters are discarded. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FieldsFunc",
				Description: "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. Every element of the returned slice is non-empty. Unlike [SplitFunc], leading and trailing runs of code points satisfying f(c) are discarded. FieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FieldsFuncSeq",
				Description: "FieldsFuncSeq returns an iterator over substrings of s split around runs of Unicode code points satisfying f(c). The iterator yields the same strings that would be returned by [FieldsFunc](s), but without constructing the slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "FieldsSeq",
				Description: "FieldsSeq returns an iterator over substrings of s split around runs of whitespace characters, as defined by [unicode.IsSpace]. The iterator yields the same strings that would be returned by [Fields](s), but without constructing the slice. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "HasPrefix",
				Description: "HasPrefix reports whether the string s begins with prefix. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasSuffix",
				Description: "HasSuffix reports whether the string s ends with suffix. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexAny",
				Description: "IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexByte",
				Description: "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexFunc",
				Description: "IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexRune",
				Description: "IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is [utf8.RuneError], it returns the first instance of any invalid UTF-8 byte sequence. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Join",
				Description: "Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndex",
				Description: "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexAny",
				Description: "LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexByte",
				Description: "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LastIndexFunc",
				Description: "LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lines",
				Description: "Lines returns an iterator over the newline-terminated lines in the string s. The lines yielded by the iterator include their terminating newlines. If s is empty, the iterator yields no lines at all. If s does not end in a newline, the final yielded line will not end in a newline. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Map",
				Description: "Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewReader",
				Description: "NewReader returns a new [Reader] reading from s. It is similar to [bytes.NewBufferString] but more efficient and non-writable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "strings",
					},
				},
			},
			funcSet{
				Name:        "NewReplacer",
				Description: "NewReplacer returns a new [Replacer] from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order. NewReplacer panics if given an odd number of arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Replacer",
						TypePkgName: "strings",
					},
				},
			},
			funcSet{
				Name:        "Repeat",
				Description: "Repeat returns a new string consisting of count copies of the string s. It panics if count is negative or if the result of (len(s) * count) overflows. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Replace",
				Description: "Replace returns a copy of s with all replacements performed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReplaceAll",
				Description: "ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Split",
				Description: "Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators. If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s. If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice. It is equivalent to [SplitN] with a count of -1. To split around the first instance of a separator, see [Cut]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfter",
				Description: "SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings. If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s. If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice. It is equivalent to [SplitAfterN] with a count of -1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfterN",
				Description: "SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings. The count determines the number of substrings to return: - n > 0: at most n substrings; the last substring will be the unsplit remainder; - n == 0: the result is nil (zero substrings); - n < 0: all substrings. Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for [SplitAfter]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitAfterSeq",
				Description: "SplitAfterSeq returns an iterator over substrings of s split after each instance of sep. The iterator yields the same strings that would be returned by [SplitAfter](s, sep), but without constructing the slice. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "SplitN",
				Description: "SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators. The count determines the number of substrings to return: - n > 0: at most n substrings; the last substring will be the unsplit remainder; - n == 0: the result is nil (zero substrings); - n < 0: all substrings. Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for [Split]. To split around the first instance of a separator, see [Cut]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SplitSeq",
				Description: "SplitSeq returns an iterator over all substrings of s separated by sep. The iterator yields the same strings that would be returned by [Split](s, sep), but without constructing the slice. It returns a single-use iterator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Title",
				Description: "Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case. Deprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLower",
				Description: "ToLower returns s with all Unicode letters mapped to their lower case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLowerSpecial",
				Description: "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToTitle",
				Description: "ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToTitleSpecial",
				Description: "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToUpper",
				Description: "ToUpper returns s with all Unicode letters mapped to their upper case. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToUpperSpecial",
				Description: "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToValidUTF8",
				Description: "ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Trim",
				Description: "Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimFunc",
				Description: "TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimLeft",
				Description: "TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. To remove a prefix, use [TrimPrefix] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimLeftFunc",
				Description: "TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimPrefix",
				Description: "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimRight",
				Description: "TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed. To remove a suffix, use [TrimSuffix] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimRightFunc",
				Description: "TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimSpace",
				Description: "TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimSuffix",
				Description: "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"ring": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New creates a ring of n elements. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
		},
		"rand": []funcSet{
			funcSet{
				Name:        "ExpFloat64",
				Description: "ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using: sample = ExpFloat64() / desiredRateParameter ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float32",
				Description: "Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64",
				Description: "Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int",
				Description: "Int returns a non-negative pseudo-random int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int32",
				Description: "Int32 returns a non-negative pseudo-random 31-bit integer as an int32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int32N",
				Description: "Int32N returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int64",
				Description: "Int64 returns a non-negative pseudo-random 63-bit integer as an int64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int64N",
				Description: "Int64N returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IntN",
				Description: "IntN returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "N",
				Description: "N returns a pseudo-random number in the half-open interval [0,n) from the default Source. The type parameter Int can be any integer type. It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new Rand that uses random values from src to generate other random values. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rand",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NewChaCha8",
				Description: "NewChaCha8 returns a new ChaCha8 seeded with the given seed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ChaCha8",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NewPCG",
				Description: "NewPCG returns a new PCG seeded with the given values. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PCG",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NewZipf",
				Description: "NewZipf returns a Zipf variate generator. The generator generates values k â [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s > 1 and v >= 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Zipf",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NormFloat64",
				Description: "NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using: sample = NormFloat64() * desiredStdDev + desiredMean ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Perm",
				Description: "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval [0,n). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Shuffle",
				Description: "Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Uint",
				Description: "Uint returns a pseudo-random uint. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint32",
				Description: "Uint32 returns a pseudo-random 32-bit value as a uint32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint32N",
				Description: "Uint32N returns, as a uint32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint64",
				Description: "Uint64 returns a uniformly distributed random uint64 value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint64N",
				Description: "Uint64N returns, as a uint64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UintN",
				Description: "UintN returns, as a uint, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ExpFloat64",
				Description: "ExpFloat64 returns an exponentially distributed float64 in the range (0, +[math.MaxFloat64]] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using: sample = ExpFloat64() / desiredRateParameter ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float32",
				Description: "Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64",
				Description: "Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int",
				Description: "Int returns a non-negative pseudo-random int. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int31",
				Description: "Int31 returns a non-negative pseudo-random 31-bit integer as an int32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int31n",
				Description: "Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int63",
				Description: "Int63 returns a non-negative pseudo-random 63-bit integer as an int64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int63n",
				Description: "Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Intn",
				Description: "Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new [Rand] that uses random values from src to generate other random values. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rand",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NewSource",
				Description: "NewSource returns a new pseudo-random [Source] seeded with the given value. Unlike the default [Source] used by top-level functions, this source is not safe for concurrent use by multiple goroutines. The returned [Source] implements [Source64]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Source",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NewZipf",
				Description: "NewZipf returns a [Zipf] variate generator. The generator generates values k â [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s > 1 and v >= 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Zipf",
						TypePkgName: "rand",
					},
				},
			},
			funcSet{
				Name:        "NormFloat64",
				Description: "NormFloat64 returns a normally distributed float64 in the range -[math.MaxFloat64] through +[math.MaxFloat64] inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using: sample = NormFloat64() * desiredStdDev + desiredMean ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Perm",
				Description: "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval [0,n). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Seed",
				Description: "Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other [Rand] method. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Shuffle",
				Description: "Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Uint32",
				Description: "Uint32 returns a pseudo-random 32-bit value as a uint32. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Uint64",
				Description: "Uint64 returns a pseudo-random 64-bit value as a uint64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Int",
				Description: "Int returns a uniform random value in [0, max). It panics if max <= 0, and returns an error if rand.Read returns one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Prime",
				Description: "Prime returns a number of the given bit length that is prime with high probability. Prime will return error for any error returned by rand.Read or if bits < 2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Text",
				Description: "Text returns a cryptographically random string using the standard RFC 4648 base32 alphabet for use when a secret string, token, password, or other text is needed. The result contains at least 128 bits of randomness, enough to prevent brute force guessing attacks and to make the likelihood of collisions vanishingly small. A future version may return longer texts as needed to maintain those properties. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"x509": []funcSet{
			funcSet{
				Name:        "CreateCertificate",
				Description: "CreateCertificate creates a new X.509 v3 certificate based on a template. The following members of template are currently used: - AuthorityKeyId - BasicConstraintsValid - CRLDistributionPoints - DNSNames - EmailAddresses - ExcludedDNSDomains - ExcludedEmailAddresses - ExcludedIPRanges - ExcludedURIDomains - ExtKeyUsage - ExtraExtensions - IPAddresses - IsCA - IssuingCertificateURL - KeyUsage - MaxPathLen - MaxPathLenZero - NotAfter - NotBefore - OCSPServer - PermittedDNSDomains - PermittedDNSDomainsCritical - PermittedEmailAddresses - PermittedIPRanges - PermittedURIDomains - PolicyIdentifiers (see note below) - Policies (see note below) - SerialNumber - SignatureAlgorithm - Subject - SubjectKeyId - URIs - UnknownExtKeyUsage The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the certificate to be generated and priv is the private key of the signer. The returned slice is the certificate in DER encoding. The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer or crypto.MessageSigner with a supported public key. The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used. If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key. If template.SerialNumber is nil, a serial number will be generated which conforms to RFC 5280, Section 4.1.2.2 using entropy from rand. The PolicyIdentifier and Policies fields can both be used to marshal certificate policy OIDs. By default, only the Policies is marshaled, but if the GODEBUG setting \"x509usepolicies\" has the value \"0\", the PolicyIdentifiers field will be marshaled instead of the Policies field. This changed in Go 1.24. The Policies field can be used to marshal policy OIDs which have components that are larger than 31 bits. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CreateCertificateRequest",
				Description: "CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used: - SignatureAlgorithm - Subject - DNSNames - EmailAddresses - IPAddresses - URIs - ExtraExtensions - Attributes (deprecated) priv is the private key to sign the CSR with, and the corresponding public key will be included in the CSR. It must implement crypto.Signer or crypto.MessageSigner and its Public() method must return a *rsa.PublicKey or a *ecdsa.PublicKey or a ed25519.PublicKey. (A *rsa.PrivateKey, *ecdsa.PrivateKey or ed25519.PrivateKey satisfies this.) The returned slice is the certificate request in DER encoding. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CreateRevocationList",
				Description: "CreateRevocationList creates a new X.509 v2 [Certificate] Revocation List, according to RFC 5280, based on template. The CRL is signed by priv which should be a crypto.Signer or crypto.MessageSigner associated with the public key in the issuer certificate. The issuer may not be nil, and the crlSign bit must be set in [KeyUsage] in order to use it as a CRL issuer. The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecryptPEMBlock",
				Description: "DecryptPEMBlock takes a PEM block encrypted according to RFC 1423 and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an [IncorrectPasswordError] is returned. Because of deficiencies in the format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise. Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncryptPEMBlock",
				Description: "EncryptPEMBlock returns a PEM block of the specified type holding the given DER encoded data encrypted with the specified algorithm and password according to RFC 1423. Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Block",
						TypePkgName: "pem",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsEncryptedPEMBlock",
				Description: "IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to RFC 1423. Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalECPrivateKey",
				Description: "MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\". For a more flexible key format which is not EC specific, use [MarshalPKCS8PrivateKey]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalPKCS1PrivateKey",
				Description: "MarshalPKCS1PrivateKey converts an [RSA] private key to PKCS #1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\". For a more flexible key format which is not [RSA] specific, use [MarshalPKCS8PrivateKey]. The key must have passed validation by calling [rsa.PrivateKey.Validate] first. MarshalPKCS1PrivateKey calls [rsa.PrivateKey.Precompute], which may modify the key if not already precomputed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalPKCS1PublicKey",
				Description: "MarshalPKCS1PublicKey converts an [RSA] public key to PKCS #1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalPKCS8PrivateKey",
				Description: "MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form. The following key types are currently supported: *[rsa.PrivateKey], *[ecdsa.PrivateKey], [ed25519.PrivateKey] (not a pointer), and *[ecdh.PrivateKey]. Unsupported key types result in an error. This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\". MarshalPKCS8PrivateKey runs [rsa.PrivateKey.Precompute] on RSA keys. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MarshalPKIXPublicKey",
				Description: "MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1). The following key types are currently supported: *[rsa.PublicKey], *[ecdsa.PublicKey], [ed25519.PublicKey] (not a pointer), and *[ecdh.PublicKey]. Unsupported key types result in an error. This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewCertPool",
				Description: "NewCertPool returns a new, empty CertPool. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertPool",
						TypePkgName: "x509",
					},
				},
			},
			funcSet{
				Name:        "OIDFromInts",
				Description: "OIDFromInts creates a new OID using ints, each integer is a separate component. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "OID",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCRL",
				Description: "ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage. Deprecated: Use [ParseRevocationList] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertificateList",
						TypePkgName: "pkix",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCertificate",
				Description: "ParseCertificate parses a single certificate from the given ASN.1 DER data. Before Go 1.23, ParseCertificate accepted certificates with negative serial numbers. This behavior can be restored by including \"x509negativeserial=1\" in the GODEBUG environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCertificateRequest",
				Description: "ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertificateRequest",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseCertificates",
				Description: "ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*crypto/x509.Certificate",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseDERCRL",
				Description: "ParseDERCRL parses a DER encoded CRL from the given bytes. Deprecated: Use [ParseRevocationList] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertificateList",
						TypePkgName: "pkix",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseECPrivateKey",
				Description: "ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseOID",
				Description: "ParseOID parses a Object Identifier string, represented by ASCII numbers separated by dots. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "OID",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParsePKCS1PrivateKey",
				Description: "ParsePKCS1PrivateKey parses an [RSA] private key in PKCS #1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\". Before Go 1.24, the CRT parameters were ignored and recomputed. To restore the old behavior, use the GODEBUG=x509rsacrt=0 environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParsePKCS1PublicKey",
				Description: "ParsePKCS1PublicKey parses an [RSA] public key in PKCS #1, ASN.1 DER form. This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParsePKCS8PrivateKey",
				Description: "ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form. It returns a *[rsa.PrivateKey], an *[ecdsa.PrivateKey], an [ed25519.PrivateKey] (not a pointer), or an *[ecdh.PrivateKey] (for X25519). More types might be supported in the future. This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\". Before Go 1.24, the CRT parameters of RSA keys were ignored and recomputed. To restore the old behavior, use the GODEBUG=x509rsacrt=0 environment variable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParsePKIXPublicKey",
				Description: "ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1). It returns a *[rsa.PublicKey], *[dsa.PublicKey], *[ecdsa.PublicKey], [ed25519.PublicKey] (not a pointer), or *[ecdh.PublicKey] (for X25519). More types might be supported in the future. This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseRevocationList",
				Description: "ParseRevocationList parses a X509 v2 [Certificate] Revocation List from the given ASN.1 DER data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RevocationList",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetFallbackRoots",
				Description: "SetFallbackRoots sets the roots to use during certificate verification, if no custom roots are specified and a platform verifier or a system certificate pool is not available (for instance in a container which does not have a root certificate bundle). SetFallbackRoots will panic if roots is nil. SetFallbackRoots may only be called once, if called multiple times it will panic. The fallback behavior can be forced on all platforms, even when there is a system certificate pool, by setting GODEBUG=x509usefallbackroots=1 (note that on Windows and macOS this will disable usage of the platform verification APIs and cause the pure Go verifier to be used). Setting x509usefallbackroots=1 without calling SetFallbackRoots has no effect. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SystemCertPool",
				Description: "SystemCertPool returns a copy of the system cert pool. On Unix systems other than macOS the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. The latter can be a colon-separated list. Any mutations to the returned pool are not written to disk and do not affect any other pool returned by SystemCertPool. New changes in the system cert pool might not be reflected in subsequent calls. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertPool",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"regexp": []funcSet{
			funcSet{
				Name:        "Compile",
				Description: "Compile parses a regular expression and returns, if successful, a [Regexp] object that can be used to match against text. When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see [CompilePOSIX]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CompilePOSIX",
				Description: "CompilePOSIX is like [Compile] but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies. However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See https://swtch.com/~rsc/regexp/regexp2.html#posix for details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Match",
				Description: "Match reports whether the byte slice b contains any match of the regular expression re. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MatchReader",
				Description: "MatchReader reports whether the text returned by the [io.RuneReader] contains any match of the regular expression re. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MatchString",
				Description: "MatchString reports whether the string s contains any match of the regular expression re. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MustCompile",
				Description: "MustCompile is like [Compile] but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
				},
			},
			funcSet{
				Name:        "MustCompilePOSIX",
				Description: "MustCompilePOSIX is like [CompilePOSIX] but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
				},
			},
			funcSet{
				Name:        "QuoteMeta",
				Description: "QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"parse": []funcSet{
			funcSet{
				Name:        "IsEmptyTree",
				Description: "IsEmptyTree reports whether this tree (node) is empty of everything but space or comments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New allocates a new parse tree with the given name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			funcSet{
				Name:        "NewIdentifier",
				Description: "NewIdentifier returns a new [IdentifierNode] with the given identifier name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IdentifierNode",
						TypePkgName: "parse",
					},
				},
			},
			funcSet{
				Name:        "Parse",
				Description: "Parse returns a map from template name to [Tree], created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[string]*text/template/parse.Tree",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"rtcov": []funcSet{
			funcSet{
				Name:        "AddMeta",
				Description: "AddMeta is invoked during package \"init\" functions by the compiler when compiling for coverage instrumentation; here 'p' is a meta-data blob of length 'dlen' for the package in question, 'hash' is a compiler-computed md5.sum for the blob, 'pkpath' is the package path, 'pkid' is the hard-coded ID that the compiler is using for the package (or -1 if the compiler doesn't think a hard-coded ID is needed), and 'cmode'/'cgran' are the coverage counter mode and granularity requested by the user. Return value is the ID for the package for use by the package code itself, or 0 for impossible errors. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
		},
		"maps": []funcSet{
			funcSet{
				Name:        "NewEmptyMap",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "maps",
					},
				},
			},
			funcSet{
				Name:        "NewMap",
				Description: "If m is non-nil, it should be used rather than allocating. maxAlloc should be runtime.maxAlloc. TODO(prattmic): Put maxAlloc somewhere accessible. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "maps",
					},
				},
			},
			funcSet{
				Name:        "OldMapKeyError",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "All",
				Description: "All returns an iterator over key-value pairs from m. The iteration order is not specified and is not guaranteed to be the same from one call to the next. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq2",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Clone",
				Description: "Clone returns a copy of m. This is a shallow clone: the new keys and values are set using ordinary assignment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "M",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Collect",
				Description: "Collect collects key-value pairs from seq into a new map and returns it. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[K]V",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Copy",
				Description: "Copy copies all key/value pairs in src adding them to dst. When a key in src is already present in dst, the value in dst will be overwritten by the value associated with the key in src. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "DeleteFunc",
				Description: "DeleteFunc deletes any key/value pairs from m for which del returns true. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Equal",
				Description: "Equal reports whether two maps contain the same key/value pairs. Values are compared using ==. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EqualFunc",
				Description: "EqualFunc is like Equal, but compares values using eq. Keys are still compared with ==. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Insert",
				Description: "Insert adds the key-value pairs from seq to m. If a key in seq already exists in m, its value will be overwritten. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Keys",
				Description: "Keys returns an iterator over keys in m. The iteration order is not specified and is not guaranteed to be the same from one call to the next. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "Values",
				Description: "Values returns an iterator over values in m. The iteration order is not specified and is not guaranteed to be the same from one call to the next. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
		},
		"errors": []funcSet{
			funcSet{
				Name:        "As",
				Description: "As finds the first error in err's tree that matches target, and if one is found, sets target to that error value and returns true. Otherwise, it returns false. The tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() []error method. When err wraps multiple errors, As examines err followed by a depth-first traversal of its children. An error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(any) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target. An error type might provide an As method so it can be treated as if it were a different error type. As panics if target is not a non-nil pointer to either a type that implements error, or to any interface type. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Is",
				Description: "Is reports whether any error in err's tree matches target. The tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() []error method. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children. An error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true. An error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines func (m MyError) Is(target error) bool { return target == fs.ErrExist } then Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is] for an example in the standard library. An Is method should only shallowly compare err and the target and not call [Unwrap] on either. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Join",
				Description: "Join returns an error that wraps the given errors. Any nil error values are discarded. Join returns nil if every value in errs is nil. The error formats as the concatenation of the strings obtained by calling the Error method of each element of errs, with a newline between each string. A non-nil error returned by Join implements the Unwrap() []error method. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Unwrap",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"adler32": []funcSet{
			funcSet{
				Name:        "Checksum",
				Description: "Checksum returns the Adler-32 checksum of data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash32",
						TypePkgName: "hash",
					},
				},
			},
		},
		"weak": []funcSet{
			funcSet{
				Name:        "Make",
				Description: "Make creates a weak pointer from a pointer to some value of type T. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pointer",
						TypePkgName: "weak",
					},
				},
			},
		},
		"png": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode reads a PNG image from r and returns it as an [image.Image]. The type of Image returned depends on the PNG contents. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeConfig",
				Description: "DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Config",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not [image.NRGBA] might be encoded lossily. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cipher": []funcSet{
			funcSet{
				Name:        "NewCBCDecrypter",
				Description: "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BlockMode",
						TypePkgName: "cipher",
					},
				},
			},
			funcSet{
				Name:        "NewCBCEncrypter",
				Description: "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BlockMode",
						TypePkgName: "cipher",
					},
				},
			},
			funcSet{
				Name:        "NewCFBDecrypter",
				Description: "NewCFBDecrypter returns a [Stream] which decrypts with cipher feedback mode, using the given [Block]. The iv must be the same length as the [Block]'s block size. Deprecated: CFB mode is not authenticated, which generally enables active attacks to manipulate and recover the plaintext. It is recommended that applications use [AEAD] modes instead. The standard library implementation of CFB is also unoptimized and not validated as part of the FIPS 140-3 module. If an unauthenticated [Stream] mode is required, use [NewCTR] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stream",
						TypePkgName: "cipher",
					},
				},
			},
			funcSet{
				Name:        "NewCFBEncrypter",
				Description: "NewCFBEncrypter returns a [Stream] which encrypts with cipher feedback mode, using the given [Block]. The iv must be the same length as the [Block]'s block size. Deprecated: CFB mode is not authenticated, which generally enables active attacks to manipulate and recover the plaintext. It is recommended that applications use [AEAD] modes instead. The standard library implementation of CFB is also unoptimized and not validated as part of the FIPS 140-3 module. If an unauthenticated [Stream] mode is required, use [NewCTR] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stream",
						TypePkgName: "cipher",
					},
				},
			},
			funcSet{
				Name:        "NewCTR",
				Description: "NewCTR returns a [Stream] which encrypts/decrypts using the given [Block] in counter mode. The length of iv must be the same as the [Block]'s block size. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stream",
						TypePkgName: "cipher",
					},
				},
			},
			funcSet{
				Name:        "NewGCM",
				Description: "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length. In general, the GHASH operation performed by this implementation of GCM is not constant-time. An exception is when the underlying [Block] was created by aes.NewCipher on systems with hardware support for AES. See the [crypto/aes] package documentation for details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMWithNonceSize",
				Description: "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length. The length must not be zero. Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use [NewGCM], which is faster and more resistant to misuse. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMWithRandomNonce",
				Description: "NewGCMWithRandomNonce returns the given cipher wrapped in Galois Counter Mode, with randomly-generated nonces. The cipher must have been created by [crypto/aes.NewCipher]. It generates a random 96-bit nonce, which is prepended to the ciphertext by Seal, and is extracted from the ciphertext by Open. The NonceSize of the AEAD is zero, while the Overhead is 28 bytes (the combination of nonce size and tag size). A given key MUST NOT be used to encrypt more than 2^32 messages, to limit the risk of a random nonce collision to negligible levels. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewGCMWithTagSize",
				Description: "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length. Tag sizes between 12 and 16 bytes are allowed. Only use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use [NewGCM], which is more resistant to misuse. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AEAD",
						TypePkgName: "cipher",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewOFB",
				Description: "NewOFB returns a [Stream] that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size. Deprecated: OFB mode is not authenticated, which generally enables active attacks to manipulate and recover the plaintext. It is recommended that applications use [AEAD] modes instead. The standard library implementation of OFB is also unoptimized and not validated as part of the FIPS 140-3 module. If an unauthenticated [Stream] mode is required, use [NewCTR] instead. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stream",
						TypePkgName: "cipher",
					},
				},
			},
		},
		"ascii": []funcSet{
			funcSet{
				Name:        "EqualFold",
				Description: "EqualFold is [strings.EqualFold], ASCII only. It reports whether s and t are equal, ASCII-case-insensitively. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Is",
				Description: "Is returns whether s is ASCII. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPrint",
				Description: "IsPrint returns whether s is ASCII and printable according to https://tools.ietf.org/html/rfc20#section-4.2. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToLower",
				Description: "ToLower returns the lowercase version of s if s is ASCII and printable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"diff": []funcSet{
			funcSet{
				Name:        "Diff",
				Description: "Diff returns an anchored diff of the two texts old and new in the âunified diffâ format. If old and new are identical, Diff returns a nil slice (no output). Unix diff implementations typically look for a diff with the smallest number of lines inserted and removed, which can in the worst case take time quadratic in the number of lines in the texts. As a result, many implementations either can be made to run for a long time or cut off the search after a predetermined amount of work. In contrast, this implementation looks for a diff with the smallest number of âuniqueâ lines inserted and removed, where unique means a line that appears just once in both old and new. We call this an âanchored diffâ because the unique lines anchor the chosen matching regions. An anchored diff is usually clearer than a standard diff, because the algorithm does not try to reuse unrelated blank lines or closing braces. The algorithm also guarantees to run in O(n log n) time instead of the standard O(nÂ²) time. Some systems call this approach a âpatience diff,â named for the âpatience sortingâ algorithm, itself named for a solitaire card game. We avoid that name for two reasons. First, the name has been used for a few different variants of the algorithm, so it is imprecise. Second, the name is frequently interpreted as meaning that you have to wait longer (to be patient) for the diff, meaning that it is a slower algorithm, when in fact the algorithm is faster than the standard one. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"math": []funcSet{
			funcSet{
				Name:        "Add64",
				Description: "Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1. This function's execution time does not depend on the inputs. On supported platforms this is an intrinsic lowered by the compiler. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mul64",
				Description: "Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo. This is a copy from math/bits.Mul64 On supported platforms this is an intrinsic lowered by the compiler. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MulUintptr",
				Description: "MulUintptr returns a * b and whether the multiplication overflowed. On supported platforms this is an intrinsic lowered by the compiler. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Abs",
				Description: "Abs returns the absolute value of x. Special cases are: Abs(Â±Inf) = +Inf Abs(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Acos",
				Description: "Acos returns the arccosine, in radians, of x. Special case is: Acos(x) = NaN if x < -1 or x > 1 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Acosh",
				Description: "Acosh returns the inverse hyperbolic cosine of x. Special cases are: Acosh(+Inf) = +Inf Acosh(x) = NaN if x < 1 Acosh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Asin",
				Description: "Asin returns the arcsine, in radians, of x. Special cases are: Asin(Â±0) = Â±0 Asin(x) = NaN if x < -1 or x > 1 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Asinh",
				Description: "Asinh returns the inverse hyperbolic sine of x. Special cases are: Asinh(Â±0) = Â±0 Asinh(Â±Inf) = Â±Inf Asinh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atan",
				Description: "Atan returns the arctangent, in radians, of x. Special cases are: Atan(Â±0) = Â±0 Atan(Â±Inf) = Â±Pi/2 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atan2",
				Description: "Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value. Special cases are (in order): Atan2(y, NaN) = NaN Atan2(NaN, x) = NaN Atan2(+0, x>=0) = +0 Atan2(-0, x>=0) = -0 Atan2(+0, x<=-0) = +Pi Atan2(-0, x<=-0) = -Pi Atan2(y>0, 0) = +Pi/2 Atan2(y<0, 0) = -Pi/2 Atan2(+Inf, +Inf) = +Pi/4 Atan2(-Inf, +Inf) = -Pi/4 Atan2(+Inf, -Inf) = 3Pi/4 Atan2(-Inf, -Inf) = -3Pi/4 Atan2(y, +Inf) = 0 Atan2(y>0, -Inf) = +Pi Atan2(y<0, -Inf) = -Pi Atan2(+Inf, x) = +Pi/2 Atan2(-Inf, x) = -Pi/2 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Atanh",
				Description: "Atanh returns the inverse hyperbolic tangent of x. Special cases are: Atanh(1) = +Inf Atanh(Â±0) = Â±0 Atanh(-1) = -Inf Atanh(x) = NaN if x < -1 or x > 1 Atanh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cbrt",
				Description: "Cbrt returns the cube root of x. Special cases are: Cbrt(Â±0) = Â±0 Cbrt(Â±Inf) = Â±Inf Cbrt(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ceil",
				Description: "Ceil returns the least integer value greater than or equal to x. Special cases are: Ceil(Â±0) = Â±0 Ceil(Â±Inf) = Â±Inf Ceil(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Copysign",
				Description: "Copysign returns a value with the magnitude of f and the sign of sign. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cos",
				Description: "Cos returns the cosine of the radian argument x. Special cases are: Cos(Â±Inf) = NaN Cos(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cosh",
				Description: "Cosh returns the hyperbolic cosine of x. Special cases are: Cosh(Â±0) = 1 Cosh(Â±Inf) = +Inf Cosh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dim",
				Description: "Dim returns the maximum of x-y or 0. Special cases are: Dim(+Inf, +Inf) = NaN Dim(-Inf, -Inf) = NaN Dim(x, NaN) = Dim(NaN, x) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Erf",
				Description: "Erf returns the error function of x. Special cases are: Erf(+Inf) = 1 Erf(-Inf) = -1 Erf(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Erfc",
				Description: "Erfc returns the complementary error function of x. Special cases are: Erfc(+Inf) = 0 Erfc(-Inf) = 2 Erfc(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Erfcinv",
				Description: "Erfcinv returns the inverse of [Erfc](x). Special cases are: Erfcinv(0) = +Inf Erfcinv(2) = -Inf Erfcinv(x) = NaN if x < 0 or x > 2 Erfcinv(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Erfinv",
				Description: "Erfinv returns the inverse error function of x. Special cases are: Erfinv(1) = +Inf Erfinv(-1) = -Inf Erfinv(x) = NaN if x < -1 or x > 1 Erfinv(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exp",
				Description: "Exp returns e**x, the base-e exponential of x. Special cases are: Exp(+Inf) = +Inf Exp(NaN) = NaN Very large values overflow to 0 or +Inf. Very small values underflow to 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Exp2",
				Description: "Exp2 returns 2**x, the base-2 exponential of x. Special cases are the same as [Exp]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Expm1",
				Description: "Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than [Exp](x) - 1 when x is near zero. Special cases are: Expm1(+Inf) = +Inf Expm1(-Inf) = -1 Expm1(NaN) = NaN Very large values overflow to -1 or +Inf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FMA",
				Description: "FMA returns x * y + z, computed with only one rounding. (That is, FMA returns the fused multiply-add of x, y, and z.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float32bits",
				Description: "Float32bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position. Float32bits(Float32frombits(x)) == x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float32frombits",
				Description: "Float32frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float32frombits(Float32bits(x)) == x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64bits",
				Description: "Float64bits returns the IEEE 754 binary representation of f, with the sign bit of f and the result in the same bit position, and Float64bits(Float64frombits(x)) == x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64frombits",
				Description: "Float64frombits returns the floating-point number corresponding to the IEEE 754 binary representation b, with the sign bit of b and the result in the same bit position. Float64frombits(Float64bits(x)) == x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Floor",
				Description: "Floor returns the greatest integer value less than or equal to x. Special cases are: Floor(Â±0) = Â±0 Floor(Â±Inf) = Â±Inf Floor(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Frexp",
				Description: "Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac Ã 2**exp, with the absolute value of frac in the interval [Â½, 1). Special cases are: Frexp(Â±0) = Â±0, 0 Frexp(Â±Inf) = Â±Inf, 0 Frexp(NaN) = NaN, 0 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Gamma",
				Description: "Gamma returns the Gamma function of x. Special cases are: Gamma(+Inf) = +Inf Gamma(+0) = +Inf Gamma(-0) = -Inf Gamma(x) = NaN for integer x < 0 Gamma(-Inf) = NaN Gamma(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Hypot",
				Description: "Hypot returns [Sqrt](p*p + q*q), taking care to avoid unnecessary overflow and underflow. Special cases are: Hypot(Â±Inf, q) = +Inf Hypot(p, Â±Inf) = +Inf Hypot(NaN, q) = NaN Hypot(p, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ilogb",
				Description: "Ilogb returns the binary exponent of x as an integer. Special cases are: Ilogb(Â±Inf) = MaxInt32 Ilogb(0) = MinInt32 Ilogb(NaN) = MaxInt32 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Inf",
				Description: "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsInf",
				Description: "IsInf reports whether f is an infinity, according to sign. If sign > 0, IsInf reports whether f is positive infinity. If sign < 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsNaN",
				Description: "IsNaN reports whether f is an IEEE 754 ânot-a-numberâ value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "J0",
				Description: "J0 returns the order-zero Bessel function of the first kind. Special cases are: J0(Â±Inf) = 0 J0(0) = 1 J0(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "J1",
				Description: "J1 returns the order-one Bessel function of the first kind. Special cases are: J1(Â±Inf) = 0 J1(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Jn",
				Description: "Jn returns the order-n Bessel function of the first kind. Special cases are: Jn(n, Â±Inf) = 0 Jn(n, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ldexp",
				Description: "Ldexp is the inverse of [Frexp]. It returns frac Ã 2**exp. Special cases are: Ldexp(Â±0, exp) = Â±0 Ldexp(Â±Inf, exp) = Â±Inf Ldexp(NaN, exp) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lgamma",
				Description: "Lgamma returns the natural logarithm and sign (-1 or +1) of [Gamma](x). Special cases are: Lgamma(+Inf) = +Inf Lgamma(0) = +Inf Lgamma(-integer) = +Inf Lgamma(-Inf) = -Inf Lgamma(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log",
				Description: "Log returns the natural logarithm of x. Special cases are: Log(+Inf) = +Inf Log(0) = -Inf Log(x < 0) = NaN Log(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log10",
				Description: "Log10 returns the decimal logarithm of x. The special cases are the same as for [Log]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log1p",
				Description: "Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than [Log](1 + x) when x is near zero. Special cases are: Log1p(+Inf) = +Inf Log1p(Â±0) = Â±0 Log1p(-1) = -Inf Log1p(x < -1) = NaN Log1p(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Log2",
				Description: "Log2 returns the binary logarithm of x. The special cases are the same as for [Log]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Logb",
				Description: "Logb returns the binary exponent of x. Special cases are: Logb(Â±Inf) = +Inf Logb(0) = -Inf Logb(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Max",
				Description: "Max returns the larger of x or y. Special cases are: Max(x, +Inf) = Max(+Inf, x) = +Inf Max(x, NaN) = Max(NaN, x) = NaN Max(+0, Â±0) = Max(Â±0, +0) = +0 Max(-0, -0) = -0 Note that this differs from the built-in function max when called with NaN and +Inf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Min",
				Description: "Min returns the smaller of x or y. Special cases are: Min(x, -Inf) = Min(-Inf, x) = -Inf Min(x, NaN) = Min(NaN, x) = NaN Min(-0, Â±0) = Min(Â±0, -0) = -0 Note that this differs from the built-in function min when called with NaN and -Inf. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Mod",
				Description: "Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x. Special cases are: Mod(Â±Inf, y) = NaN Mod(NaN, y) = NaN Mod(x, 0) = NaN Mod(x, Â±Inf) = x Mod(x, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Modf",
				Description: "Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f. Special cases are: Modf(Â±Inf) = Â±Inf, NaN Modf(NaN) = NaN, NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NaN",
				Description: "NaN returns an IEEE 754 ânot-a-numberâ value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Nextafter",
				Description: "Nextafter returns the next representable float64 value after x towards y. Special cases are: Nextafter(x, x) = x Nextafter(NaN, y) = NaN Nextafter(x, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Nextafter32",
				Description: "Nextafter32 returns the next representable float32 value after x towards y. Special cases are: Nextafter32(x, x) = x Nextafter32(NaN, y) = NaN Nextafter32(x, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pow",
				Description: "Pow returns x**y, the base-x exponential of y. Special cases are (in order): Pow(x, Â±0) = 1 for any x Pow(1, y) = 1 for any y Pow(x, 1) = x for any x Pow(NaN, y) = NaN Pow(x, NaN) = NaN Pow(Â±0, y) = Â±Inf for y an odd integer < 0 Pow(Â±0, -Inf) = +Inf Pow(Â±0, +Inf) = +0 Pow(Â±0, y) = +Inf for finite y < 0 and not an odd integer Pow(Â±0, y) = Â±0 for y an odd integer > 0 Pow(Â±0, y) = +0 for finite y > 0 and not an odd integer Pow(-1, Â±Inf) = 1 Pow(x, +Inf) = +Inf for |x| > 1 Pow(x, -Inf) = +0 for |x| > 1 Pow(x, +Inf) = +0 for |x| < 1 Pow(x, -Inf) = +Inf for |x| < 1 Pow(+Inf, y) = +Inf for y > 0 Pow(+Inf, y) = +0 for y < 0 Pow(-Inf, y) = Pow(-0, -y) Pow(x, y) = NaN for finite x < 0 and finite non-integer y ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Pow10",
				Description: "Pow10 returns 10**n, the base-10 exponential of n. Special cases are: Pow10(n) = 0 for n < -323 Pow10(n) = +Inf for n > 308 ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Remainder",
				Description: "Remainder returns the IEEE 754 floating-point remainder of x/y. Special cases are: Remainder(Â±Inf, y) = NaN Remainder(NaN, y) = NaN Remainder(x, 0) = NaN Remainder(x, Â±Inf) = x Remainder(x, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Round",
				Description: "Round returns the nearest integer, rounding half away from zero. Special cases are: Round(Â±0) = Â±0 Round(Â±Inf) = Â±Inf Round(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RoundToEven",
				Description: "RoundToEven returns the nearest integer, rounding ties to even. Special cases are: RoundToEven(Â±0) = Â±0 RoundToEven(Â±Inf) = Â±Inf RoundToEven(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Signbit",
				Description: "Signbit reports whether x is negative or negative zero. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sin",
				Description: "Sin returns the sine of the radian argument x. Special cases are: Sin(Â±0) = Â±0 Sin(Â±Inf) = NaN Sin(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sincos",
				Description: "Sincos returns Sin(x), Cos(x). Special cases are: Sincos(Â±0) = Â±0, 1 Sincos(Â±Inf) = NaN, NaN Sincos(NaN) = NaN, NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sinh",
				Description: "Sinh returns the hyperbolic sine of x. Special cases are: Sinh(Â±0) = Â±0 Sinh(Â±Inf) = Â±Inf Sinh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sqrt",
				Description: "Sqrt returns the square root of x. Special cases are: Sqrt(+Inf) = +Inf Sqrt(Â±0) = Â±0 Sqrt(x < 0) = NaN Sqrt(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Tan",
				Description: "Tan returns the tangent of the radian argument x. Special cases are: Tan(Â±0) = Â±0 Tan(Â±Inf) = NaN Tan(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Tanh",
				Description: "Tanh returns the hyperbolic tangent of x. Special cases are: Tanh(Â±0) = Â±0 Tanh(Â±Inf) = Â±1 Tanh(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Trunc",
				Description: "Trunc returns the integer value of x. Special cases are: Trunc(Â±0) = Â±0 Trunc(Â±Inf) = Â±Inf Trunc(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Y0",
				Description: "Y0 returns the order-zero Bessel function of the second kind. Special cases are: Y0(+Inf) = 0 Y0(0) = -Inf Y0(x < 0) = NaN Y0(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Y1",
				Description: "Y1 returns the order-one Bessel function of the second kind. Special cases are: Y1(+Inf) = 0 Y1(0) = -Inf Y1(x < 0) = NaN Y1(NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Yn",
				Description: "Yn returns the order-n Bessel function of the second kind. Special cases are: Yn(n, +Inf) = 0 Yn(n â¥ 0, 0) = -Inf Yn(n < 0, 0) = +Inf if n is odd, -Inf if n is even Yn(n, x < 0) = NaN Yn(n, NaN) = NaN ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
		},
		"sha512": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New returns a new Digest computing the SHA-512 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha512",
					},
				},
			},
			funcSet{
				Name:        "New384",
				Description: "New384 returns a new Digest computing the SHA-384 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha512",
					},
				},
			},
			funcSet{
				Name:        "New512_224",
				Description: "New512_224 returns a new Digest computing the SHA-512/224 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha512",
					},
				},
			},
			funcSet{
				Name:        "New512_256",
				Description: "New512_256 returns a new Digest computing the SHA-512/256 hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha512",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New returns a new [hash.Hash] computing the SHA-512 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New384",
				Description: "New384 returns a new [hash.Hash] computing the SHA-384 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New512_224",
				Description: "New512_224 returns a new [hash.Hash] computing the SHA-512/224 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "New512_256",
				Description: "New512_256 returns a new [hash.Hash] computing the SHA-512/256 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			funcSet{
				Name:        "Sum384",
				Description: "Sum384 returns the SHA384 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[48]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum512",
				Description: "Sum512 returns the SHA512 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[64]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum512_224",
				Description: "Sum512_224 returns the Sum512/224 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[28]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Sum512_256",
				Description: "Sum512_256 returns the Sum512/256 checksum of the data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"debug": []funcSet{
			funcSet{
				Name:        "FreeOSMemory",
				Description: "FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.) ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ParseBuildInfo",
				Description: "ParseBuildInfo parses the string returned by [*BuildInfo.String], restoring the original BuildInfo, except that the GoVersion field is not set. Programs should normally not call this function, but instead call [ReadBuildInfo], [debug/buildinfo.ReadFile], or [debug/buildinfo.Read]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BuildInfo",
						TypePkgName: "debug",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PrintStack",
				Description: "PrintStack prints to standard error the stack trace returned by runtime.Stack. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadBuildInfo",
				Description: "ReadBuildInfo returns the build information embedded in the running binary. The information is available only in binaries built with module support. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BuildInfo",
						TypePkgName: "debug",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadGCStats",
				Description: "ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SetCrashOutput",
				Description: "SetCrashOutput configures a single additional file where unhandled panics and other fatal errors are printed, in addition to standard error. There is only one additional file: calling SetCrashOutput again overrides any earlier call. SetCrashOutput duplicates f's file descriptor, so the caller may safely close f as soon as SetCrashOutput returns. To disable this additional crash output, call SetCrashOutput(nil). If called concurrently with a crash, some in-progress output may be written to the old file even after an overriding SetCrashOutput returns. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetGCPercent",
				Description: "SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. This setting may be effectively reduced in order to maintain a memory limit. A negative percentage effectively disables garbage collection, unless the memory limit is reached. See SetMemoryLimit for more details. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetMaxStack",
				Description: "SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems. There may be a system-imposed maximum stack limit regardless of the value provided to SetMaxStack. SetMaxStack is useful mainly for limiting the damage done by goroutines that enter an infinite recursion. It only limits future stack growth. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetMaxThreads",
				Description: "SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads. The limit controls the number of operating system threads, not the number of goroutines. A Go program creates a new thread only when a goroutine is ready to run but all the existing threads are blocked in system calls, cgo calls, or are locked to other goroutines due to use of runtime.LockOSThread. SetMaxThreads is useful mainly for limiting the damage done by programs that create an unbounded number of threads. The idea is to take down the program before it takes down the operating system. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetMemoryLimit",
				Description: "SetMemoryLimit provides the runtime with a soft memory limit. The runtime undertakes several processes to try to respect this memory limit, including adjustments to the frequency of garbage collections and returning memory to the underlying system more aggressively. This limit will be respected even if GOGC=off (or, if SetGCPercent(-1) is executed). The input limit is provided as bytes, and includes all memory mapped, managed, and not released by the Go runtime. Notably, it does not account for space used by the Go binary and memory external to Go, such as memory managed by the underlying system on behalf of the process, or memory managed by non-Go code inside the same process. Examples of excluded memory sources include: OS kernel memory held on behalf of the process, memory allocated by C code, and memory mapped by syscall.Mmap (because it is not managed by the Go runtime). More specifically, the following expression accurately reflects the value the runtime attempts to maintain as the limit: runtime.MemStats.Sys - runtime.MemStats.HeapReleased or in terms of the runtime/metrics package: /memory/classes/total:bytes - /memory/classes/heap/released:bytes A zero limit or a limit that's lower than the amount of memory used by the Go runtime may cause the garbage collector to run nearly continuously. However, the application may still make progress. The memory limit is always respected by the Go runtime, so to effectively disable this behavior, set the limit very high. [math.MaxInt64] is the canonical value for disabling the limit, but values much greater than the available memory on the underlying system work just as well. See https://go.dev/doc/gc-guide for a detailed guide explaining the soft memory limit in more detail, as well as a variety of common use-cases and scenarios. The initial setting is math.MaxInt64 unless the GOMEMLIMIT environment variable is set, in which case it provides the initial setting. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix. The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes represent quantities of bytes as defined by the IEC 80000-13 standard. That is, they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes, and so on. SetMemoryLimit returns the previously set memory limit. A negative input does not adjust the limit, and allows for retrieval of the currently set memory limit. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetPanicOnFault",
				Description: "SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. The runtime.Error that the runtime panics with may have an additional method: Addr() uintptr If that method exists, it returns the memory address which triggered the fault. The results of Addr are best-effort and the veracity of the result may depend on the platform. SetPanicOnFault applies only to the current goroutine. It returns the previous setting. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetTraceback",
				Description: "SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(\"all\") ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Stack",
				Description: "Stack returns a formatted stack trace of the goroutine that calls it. It calls [runtime.Stack] with a large enough buffer to capture the entire trace. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteHeapDump",
				Description: "WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor. WriteHeapDump suspends the execution of all goroutines until the heap dump is completely written. Thus, the file descriptor must not be connected to a pipe or socket whose other end is in the same Go process; instead, use a temporary file or network socket. The heap dump format is defined at https://golang.org/s/go15heapdump. ",
				Returns:     []returnSet{},
			},
		},
		"pe": []funcSet{
			funcSet{
				Name:        "NewFile",
				Description: "NewFile creates a new [File] for accessing a PE binary in an underlying reader. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "pe",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open opens the named file using [os.Open] and prepares it for use as a PE binary. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "pe",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"stringslite": []funcSet{
			funcSet{
				Name:        "Clone",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Cut",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutPrefix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutSuffix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasPrefix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasSuffix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Index",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IndexByte",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimPrefix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TrimSuffix",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"heap": []funcSet{
			funcSet{
				Name:        "Fix",
				Description: "Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling [Remove](h, i) followed by a Push of the new value. The complexity is O(log n) where n = h.Len(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Init",
				Description: "Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. The complexity is O(n) where n = h.Len(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Pop",
				Description: "Pop removes and returns the minimum element (according to Less) from the heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to [Remove](h, 0). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Push",
				Description: "Push pushes the element x onto the heap. The complexity is O(log n) where n = h.Len(). ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Remove",
				Description: "Remove removes and returns the element at index i from the heap. The complexity is O(log n) where n = h.Len(). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
		},
		"sysrand": []funcSet{
			funcSet{
				Name:        "Read",
				Description: "Read fills b with cryptographically secure random bytes from the operating system. It always fills b entirely and crashes the program irrecoverably if an error is encountered. The operating system APIs are documented to never return an error on all but legacy Linux systems. ",
				Returns:     []returnSet{},
			},
		},
		"utf16": []funcSet{
			funcSet{
				Name:        "AppendRune",
				Description: "AppendRune appends the UTF-16 encoding of the Unicode code point r to the end of p and returns the extended buffer. If the rune is not a valid Unicode code point, it appends the encoding of U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Decode",
				Description: "Decode returns the Unicode code point sequence represented by the UTF-16 encoding s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeRune",
				Description: "DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode returns the UTF-16 encoding of the Unicode code point sequence s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint16",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeRune",
				Description: "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsSurrogate",
				Description: "IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RuneLen",
				Description: "RuneLen returns the number of 16-bit words in the UTF-16 encoding of the rune. It returns -1 if the rune is not a valid value to encode in UTF-16. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"imageutil": []funcSet{
			funcSet{
				Name:        "DrawYCbCr",
				Description: "DrawYCbCr draws the YCbCr source image on the RGBA destination image with r.Min in dst aligned with sp in src. It reports whether the draw was successful. If it returns false, no dst pixels were changed. This function assumes that r is entirely within dst's bounds and the translation of r from dst coordinate space to src coordinate space is entirely within src's bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"httptest": []funcSet{
			funcSet{
				Name:        "NewRecorder",
				Description: "NewRecorder returns an initialized [ResponseRecorder]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ResponseRecorder",
						TypePkgName: "httptest",
					},
				},
			},
			funcSet{
				Name:        "NewRequest",
				Description: "NewRequest wraps NewRequestWithContext using context.Background. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewRequestWithContext",
				Description: "NewRequestWithContext returns a new incoming server Request, suitable for passing to an [http.Handler] for testing. The target is the RFC 7230 \"request-target\": it may be either a path or an absolute URL. If target is an absolute URL, the host name from the URL is used. Otherwise, \"example.com\" is used. The TLS field is set to a non-nil dummy value if target has scheme \"https\". The Request.Proto is always HTTP/1.1. An empty method means \"GET\". The provided body may be nil. If the body is of type [bytes.Reader], [strings.Reader], [bytes.Buffer], or the value [http.NoBody], the Request.ContentLength is set. NewRequest panics on error for ease of use in testing, where a panic is acceptable. To generate a client HTTP request instead of a server request, see the NewRequest function in the net/http package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
				},
			},
			funcSet{
				Name:        "NewServer",
				Description: "NewServer starts and returns a new [Server]. The caller should call Close when finished, to shut it down. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Server",
						TypePkgName: "httptest",
					},
				},
			},
			funcSet{
				Name:        "NewTLSServer",
				Description: "NewTLSServer starts and returns a new [Server] using TLS. The caller should call Close when finished, to shut it down. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Server",
						TypePkgName: "httptest",
					},
				},
			},
			funcSet{
				Name:        "NewUnstartedServer",
				Description: "NewUnstartedServer returns a new [Server] but doesn't start it. After changing its configuration, the caller should call Start or StartTLS. The caller should call Close when finished, to shut it down. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Server",
						TypePkgName: "httptest",
					},
				},
			},
		},
		"filepathlite": []funcSet{
			funcSet{
				Name:        "Base",
				Description: "Base is filepath.Base. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Clean",
				Description: "Clean is filepath.Clean. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Dir",
				Description: "Dir is filepath.Dir. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Ext",
				Description: "Ext is filepath.Ext. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FromSlash",
				Description: "FromSlash is filepath.FromSlash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsAbs",
				Description: "IsAbs reports whether the path is absolute. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsLocal",
				Description: "IsLocal is filepath.IsLocal. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsPathSeparator",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Localize",
				Description: "Localize is filepath.Localize. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Split",
				Description: "Split is filepath.Split. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToSlash",
				Description: "ToSlash is filepath.ToSlash. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VolumeName",
				Description: "VolumeName is filepath.VolumeName. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "VolumeNameLen",
				Description: "VolumeNameLen returns the length of the leading volume name on Windows. It returns 0 elsewhere. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"hpke": []funcSet{
			funcSet{
				Name:        "ParseHPKEPrivateKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseHPKEPublicKey",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetupRecipient",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Recipient",
						TypePkgName: "hpke",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SetupSender",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sender",
						TypePkgName: "hpke",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"ast": []funcSet{
			funcSet{
				Name:        "FileExports",
				Description: "FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The [File.Comments] list is not changed. FileExports reports whether there are exported declarations. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FilterDecl",
				Description: "FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. FilterDecl reports whether there are any declared names left after filtering. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FilterFile",
				Description: "FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The [File.Comments] list is not changed. FilterFile reports whether there are any top-level declarations left after filtering. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FilterPackage",
				Description: "FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. FilterPackage reports whether there are any top-level declarations left after filtering. Deprecated: use the type checker [go/types] instead of [Package]; see [Object]. Alternatively, use [FilterFile]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Fprint",
				Description: "Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets). A non-nil [FieldFilter] f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Inspect",
				Description: "Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil). In many cases it may be more convenient to use [Preorder], which returns an iterator over the sqeuence of nodes, or [PreorderStack], which (like [Inspect]) provides control over descent into subtrees, but additionally reports the stack of enclosing nodes. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "IsExported",
				Description: "IsExported reports whether name starts with an upper-case letter. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsGenerated",
				Description: "IsGenerated reports whether the file was generated by a program, not handwritten, by detecting the special comment described at https://go.dev/s/generatedcode. The syntax tree must have been parsed with the [parser.ParseComments] flag. Example: f, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly) if err != nil { ... } gen := ast.IsGenerated(f) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MergePackageFiles",
				Description: "MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior. Deprecated: this function is poorly specified and has unfixable bugs; also [Package] is deprecated. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "NewCommentMap",
				Description: "NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node. A comment group g is associated with a node n if: - g starts on the same line as n ends - g starts on the line immediately following n, and there is at least one empty line after g and before the next node - g starts before n and is not associated to the node before n via the previous rules NewCommentMap tries to associate a comment group to the \"largest\" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommentMap",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "NewIdent",
				Description: "NewIdent creates a new [Ident] without position. Useful for ASTs generated by code other than the Go parser. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ident",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "NewObj",
				Description: "NewObj creates a new object of a given kind and name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "NewPackage",
				Description: "NewPackage creates a new [Package] node from a set of [File] nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a [scanner.ErrorList] if there were errors. Deprecated: use the type checker [go/types] instead; see [Object]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewScope",
				Description: "NewScope creates a new scope nested in the outer scope. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scope",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "NotNilFilter",
				Description: "NotNilFilter is a [FieldFilter] that returns true for field values that are not nil; it returns false otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PackageExports",
				Description: "PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. PackageExports reports whether there are exported declarations; it returns false otherwise. Deprecated: use the type checker [go/types] instead of [Package]; see [Object]. Alternatively, use [FileExports]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Preorder",
				Description: "Preorder returns an iterator over all the nodes of the syntax tree beneath (and including) the specified root, in depth-first preorder. For greater control over the traversal of each subtree, use [Inspect] or [PreorderStack]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			funcSet{
				Name:        "PreorderStack",
				Description: "PreorderStack traverses the tree rooted at root, calling f before visiting each node. Each call to f provides the current node and traversal stack, consisting of the original value of stack appended with all nodes from root to n, excluding n itself. (This design allows calls to PreorderStack to be nested without double counting.) If f returns false, the traversal skips over that subtree. Unlike [Inspect], no second call to f is made after visiting node n. (In practice, the second call is nearly always used only to pop the stack, and it is surprisingly tricky to do this correctly.) ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Print",
				Description: "Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "SortImports",
				Description: "SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Unparen",
				Description: "Unparen returns the expression with any enclosing parentheses removed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "ast",
					},
				},
			},
			funcSet{
				Name:        "Walk",
				Description: "Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil). ",
				Returns:     []returnSet{},
			},
		},
		"exportdata": []funcSet{
			funcSet{
				Name:        "FindPackageDefinition",
				Description: "FindPackageDefinition positions the reader r at the beginning of a package definition file (\"__.PKGDEF\") within a GC-created archive by reading from it, and returns the size of the package definition file in the archive. The reader must be positioned at the start of the archive file before calling this function, and \"__.PKGDEF\" is assumed to be the first file in the archive. See cmd/internal/archive for details on the archive format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FindPkg",
				Description: "FindPkg returns the filename and unique package id for an import path based on package information provided by build.Import (using the build.Default build.Context). A relative srcDir is interpreted relative to the current working directory. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadExportDataHeader",
				Description: "ReadExportDataHeader reads the export data header and format from r. It returns the number of bytes read, or an error if the format is no longer supported or it failed to read. The only currently supported format is binary export data in the unified export format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadObjectHeaders",
				Description: "ReadObjectHeaders reads object headers from the reader. Object headers are lines that do not start with an end-of-section marker \"$$\". The first header is the objabi header. On success, the reader will be positioned at the beginning of the end-of-section marker. It returns an error if any header does not fit in r.Size() bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadUnified",
				Description: "ReadUnified reads the contents of the unified export data from a reader r that contains the contents of a GC-created archive file. On success, the reader will be positioned after the end-of-section marker \"\\n$$\\n\". Supported GC-created archive files have 4 layers of nesting: - An archive file containing a package definition file. - The package definition file contains headers followed by a data section. Headers are lines (â¤ 4kb) that do not start with \"$$\". - The data section starts with \"$$B\\n\" followed by export data followed by an end of section marker \"\\n$$\\n\". (The section start \"$$\\n\" is no longer supported.) - The export data starts with a format byte ('u') followed by the <data> in the given format. (See ReadExportDataHeader for older formats.) Putting this together, the bytes in a GC-created archive files are expected to look like the following. See cmd/internal/archive for more details on ar file headers. | <!arch>\\n | ar file signature | __.PKGDEF...size...\\n | ar header for __.PKGDEF including size. | go object <...>\\n | objabi header | <optional headers>\\n | other headers such as build id | $$B\\n | binary format marker | u<data>\\n | unified export <data> | $$\\n | end-of-section marker | [optional padding] | padding byte (0x0A) if size is odd | [ar file header] | other ar files | [ar file data] | ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"pkgbits": []funcSet{
			funcSet{
				Name:        "NewPkgDecoder",
				Description: "NewPkgDecoder returns a PkgDecoder initialized to read the Unified IR export data from input. pkgPath is the package path for the compilation unit that produced the export data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PkgDecoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			funcSet{
				Name:        "NewPkgEncoder",
				Description: "NewPkgEncoder returns an initialized PkgEncoder. syncFrames is the number of caller frames that should be serialized at Sync points. Serializing additional frames results in larger export data files, but can help diagnosing desync errors in higher-level Unified IR reader/writer code. If syncFrames is negative, then sync markers are omitted entirely. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PkgEncoder",
						TypePkgName: "pkgbits",
					},
				},
			},
		},
		"cformat": []funcSet{
			funcSet{
				Name:        "NewFormatter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Formatter",
						TypePkgName: "cformat",
					},
				},
			},
		},
		"testpty": []funcSet{
			funcSet{
				Name:        "Open",
				Description: "Open returns a control pty and the name of the linked process tty. If Open is not implemented on this platform, it returns ErrNotSupported. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"asan": []funcSet{
			funcSet{
				Name:        "Read",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Write",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"subtle": []funcSet{
			funcSet{
				Name:        "ConstantTimeByteEq",
				Description: "ConstantTimeByteEq returns 1 if x == y and 0 otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeCompare",
				Description: "ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeCopy",
				Description: "ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ConstantTimeEq",
				Description: "ConstantTimeEq returns 1 if x == y and 0 otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeLessOrEq",
				Description: "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise. Its behavior is undefined if x or y are negative or > 2**31 - 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeLessOrEqBytes",
				Description: "ConstantTimeLessOrEqBytes returns 1 if x <= y and 0 otherwise. The comparison is lexigraphical, or big-endian. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeSelect",
				Description: "ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "XORBytes",
				Description: "XORBytes sets dst[i] = x[i] ^ y[i] for all i < n = min(len(x), len(y)), returning n, the number of bytes written to dst. If dst does not have length at least n, XORBytes panics without writing anything to dst. dst and x or y may overlap exactly or not at all, otherwise XORBytes may panic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeByteEq",
				Description: "ConstantTimeByteEq returns 1 if x == y and 0 otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeCompare",
				Description: "ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeCopy",
				Description: "ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ConstantTimeEq",
				Description: "ConstantTimeEq returns 1 if x == y and 0 otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeLessOrEq",
				Description: "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise. Its behavior is undefined if x or y are negative or > 2**31 - 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ConstantTimeSelect",
				Description: "ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WithDataIndependentTiming",
				Description: "WithDataIndependentTiming enables architecture specific features which ensure that the timing of specific instructions is independent of their inputs before executing f. On f returning it disables these features. WithDataIndependentTiming should only be used when f is written to make use of constant-time operations. WithDataIndependentTiming does not make variable-time code constant-time. WithDataIndependentTiming may lock the current goroutine to the OS thread for the duration of f. Calls to WithDataIndependentTiming may be nested. On Arm64 processors with FEAT_DIT, WithDataIndependentTiming enables PSTATE.DIT. See https://developer.arm.com/documentation/ka005181/1-0/?lang=en. Currently, on all other architectures WithDataIndependentTiming executes f immediately with no other side-effects. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "XORBytes",
				Description: "XORBytes sets dst[i] = x[i] ^ y[i] for all i < n = min(len(x), len(y)), returning n, the number of bytes written to dst. If dst does not have length at least n, XORBytes panics without writing anything to dst. dst and x or y may overlap exactly or not at all, otherwise XORBytes may panic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"randutil": []funcSet{
			funcSet{
				Name:        "MaybeReadByte",
				Description: "MaybeReadByte reads a single byte from r with 50% probability. This is used to ensure that callers do not depend on non-guaranteed behaviour, e.g. assuming that rsa.GenerateKey is deterministic w.r.t. a given random stream. This does not affect tests that pass a stream of fixed bytes as the random source (e.g. a zeroReader). ",
				Returns:     []returnSet{},
			},
		},
		"macho": []funcSet{
			funcSet{
				Name:        "NewFatFile",
				Description: "NewFatFile creates a new [FatFile] for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FatFile",
						TypePkgName: "macho",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewFile",
				Description: "NewFile creates a new [File] for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "macho",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open returns a new ReadSeeker reading the segment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "macho",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenFat",
				Description: "OpenFat opens the named file using [os.Open] and prepares it for use as a Mach-O universal binary. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FatFile",
						TypePkgName: "macho",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sync": []funcSet{
			funcSet{
				Name:        "NewCond",
				Description: "NewCond returns a new Cond with Locker l. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cond",
						TypePkgName: "sync",
					},
				},
			},
			funcSet{
				Name:        "OnceFunc",
				Description: "OnceFunc returns a function that invokes f only once. The returned function may be called concurrently. If f panics, the returned function will panic with the same value on every call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func()",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnceValue",
				Description: "OnceValue returns a function that invokes f only once and returns the value returned by f. The returned function may be called concurrently. If f panics, the returned function will panic with the same value on every call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() T",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OnceValues",
				Description: "OnceValues returns a function that invokes f only once and returns the values returned by f. The returned function may be called concurrently. If f panics, the returned function will panic with the same value on every call. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() (T1, T2)",
						TypePkgName: "",
					},
				},
			},
		},
		"comment": []funcSet{
			funcSet{
				Name:        "DefaultLookupPackage",
				Description: "DefaultLookupPackage is the default package lookup function, used when [Parser.LookupPackage] is nil. It recognizes names of the packages from the standard library with single-element import paths, such as math, which would otherwise be impossible to name. Note that the go/doc package provides a more sophisticated lookup based on the imports used in the current package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"lazyregexp": []funcSet{
			funcSet{
				Name:        "New",
				Description: "New creates a new lazy regexp, delaying the compiling work until it is first needed. If the code is being run as part of tests, the regexp compiling will happen immediately. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "lazyregexp",
					},
				},
			},
		},
		"jpeg": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode reads a JPEG image from r and returns it as an [image.Image]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeConfig",
				Description: "DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Config",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *[Options] is passed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"iotest": []funcSet{
			funcSet{
				Name:        "DataErrReader",
				Description: "DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "ErrReader",
				Description: "ErrReader returns an [io.Reader] that returns 0, err from all Read calls. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "HalfReader",
				Description: "HalfReader returns a Reader that implements Read by reading half as many requested bytes from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewReadLogger",
				Description: "NewReadLogger returns a reader that behaves like r except that it logs (using [log.Printf]) each read to standard error, printing the prefix and the hexadecimal data read. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewWriteLogger",
				Description: "NewWriteLogger returns a writer that behaves like w except that it logs (using [log.Printf]) each write to standard error, printing the prefix and the hexadecimal data written. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "OneByteReader",
				Description: "OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "TestReader",
				Description: "TestReader tests that reading from r returns the expected file content. It does reads of different sizes, until EOF. If r implements [io.ReaderAt] or [io.Seeker], TestReader also checks that those operations behave as they should. If TestReader finds any misbehaviors, it returns an error reporting them. The error text may span multiple lines. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "TimeoutReader",
				Description: "TimeoutReader returns [ErrTimeout] on the second read with no data. Subsequent calls to read succeed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "TruncateWriter",
				Description: "TruncateWriter returns a Writer that writes to w but stops silently after n bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
		},
		"bisect": []funcSet{
			funcSet{
				Name:        "AppendMarker",
				Description: "AppendMarker is like [Marker] but appends the marker to dst. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CutMarker",
				Description: "CutMarker finds the first match marker in line and removes it, returning the shortened line (with the marker removed), the ID from the match marker, and whether a marker was found at all. If there is no marker, CutMarker returns line, 0, false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Hash",
				Description: "Hash computes a hash of the data arguments, each of which must be of type string, byte, int, uint, int32, uint32, int64, uint64, uintptr, or a slice of one of those types. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Marker",
				Description: "Marker returns the match marker text to use on any line reporting details about a match of the given ID. It always returns the hexadecimal format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New creates and returns a new Matcher implementing the given pattern. The pattern syntax is defined in the package doc comment. In addition to the pattern syntax syntax, New(\"\") returns nil, nil. The nil *Matcher is valid for use: it returns true from ShouldEnable and false from ShouldPrint for all changes. Callers can avoid calling [Hash], [Matcher.ShouldEnable], and [Matcher.ShouldPrint] entirely when they recognize the nil Matcher. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Matcher",
						TypePkgName: "bisect",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "PrintMarker",
				Description: "PrintMarker prints to w a one-line report containing only the marker for h. It is appropriate to use when [Matcher.ShouldPrint] and [Matcher.MarkerOnly] both return true. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"testenv": []funcSet{
			funcSet{
				Name:        "Builder",
				Description: "Builder reports the name of the builder running this test (for example, \"linux-amd64\" or \"windows-386-gce\"). If the test is not running on the build infrastructure, Builder returns the empty string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CPUIsSlow",
				Description: "CPUIsSlow reports whether the CPU running the test is suspected to be slow. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CPUProfilingBroken",
				Description: "CPUProfilingBroken returns true if CPU profiling has known issues on this platform. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CanInternalLink",
				Description: "CanInternalLink reports whether the current system can link programs with internal linking. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CleanCmdEnv",
				Description: "CleanCmdEnv will fill cmd.Env with the environment, excluding certain variables that could modify the behavior of the Go tools such as GODEBUG and GOTRACEBACK. If the caller wants to set cmd.Dir, set it before calling this function, so PWD will be set correctly in the environment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cmd",
						TypePkgName: "exec",
					},
				},
			},
			funcSet{
				Name:        "Command",
				Description: "Command is like exec.Command, but applies the same changes as testenv.CommandContext (with a default Context). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cmd",
						TypePkgName: "exec",
					},
				},
			},
			funcSet{
				Name:        "CommandContext",
				Description: "CommandContext is like exec.CommandContext, but: - skips t if the platform does not support os/exec, - sends SIGQUIT (if supported by the platform) instead of SIGKILL in its Cancel function - if the test has a deadline, adds a Context timeout and WaitDelay for an arbitrary grace period before the test's deadline expires, - fails the test if the command does not complete before the test's deadline, and - sets a Cleanup function that verifies that the test did not leak a subprocess. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cmd",
						TypePkgName: "exec",
					},
				},
			},
			funcSet{
				Name:        "Executable",
				Description: "Executable is a wrapper around [MustHaveExec] and [os.Executable]. It returns the path name for the executable that started the current process, or skips the test if the current system can't start new processes, or fails the test if the path can not be obtained. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GOROOT",
				Description: "GOROOT reports the path to the directory containing the root of the Go project source tree. This is normally equivalent to runtime.GOROOT, but works even if the test binary was built with -trimpath and cannot exec 'go env GOROOT'. If GOROOT cannot be found, GOROOT skips t if t is non-nil, or panics otherwise. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GoTool",
				Description: "GoTool reports the path to the Go tool. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "GoToolPath",
				Description: "GoToolPath reports the path to the Go tool. It is a convenience wrapper around GoTool. If the tool is unavailable GoToolPath calls t.Skip. If the tool should be available and isn't, GoToolPath calls t.Fatal. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasCGO",
				Description: "HasCGO reports whether the current system can use cgo. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasExternalNetwork",
				Description: "HasExternalNetwork reports whether the current system can use external (non-localhost) networks. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasGoBuild",
				Description: "HasGoBuild reports whether the current system can build programs with âgo buildâ and then run them with os.StartProcess or exec.Command. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasGoRun",
				Description: "HasGoRun reports whether the current system can run programs with âgo runâ. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasLink",
				Description: "HasLink reports whether the current system can use os.Link. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasParallelism",
				Description: "HasParallelism reports whether the current system can execute multiple threads in parallel. There is a copy of this function in cmd/dist/test.go. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HasSymlink",
				Description: "HasSymlink reports whether the current system can use os.Symlink. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MustHaveBuildMode",
				Description: "MustHaveBuildMode reports whether the current system can build programs in the given build mode. If not, MustHaveBuildMode calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveCGO",
				Description: "MustHaveCGO calls t.Skip if cgo is not available. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveExec",
				Description: "MustHaveExec checks that the current system can start new processes using os.StartProcess or (more commonly) exec.Command. If not, MustHaveExec calls t.Skip with an explanation. On some platforms MustHaveExec checks for exec support by re-executing the current executable, which must be a binary built by 'go test'. We intentionally do not provide a HasExec function because of the risk of inappropriate recursion in TestMain functions. To check for exec support outside of a test, just try to exec the command. If exec is not supported, testenv.SyscallIsNotSupported will return true for the resulting error. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveExecPath",
				Description: "MustHaveExecPath checks that the current system can start the named executable using os.StartProcess or (more commonly) exec.Command. If not, MustHaveExecPath calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveExternalNetwork",
				Description: "MustHaveExternalNetwork checks that the current system can use external (non-localhost) networks. If not, MustHaveExternalNetwork calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveGoBuild",
				Description: "MustHaveGoBuild checks that the current system can build programs with âgo buildâ and then run them with os.StartProcess or exec.Command. If not, MustHaveGoBuild calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveGoRun",
				Description: "MustHaveGoRun checks that the current system can run programs with âgo runâ. If not, MustHaveGoRun calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveLink",
				Description: "MustHaveLink reports whether the current system can use os.Link. If not, MustHaveLink calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveParallelism",
				Description: "MustHaveParallelism checks that the current system can execute multiple threads in parallel. If not, MustHaveParallelism calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveSource",
				Description: "MustHaveSource checks that the entire source tree is available under GOROOT. If not, it calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustHaveSymlink",
				Description: "MustHaveSymlink reports whether the current system can use os.Symlink. If not, MustHaveSymlink calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustInternalLink",
				Description: "MustInternalLink checks that the current system can link programs with internal linking. If not, MustInternalLink calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "MustInternalLinkPIE",
				Description: "MustInternalLinkPIE checks whether the current system can link PIE binary using internal linking. If not, MustInternalLinkPIE calls t.Skip with an explanation. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "OptimizationOff",
				Description: "OptimizationOff reports whether optimization is disabled. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParallelOn64Bit",
				Description: "ParallelOn64Bit calls t.Parallel() unless there is a case that cannot be parallel. This function should be used when it is necessary to avoid t.Parallel on 32-bit machines, typically because the test uses lots of memory. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SkipFlaky",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SkipFlakyNet",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SkipIfOptimizationOff",
				Description: "SkipIfOptimizationOff skips t if optimization is disabled. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SkipIfShortAndSlow",
				Description: "SkipIfShortAndSlow skips t if -short is set and the CPU running the test is suspected to be slow. (This is useful for CPU-intensive tests that otherwise complete quickly.) ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "SyscallIsNotSupported",
				Description: "SyscallIsNotSupported reports whether err may indicate that a system call is not supported by the current platform or execution environment. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteImportcfg",
				Description: "WriteImportcfg writes an importcfg file used by the compiler or linker to dstPath containing entries for the file mappings in packageFiles, as well as for the packages transitively imported by the package(s) in pkgs. pkgs may include any package pattern that is valid to pass to 'go list', so it may also be a list of Go source files all in the same directory. ",
				Returns:     []returnSet{},
			},
		},
		"testhash": []funcSet{
			funcSet{
				Name:        "TestHash",
				Description: "TestHash performs a set of tests on hash.Hash implementations, checking the documented requirements of Write, Sum, Reset, Size, and BlockSize. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestHashWithoutClone",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"httptrace": []funcSet{
			funcSet{
				Name:        "ContextClientTrace",
				Description: "ContextClientTrace returns the [ClientTrace] associated with the provided context. If none, it returns nil. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ClientTrace",
						TypePkgName: "httptrace",
					},
				},
			},
			funcSet{
				Name:        "WithClientTrace",
				Description: "WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
		},
		"parser": []funcSet{
			funcSet{
				Name:        "ParseDir",
				Description: "ParseDir calls [ParseFile] for all files with names ending in \".go\" in the directory specified by path and returns a map of package name -> package AST with all the packages found. If filter != nil, only the files with [fs.FileInfo] entries passing through the filter (and ending in \".go\") are considered. The mode bits are passed to [ParseFile] unchanged. Position information is recorded in fset, which must not be nil. If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned. Deprecated: ParseDir does not consider build tags when associating files with packages. For precise information about the relationship between packages and files, use golang.org/x/tools/go/packages, which can also optionally parse and type-check the files too. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[string]*go/ast.Package",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseExpr",
				Description: "ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string. If syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseExprFrom",
				Description: "ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for [ParseFile], but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil. If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseFile",
				Description: "ParseFile parses the source code of a single Go source file and returns the corresponding [ast.File] node. The source code may be provided via the filename of the source file, or via the src parameter. If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or [io.Reader]. If src == nil, ParseFile parses the file specified by filename. The mode parameter controls the amount of source text parsed and other optional parser functionality. If the [SkipObjectResolution] mode bit is set (recommended), the object resolution phase of parsing will be skipped, causing File.Scope, File.Unresolved, and all Ident.Obj fields to be nil. Those fields are deprecated; see [ast.Object] for details. Position information is recorded in the file set fset, which must not be nil. If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"version": []funcSet{
			funcSet{
				Name:        "Compare",
				Description: "Compare returns -1, 0, or +1 depending on whether x < y, x == y, or x > y, interpreted as Go versions. The versions x and y must begin with a \"go\" prefix: \"go1.21\" not \"1.21\". Invalid versions, including the empty string, compare less than valid versions and equal to each other. The language version \"go1.21\" compares less than the release candidate and eventual releases \"go1.21rc1\" and \"go1.21.0\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsValid",
				Description: "IsValid reports whether the version x is valid. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Lang",
				Description: "Lang returns the Go language version for version x. If x is not a valid version, Lang returns the empty string. For example: Lang(\"go1.21rc2\") = \"go1.21\" Lang(\"go1.21.2\") = \"go1.21\" Lang(\"go1.21\") = \"go1.21\" Lang(\"go1\") = \"go1\" Lang(\"bad\") = \"\" Lang(\"1.21\") = \"\" ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadHeader",
				Description: "ReadHeader reads the version of the trace out of the trace file's header, whose prefix must be present in v. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "version",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "WriteHeader",
				Description: "WriteHeader writes a header for a trace version v to w. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"raw": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "NewReader creates a new reader for the trace wire format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewTextReader",
				Description: "NewTextReader creates a new reader for the trace text format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TextReader",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewTextWriter",
				Description: "NewTextWriter creates a new write for the trace text format. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TextWriter",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewWriter",
				Description: "NewWriter creates a new byte format writer. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"drbg": []funcSet{
			funcSet{
				Name:        "NewCounter",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Counter",
						TypePkgName: "drbg",
					},
				},
			},
			funcSet{
				Name:        "Read",
				Description: "Read fills b with cryptographically secure random bytes. In FIPS mode, it uses an SP 800-90A Rev. 1 Deterministic Random Bit Generator (DRBG). Otherwise, it uses the operating system's random number generator. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "ReadWithReader",
				Description: "ReadWithReader uses Reader to fill b with cryptographically secure random bytes. It is intended for use in APIs that expose a rand io.Reader. If Reader is not the default Reader from crypto/rand, [randutil.MaybeReadByte] and [fips140.RecordNonApproved] are called. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ReadWithReaderDeterministic",
				Description: "ReadWithReaderDeterministic is like ReadWithReader, but it doesn't call [randutil.MaybeReadByte] on non-default Readers. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"edwards25519": []funcSet{
			funcSet{
				Name:        "NewGeneratorPoint",
				Description: "NewGeneratorPoint returns a new Point set to the canonical generator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			funcSet{
				Name:        "NewIdentityPoint",
				Description: "NewIdentityPoint returns a new Point set to the identity. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			funcSet{
				Name:        "NewScalar",
				Description: "NewScalar returns a new zero Scalar. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
		},
		"signal": []funcSet{
			funcSet{
				Name:        "Ignore",
				Description: "Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to [Notify] for the provided signals. If no signals are provided, all incoming signals will be ignored. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Ignored",
				Description: "Ignored reports whether sig is currently ignored. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Notify",
				Description: "Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will. Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient. It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call [Stop]. It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "NotifyContext",
				Description: "NotifyContext returns a copy of the parent context that is marked done (its Done channel is closed) when one of the listed signals arrives, when the returned stop function is called, or when the parent context's Done channel is closed, whichever happens first. The stop function unregisters the signal behavior, which, like [signal.Reset], may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving [os.Interrupt] is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called. The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
					returnSet{
						TypeName:    "CancelFunc",
						TypePkgName: "context",
					},
				},
			},
			funcSet{
				Name:        "Reset",
				Description: "Reset undoes the effect of any prior calls to [Notify] for the provided signals. If no signals are provided, all signal handlers will be reset. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Stop",
				Description: "Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to [Notify] using c. When Stop returns, it is guaranteed that c will receive no more signals. ",
				Returns:     []returnSet{},
			},
		},
		"image": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeConfig",
				Description: "DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Config",
						TypePkgName: "image",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewAlpha",
				Description: "NewAlpha returns a new [Alpha] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alpha",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewAlpha16",
				Description: "NewAlpha16 returns a new [Alpha16] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alpha16",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewCMYK",
				Description: "NewCMYK returns a new CMYK image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CMYK",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewGray",
				Description: "NewGray returns a new [Gray] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Gray",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewGray16",
				Description: "NewGray16 returns a new [Gray16] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Gray16",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewNRGBA",
				Description: "NewNRGBA returns a new [NRGBA] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NRGBA",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewNRGBA64",
				Description: "NewNRGBA64 returns a new [NRGBA64] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NRGBA64",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewNYCbCrA",
				Description: "NewNYCbCrA returns a new [NYCbCrA] image with the given bounds and subsample ratio. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NYCbCrA",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewPaletted",
				Description: "NewPaletted returns a new [Paletted] image with the given width, height and palette. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Paletted",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewRGBA",
				Description: "NewRGBA returns a new [RGBA] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewRGBA64",
				Description: "NewRGBA64 returns a new [RGBA64] image with the given bounds. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewUniform",
				Description: "NewUniform returns a new [Uniform] image of the given color. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Uniform",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "NewYCbCr",
				Description: "NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "YCbCr",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "Pt",
				Description: "Pt is shorthand for [Point]{X, Y}. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "Rect",
				Description: "Rect is shorthand for [Rectangle]{Pt(x0, y0), [Pt](x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			funcSet{
				Name:        "RegisterFormat",
				Description: "RegisterFormat registers an image format for use by [Decode]. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. [Decode] is the function that decodes the encoded image. [DecodeConfig] is the function that decodes just its configuration. ",
				Returns:     []returnSet{},
			},
		},
		"slicereader": []funcSet{
			funcSet{
				Name:        "NewReader",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "slicereader",
					},
				},
			},
		},
		"testtrace": []funcSet{
			funcSet{
				Name:        "ExpectSuccess",
				Description: "ExpectSuccess returns an Expectation that trivially expects success. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expectation",
						TypePkgName: "testtrace",
					},
				},
			},
			funcSet{
				Name:        "NewValidator",
				Description: "NewValidator creates a new Validator. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Validator",
						TypePkgName: "testtrace",
					},
				},
			},
			funcSet{
				Name:        "ParseExpectation",
				Description: "ParseExpectation parses the serialized form of an Expectation. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expectation",
						TypePkgName: "testtrace",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseFile",
				Description: "ParseFile parses a test file generated by the testgen package. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "Version",
						TypePkgName: "version",
					},
					returnSet{
						TypeName:    "Expectation",
						TypePkgName: "testtrace",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"msan": []funcSet{
			funcSet{
				Name:        "Free",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Malloc",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Move",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Read",
				Description: "",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "Write",
				Description: "",
				Returns:     []returnSet{},
			},
		},
		"sql": []funcSet{
			funcSet{
				Name:        "Drivers",
				Description: "Drivers returns a sorted list of the names of the registered drivers. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Named",
				Description: "Named provides a more concise way to create [NamedArg] values. Example usage: db.ExecContext(ctx, ` delete from Invoice where TimeCreated < @end and TimeCreated >= @start;`, sql.Named(\"start\", startTime), sql.Named(\"end\", endTime), ) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NamedArg",
						TypePkgName: "sql",
					},
				},
			},
			funcSet{
				Name:        "Open",
				Description: "Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information. Most users will open a database via a driver-specific connection helper function that returns a [*DB]. No database drivers are included in the Go standard library. See https://golang.org/s/sqldrivers for a list of third-party drivers. Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call [DB.Ping]. The returned [DB] is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the Open function should be called just once. It is rarely necessary to close a [DB]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DB",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "OpenDB",
				Description: "OpenDB opens a database using a [driver.Connector], allowing drivers to bypass a string based data source name. Most users will open a database via a driver-specific connection helper function that returns a [*DB]. No database drivers are included in the Go standard library. See https://golang.org/s/sqldrivers for a list of third-party drivers. OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call [DB.Ping]. The returned [DB] is safe for concurrent use by multiple goroutines and maintains its own pool of idle connections. Thus, the OpenDB function should be called just once. It is rarely necessary to close a [DB]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DB",
						TypePkgName: "sql",
					},
				},
			},
			funcSet{
				Name:        "Register",
				Description: "Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics. ",
				Returns:     []returnSet{},
			},
		},
		"constant": []funcSet{
			funcSet{
				Name:        "BinaryOp",
				Description: "BinaryOp returns the result of the binary expression x op y. The operation must be defined for the operands. If one of the operands is [Unknown], the result is [Unknown]. BinaryOp doesn't handle comparisons or shifts; use [Compare] or [Shift] instead. To force integer division of [Int] operands, use op == [token.QUO_ASSIGN] instead of [token.QUO]; the result is guaranteed to be [Int] in this case. Division by zero leads to a run-time panic. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "BitLen",
				Description: "BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an [Int] or an [Unknown]. If x is [Unknown], the result is 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "BoolVal",
				Description: "BoolVal returns the Go boolean value of x, which must be a [Bool] or an [Unknown]. If x is [Unknown], the result is false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Bytes",
				Description: "Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an [Int]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Compare",
				Description: "Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is [Unknown], the result is false. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Denom",
				Description: "Denom returns the denominator of x; x must be [Int], [Float], or [Unknown]. If x is [Unknown], or if it is too large or small to represent as a fraction, the result is [Unknown]. Otherwise the result is an [Int] >= 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Float32Val",
				Description: "Float32Val is like [Float64Val] but for float32 instead of float64. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Float64Val",
				Description: "Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an [Unknown], but not [Complex]. For values too small (too close to 0) to represent as float64, [Float64Val] silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is [Unknown], the result is (0, false). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Imag",
				Description: "Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is [Unknown], the result is [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Int64Val",
				Description: "Int64Val returns the Go int64 value of x and whether the result is exact; x must be an [Int] or an [Unknown]. If the result is not exact, its value is undefined. If x is [Unknown], the result is (0, false). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Make",
				Description: "Make returns the [Value] for x. type of x result Kind ---------------------------- bool Bool string String int64 Int *big.Int Int *big.Float Float *big.Rat Float anything else Unknown ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeBool",
				Description: "MakeBool returns the [Bool] value for b. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeFloat64",
				Description: "MakeFloat64 returns the [Float] value for x. If x is -0.0, the result is 0.0. If x is not finite, the result is an [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeFromBytes",
				Description: "MakeFromBytes returns the [Int] value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeFromLiteral",
				Description: "MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of [token.INT], [token.FLOAT], [token.IMAG], [token.CHAR], or [token.STRING]. The final argument must be zero. If the literal string syntax is invalid, the result is an [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeImag",
				Description: "MakeImag returns the [Complex] value x*i; x must be [Int], [Float], or [Unknown]. If x is [Unknown], the result is [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeInt64",
				Description: "MakeInt64 returns the [Int] value for x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeString",
				Description: "MakeString returns the [String] value for s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeUint64",
				Description: "MakeUint64 returns the [Int] value for x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "MakeUnknown",
				Description: "MakeUnknown returns the [Unknown] value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Num",
				Description: "Num returns the numerator of x; x must be [Int], [Float], or [Unknown]. If x is [Unknown], or if it is too large or small to represent as a fraction, the result is [Unknown]. Otherwise the result is an [Int] with the same sign as x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Real",
				Description: "Real returns the real part of x, which must be a numeric or unknown value. If x is [Unknown], the result is [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Shift",
				Description: "Shift returns the result of the shift expression x op s with op == [token.SHL] or [token.SHR] (<< or >>). x must be an [Int] or an [Unknown]. If x is [Unknown], the result is x. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Sign",
				Description: "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0; x must be numeric or [Unknown]. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is [Unknown], the result is 1. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "StringVal",
				Description: "StringVal returns the Go string value of x, which must be a [String] or an [Unknown]. If x is [Unknown], the result is \"\". ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ToComplex",
				Description: "ToComplex converts x to a [Complex] value if x is representable as a [Complex]. Otherwise it returns an [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "ToFloat",
				Description: "ToFloat converts x to a [Float] value if x is representable as a [Float]. Otherwise it returns an [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "ToInt",
				Description: "ToInt converts x to an [Int] value if x is representable as an [Int]. Otherwise it returns an [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Uint64Val",
				Description: "Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an [Int] or an [Unknown]. If the result is not exact, its value is undefined. If x is [Unknown], the result is (0, false). ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "UnaryOp",
				Description: "UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec > 0 it specifies the ^ (xor) result size in bits. If y is [Unknown], the result is [Unknown]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			funcSet{
				Name:        "Val",
				Description: "Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are: x Kind type of result ----------------------------------------- Bool bool String string Int int64 or *big.Int Float *big.Float or *big.Rat everything else nil ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
		},
		"template": []funcSet{
			funcSet{
				Name:        "HTMLEscape",
				Description: "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "HTMLEscapeString",
				Description: "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HTMLEscaper",
				Description: "HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsTrue",
				Description: "IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "JSEscape",
				Description: "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "JSEscapeString",
				Description: "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "JSEscaper",
				Description: "JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Must",
				Description: "Must is a helper that wraps a call to a function returning ([*Template], error) and panics if the error is non-nil. It is intended for use in variable initializations such as var t = template.Must(template.New(\"name\").Parse(\"text\")) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New allocates a new, undefined template with the given name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			funcSet{
				Name:        "ParseFS",
				Description: "ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns (see [path.Match]). (Note that most file names serve as glob patterns matching only themselves.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseFiles",
				Description: "ParseFiles creates a new [Template] and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseGlob",
				Description: "ParseGlob creates a new [Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of [filepath.Match], and the pattern must match at least one file. The returned template will have the [filepath.Base] name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling [ParseFiles] with the list of files matched by the pattern. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "URLQueryEscaper",
				Description: "URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HTMLEscape",
				Description: "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "HTMLEscapeString",
				Description: "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "HTMLEscaper",
				Description: "HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsTrue",
				Description: "IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "JSEscape",
				Description: "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "JSEscapeString",
				Description: "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "JSEscaper",
				Description: "JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Must",
				Description: "Must is a helper that wraps a call to a function returning ([*Template], error) and panics if the error is non-nil. It is intended for use in variable initializations such as var t = template.Must(template.New(\"name\").Parse(\"html\")) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			funcSet{
				Name:        "New",
				Description: "New allocates a new HTML template with the given name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			funcSet{
				Name:        "ParseFS",
				Description: "ParseFS is like [ParseFiles] or [ParseGlob] but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseFiles",
				Description: "ParseFiles creates a new [Template] and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned [*Template] is nil. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ParseGlob",
				Description: "ParseGlob creates a new [Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling [ParseFiles] with the list of files matched by the pattern. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "URLQueryEscaper",
				Description: "URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"slogtest": []funcSet{
			funcSet{
				Name:        "Run",
				Description: "Run exercises a [slog.Handler] on the same test cases as [TestHandler], but runs each case in a subtest. For each test case, it first calls newHandler to get an instance of the handler under test, then runs the test case, then calls result to get the result. If the test case fails, it calls t.Error. ",
				Returns:     []returnSet{},
			},
			funcSet{
				Name:        "TestHandler",
				Description: "TestHandler tests a [slog.Handler]. If TestHandler finds any misbehaviors, it returns an error for each, combined into a single error with [errors.Join]. TestHandler installs the given Handler in a [slog.Logger] and makes several calls to the Logger's output methods. The Handler should be enabled for levels Info and above. The results function is invoked after all such calls. It should return a slice of map[string]any, one for each call to a Logger output method. The keys and values of the map should correspond to the keys and values of the Handler's output. Each group in the output should be represented as its own nested map[string]any. The standard keys [slog.TimeKey], [slog.LevelKey] and [slog.MessageKey] should be used. If the Handler outputs JSON, then calling [encoding/json.Unmarshal] with a `map[string]any` will create the right data structure. If a Handler intentionally drops an attribute that is checked by a test, then the results function should check for its absence and add it to the map it returns. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"ascii85": []funcSet{
			funcSet{
				Name:        "Decode",
				Description: "Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a [CorruptInputError]. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in <~ and ~> symbols. Decode expects these to have been stripped by the caller. If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block. [NewDecoder] wraps an [io.Reader] interface around Decode. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Encode",
				Description: "Encode encodes src into at most [MaxEncodedLen](len(src)) bytes of dst, returning the actual number of bytes written. The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use [NewEncoder] instead. Often, ascii85-encoded data is wrapped in <~ and ~> symbols. Encode does not add these. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "MaxEncodedLen",
				Description: "MaxEncodedLen returns the maximum length of an encoding of n source bytes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewDecoder",
				Description: "NewDecoder constructs a new ascii85 stream decoder. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			funcSet{
				Name:        "NewEncoder",
				Description: "NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
		},
		"cgo": []funcSet{
			funcSet{
				Name:        "NewHandle",
				Description: "NewHandle returns a handle for a given value. The handle is valid until the program calls Delete on it. The handle uses resources, and this package assumes that C code may hold on to the handle, so a program must explicitly call Delete when the handle is no longer needed. The intended use is to pass the returned handle to C code, which passes it back to Go, which calls Value. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handle",
						TypePkgName: "cgo",
					},
				},
			},
		},
		"httpcommon": []funcSet{
			funcSet{
				Name:        "CachedCanonicalHeader",
				Description: "CachedCanonicalHeader returns the canonical form of a well-known header name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "CanonicalHeader",
				Description: "CanonicalHeader canonicalizes a header name. (For example, \"host\" becomes \"Host\".) ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeHeaders",
				Description: "EncodeHeaders constructs request headers common to HTTP/2 and HTTP/3. It validates a request and calls headerf with each pseudo-header and header for the request. The headerf function is called with the validated, canonicalized header name. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncodeHeadersResult",
						TypePkgName: "httpcommon",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "IsRequestGzip",
				Description: "IsRequestGzip reports whether we should add an Accept-Encoding: gzip header for a request. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "LowerHeader",
				Description: "LowerHeader returns the lowercase form of a header name, used on the wire for HTTP/2 and HTTP/3 requests. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "NewServerRequest",
				Description: "",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ServerRequestResult",
						TypePkgName: "httpcommon",
					},
				},
			},
		},
		"utf8": []funcSet{
			funcSet{
				Name:        "AppendRune",
				Description: "AppendRune appends the UTF-8 encoding of r to the end of p and returns the extended buffer. If the rune is out of range, it appends the encoding of [RuneError]. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeLastRune",
				Description: "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns ([RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeLastRuneInString",
				Description: "DecodeLastRuneInString is like [DecodeLastRune] but its input is a string. If s is empty it returns ([RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeRune",
				Description: "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns ([RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "DecodeRuneInString",
				Description: "DecodeRuneInString is like [DecodeRune] but its input is a string. If s is empty it returns ([RuneError], 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8. An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out of range, or is not the shortest possible UTF-8 encoding for the value. No other validation is performed. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "EncodeRune",
				Description: "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. If the rune is out of range, it writes the encoding of [RuneError]. It returns the number of bytes written. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FullRune",
				Description: "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "FullRuneInString",
				Description: "FullRuneInString is like FullRune but its input is a string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RuneCount",
				Description: "RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RuneCountInString",
				Description: "RuneCountInString is like [RuneCount] but its input is a string. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RuneLen",
				Description: "RuneLen returns the number of bytes in the UTF-8 encoding of the rune. It returns -1 if the rune is not a valid value to encode in UTF-8. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "RuneStart",
				Description: "RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "Valid",
				Description: "Valid reports whether p consists entirely of valid UTF-8-encoded runes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ValidRune",
				Description: "ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			funcSet{
				Name:        "ValidString",
				Description: "ValidString reports whether s consists entirely of valid UTF-8-encoded runes. ",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
	},
	Methods: map[types.PkgName][]methodSet{
		"strconv": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "NumError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "NumError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"reflect": []methodSet{
			methodSet{
				Name:             "Key",
				Description:      "",
				ReceiverTypeName: "MapIter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value returns the value of iter's current map entry. ",
				ReceiverTypeName: "MapIter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next advances the map iterator and reports whether there is another entry. It returns false when iter is exhausted; subsequent calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic. ",
				ReceiverTypeName: "MapIter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset modifies iter to iterate over v. It panics if v's Kind is not [Map] and v is not the zero Value. Reset(Value{}) causes iter to not to refer to any map, which may allow the previously iterated-over map to be garbage collected. ",
				ReceiverTypeName: "MapIter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IsExported",
				Description:      "IsExported reports whether the method is exported. ",
				ReceiverTypeName: "Method",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsExported",
				Description:      "IsExported reports whether the method is exported. ",
				ReceiverTypeName: "StructField",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use [StructTag.Lookup]. ",
				ReceiverTypeName: "StructTag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified. ",
				ReceiverTypeName: "StructTag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ValueError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"list": []methodSet{
			methodSet{
				Name:             "Next",
				Description:      "Next returns the next list element or nil. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "Prev",
				Description:      "Prev returns the previous list element or nil. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init initializes or clears list l. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "List",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the number of elements of list l. The complexity is O(1). ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Front",
				Description:      "Front returns the first element of list l or nil if the list is empty. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "Back",
				Description:      "Back returns the last element of list l or nil if the list is empty. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "lazyInit",
				Description:      "lazyInit lazily initializes a zero List value. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "insert",
				Description:      "insert inserts e after at, increments l.len, and returns e. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "insertValue",
				Description:      "insertValue is a convenience wrapper for insert(&Element{Value: v}, at). ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "remove",
				Description:      "remove removes e from its list, decrements l.len ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "move",
				Description:      "move moves e to next to at. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Remove",
				Description:      "Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PushFront",
				Description:      "PushFront inserts a new element e with value v at the front of list l and returns e. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "PushBack",
				Description:      "PushBack inserts a new element e with value v at the back of list l and returns e. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "InsertBefore",
				Description:      "InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "InsertAfter",
				Description:      "InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "list",
					},
				},
			},
			methodSet{
				Name:             "MoveToFront",
				Description:      "MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MoveToBack",
				Description:      "MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MoveBefore",
				Description:      "MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MoveAfter",
				Description:      "MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "PushBackList",
				Description:      "PushBackList inserts a copy of another list at the back of list l. The lists l and other may be the same. They must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "PushFrontList",
				Description:      "PushFrontList inserts a copy of another list at the front of list l. The lists l and other may be the same. They must not be nil. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
		},
		"macOS": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "OSStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"singleflight": []methodSet{
			methodSet{
				Name:             "Do",
				Description:      "Do executes and returns the results of the given function, making sure that only one execution is in-flight for a given key at a time. If a duplicate comes in, the duplicate caller waits for the original to complete and receives the same results. The return value shared indicates whether v was given to multiple callers. ",
				ReceiverTypeName: "Group",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DoChan",
				Description:      "DoChan is like Do but returns a channel that will receive the results when they are ready. ",
				ReceiverTypeName: "Group",
				Returns: []returnSet{
					returnSet{
						TypeName:    "<-chan internal/singleflight.Result",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "doCall",
				Description:      "doCall handles the single call for a key. ",
				ReceiverTypeName: "Group",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ForgetUnshared",
				Description:      "ForgetUnshared tells the singleflight to forget about a key if it is not shared with any other goroutines. Future calls to Do for a forgotten key will call the function rather than waiting for an earlier call to complete. Returns whether the key was forgotten or unknown--that is, whether no other goroutines are waiting for the result. ",
				ReceiverTypeName: "Group",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"tracev2": []methodSet{
			methodSet{
				Name:             "Experimental",
				Description:      "",
				ReceiverTypeName: "EventType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "GoStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ProcStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"poll": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "Error returns the error message for ErrNetClosing. Keep this string consistent because of issue #4373: since historically programs have not been able to detect this error, they look for the string. ",
				ReceiverTypeName: "DeadlineExceededError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "DeadlineExceededError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "DeadlineExceededError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fsync",
				Description:      "Fsync invokes SYS_FCNTL with SYS_FULLFSYNC because on OS X, SYS_FSYNC doesn't fully flush contents to disk. See Issue #26650 as well as the man page for fsync on OS X. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "incref",
				Description:      "incref adds a reference to mu. It reports whether mu is available for reading or writing. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decref",
				Description:      "decref removes a reference from mu. It reports whether there is no remaining reference. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLock",
				Description:      "readLock adds a reference to fd and locks fd for reading. It returns an error when fd cannot be used for reading. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readUnlock",
				Description:      "readUnlock removes a reference from fd and unlocks fd for reading. It also closes fd when the state of fd is set to closed and there is no remaining reference. ",
				ReceiverTypeName: "FD",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeLock",
				Description:      "writeLock adds a reference to fd and locks fd for writing. It returns an error when fd cannot be used for writing. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeUnlock",
				Description:      "writeUnlock removes a reference from fd and unlocks fd for writing. It also closes fd when the state of fd is set to closed and there is no remaining reference. ",
				ReceiverTypeName: "FD",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closing",
				Description:      "closing returns true if fd is closing. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OpenDir",
				Description:      "OpenDir returns a pointer to a DIR structure suitable for ReadDir. In case of an error, the name of the failed syscall is returned along with a syscall.Errno. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetDeadline",
				Description:      "SetDeadline sets the read and write deadlines associated with fd. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetReadDeadline",
				Description:      "SetReadDeadline sets the read deadline associated with fd. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetWriteDeadline",
				Description:      "SetWriteDeadline sets the write deadline associated with fd. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "eofError",
				Description:      "eofError returns io.EOF when fd is available for reading end of file. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Shutdown",
				Description:      "Shutdown wraps syscall.Shutdown. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fchown",
				Description:      "Fchown wraps syscall.Fchown. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Ftruncate",
				Description:      "Ftruncate wraps syscall.Ftruncate. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RawControl",
				Description:      "RawControl invokes the user-defined function f for a non-IO operation. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init initializes the FD. The Sysfd field should already be set. This can be called multiple times on a single FD. The net argument is a network name from the net package (e.g., \"tcp\"), or \"file\". Set pollable to true if fd should be managed by runtime netpoll. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "destroy",
				Description:      "Destroy closes the file descriptor. This is called when there are no remaining references. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the FD. The underlying file descriptor is closed by the destroy method when there are no remaining references. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBlocking",
				Description:      "SetBlocking puts the file into blocking mode. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read implements io.Reader. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pread",
				Description:      "Pread wraps the pread system call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom wraps the recvfrom network call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromInet4",
				Description:      "ReadFromInet4 wraps the recvfrom network call for IPv4. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromInet6",
				Description:      "ReadFromInet6 wraps the recvfrom network call for IPv6. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsg",
				Description:      "ReadMsg wraps the recvmsg network call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgInet4",
				Description:      "ReadMsgInet4 is ReadMsg, but specialized for syscall.SockaddrInet4. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgInet6",
				Description:      "ReadMsgInet6 is ReadMsg, but specialized for syscall.SockaddrInet6. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write implements io.Writer. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pwrite",
				Description:      "Pwrite wraps the pwrite system call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToInet4",
				Description:      "WriteToInet4 wraps the sendto network call for IPv4 addresses. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToInet6",
				Description:      "WriteToInet6 wraps the sendto network call for IPv6 addresses. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo wraps the sendto network call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsg",
				Description:      "WriteMsg wraps the sendmsg network call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgInet4",
				Description:      "WriteMsgInet4 is WriteMsg specialized for syscall.SockaddrInet4. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgInet6",
				Description:      "WriteMsgInet6 is WriteMsg specialized for syscall.SockaddrInet6. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Accept",
				Description:      "Accept wraps the accept network call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fchmod",
				Description:      "Fchmod wraps syscall.Fchmod. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fstat",
				Description:      "Fstat wraps syscall.Fstat ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dup",
				Description:      "Dup duplicates the file descriptor. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WaitWrite",
				Description:      "WaitWrite waits until data can be written to fd. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteOnce",
				Description:      "WriteOnce is for testing only. It makes a single write call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RawRead",
				Description:      "RawRead invokes the user-defined function f for a read operation. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RawWrite",
				Description:      "RawWrite invokes the user-defined function f for a write operation. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fchdir",
				Description:      "Fchdir wraps syscall.Fchdir. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadDirent",
				Description:      "ReadDirent wraps syscall.ReadDirent. We treat this like an ordinary system call rather than a call that tries to fill the buffer. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek wraps syscall.Seek. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptInt",
				Description:      "SetsockoptInt wraps the setsockopt network call with an int argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptInet4Addr",
				Description:      "SetsockoptInet4Addr wraps the setsockopt network call with an IPv4 address. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptLinger",
				Description:      "SetsockoptLinger wraps the setsockopt network call with a Linger argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetsockoptInt",
				Description:      "GetsockoptInt wraps the getsockopt network call with an int argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptByte",
				Description:      "SetsockoptByte wraps the setsockopt network call with a byte argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptIPMreq",
				Description:      "SetsockoptIPMreq wraps the setsockopt network call with an IPMreq argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetsockoptIPv6Mreq",
				Description:      "SetsockoptIPv6Mreq wraps the setsockopt network call with an IPv6Mreq argument. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Writev",
				Description:      "Writev wraps the writev system call. ",
				ReceiverTypeName: "FD",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "SysFile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "destroy",
				Description:      "Destroy closes the file descriptor. This is called when there are no remaining references. ",
				ReceiverTypeName: "SysFile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sha3": []methodSet{
			methodSet{
				Name:             "BlockSize",
				Description:      "BlockSize returns the rate of sponge underlying this hash function. ",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the output size of the hash function in bytes. ",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the Digest to its initial state. ",
				ReceiverTypeName: "Digest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Digest",
						TypePkgName: "sha3",
					},
				},
			},
			methodSet{
				Name:             "permute",
				Description:      "permute applies the KeccakF-1600 permutation. ",
				ReceiverTypeName: "Digest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "padAndPermute",
				Description:      "padAndPermute appends the domain separation bits in dsbyte, applies the multi-bitrate 10..1 padding rule, and permutes the state. ",
				ReceiverTypeName: "Digest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write absorbs more data into the hash's state. ",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeGeneric",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readGeneric",
				Description:      "read squeezes an arbitrary number of bytes from the sponge. ",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum appends the current hash to b and returns the resulting slice. It does not change the underlying hash state. ",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sumGeneric",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "read",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sum",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "BlockSize returns the rate of sponge underlying this hash function. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the output size of the hash function in bytes. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum appends the current hash to b and returns the resulting slice. It does not change the underlying hash state. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write absorbs more data into the hash's state. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the Digest to its initial state. ",
				ReceiverTypeName: "SHAKE",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SHAKE",
						TypePkgName: "sha3",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write absorbs more data into the hash's state. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum appends the current hash to b and returns the resulting slice. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the hash to its initial state. ",
				ReceiverTypeName: "SHA3",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the number of bytes Sum will produce. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "BlockSize returns the hash's rate. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements [encoding.BinaryMarshaler]. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements [encoding.BinaryAppender]. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements [encoding.BinaryUnmarshaler]. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone implements [hash.Cloner]. ",
				ReceiverTypeName: "SHA3",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cloner",
						TypePkgName: "hash",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write absorbs more data into the hash's state. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read squeezes more output from the XOF. Any call to Write after a call to Read will panic. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the hash to its initial state. ",
				ReceiverTypeName: "SHAKE",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "BlockSize returns the hash's rate. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements [encoding.BinaryMarshaler]. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements [encoding.BinaryAppender]. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements [encoding.BinaryUnmarshaler]. ",
				ReceiverTypeName: "SHAKE",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"srcimporter": []methodSet{
			methodSet{
				Name:             "Import",
				Description:      "Import(path) is a shortcut for ImportFrom(path, \".\", 0). ",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportFrom",
				Description:      "ImportFrom imports the package with the given import path resolved from the given srcDir, adds the new package to the set of packages maintained by the importer, and returns the package. Package path resolution and file system operations are controlled by the context maintained with the importer. The import mode must be zero but is otherwise ignored. Packages that are not comprised entirely of pure Go files may fail to import because the type checker may not be able to determine all exported entities (e.g. due to cgo dependencies). ",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseFiles",
				Description:      "",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/ast.File",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cgo",
				Description:      "",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "absPath",
				Description:      "",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isAbsPath",
				Description:      "",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "joinPath",
				Description:      "",
				ReceiverTypeName: "Importer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"aes": []methodSet{
			methodSet{
				Name:             "Encrypt",
				Description:      "",
				ReceiverTypeName: "Block",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Decrypt",
				Description:      "",
				ReceiverTypeName: "Block",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CryptBlocks",
				Description:      "",
				ReceiverTypeName: "CBCDecrypter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetIV",
				Description:      "",
				ReceiverTypeName: "CBCDecrypter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CryptBlocks",
				Description:      "",
				ReceiverTypeName: "CBCEncrypter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetIV",
				Description:      "",
				ReceiverTypeName: "CBCEncrypter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "XORKeyStream",
				Description:      "",
				ReceiverTypeName: "CTR",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "XORKeyStreamAt",
				Description:      "XORKeyStreamAt behaves like XORKeyStream but keeps no state, and instead seeks into the keystream by the given bytes offset from the start (ignoring any XORKetStream calls). This allows for random access into the keystream, up to 16 EiB from the start. ",
				ReceiverTypeName: "CTR",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "KeySizeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "KeySizeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"base32": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CorruptInputError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WithPadding",
				Description:      "WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. The padding character must not be '\\r' or '\\n', must not be contained in the encoding's alphabet, must not be negative, and must be a rune equal or below '\\xff'. Padding characters above '\\x7f' are encoded as their exact byte value rather than using the UTF-8 representation of the codepoint. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoding",
						TypePkgName: "base32",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode encodes src using the encoding enc, writing [Encoding.EncodedLen](len(src)) bytes to dst. The encoding pads the output to a multiple of 8 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use [NewEncoder] instead. ",
				ReceiverTypeName: "Encoding",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AppendEncode",
				Description:      "AppendEncode appends the base32 encoded src to dst and returns the extended buffer. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodeToString",
				Description:      "EncodeToString returns the base32 encoding of src. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodedLen",
				Description:      "EncodedLen returns the length in bytes of the base32 encoding of an input buffer of length n. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decode",
				Description:      "decode is like Decode but returns an additional 'end' value, which indicates if end-of-message padding was encountered and thus any additional data is an error. This method assumes that src has been stripped of all supported whitespace ('\\r' and '\\n'). ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Decode",
				Description:      "Decode decodes src using the encoding enc. It writes at most [Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes written. The caller must ensure that dst is large enough to hold all the decoded data. If src contains invalid base32 data, it will return the number of bytes successfully written and [CorruptInputError]. Newline characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendDecode",
				Description:      "AppendDecode appends the base32 decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error. New line characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodeString",
				Description:      "DecodeString returns the bytes represented by the base32 string s. If the input is malformed, it returns the partially decoded data and [CorruptInputError]. New line characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodedLen",
				Description:      "DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base32-encoded data. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"lazyregexp": []methodSet{
			methodSet{
				Name:             "re",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
				},
			},
			methodSet{
				Name:             "build",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "FindSubmatch",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindStringSubmatch",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindStringSubmatchIndex",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllString",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindString",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllString",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchString",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SubexpNames",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
		},
		"template": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ExecError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "ExecError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExecuteTemplate",
				Description:      "ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Execute",
				Description:      "Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. If data is a [reflect.Value], the template applies to the concrete value that the reflect.Value holds, as in [fmt.Print]. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "execute",
				Description:      "",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DefinedTemplates",
				Description:      "DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. For generating an error message here and in [html/template]. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseFiles",
				Description:      "ParseFiles creates a new [Template] and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseGlob",
				Description:      "ParseGlob creates a new [Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of [filepath.Match], and the pattern must match at least one file. The returned template will have the [filepath.Base] name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling [ParseFiles] with the list of files matched by the pattern. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseFS",
				Description:      "ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns (see [path.Match]). (Note that most file names serve as glob patterns matching only themselves.) ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Option",
				Description:      "Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. Known options: missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. \"missingkey=default\" or \"missingkey=invalid\" The default behavior: Do nothing and continue execution. If printed, the result of the index operation is the string \"<no value>\". \"missingkey=zero\" The operation returns the zero value for the map type's element. \"missingkey=error\" Execution stops immediately with an error. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "setOption",
				Description:      "",
				ReceiverTypeName: "Template",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the template. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "New",
				Description:      "New allocates a new, undefined template with the given name. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "init",
				Description:      "init guarantees that t has a valid common structure. ",
				ReceiverTypeName: "Template",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to [Template.Parse] in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "copy",
				Description:      "copy returns a shallow copy of t, with common set to the argument. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "AddParseTree",
				Description:      "AddParseTree associates the argument parse tree with the template t, giving it the specified name. If the template has not been defined, this tree becomes its definition. If it has been defined and already has that name, the existing definition is replaced; otherwise a new template is created, defined, and returned. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Templates",
				Description:      "Templates returns a slice of defined templates associated with t. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*text/template.Template",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Delims",
				Description:      "Delims sets the action delimiters to the specified strings, to be used in subsequent calls to [Template.Parse], [Template.ParseFiles], or [Template.ParseGlob]. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Funcs",
				Description:      "Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself. Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "associate",
				Description:      "associate installs the new template into the group of templates associated with t. The two are already known to share the common structure. The boolean return value reports whether to store this tree as t.Tree. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Templates",
				Description:      "Templates returns a slice of the templates associated with t, including t itself. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*html/template.Template",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Option",
				Description:      "Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. Known options: missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. \"missingkey=default\" or \"missingkey=invalid\" The default behavior: Do nothing and continue execution. If printed, the result of the index operation is the string \"<no value>\". \"missingkey=zero\" The operation returns the zero value for the map type's element. \"missingkey=error\" Execution stops immediately with an error. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "checkCanParse",
				Description:      "checkCanParse checks whether it is OK to parse templates. If not, it returns an error. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "escape",
				Description:      "escape escapes a template node. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Execute",
				Description:      "Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExecuteTemplate",
				Description:      "ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupAndEscapeTemplate",
				Description:      "lookupAndEscapeTemplate guarantees that the template with the given name is escaped, or returns an error if it cannot be. It returns the named template. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DefinedTemplates",
				Description:      "DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. Used to generate an error message. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself. Templates can be redefined in successive calls to Parse, before the first use of [Template.Execute] on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddParseTree",
				Description:      "AddParseTree creates a new template with the name and parse tree and associates it with t. It returns an error if t or any associated template has already been executed. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to [Template.Parse] in the copy will add templates to the copy but not to the original. [Template.Clone] can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. It returns an error if t has already been executed. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "New",
				Description:      "New allocates a new HTML template with the given name. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "new",
				Description:      "new is the implementation of New, without the lock. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the template. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Funcs",
				Description:      "Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Delims",
				Description:      "Delims sets the action delimiters to the specified strings, to be used in subsequent calls to [Template.Parse], [ParseFiles], or [ParseGlob]. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the template with the given name that is associated with t, or nil if there is no such template. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "ParseFiles",
				Description:      "ParseFiles creates a new [Template] and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned [*Template] is nil. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseGlob",
				Description:      "ParseGlob creates a new [Template] and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling [ParseFiles] with the list of files matched by the pattern. When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseFS",
				Description:      "ParseFS is like [ParseFiles] or [ParseGlob] but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) ",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"jpeg": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "FormatError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnsupportedError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"rpc": []methodSet{
			methodSet{
				Name:             "done",
				Description:      "",
				ReceiverTypeName: "Call",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "send",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "input",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Go",
				Description:      "Go invokes the function asynchronously. It returns the [Call] structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Call",
						TypePkgName: "rpc",
					},
				},
			},
			methodSet{
				Name:             "Register",
				Description:      "Register publishes in the server the set of methods of the receiver value that satisfy the following conditions: - exported method of exported type - two arguments, both of exported type - the second argument is a pointer - one return value, of type error It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form \"Type.Method\", where Type is the receiver's concrete type. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegisterName",
				Description:      "RegisterName is like [Register] but uses the provided name for the type instead of the receiver's concrete type. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "register",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendResponse",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ServeConn",
				Description:      "ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use [ServeCodec]. See [NewClient]'s comment for information about concurrent access. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ServeCodec",
				Description:      "ServeCodec is like [ServeConn] but uses the specified codec to decode requests and encode responses. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ServeRequest",
				Description:      "ServeRequest is like [ServeCodec] but synchronously serves a single request. It does not close the codec upon completion. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getRequest",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "rpc",
					},
				},
			},
			methodSet{
				Name:             "freeRequest",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "getResponse",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "rpc",
					},
				},
			},
			methodSet{
				Name:             "freeResponse",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "readRequest",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "service",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "methodType",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "Request",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflect",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readRequestHeader",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "service",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "methodType",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "Request",
						TypePkgName: "rpc",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Accept",
				Description:      "Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ServeHTTP",
				Description:      "Runs at /debug/rpc ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HandleHTTP",
				Description:      "HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke [http.Serve](), typically in a go statement. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ServerError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"atomic": []methodSet{
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Bool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Bool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Float64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Float64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Int32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap replaces i's value with new, returning i's value before the replacement. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta to i atomically, returning the new updated value. This operation wraps around in the usual two's-complement way. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Int64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap replaces i's value with new, returning i's value before the replacement. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta to i atomically, returning the new updated value. This operation wraps around in the usual two's-complement way. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*T",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StoreNoWB",
				Description:      "StoreNoWB updates the value atomically. WARNING: As the name implies this operation does *not* perform a write barrier on value, and so this operation may hide pointers from the GC. Use with care and sparingly. It is safe to use with values not found in the Go heap. Prefer Store instead. ",
				ReceiverTypeName: "Pointer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Pointer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwapNoWB",
				Description:      "CompareAndSwapNoWB atomically (with respect to other methods) compares u's value with old, and if they're equal, swaps u's value with new. It reports whether the swap ran. WARNING: As the name implies this operation does *not* perform a write barrier on value, and so this operation may hide pointers from the GC. Use with care and sparingly. It is safe to use with values not found in the Go heap. Prefer CompareAndSwap instead. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadAcquire",
				Description:      "LoadAcquire is a partially unsynchronized version of Load that relaxes ordering constraints. Other threads may observe operations that precede this operation to occur after it, but no operation that occurs after it on this thread can be observed to occur before it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Uint32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StoreRelease",
				Description:      "StoreRelease is a partially unsynchronized version of Store that relaxes ordering constraints. Other threads may observe operations that occur after this operation to precede it, but no operation that precedes it on this thread can be observed to occur after it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uint32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwapRelease",
				Description:      "CompareAndSwapRelease is a partially unsynchronized version of Cas that relaxes ordering constraints. Other threads may observe operations that occur after this operation to precede it, but no operation that precedes it on this thread can be observed to occur after it. It reports whether the swap ran. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap replaces i's value with new, returning i's value before the replacement. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "",
				ReceiverTypeName: "Uint32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Or",
				Description:      "",
				ReceiverTypeName: "Uint32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta to i atomically, returning the new updated value. This operation wraps around in the usual two's-complement way. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Uint64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap replaces i's value with new, returning i's value before the replacement. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta to i atomically, returning the new updated value. This operation wraps around in the usual two's-complement way. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadAcquire",
				Description:      "LoadAcquire is a partially unsynchronized version of Load that relaxes ordering constraints. Other threads may observe operations that precede this operation to occur after it, but no operation that occurs after it on this thread can be observed to occur before it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StoreRelease",
				Description:      "StoreRelease is a partially unsynchronized version of Store that relaxes ordering constraints. Other threads may observe operations that occur after this operation to precede it, but no operation that precedes it on this thread can be observed to occur after it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uint64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Uint8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Uint8",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "And",
				Description:      "",
				ReceiverTypeName: "Uint8",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Or",
				Description:      "",
				ReceiverTypeName: "Uint8",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadAcquire",
				Description:      "LoadAcquire is a partially unsynchronized version of Load that relaxes ordering constraints. Other threads may observe operations that precede this operation to occur after it, but no operation that occurs after it on this thread can be observed to occur before it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "Uintptr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StoreRelease",
				Description:      "StoreRelease is a partially unsynchronized version of Store that relaxes ordering constraints. Other threads may observe operations that occur after this operation to precede it, but no operation that precedes it on this thread can be observed to occur after it. WARNING: Use sparingly and with great care. ",
				ReceiverTypeName: "Uintptr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap replaces i's value with new, returning i's value before the replacement. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta to i atomically, returning the new updated value. This operation wraps around in the usual two's-complement way. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "",
				ReceiverTypeName: "UnsafePointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StoreNoWB",
				Description:      "StoreNoWB updates the value atomically. WARNING: As the name implies this operation does *not* perform a write barrier on value, and so this operation may hide pointers from the GC. Use with care and sparingly. It is safe to use with values not found in the Go heap. Prefer Store instead. ",
				ReceiverTypeName: "UnsafePointer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Store",
				Description:      "",
				ReceiverTypeName: "UnsafePointer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndSwapNoWB",
				Description:      "CompareAndSwapNoWB atomically (with respect to other methods) compares u's value with old, and if they're equal, swaps u's value with new. It reports whether the swap ran. WARNING: As the name implies this operation does *not* perform a write barrier on value, and so this operation may hide pointers from the GC. Use with care and sparingly. It is safe to use with values not found in the Go heap. Prefer CompareAndSwap instead. ",
				ReceiverTypeName: "UnsafePointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap atomically compares i's value with old, and if they're equal, swaps i's value with new. It reports whether the swap ran. ",
				ReceiverTypeName: "UnsafePointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Bool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Bool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Bool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Bool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Int32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add atomically adds delta to x and returns the new value. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Int32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Int64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add atomically adds delta to x and returns the new value. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Int64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*T",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Pointer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*T",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Uint32",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add atomically adds delta to x and returns the new value. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uint32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Uint64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add atomically adds delta to x and returns the new value. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uint64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Uintptr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add atomically adds delta to x and returns the new value. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "And",
				Description:      "And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. ",
				ReceiverTypeName: "Uintptr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load atomically loads and returns the value stored in x. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store atomically stores val into x. ",
				ReceiverTypeName: "Value",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap atomically stores new into x and returns the previous value. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap executes the compare-and-swap operation for the boolean value x. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"ring": []methodSet{
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next returns the next ring element. r must not be empty. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Prev",
				Description:      "Prev returns the previous ring element. r must not be empty. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Move",
				Description:      "Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0) in the ring and returns that ring element. r must not be empty. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Link",
				Description:      "Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty. If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil). If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Unlink",
				Description:      "Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Ring",
						TypePkgName: "ring",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len computes the number of elements in ring r. It executes in time proportional to the number of elements. ",
				ReceiverTypeName: "Ring",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Do",
				Description:      "Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r. ",
				ReceiverTypeName: "Ring",
				Returns:          []returnSet{},
			},
		},
		"cipher": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "StreamReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "StreamWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the underlying Writer and returns its Close return value, if the Writer is also an io.Closer. Otherwise it returns nil. ",
				ReceiverTypeName: "StreamWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"boring": []methodSet{
			methodSet{
				Name:             "PublicKey",
				Description:      "",
				ReceiverTypeName: "PrivateKeyECDH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKeyECDH",
						TypePkgName: "boring",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "",
				ReceiverTypeName: "PublicKeyECDH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"ecdh": []methodSet{
			methodSet{
				Name:             "Bytes",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PublicKey",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdh",
					},
				},
			},
			methodSet{
				Name:             "ECDH",
				Description:      "ECDH performs an ECDH exchange and returns the shared secret. The [PrivateKey] and [PublicKey] must use the same curve. For NIST curves, this performs ECDH as specified in SEC 1, Version 2.0, Section 3.3.1, and returns the x-coordinate encoded according to SEC 1, Version 2.0, Section 2.3.5. The result is never the point at infinity. This is also known as the Shared Secret Computation of the Ephemeral Unified Model scheme specified in NIST SP 800-56A Rev. 3, Section 6.1.2.2. For [X25519], this performs ECDH as specified in RFC 7748, Section 6.1. If the result is the all-zero value, ECDH returns an error. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns a copy of the encoding of the public key. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns whether x represents the same public key as k. Note that there can be equivalent public keys with different encodings which would return false from this check but behave the same way as inputs to ECDH. This check is performed in constant time as long as the key types and their curve match. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Public",
				Description:      "Public implements the implicit interface of all standard library private keys. See the docs of [crypto.PrivateKey]. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns a copy of the encoding of the public key. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns whether x represents the same public key as k. Note that there can be equivalent public keys with different encodings which would return false from this check but behave the same way as inputs to ECDH. This check is performed in constant time as long as the key types and their curve match. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"x509": []methodSet{
			methodSet{
				Name:             "len",
				Description:      "len returns the number of certs in the set. A nil set is a valid empty set. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cert",
				Description:      "cert returns cert index n in s. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "func([]*crypto/x509.Certificate) error",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a copy of s. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CertPool",
						TypePkgName: "x509",
					},
				},
			},
			methodSet{
				Name:             "findPotentialParents",
				Description:      "findPotentialParents returns the certificates in s which might have signed cert. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]crypto/x509.potentialParent",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "contains",
				Description:      "",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddCert",
				Description:      "AddCert adds a certificate to a pool. ",
				ReceiverTypeName: "CertPool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "addCertFunc",
				Description:      "addCertFunc adds metadata about a certificate to a pool, along with a func to fetch that certificate later when needed. The rawSubject is Certificate.RawSubject and must be non-empty. The getCert func may be called 0 or more times. ",
				ReceiverTypeName: "CertPool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AppendCertsFromPEM",
				Description:      "AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed. On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Subjects",
				Description:      "Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool. Deprecated: if s was returned by [SystemCertPool], Subjects will not include the system roots. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether s and other are equal. ",
				ReceiverTypeName: "CertPool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddCertWithConstraint",
				Description:      "AddCertWithConstraint adds a certificate to the pool with the additional constraint. When Certificate.Verify builds a chain which is rooted by cert, it will additionally pass the whole chain to constraint to determine its validity. If constraint returns a non-nil error, the chain will be discarded. constraint may be called concurrently from multiple goroutines. ",
				ReceiverTypeName: "CertPool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "systemVerify",
				Description:      "",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]*crypto/x509.Certificate",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkNameConstraints",
				Description:      "checkNameConstraints checks that c permits a child certificate to claim the given name, of type nameType. The argument parsedName contains the parsed form of name, suitable for passing to the match function. The total number of comparisons is tracked in the given count and should not exceed the given limit. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isValid",
				Description:      "isValid performs validity checks on c given that it is a candidate to append to the chain in currentChain. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Verify",
				Description:      "Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots. If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError. Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported. Name constraint validation follows the rules from RFC 5280, with the addition that DNS name constraints may use the leading period format defined for emails and URIs. When a constraint has a leading period it indicates that at least one additional label must be prepended to the constrained name to be considered valid. Extended Key Usage values are enforced nested down a chain, so an intermediate or root that enumerates EKUs prevents a leaf from asserting an EKU not in that list. (While this is not specified, it is common practice in order to limit the types of certificates a CA can issue.) Certificates that use SHA1WithRSA and ECDSAWithSHA1 signatures are not supported, and will not be used to build chains. Certificates other than c in the returned chains should not be modified. WARNING: this function doesn't do any revocation checking. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]*crypto/x509.Certificate",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "buildChains",
				Description:      "",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]*crypto/x509.Certificate",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "VerifyHostname",
				Description:      "VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch. IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the complete left-most label (e.g. *.example.com). Note that the legacy Common Name field is ignored. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether s and other are equal. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasSANExtension",
				Description:      "",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckSignatureFrom",
				Description:      "CheckSignatureFrom verifies that the signature on c is a valid signature from parent. This is a low-level API that performs very limited checks, and not a full path verifier. Most users should use [Certificate.Verify] instead. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckSignature",
				Description:      "CheckSignature verifies that signature is a valid signature over signed from c's public key. This is a low-level API that performs no validity checks on the certificate. [MD5WithRSA] signatures are rejected, while [SHA1WithRSA] and [ECDSAWithSHA1] signatures are currently accepted. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasNameConstraints",
				Description:      "",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getSANExtension",
				Description:      "",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckCRLSignature",
				Description:      "CheckCRLSignature checks that the signature in crl is from c. Deprecated: Use [RevocationList.CheckSignatureFrom] instead. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreateCRL",
				Description:      "CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates. Deprecated: this method does not generate an RFC 5280 conformant X.509 v2 CRL. To generate a standards compliant CRL, use [CreateRevocationList] instead. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CertificateInvalidError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckSignature",
				Description:      "CheckSignature verifies that signature is a valid signature over signed from c's public key. This is a low-level API that performs no validity checks on the certificate. [MD5WithRSA] signatures are rejected, while [SHA1WithRSA] and [ECDSAWithSHA1] signatures are currently accepted. ",
				ReceiverTypeName: "CertificateRequest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ConstraintViolationError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "HostnameError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InsecureAlgorithmError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements [encoding.TextAppender] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements [encoding.TextMarshaler] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements [encoding.TextUnmarshaler] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalOIDText",
				Description:      "",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements [encoding.BinaryAppender] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements [encoding.BinaryMarshaler] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements [encoding.BinaryUnmarshaler] ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether s and other are equal. ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EqualASN1OID",
				Description:      "EqualASN1OID returns whether an OID equals an asn1.ObjectIdentifier. If asn1.ObjectIdentifier cannot represent the OID specified by oid, because a component of OID requires more than 31 bits, it returns false. ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "Strings returns the string representation of the Object Identifier. ",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "toASN1OID",
				Description:      "",
				ReceiverTypeName: "OID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ObjectIdentifier",
						TypePkgName: "asn1",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "Strings returns the string representation of the Object Identifier. ",
				ReceiverTypeName: "PublicKeyAlgorithm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckSignatureFrom",
				Description:      "CheckSignatureFrom verifies that the signature on c is a valid signature from parent. This is a low-level API that performs very limited checks, and not a full path verifier. Most users should use [Certificate.Verify] instead. ",
				ReceiverTypeName: "RevocationList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isRSAPSS",
				Description:      "",
				ReceiverTypeName: "SignatureAlgorithm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hashFunc",
				Description:      "",
				ReceiverTypeName: "SignatureAlgorithm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "Strings returns the string representation of the Object Identifier. ",
				ReceiverTypeName: "SignatureAlgorithm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SystemRootsError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "SystemRootsError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnhandledCriticalExtension",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownAuthorityError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"tls": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "AlertError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "leaf",
				Description:      "leaf returns the parsed leaf certificate, either from c.Leaf or by parsing the corresponding c.Certificate[0]. ",
				ReceiverTypeName: "Certificate",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "x509",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Context",
				Description:      "Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. ",
				ReceiverTypeName: "CertificateRequestInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			methodSet{
				Name:             "SupportsCertificate",
				Description:      "SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility. If this [ClientHelloInfo] was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated [Config]. Note that if GetConfigForClient returns a different [Config], the change can't be accounted for by this method. This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost. ",
				ReceiverTypeName: "CertificateRequestInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CertificateVerificationError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "CertificateVerificationError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ClientAuthType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Context",
				Description:      "Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. ",
				ReceiverTypeName: "ClientHelloInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			methodSet{
				Name:             "SupportsCertificate",
				Description:      "SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility. If this [ClientHelloInfo] was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated [Config]. Note that if GetConfigForClient returns a different [Config], the change can't be accounted for by this method. This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost. ",
				ReceiverTypeName: "ClientHelloInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ResumptionState",
				Description:      "ResumptionState returns the session ticket sent by the server (also known as the session's identity) and the state necessary to resume this session. It can be called by [ClientSessionCache.Put] to serialize (with [SessionState.Bytes]) and store the session. ",
				ReceiverTypeName: "ClientSessionState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "SessionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ticketKeyFromBytes",
				Description:      "ticketKeyFromBytes converts from the external representation of a session ticket key to a ticketKey. Externally, session ticket keys are 32 random bytes and this function expands that into sufficient name and key material. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ticketKey",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a [Config] that is being used concurrently by a TLS client or server. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Config",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "initLegacySessionTicketKeyRLocked",
				Description:      "initLegacySessionTicketKeyRLocked ensures the legacy SessionTicketKey field is randomized if empty, and that sessionTicketKeys is populated from it otherwise. ",
				ReceiverTypeName: "Config",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ticketKeys",
				Description:      "ticketKeys returns the ticketKeys for this connection. If configForClient has explicitly set keys, those will be returned. Otherwise, the keys on c will be used and may be rotated if auto-managed. During rotation, any expired session ticket keys are deleted from c.sessionTicketKeys. If the session ticket key that is currently encrypting tickets (ie. the first ticketKey in c.sessionTicketKeys) is not fresh, then a new session ticket key will be created and prepended to c.sessionTicketKeys. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]crypto/tls.ticketKey",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetSessionTicketKeys",
				Description:      "SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty. Calling this function will turn off automatic session ticket key rotation. If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised. ",
				ReceiverTypeName: "Config",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rand",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "time",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "supportedCipherSuites",
				Description:      "supportedCipherSuites returns the supported TLS 1.0â1.2 cipher suites in an undefined order. For preference ordering, use [Config.cipherSuites]. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint16",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "maxSupportedVersion",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "curvePreferences",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]crypto/tls.CurveID",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "supportsCurve",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mutualVersion",
				Description:      "mutualVersion returns the protocol version to use given the advertised versions of the peer. The highest supported version is preferred. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getCertificate",
				Description:      "getCertificate returns the best certificate for the given ClientHelloInfo, defaulting to the first element of c.Certificates. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BuildNameToCertificate",
				Description:      "BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates. Deprecated: NameToCertificate only allows associating a single certificate with a given name. Leave that field nil to let the library select the first compatible chain from Certificates. ",
				ReceiverTypeName: "Config",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeKeyLog",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncryptTicket",
				Description:      "EncryptTicket encrypts a ticket with the [Config]'s configured (or default) session ticket keys. It can be used as a [Config.WrapSession] implementation. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encryptTicket",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecryptTicket",
				Description:      "DecryptTicket decrypts a ticket encrypted by [Config.EncryptTicket]. It can be used as a [Config.UnwrapSession] implementation. If the ticket can't be decrypted or parsed, DecryptTicket returns (nil, nil). ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SessionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decryptTicket",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LocalAddr",
				Description:      "LocalAddr returns the local network address. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "RemoteAddr",
				Description:      "RemoteAddr returns the remote network address. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "SetDeadline",
				Description:      "SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means [Conn.Read] and [Conn.Write] will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetReadDeadline",
				Description:      "SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means [Conn.Read] will not time out. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetWriteDeadline",
				Description:      "SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means [Conn.Write] will not time out. After a [Conn.Write] has timed out, the TLS state is corrupt and all future writes will return the same error. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NetConn",
				Description:      "NetConn returns the underlying connection that is wrapped by c. Note that writing to or reading from this connection directly will corrupt the TLS session. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "newRecordHeaderError",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RecordHeaderError",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "readRecord",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readChangeCipherSpec",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readRecordOrCCS",
				Description:      "readRecordOrCCS reads one or more TLS records from the connection and updates the record layer state. Some invariants: - c.in must be locked - c.input must be empty During the handshake one and only one of the following will happen: - c.hand grows - c.in.changeCipherSpec is called - an error is returned After the handshake one and only one of the following will happen: - c.hand grows - c.input is set - an error is returned ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "retryReadRecord",
				Description:      "retryReadRecord recurs into readRecordOrCCS to drop a non-advancing record, like a warning alert, empty application_data, or a change_cipher_spec in TLS 1.3. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFromUntil",
				Description:      "readFromUntil reads from r into c.rawInput until c.rawInput contains at least n bytes or else returns an error. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendAlertLocked",
				Description:      "sendAlertLocked sends a TLS alert message. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendAlert",
				Description:      "sendAlert sends a TLS alert message. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "maxPayloadSizeForWrite",
				Description:      "maxPayloadSizeForWrite returns the maximum TLS payload size to use for the next application data record. There is the following trade-off: - For latency-sensitive applications, such as web browsing, each TLS record should fit in one TCP segment. - For throughput-sensitive applications, such as large file transfers, larger TLS records better amortize framing and encryption overheads. A simple heuristic that works well in practice is to use small records for the first 1MB of data, then use larger records for subsequent data, and reset back to smaller records after the connection becomes idle. See \"High Performance Web Networking\", Chapter 4, or: https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/ In the interests of simplicity and determinism, this code does not attempt to reset the record size once the connection is idle, however. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "flush",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeRecordLocked",
				Description:      "writeRecordLocked writes a TLS record with the given type and payload to the connection and updates the record layer state. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeHandshakeRecord",
				Description:      "writeHandshakeRecord writes a handshake message to the connection and updates the record layer state. If transcript is non-nil the marshaled message is written to it. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeChangeCipherRecord",
				Description:      "writeChangeCipherRecord writes a ChangeCipherSpec message to the connection and updates the record layer state. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHandshakeBytes",
				Description:      "readHandshakeBytes reads handshake data until c.hand contains at least n bytes. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHandshake",
				Description:      "readHandshake reads the next handshake message from the record layer. If transcript is non-nil, the message is written to the passed transcriptHash. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalHandshakeMessage",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "handshakeMessage",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleRenegotiation",
				Description:      "handleRenegotiation processes a HelloRequest handshake message. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handlePostHandshakeMessage",
				Description:      "handlePostHandshakeMessage processes a handshake message arrived after the handshake is complete. Up to TLS 1.2, it indicates the start of a renegotiation. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleKeyUpdate",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the connection. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseWrite",
				Description:      "CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use [Conn.Close]. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "closeNotify",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Handshake",
				Description:      "Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first [Conn.Read] or [Conn.Write] will call it automatically. For control over canceling or setting a timeout on a handshake, use [Conn.HandshakeContext] or the [Dialer]'s DialContext method instead. In order to avoid denial of service attacks, the maximum RSA key size allowed in certificates sent by either the TLS server or client is limited to 8192 bits. This limit can be overridden by setting tlsmaxrsasize in the GODEBUG environment variable (e.g. GODEBUG=tlsmaxrsasize=4096). ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HandshakeContext",
				Description:      "HandshakeContext runs the client or server handshake protocol if it has not yet been run. The provided Context must be non-nil. If the context is canceled before the handshake is complete, the handshake is interrupted and an error is returned. Once the handshake has completed, cancellation of the context will not affect the connection. Most uses of this package need not call HandshakeContext explicitly: the first [Conn.Read] or [Conn.Write] will call it automatically. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handshakeContext",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "connectionStateLocked",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ConnectionState",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "OCSPResponse",
				Description:      "OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.) ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "VerifyHostname",
				Description:      "VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "processECHClientHello",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "clientHelloMsg",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "echServerContext",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeClientHello",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "clientHelloMsg",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "keySharePrivateKeys",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "echClientContext",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "clientHandshake",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "loadSession",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SessionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "EarlySecret",
						TypePkgName: "tls13",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pickTLSVersion",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "verifyServerCertificate",
				Description:      "verifyServerCertificate parses and verifies the provided chain, setting c.verifiedChains and c.peerCertificates or sending the appropriate alert. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getClientCertificate",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "clientSessionCacheKey",
				Description:      "clientSessionCacheKey returns a key used to cache sessionTickets that could be used to resume previously negotiated TLS sessions with a server. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleNewSessionTicket",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "serverHandshake",
				Description:      "serverHandshake performs a TLS handshake as a server. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readClientHello",
				Description:      "readClientHello reads a ClientHello message and selects the protocol version. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "clientHelloMsg",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "echServerContext",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "processCertsFromClient",
				Description:      "processCertsFromClient takes a chain of client certificates either from a certificateMsg message or a certificateMsgTLS13 message and verifies them. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendSessionTicket",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "quicReadHandshakeBytes",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "quicSetReadSecret",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicSetWriteSecret",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicWriteCryptoData",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicResumeSession",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "quicStoreSession",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicSetTransportParameters",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicGetTransportParameters",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "quicHandshakeComplete",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicRejectedEarlyData",
				Description:      "",
				ReceiverTypeName: "Conn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "quicWaitForSignal",
				Description:      "quicWaitForSignal notifies the QUICConn that handshake progress is blocked, and waits for a signal that the handshake should proceed. The handshake may become blocked waiting for handshake bytes or for the user to provide transport parameters. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sessionState",
				Description:      "sessionState returns a partially filled-out [SessionState] with information from the current connection. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SessionState",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "ExportKeyingMaterial",
				Description:      "ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, or if the connections supports neither TLS 1.3 nor Extended Master Secret, this function will return an error. Exporting key material without Extended Master Secret or TLS 1.3 was disabled in Go 1.22 due to security issues (see the Security Considerations sections of RFC 5705 and RFC 7627), but can be re-enabled with the GODEBUG setting tlsunsafeekm=1. ",
				ReceiverTypeName: "ConnectionState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CurveID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dial",
				Description:      "Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "netDialer",
				Description:      "",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Dialer",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "DialContext",
				Description:      "DialContext connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection. The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. The returned [Conn], if any, will always be of type *[Conn]. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ECHRejectionError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Start",
				Description:      "Start starts the client or server handshake protocol. It may produce connection events, which may be read with [QUICConn.NextEvent]. Start must be called at most once. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NextEvent",
				Description:      "NextEvent returns the next event occurring on the connection. It returns an event with a Kind of [QUICNoEvent] when no events are available. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "QUICEvent",
						TypePkgName: "tls",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the connection. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HandleData",
				Description:      "HandleData handles handshake bytes received from the peer. It may produce connection events, which may be read with [QUICConn.NextEvent]. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SendSessionTicket",
				Description:      "SendSessionTicket sends a session ticket to the client. It produces connection events, which may be read with [QUICConn.NextEvent]. Currently, it can only be called once. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StoreSession",
				Description:      "StoreSession stores a session previously received in a QUICStoreSession event in the ClientSessionCache. The application may process additional events or modify the SessionState before storing the session. ",
				ReceiverTypeName: "QUICConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetTransportParameters",
				Description:      "SetTransportParameters sets the transport parameters to send to the peer. Server connections may delay setting the transport parameters until after receiving the client's transport parameters. See [QUICTransportParametersRequired]. ",
				ReceiverTypeName: "QUICConn",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "QUICEncryptionLevel",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "RecordHeaderError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes encodes the session, including any private fields, so that it can be parsed by [ParseSessionState]. The encoding contains secret values critical to the security of future and possibly past sessions. The specific encoding should be considered opaque and may change incompatibly between Go versions. ",
				ReceiverTypeName: "SessionState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SignatureScheme",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"build": []methodSet{
			methodSet{
				Name:             "joinPath",
				Description:      "joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "splitPathList",
				Description:      "splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isAbsPath",
				Description:      "isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isDir",
				Description:      "isDir calls ctxt.IsDir (if not nil) or else uses os.Stat. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasSubdir",
				Description:      "hasSubdir calls ctxt.HasSubdir (if not nil) or else uses the local file system to answer the question. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readDir",
				Description:      "readDir calls ctxt.ReadDir (if not nil) or else os.ReadDir. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]io/fs.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "openFile",
				Description:      "openFile calls ctxt.OpenFile (if not nil) or else os.Open. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isFile",
				Description:      "isFile determines whether path is a file by trying to open it. It reuses openFile instead of adding another function to the list in Context. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "gopath",
				Description:      "gopath returns the list of Go path directories. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SrcDirs",
				Description:      "SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportDir",
				Description:      "ImportDir is like [Import] but processes the Go package found in the named directory. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "build",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Import",
				Description:      "Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path. In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for: - .go files in package documentation - files starting with _ or . (likely editor temporary files) - files with build constraints not satisfied by the context If an error occurs, Import returns a non-nil error and a non-nil *[Package] containing partial information. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "build",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "importGo",
				Description:      "importGo checks whether it can use the go command to find the directory for path. If using the go command is not appropriate, importGo returns errNoModules. Otherwise, importGo tries using the go command and reports whether that succeeded. Using the go command lets build.Import and build.Context.Import find code in Go modules. In the long term we want tools to use go/packages (currently golang.org/x/tools/go/packages), which will also use the go command. Invoking the go command here is not very efficient in that it computes information about the requested package and all dependencies and then only reports about the requested package. Then we reinvoke it for every dependency. But this is still better than not working at all. See golang.org/issue/26504. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchFile",
				Description:      "MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a [Package] created by [ImportDir] of that directory. MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "matchFile",
				Description:      "matchFile determines whether the file with the given name in the given directory should be included in the package being constructed. If the file should be included, matchFile returns a non-nil *fileInfo (and a nil error). Non-nil errors are reserved for unexpected problems. If name denotes a Go program, matchFile reads until the end of the imports and returns that section of the file in the fileInfo's header field, even though it only considers text until the first non-comment for go:build lines. If allTags is non-nil, matchFile records any encountered build tag by setting allTags[tag] = true. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "fileInfo",
						TypePkgName: "build",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shouldBuild",
				Description:      "shouldBuild reports whether it is okay to use this file, The rule is that in the file's leading run of // comments and blank lines, which must be followed by a blank line (to avoid including a Go package clause doc comment), lines beginning with '//go:build' are taken as build directives. The file is accepted only if each such line lists something matching the file. For example: //go:build windows linux marks the file as applicable only on Windows and Linux. For each build tag it consults, shouldBuild sets allTags[tag] = true. shouldBuild reports whether the file should be built and whether a //go:binary-only-package comment was found. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "saveCgo",
				Description:      "saveCgo saves the information from the #cgo lines in the import \"C\" comment. These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives that affect the way cgo's C code is built. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makePathsAbsolute",
				Description:      "makePathsAbsolute looks for compiler options that take paths and makes them absolute. We do this because through the 1.8 release we ran the compiler in the package directory, so any relative -I or -L options would be relative to that directory. In 1.9 we changed to running the compiler in the build directory, to get consistent build results (issue #19964). To keep builds working, we change any relative -I or -L options to be absolute. Using filepath.IsAbs and filepath.Join here means the results will be different on different systems, but that's OK: -I and -L options are inherently system-dependent. ",
				ReceiverTypeName: "Context",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "matchAuto",
				Description:      "matchAuto interprets text as either a +build or //go:build expression (whichever works), reporting whether the expression matches the build context. matchAuto is only used for testing of tag evaluation and in #cgo lines, which accept either syntax. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "eval",
				Description:      "",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "matchTag",
				Description:      "matchTag reports whether the name is one of: cgo (if cgo is enabled) $GOOS $GOARCH ctxt.Compiler linux (if GOOS = android) solaris (if GOOS = illumos) darwin (if GOOS = ios) unix (if this is a Unix GOOS) boringcrypto (if GOEXPERIMENT=boringcrypto is enabled) tag (if tag is listed in ctxt.BuildTags, ctxt.ToolTags, or ctxt.ReleaseTags) It records all consulted tags in allTags. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goodOSArchFile",
				Description:      "goodOSArchFile returns false if the name contains a $GOOS or $GOARCH suffix which does not match the current system. The recognized name formats are: name_$(GOOS).* name_$(GOARCH).* name_$(GOOS)_$(GOARCH).* name_$(GOOS)_test.* name_$(GOARCH)_test.* name_$(GOOS)_$(GOARCH)_test.* Exceptions: if GOOS=android, then files with GOOS=linux are also matched. if GOOS=illumos, then files with GOOS=solaris are also matched. if GOOS=ios, then files with GOOS=darwin are also matched. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "MultiplePackageError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "NoGoError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsCommand",
				Description:      "IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named \"main\" are treated as commands. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"fs": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "FileMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsDir",
				Description:      "IsDir reports whether m describes a directory. That is, it tests for the [ModeDir] bit being set in m. ",
				ReceiverTypeName: "FileMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsRegular",
				Description:      "IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set. ",
				ReceiverTypeName: "FileMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Perm",
				Description:      "Perm returns the Unix permission bits in m (m & [ModePerm]). ",
				ReceiverTypeName: "FileMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileMode",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns type bits in m (m & [ModeType]). ",
				ReceiverTypeName: "FileMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileMode",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "PathError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "PathError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "Timeout reports whether this error represents a timeout. ",
				ReceiverTypeName: "PathError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"rc4": []methodSet{
			methodSet{
				Name:             "Reset",
				Description:      "Reset zeros the key data and makes the [Cipher] unusable. Deprecated: Reset can't guarantee that the key will be entirely removed from the process's memory. ",
				ReceiverTypeName: "Cipher",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "XORKeyStream",
				Description:      "XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src must overlap entirely or not at all. ",
				ReceiverTypeName: "Cipher",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "KeySizeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"xml": []methodSet{
			methodSet{
				Name:             "Copy",
				Description:      "Copy creates a new copy of StartElement. ",
				ReceiverTypeName: "CharData",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CharData",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy creates a new copy of StartElement. ",
				ReceiverTypeName: "Comment",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Comment",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "Decode",
				Description:      "Decode works like [Unmarshal], except it reads the decoder stream to find the start element. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodeElement",
				Description:      "DecodeElement works like [Unmarshal] except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to [Unmarshal] for some elements. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalInterface",
				Description:      "unmarshalInterface unmarshals a single XML element into val. start is the opening tag of the element. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalTextInterface",
				Description:      "unmarshalTextInterface unmarshals a single XML element into val. The chardata contained in the element (but not its children) is passed to the text unmarshaler. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalAttr",
				Description:      "unmarshalAttr unmarshals a single XML attribute into val. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshal",
				Description:      "Unmarshal a single XML element into val. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unmarshalPath",
				Description:      "unmarshalPath walks down an XML structure looking for wanted paths, and calls unmarshal on them. The consumed result tells whether XML elements have been consumed from the Decoder until start's matching end element, or if it's still untouched because start is uninteresting for sv's fields. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Skip",
				Description:      "Skip reads tokens until it has consumed the end element matching the most recent start element already consumed, skipping nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "translate",
				Description:      "Apply name space translation to name n. The default name space (for Space==\"\") applies only to element names, not to attribute names. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "switchToReader",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "push",
				Description:      "push adds parent elements to the stack and writes open tags. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "stack",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "pop",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "stack",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "pushEOF",
				Description:      "Record that after the current element is finished (that element is already pushed on the stack) Token should return EOF until popEOF is called. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "popEOF",
				Description:      "Undo a pushEOF. The element must have been finished, so the EOF should be at the top of the stack. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pushElement",
				Description:      "Record that we are starting an element with the given name. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "pushNs",
				Description:      "Record that we are changing the value of ns[local]. The old value is url, ok. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "syntaxError",
				Description:      "Creates a SyntaxError with the current line number. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "popElement",
				Description:      "Record that we are ending an element with the given name. The name must match the record at the top of the stack, which must be a pushElement record. After popping the element, apply any undo records from the stack to restore the name translations that existed before we saw this element. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "autoClose",
				Description:      "If the top element on the stack is autoclosing and t is not the end tag, invent the end tag. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "xml",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RawToken",
				Description:      "RawToken is like [Decoder.Token] but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "xml",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rawToken",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "xml",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "attrval",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "space",
				Description:      "Skip spaces if any ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "getc",
				Description:      "Read a single byte. If there is no byte to read, return ok==false and leave the error in d.err. Maintain line number. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InputOffset",
				Description:      "InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InputPos",
				Description:      "InputPos returns the line of the current decoder position and the 1 based input position of the line. The position gives the location of the end of the most recently returned token. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "savedOffset",
				Description:      "Return saved offset. If we did ungetc (nextByte >= 0), have to back up one. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mustgetc",
				Description:      "Must read a single byte. If there is no byte to read, set d.err to SyntaxError(\"unexpected EOF\") and return ok==false ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ungetc",
				Description:      "Unread a single byte. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "text",
				Description:      "Read plain text section (XML calls it character data). If quote >= 0, we are in a quoted string and need to find the matching quote. If cdata == true, we are in a <![CDATA[ section and need to find ]]>. On failure return nil and leave the error in d.err. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nsname",
				Description:      "Get name space name: name with a : stuck in the middle. The part before the : is the name space identifier. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Name",
						TypePkgName: "xml",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "name",
				Description:      "Get name: /first(first|second)*/ Do not set d.err if the name is missing (unless unexpected EOF is received): let the caller provide better context. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readName",
				Description:      "Read a name and append its bytes to d.buf. The name is delimited by any single-byte character not valid in names. All multi-byte characters are accepted; the caller must check their validity. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy creates a new copy of StartElement. ",
				ReceiverTypeName: "Directive",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Directive",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "Indent",
				Description:      "Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode writes the XML encoding of v to the stream. See the documentation for [Marshal] for details about the conversion of Go values to XML. Encode calls [Encoder.Flush] before returning. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodeElement",
				Description:      "EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding. See the documentation for [Marshal] for details about the conversion of Go values to XML. EncodeElement calls [Encoder.Flush] before returning. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodeToken",
				Description:      "EncodeToken writes the given XML token to the stream. It returns an error if [StartElement] and [EndElement] tokens are not properly matched. EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer. EncodeToken allows writing a [ProcInst] with Target set to \"xml\" only as the first token in the stream. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush flushes any buffered XML to the underlying writer. See the [Encoder.EncodeToken] documentation for details about when it is necessary. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close the Encoder, indicating that no more data will be written. It flushes any buffered XML to the underlying writer and returns an error if the written XML is invalid (e.g. by containing unclosed elements). ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy creates a new copy of StartElement. ",
				ReceiverTypeName: "ProcInst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcInst",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy creates a new copy of StartElement. ",
				ReceiverTypeName: "StartElement",
				Returns: []returnSet{
					returnSet{
						TypeName:    "StartElement",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "End returns the corresponding XML end element. ",
				ReceiverTypeName: "StartElement",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EndElement",
						TypePkgName: "xml",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SyntaxError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "TagPathError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnmarshalError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnsupportedTypeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"errors": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Code",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"png": []methodSet{
			methodSet{
				Name:             "Encode",
				Description:      "Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not [image.NRGBA] might be encoded lossily. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "FormatError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnsupportedError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"slicewriter": []methodSet{
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "WriteSeeker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek repositions the read/write position of the WriteSeeker within its internally maintained slice. Note that it is not possible to expand the size of the slice using SEEK_SET; trying to seek outside the slice will result in an error. ",
				ReceiverTypeName: "WriteSeeker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesWritten",
				Description:      "BytesWritten returns the underlying byte slice for the WriteSeeker, containing the data written to it via Write/Seek calls. ",
				ReceiverTypeName: "WriteSeeker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "WriteSeeker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"lazytemplate": []methodSet{
			methodSet{
				Name:             "tp",
				Description:      "",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Template",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "build",
				Description:      "",
				ReceiverTypeName: "Template",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Execute",
				Description:      "",
				ReceiverTypeName: "Template",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"testdeps": []methodSet{
			methodSet{
				Name:             "MatchString",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StartCPUProfile",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StopCPUProfile",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "WriteProfileTo",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StartTestLog",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StopTestLog",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetPanicOnExit0",
				Description:      "SetPanicOnExit0 tells the os package whether to panic on os.Exit(0). ",
				ReceiverTypeName: "TestDeps",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CoordinateFuzzing",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RunFuzzWorker",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadCorpus",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/fuzz.CorpusEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckCorpus",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ResetCoverage",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SnapshotCoverage",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "InitRuntimeCoverage",
				Description:      "",
				ReceiverTypeName: "TestDeps",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "func(string, string) (string, error)",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "func() float64",
						TypePkgName: "",
					},
				},
			},
		},
		"io": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "LimitedReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "OffsetWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteAt",
				Description:      "",
				ReceiverTypeName: "OffsetWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "",
				ReceiverTypeName: "OffsetWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "PipeReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "PipeReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseWithError",
				Description:      "CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err. CloseWithError never overwrites the previous error if it exists and always returns nil. ",
				ReceiverTypeName: "PipeReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "PipeWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "PipeWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseWithError",
				Description:      "CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err. CloseWithError never overwrites the previous error if it exists and always returns nil. ",
				ReceiverTypeName: "PipeWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "SectionReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "",
				ReceiverTypeName: "SectionReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadAt",
				Description:      "",
				ReceiverTypeName: "SectionReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of the section in bytes. ",
				ReceiverTypeName: "SectionReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Outer",
				Description:      "Outer returns the underlying [ReaderAt] and offsets for the section. The returned values are the same that were passed to [NewSectionReader] when the [SectionReader] was created. ",
				ReceiverTypeName: "SectionReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReaderAt",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
		},
		"crypto": []methodSet{
			methodSet{
				Name:             "HashFunc",
				Description:      "HashFunc simply returns the value of h so that [Hash] implements [SignerOpts]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "New",
				Description:      "New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "hash",
					},
				},
			},
			methodSet{
				Name:             "Available",
				Description:      "Available reports whether the given hash function is linked into the binary. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"hpke": []methodSet{
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "Recipient",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "Sender",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"netip": []methodSet{
			methodSet{
				Name:             "v4",
				Description:      "v4 returns the i'th byte of ip. If ip is not an IPv4, v4 returns unspecified garbage. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "v6",
				Description:      "v6 returns the i'th byte of ip. If ip is an IPv4 address, this accesses the IPv4-mapped IPv6 address form of the IP. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "v6u16",
				Description:      "v6u16 returns the i'th 16-bit word of ip. If ip is an IPv4 address, this accesses the IPv4-mapped IPv6 address form of the IP. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isZero",
				Description:      "isZero reports whether ip is the zero value of the IP type. The zero value is not a valid IP address of any type. Note that \"0.0.0.0\" and \"::\" are not the zero value. Use IsUnspecified to check for these values instead. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether the [Addr] is an initialized address (not the zero Addr). Note that \"0.0.0.0\" and \"::\" are both valid values. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BitLen",
				Description:      "BitLen returns the number of bits in the IP address: 128 for IPv6, 32 for IPv4, and 0 for the zero [Addr]. Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses and therefore have bit length 128. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Zone",
				Description:      "Zone returns ip's IPv6 scoped addressing zone, if any. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Compare",
				Description:      "Compare returns an integer comparing two IPs. The result will be 0 if ip == ip2, -1 if ip < ip2, and +1 if ip > ip2. The definition of \"less than\" is the same as the [Addr.Less] method. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Less",
				Description:      "Less reports whether ip sorts before ip2. IP addresses sort first by length, then their address. IPv6 addresses with zones sort just after the same address without a zone. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Is4",
				Description:      "Is4 reports whether ip is an IPv4 address. It returns false for IPv4-mapped IPv6 addresses. See [Addr.Unmap]. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Is4In6",
				Description:      "Is4In6 reports whether ip is an \"IPv4-mapped IPv6 address\" as defined by RFC 4291. That is, it reports whether ip is in ::ffff:0:0/96. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Is6",
				Description:      "Is6 reports whether ip is an IPv6 address, including IPv4-mapped IPv6 addresses. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unmap",
				Description:      "Unmap returns ip with any IPv4-mapped IPv6 address prefix removed. That is, if ip is an IPv6 address wrapping an IPv4 address, it returns the wrapped IPv4 address. Otherwise it returns ip unmodified. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "WithZone",
				Description:      "WithZone returns an IP that's the same as ip but with the provided zone. If zone is empty, the zone is removed. If ip is an IPv4 address, WithZone is a no-op and returns ip unchanged. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "withoutZone",
				Description:      "withoutZone unconditionally strips the zone from ip. It's similar to WithZone, but small enough to be inlinable. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "hasZone",
				Description:      "hasZone reports whether ip has an IPv6 zone. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLinkLocalUnicast",
				Description:      "IsLinkLocalUnicast reports whether ip is a link-local unicast address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLoopback",
				Description:      "IsLoopback reports whether ip is a loopback address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsMulticast",
				Description:      "IsMulticast reports whether ip is a multicast address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsInterfaceLocalMulticast",
				Description:      "IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local multicast address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLinkLocalMulticast",
				Description:      "IsLinkLocalMulticast reports whether ip is a link-local multicast address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsGlobalUnicast",
				Description:      "IsGlobalUnicast reports whether ip is a global unicast address. It returns true for IPv6 addresses which fall outside of the current IANA-allocated 2000::/3 global unicast space, with the exception of the link-local address space. It also returns true even if ip is in the IPv4 private address space or IPv6 unique local address space. It returns false for the zero [Addr]. For reference, see RFC 1122, RFC 4291, and RFC 4632. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsPrivate",
				Description:      "IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the same as [net.IP.IsPrivate]. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsUnspecified",
				Description:      "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\". Note that the zero [Addr] is not an unspecified address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Prefix",
				Description:      "Prefix keeps only the top b bits of IP, producing a Prefix of the specified length. If ip is a zero [Addr], Prefix always returns a zero Prefix and a nil error. Otherwise, if bits is less than zero or greater than ip.BitLen(), Prefix returns an error. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Prefix",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "As16",
				Description:      "As16 returns the IP address in its 16-byte representation. IPv4 addresses are returned as IPv4-mapped IPv6 addresses. IPv6 addresses with zones are returned without their zone (use the [Addr.Zone] method to get it). The ip zero value returns all zeroes. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "As4",
				Description:      "As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation. If ip is the zero [Addr] or an IPv6 address, As4 panics. Note that 0.0.0.0 is not the zero Addr. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[4]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AsSlice",
				Description:      "AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next returns the address following ip. If there is none, it returns the zero [Addr]. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "Prev",
				Description:      "Prev returns the IP before ip. If there is none, it returns the IP zero value. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the string form of the IP address ip. It returns one of 5 forms: - \"invalid IP\", if ip is the zero [Addr] - IPv4 dotted decimal (\"192.0.2.1\") - IPv6 (\"2001:db8::1\") - \"::ffff:1.2.3.4\" (if [Addr.Is4In6]) - IPv6 with zone (\"fe80:db8::1%eth0\") Note that unlike package net's IP.String method, IPv4-mapped IPv6 addresses format with a \"::ffff:\" prefix before the dotted quad. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendTo",
				Description:      "AppendTo appends a text encoding of ip, as generated by [Addr.MarshalText], to b and returns the extended buffer. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "string4",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendTo4",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "string4In6",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendTo4In6",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "string6",
				Description:      "string6 formats ip in IPv6 textual representation. It follows the guidelines in section 4 of RFC 5952 (https://tools.ietf.org/html/rfc5952#section-4): no unnecessary zeros, use :: to elide the longest run of zeros, and don't use :: to compact a single zero field. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendTo6",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StringExpanded",
				Description:      "StringExpanded is like [Addr.String] but IPv6 addresses are expanded with leading zeroes and no \"::\" compression. For example, \"2001:db8::1\" becomes \"2001:0db8:0000:0000:0000:0000:0000:0001\". ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements the [encoding.TextAppender] interface, It is the same as [Addr.AppendTo]. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements the [encoding.TextMarshaler] interface, The encoding is the same as returned by [Addr.String], with one exception: If ip is the zero [Addr], the encoding is the empty string. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by [ParseAddr]. If text is empty, UnmarshalText sets *ip to the zero [Addr] and returns no error. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements the [encoding.BinaryAppender] interface. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "marshalBinarySize",
				Description:      "",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements the [encoding.BinaryMarshaler] interface. It returns a zero-length slice for the zero [Addr], the 4-byte form for an IPv4 address, and the 16-byte form with zone appended for an IPv6 address. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. It expects data in the form generated by MarshalBinary. ",
				ReceiverTypeName: "Addr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Port",
				Description:      "Port returns p's port. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether the [Addr] is an initialized address (not the zero Addr). Note that \"0.0.0.0\" and \"::\" are both valid values. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Compare",
				Description:      "Compare returns an integer comparing two IPs. The result will be 0 if ip == ip2, -1 if ip < ip2, and +1 if ip > ip2. The definition of \"less than\" is the same as the [Addr.Less] method. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the string form of the IP address ip. It returns one of 5 forms: - \"invalid IP\", if ip is the zero [Addr] - IPv4 dotted decimal (\"192.0.2.1\") - IPv6 (\"2001:db8::1\") - \"::ffff:1.2.3.4\" (if [Addr.Is4In6]) - IPv6 with zone (\"fe80:db8::1%eth0\") Note that unlike package net's IP.String method, IPv4-mapped IPv6 addresses format with a \"::ffff:\" prefix before the dotted quad. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendTo",
				Description:      "AppendTo appends a text encoding of ip, as generated by [Addr.MarshalText], to b and returns the extended buffer. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements the [encoding.TextAppender] interface, It is the same as [Addr.AppendTo]. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements the [encoding.TextMarshaler] interface, The encoding is the same as returned by [Addr.String], with one exception: If ip is the zero [Addr], the encoding is the empty string. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by [ParseAddr]. If text is empty, UnmarshalText sets *ip to the zero [Addr] and returns no error. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements the [encoding.BinaryAppender] interface. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements the [encoding.BinaryMarshaler] interface. It returns a zero-length slice for the zero [Addr], the 4-byte form for an IPv4 address, and the 16-byte form with zone appended for an IPv6 address. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. It expects data in the form generated by MarshalBinary. ",
				ReceiverTypeName: "AddrPort",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"testpty": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "PtyError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "PtyError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"lzw": []methodSet{
			methodSet{
				Name:             "readLSB",
				Description:      "readLSB returns the next code for \"Least Significant Bits first\" data. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readMSB",
				Description:      "readMSB returns the next code for \"Most Significant Bits first\" data. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read implements io.Reader, reading uncompressed bytes from its underlying reader. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decode",
				Description:      "decode decompresses bytes from r and leaves them in d.toRead. read specifies how to decode bytes into codes. litWidth is the width in bits of literal codes. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [Reader] and returns an error for any future read operation. It does not close the underlying [io.Reader]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset clears the [Reader]'s state and allows it to be reused again as a new [Reader]. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeLSB",
				Description:      "writeLSB writes the code c for \"Least Significant Bits first\" data. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeMSB",
				Description:      "writeMSB writes the code c for \"Most Significant Bits first\" data. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "incHi",
				Description:      "incHi increments e.hi and checks for both overflow and running out of unused codes. In the latter case, incHi sends a clear code, resets the writer state and returns errOutOfCodes. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes a compressed representation of p to w's underlying writer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [Reader] and returns an error for any future read operation. It does not close the underlying [io.Reader]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset clears the [Reader]'s state and allows it to be reused again as a new [Reader]. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
		},
		"regexp": []methodSet{
			methodSet{
				Name:             "tryBacktrack",
				Description:      "tryBacktrack runs a backtracking search starting at pos. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "backtrack",
				Description:      "backtrack runs a backtracking search of prog on the input starting at pos. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "doOnePass",
				Description:      "doOnePass implements r.doExecute using the one-pass execution engine. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "doMatch",
				Description:      "doMatch reports whether either r, b or s match the regexp. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "doExecute",
				Description:      "doExecute finds the leftmost match in the input, appends the position of its subexpressions to dstCap and returns dstCap. nil is returned if no matches are found and non-nil if matches are found. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the source text used to compile the regular expression. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy returns a new [Regexp] object copied from re. Calling [Regexp.Longest] on one copy does not affect another. Deprecated: In earlier releases, when using a [Regexp] in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different [Regexp.Longest] settings. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "regexp",
					},
				},
			},
			methodSet{
				Name:             "Longest",
				Description:      "Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the [Regexp] and may not be called concurrently with any other methods. ",
				ReceiverTypeName: "Regexp",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "get",
				Description:      "get returns a machine to use for matching re. It uses the re's machine cache if possible, to avoid unnecessary allocation. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "machine",
						TypePkgName: "regexp",
					},
				},
			},
			methodSet{
				Name:             "put",
				Description:      "put returns a machine to the correct machine pool. ",
				ReceiverTypeName: "Regexp",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "NumSubexp",
				Description:      "NumSubexp returns the number of parenthesized subexpressions in this [Regexp]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SubexpNames",
				Description:      "SubexpNames returns the names of the parenthesized subexpressions in this [Regexp]. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SubexpIndex",
				Description:      "SubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name. Note that multiple subexpressions can be written using the same name, as in (?P<bob>a+)(?P<bob>b+), which declares two subexpressions named \"bob\". In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LiteralPrefix",
				Description:      "LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchReader",
				Description:      "MatchReader reports whether the text returned by the [io.RuneReader] contains any match of the regular expression re. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchString",
				Description:      "MatchString reports whether the string s contains any match of the regular expression re. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Match",
				Description:      "Match reports whether the byte slice b contains any match of the regular expression re. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllString",
				Description:      "ReplaceAllString returns a copy of src, replacing matches of the [Regexp] with the replacement string repl. Inside repl, $ signs are interpreted as in [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllLiteralString",
				Description:      "ReplaceAllLiteralString returns a copy of src, replacing matches of the [Regexp] with the replacement string repl. The replacement repl is substituted directly, without using [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllStringFunc",
				Description:      "ReplaceAllStringFunc returns a copy of src in which all matches of the [Regexp] have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "replaceAll",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAll",
				Description:      "ReplaceAll returns a copy of src, replacing matches of the [Regexp] with the replacement text repl. Inside repl, $ signs are interpreted as in [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllLiteral",
				Description:      "ReplaceAllLiteral returns a copy of src, replacing matches of the [Regexp] with the replacement bytes repl. The replacement repl is substituted directly, without using [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReplaceAllFunc",
				Description:      "ReplaceAllFunc returns a copy of src in which all matches of the [Regexp] have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using [Regexp.Expand]. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pad",
				Description:      "The number of capture values in the program may correspond to fewer capturing expressions than are in the regexp. For example, \"(a){0}\" turns into an empty program, so the maximum capture in the program is 0 but we need to return an expression for \\1. Pad appends -1s to the slice a as needed. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "allMatches",
				Description:      "allMatches calls deliver at most n times with the location of successive matches in the input text. The input text is b if non-nil, otherwise s. ",
				ReceiverTypeName: "Regexp",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Find",
				Description:      "Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindIndex",
				Description:      "FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindString",
				Description:      "FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use [Regexp.FindStringIndex] or [Regexp.FindStringSubmatch] if it is necessary to distinguish these cases. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindStringIndex",
				Description:      "FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindReaderIndex",
				Description:      "FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the [io.RuneReader]. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindSubmatch",
				Description:      "FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Expand",
				Description:      "Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by [Regexp.FindSubmatchIndex]. In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P<name>...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice. In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0. To insert a literal $ in the output, use $$ in the template. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExpandString",
				Description:      "ExpandString is like [Regexp.Expand] but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "expand",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindSubmatchIndex",
				Description:      "FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindStringSubmatch",
				Description:      "FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindStringSubmatchIndex",
				Description:      "FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindReaderSubmatchIndex",
				Description:      "FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the [io.RuneReader], and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAll",
				Description:      "FindAll is the 'All' version of [Regexp.Find]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllIndex",
				Description:      "FindAllIndex is the 'All' version of [Regexp.FindIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllString",
				Description:      "FindAllString is the 'All' version of [Regexp.FindString]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllStringIndex",
				Description:      "FindAllStringIndex is the 'All' version of [Regexp.FindStringIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllSubmatch",
				Description:      "FindAllSubmatch is the 'All' version of [Regexp.FindSubmatch]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][][]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllSubmatchIndex",
				Description:      "FindAllSubmatchIndex is the 'All' version of [Regexp.FindSubmatchIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllStringSubmatch",
				Description:      "FindAllStringSubmatch is the 'All' version of [Regexp.FindStringSubmatch]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllStringSubmatchIndex",
				Description:      "FindAllStringSubmatchIndex is the 'All' version of [Regexp.FindStringSubmatchIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Split",
				Description:      "Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches. The slice returned by this method consists of all the substrings of s not contained in the slice returned by [Regexp.FindAllString]. When called on an expression that contains no metacharacters, it is equivalent to [strings.SplitN]. Example: s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5) // s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"] The count determines the number of substrings to return: - n > 0: at most n substrings; the last substring will be the unsplit remainder; - n == 0: the result is nil (zero substrings); - n < 0: all substrings. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements [encoding.TextAppender]. The output matches that of calling the [Regexp.String] method. Note that the output is lossy in some cases: This method does not indicate POSIX regular expressions (i.e. those compiled by calling [CompilePOSIX]), or those for which the [Regexp.Longest] method has been called. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements [encoding.TextMarshaler]. The output matches that of calling the [Regexp.AppendText] method. See [Regexp.AppendText] for more information. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements [encoding.TextUnmarshaler] by calling [Compile] on the encoded value. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"image": []methodSet{
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "AlphaAt",
				Description:      "",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alpha",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Alpha",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "Alpha",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetAlpha",
				Description:      "",
				ReceiverTypeName: "Alpha",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Alpha",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Alpha16At",
				Description:      "",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alpha16",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Alpha16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "Alpha16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetAlpha16",
				Description:      "",
				ReceiverTypeName: "Alpha16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Alpha16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "CMYKAt",
				Description:      "",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CMYK",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "CMYK",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "CMYK",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetCMYK",
				Description:      "",
				ReceiverTypeName: "CMYK",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "CMYK",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "GrayAt",
				Description:      "",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Gray",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Gray",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "Gray",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetGray",
				Description:      "",
				ReceiverTypeName: "Gray",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Gray",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Gray16At",
				Description:      "",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Gray16",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Gray16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "Gray16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetGray16",
				Description:      "",
				ReceiverTypeName: "Gray16",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Gray16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "NRGBAAt",
				Description:      "",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NRGBA",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "NRGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "NRGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetNRGBA",
				Description:      "",
				ReceiverTypeName: "NRGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "NRGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "NRGBA64At",
				Description:      "",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NRGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "NRGBA64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "NRGBA64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetNRGBA64",
				Description:      "",
				ReceiverTypeName: "NRGBA64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "NRGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "NYCbCrAAt",
				Description:      "",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NYCbCrA",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "AOffset",
				Description:      "AOffset returns the index of the first element of A that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "NYCbCrA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Paletted",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "Paletted",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ColorIndexAt",
				Description:      "",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetColorIndex",
				Description:      "",
				ReceiverTypeName: "Paletted",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Paletted",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of p like \"(3,4)\". ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add returns the vector p+q. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub returns the vector p-q. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul returns the vector p*k. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Div",
				Description:      "Div returns the vector p/k. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "In",
				Description:      "In reports whether p is in r. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Mod",
				Description:      "Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Eq",
				Description:      "Eq reports whether p and q are equal. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBAAt",
				Description:      "",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "RGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "RGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA",
				Description:      "",
				ReceiverTypeName: "RGBA",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "RGBA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "PixOffset",
				Description:      "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "RGBA64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRGBA64",
				Description:      "",
				ReceiverTypeName: "RGBA64",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "RGBA64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of p like \"(3,4)\". ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dx",
				Description:      "Dx returns r's width. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dy",
				Description:      "Dy returns r's height. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns r's width and height. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add returns the vector p+q. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub returns the vector p-q. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Inset",
				Description:      "Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Intersect",
				Description:      "Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Union",
				Description:      "Union returns the smallest rectangle that contains both r and s. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Empty",
				Description:      "Empty reports whether the rectangle contains no points. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Eq",
				Description:      "Eq reports whether p and q are equal. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overlaps",
				Description:      "Overlaps reports whether r and s have a non-empty intersection. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "In",
				Description:      "In reports whether p is in r. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Canon",
				Description:      "Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Rectangle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Convert",
				Description:      "",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "Uniform",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColorModel",
				Description:      "ColorModel implements the [Image] interface. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Model",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Bounds",
				Description:      "Bounds implements the [Image] interface. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rectangle",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At implements the [Image] interface. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "RGBA64At",
				Description:      "RGBA64At implements the [RGBA64Image] interface. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RGBA64",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "YCbCrAt",
				Description:      "",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "YCbCr",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "YOffset",
				Description:      "YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "COffset",
				Description:      "COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y). ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SubImage",
				Description:      "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Image",
						TypePkgName: "image",
					},
				},
			},
			methodSet{
				Name:             "Opaque",
				Description:      "Opaque scans the entire image and reports whether it is fully opaque. ",
				ReceiverTypeName: "YCbCr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of p like \"(3,4)\". ",
				ReceiverTypeName: "YCbCrSubsampleRatio",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"decodemeta": []methodSet{
			methodSet{
				Name:             "readHeader",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readStringTable",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PackagePath",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PackageName",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ModulePath",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumFuncs",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFunc",
				Description:      "ReadFunc reads the coverage meta-data for the function with index 'findex', filling it into the FuncDesc pointed to by 'f'. ",
				ReceiverTypeName: "CoverageMetaDataDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFileHeader",
				Description:      "",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rdUint64",
				Description:      "",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumPackages",
				Description:      "NumPackages returns the number of packages for which this file contains meta-data. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CounterMode",
				Description:      "CounterMode returns the counter mode (set, count, atomic) used when building for coverage for the program that produce this meta-data file. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterMode",
						TypePkgName: "coverage",
					},
				},
			},
			methodSet{
				Name:             "CounterGranularity",
				Description:      "CounterGranularity returns the counter granularity (single counter per function, or counter per block) selected when building for coverage for the program that produce this meta-data file. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterGranularity",
						TypePkgName: "coverage",
					},
				},
			},
			methodSet{
				Name:             "FileHash",
				Description:      "FileHash returns the hash computed for all of the package meta-data blobs. Coverage counter data files refer to this hash, and the hash will be encoded into the meta-data file name. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetPackageDecoder",
				Description:      "GetPackageDecoder requests a decoder object for the package within the meta-data file whose index is 'pkIdx'. If the CoverageMetaFileReader was set up with a read-only file view, a pointer into that file view will be returned, otherwise the buffer 'payloadbuf' will be written to (or if it is not of sufficient size, a new buffer will be allocated). Return value is the decoder, a byte slice with the encoded meta-data, and an error. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CoverageMetaDataDecoder",
						TypePkgName: "decodemeta",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetPackagePayload",
				Description:      "GetPackagePayload returns the raw (encoded) meta-data payload for the package with index 'pkIdx'. As with GetPackageDecoder, if the CoverageMetaFileReader was set up with a read-only file view, a pointer into that file view will be returned, otherwise the buffer 'payloadbuf' will be written to (or if it is not of sufficient size, a new buffer will be allocated). Return value is the decoder, a byte slice with the encoded meta-data, and an error. ",
				ReceiverTypeName: "CoverageMetaFileReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"dag": []methodSet{
			methodSet{
				Name:             "Transpose",
				Description:      "Transpose reverses all edges in g. ",
				ReceiverTypeName: "Graph",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Topo",
				Description:      "Topo returns a topological sort of g. This function is deterministic. ",
				ReceiverTypeName: "Graph",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "TransitiveReduction",
				Description:      "TransitiveReduction removes edges from g that are transitively reachable. g must be transitively closed. ",
				ReceiverTypeName: "Graph",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "addNode",
				Description:      "",
				ReceiverTypeName: "Graph",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddEdge",
				Description:      "",
				ReceiverTypeName: "Graph",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DelEdge",
				Description:      "",
				ReceiverTypeName: "Graph",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HasEdge",
				Description:      "",
				ReceiverTypeName: "Graph",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Edges",
				Description:      "",
				ReceiverTypeName: "Graph",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
		},
		"smtp": []methodSet{
			methodSet{
				Name:             "Close",
				Description:      "Close closes the connection. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hello",
				Description:      "hello runs a hello exchange if needed. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Hello",
				Description:      "Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as \"localhost\" automatically otherwise. If Hello is called, it must be called before any of the other methods. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cmd",
				Description:      "cmd is a convenience function that sends a command and returns the response ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "helo",
				Description:      "helo sends the HELO greeting to the server. It should be used only when the server does not support ehlo. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ehlo",
				Description:      "ehlo sends the EHLO (extended hello) greeting to the server. It should be the preferred greeting for servers that support it. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StartTLS",
				Description:      "StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "TLSConnectionState",
				Description:      "TLSConnectionState returns the client's TLS connection state. The return values are their zero values if [Client.StartTLS] did not succeed. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ConnectionState",
						TypePkgName: "tls",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Verify",
				Description:      "Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Mail",
				Description:      "Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. If the server supports the SMTPUTF8 extension, Mail adds the SMTPUTF8 parameter. This initiates a mail transaction and is followed by one or more [Client.Rcpt] calls. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Rcpt",
				Description:      "Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to [Client.Mail] and may be followed by a [Client.Data] call or another Rcpt call. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to [Client.Rcpt]. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Extension",
				Description:      "Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset sends the RSET command to the server, aborting the current mail transaction. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Noop",
				Description:      "Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Quit",
				Description:      "Quit sends the QUIT command and closes the connection to the server. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"os": []methodSet{
			methodSet{
				Name:             "Readdir",
				Description:      "Readdir reads the contents of the directory associated with file and returns a slice of up to n [FileInfo] values, as would be returned by [Lstat], in directory order. Subsequent calls on the same file will yield further FileInfos. If n > 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is [io.EOF]. If n <= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error. Most clients are better served by the more efficient ReadDir method. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Readdirnames",
				Description:      "Readdirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names. If n > 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is [io.EOF]. If n <= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadDir",
				Description:      "ReadDir reads the contents of the directory associated with the file f and returns a slice of [DirEntry] values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory. If n > 0, ReadDir returns at most n DirEntry records. In this case, if ReadDir returns an empty slice, it will return an error explaining why. At the end of a directory, the error is [io.EOF]. If n <= 0, ReadDir returns all the DirEntry records remaining in the directory. When it succeeds, it returns a nil error (not io.EOF). ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]os.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readdir",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]os.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the file as presented to Open. It is safe to call Name after [Close]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads up to len(b) bytes from the File and stores them in b. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadAt",
				Description:      "ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n < len(b). At end of file, that error is io.EOF. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements io.ReaderFrom. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes len(b) bytes from b to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b). ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteAt",
				Description:      "WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b). If file was opened with the [O_APPEND] flag, WriteAt returns an error. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements io.WriterTo. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with [O_APPEND] is not specified. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString is like Write, but writes the contents of string s rather than a slice of bytes. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wrapErr",
				Description:      "wrapErr wraps an error that occurred during an operation on an open file. It passes io.EOF through unchanged, otherwise converts poll.ErrFileClosing to ErrClosed and wraps the error in a PathError. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chmod",
				Description:      "Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type [*PathError]. A different subset of the mode bits are used, depending on the operating system. On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and [ModeSticky] are used. On Windows, only the 0o200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0o400 for a read-only file and 0o600 for a readable+writable file. On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive], and [ModeTemporary] are used. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetDeadline",
				Description:      "SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline. Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do. A deadline is an absolute time after which I/O operations fail with an error instead of blocking. The deadline applies to all future and pending I/O, not just the immediately following call to Read or Write. After a deadline has been exceeded, the connection can be refreshed by setting a deadline in the future. If the deadline is exceeded a call to Read or Write or to other I/O methods will return an error that wraps ErrDeadlineExceeded. This can be tested using errors.Is(err, os.ErrDeadlineExceeded). That error implements the Timeout method, and calling the Timeout method will return true, but there are other possible errors for which the Timeout will return true even if the deadline has not been exceeded. An idle timeout can be implemented by repeatedly extending the deadline after successful Read or Write calls. A zero value for t means I/O operations will not time out. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetReadDeadline",
				Description:      "SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetWriteDeadline",
				Description:      "SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n > 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw file. This implements the syscall.Conn interface. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fd",
				Description:      "Fd returns the system file descriptor or handle referencing the open file. If f is closed, the descriptor becomes invalid. If f is garbage collected, a finalizer may close the descriptor, making it invalid; see [runtime.SetFinalizer] for more information on when a finalizer might be run. Do not close the returned descriptor; that could cause a later close of f to close an unrelated descriptor. Fd's behavior differs on some platforms: - On Unix and Windows, [File.SetDeadline] methods will stop working. - On Windows, the file descriptor will be disassociated from the Go runtime I/O completion port if there are no concurrent I/O operations on the file. For most uses prefer the f.SyscallConn method. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [File], rendering it unusable for I/O. On files that support [File.SetDeadline], any pending I/O operations will be canceled and return immediately with an [ErrClosed] error. Close will return an error if it has already been called. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "read",
				Description:      "read reads up to len(b) bytes from the File. It returns the number of bytes read and an error, if any. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pread",
				Description:      "pread reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. EOF is signaled by a zero count with err set to nil. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pwrite",
				Description:      "pwrite writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "chmod",
				Description:      "See docs in file.go:Chmod. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chown",
				Description:      "Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type [*PathError]. On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or [syscall.EPLAN9] error, wrapped in [*PathError]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Truncate",
				Description:      "Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sync",
				Description:      "Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chdir",
				Description:      "Chdir changes the current working directory to the named directory. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setDeadline",
				Description:      "setDeadline sets the read and write deadline. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setReadDeadline",
				Description:      "setReadDeadline sets the read deadline. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setWriteDeadline",
				Description:      "setWriteDeadline sets the write deadline. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkValid",
				Description:      "checkValid checks whether f is valid for use. If not, it returns an appropriate error, perhaps incorporating the operation name op. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fd",
				Description:      "fd is the Unix implementation of Fd. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "seek",
				Description:      "seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stat",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "LinkError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "LinkError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleTransientAcquire",
				Description:      "handleTransientAcquire returns the process handle or, if the process is not ready, the current status. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "processStatus",
						TypePkgName: "os",
					},
				},
			},
			methodSet{
				Name:             "handleTransientRelease",
				Description:      "handleTransientRelease releases a handle returned by handleTransientAcquire. ",
				ReceiverTypeName: "Process",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "pidStatus",
				Description:      "pidStatus returns the current process status. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "processStatus",
						TypePkgName: "os",
					},
				},
			},
			methodSet{
				Name:             "Release",
				Description:      "Release releases any resources associated with the [Process] p, rendering it unusable in the future. Release only needs to be called if [Process.Wait] is not. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "doRelease",
				Description:      "doRelease releases a [Process], setting the status to newStatus. If the previous status is not statusOK, this does nothing. It returns the previous status. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "processStatus",
						TypePkgName: "os",
					},
				},
			},
			methodSet{
				Name:             "Kill",
				Description:      "Kill causes the [Process] to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Wait",
				Description:      "Wait waits for the [Process] to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcessState",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "kill",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wait",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcessState",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pidWait",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcessState",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "signal",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pidSignal",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pidfdWait",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcessState",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pidfdSendSignal",
				Description:      "",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "blockUntilWaitable",
				Description:      "blockUntilWaitable attempts to block until a call to p.Wait will succeed immediately, and reports whether it has done so. It does not actually call p.Wait. This version is used on systems that do not implement waitid, or where we have not implemented it yet. Note that this is racy: a call to Process.Signal can in an extremely unlikely case send a signal to the wrong process, see issue #13987. ",
				ReceiverTypeName: "Process",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UserTime",
				Description:      "UserTime returns the user CPU time of the exited process and its children. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "SystemTime",
				Description:      "SystemTime returns the system CPU time of the exited process and its children. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Exited",
				Description:      "Exited reports whether the program has exited. On Unix systems this reports true if the program exited due to calling exit, but false if the program terminated due to a signal. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Success",
				Description:      "Success reports whether the program exited successfully, such as with exit status 0 on Unix. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sys",
				Description:      "Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as [syscall.WaitStatus] on Unix, to access its contents. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SysUsage",
				Description:      "SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as [*syscall.Rusage] on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.) ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pid",
				Description:      "Pid returns the process id of the exited process. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "exited",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "success",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sys",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sysUsage",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExitCode",
				Description:      "ExitCode returns the exit code of the exited process, or -1 if the process hasn't exited or was terminated by a signal. ",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "userTime",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "systemTime",
				Description:      "",
				ReceiverTypeName: "ProcessState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the file as presented to Open. It is safe to call Name after [Close]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [File], rendering it unusable for I/O. On files that support [File.SetDeadline], any pending I/O operations will be canceled and return immediately with an [ErrClosed] error. Close will return an error if it has already been called. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode [O_RDONLY]. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Create",
				Description:      "Create creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0o666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode [O_RDWR]. The directory containing the file must already exist. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OpenFile",
				Description:      "OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag is passed, it is created with mode perm (before umask); the containing directory must exist. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OpenRoot",
				Description:      "OpenRoot opens the named directory. It follows symbolic links in the directory name. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Root",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chmod",
				Description:      "Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type [*PathError]. A different subset of the mode bits are used, depending on the operating system. On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and [ModeSticky] are used. On Windows, only the 0o200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0o400 for a read-only file and 0o600 for a readable+writable file. On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive], and [ModeTemporary] are used. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Mkdir",
				Description:      "Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MkdirAll",
				Description:      "MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chown",
				Description:      "Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type [*PathError]. On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or [syscall.EPLAN9] error, wrapped in [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Lchown",
				Description:      "Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type [*PathError]. On Windows, it always returns the [syscall.EWINDOWS] error, wrapped in [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Chtimes",
				Description:      "Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. A zero [time.Time] value will leave the corresponding file time unchanged. The underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Remove",
				Description:      "Remove removes the named file or (empty) directory. If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RemoveAll",
				Description:      "RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type [*PathError]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stat",
				Description:      "",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Lstat",
				Description:      "",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "os.FileInfo",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Readlink",
				Description:      "Readlink returns the destination of the named symbolic link. If there is an error, it will be of type [*PathError]. If the link destination is relative, Readlink returns the relative path without resolving it to an absolute one. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Rename",
				Description:      "Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. If newpath already exists and is a directory, Rename returns an error. OS-specific restrictions may apply when oldpath and newpath are in different directories. Even within the same directory, on non-Unix platforms Rename is not an atomic operation. If there is an error, it will be of type *LinkError. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Link",
				Description:      "Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Symlink",
				Description:      "Symlink creates newname as a symbolic link to oldname. On Windows, a symlink to a non-existent oldname creates a file symlink; if oldname is later created as a directory the symlink will not work. If there is an error, it will be of type *LinkError. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFile",
				Description:      "The ReadFile method calls the [ReadFile] function for the file with the given name in the directory. The function provides robust handling for small files and special file systems. Through this method, dirFS implements [io/fs.ReadFileFS]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteFile",
				Description:      "WriteFile writes data to the named file, creating it if necessary. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions. Since WriteFile requires multiple system calls to complete, a failure mid-operation can leave the file in a partially written state. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "logOpen",
				Description:      "",
				ReceiverTypeName: "Root",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "logStat",
				Description:      "",
				ReceiverTypeName: "Root",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "FS",
				Description:      "FS returns a file system (an fs.FS) for the tree of files in the root. The result implements [io/fs.StatFS], [io/fs.ReadFileFS], [io/fs.ReadDirFS], and [io/fs.ReadLinkFS]. ",
				ReceiverTypeName: "Root",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FS",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SyscallError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "SyscallError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "Timeout reports whether this error represents a timeout. ",
				ReceiverTypeName: "SyscallError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"zlib": []methodSet{
			methodSet{
				Name:             "Reset",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeHeader",
				Description:      "writeHeader writes the ZLIB header. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes a compressed form of p to the underlying [io.Writer]. The compressed bytes are not necessarily flushed until the [Writer] is closed or explicitly flushed. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush flushes the Writer to its underlying [io.Writer]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Calling Close does not close the wrapped [io.Reader] originally passed to [NewReader]. In order for the ZLIB checksum to be verified, the reader must be fully consumed until the [io.EOF]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"bigmod": []methodSet{
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of m in bytes. ",
				ReceiverTypeName: "Modulus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BitLen",
				Description:      "BitLen returns the size of m in bits. ",
				ReceiverTypeName: "Modulus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "expand",
				Description:      "expand expands x to n limbs, leaving its value unchanged. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "reset",
				Description:      "reset returns a zero nat of n limbs, reusing x's storage if n <= cap(x.limbs). ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "resetToBytes",
				Description:      "resetToBytes assigns x = b, where b is a slice of big-endian bytes, resizing n to the appropriate size. The announced length of x is set based on the actual bit size of the input, ignoring leading zeroes. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "trim",
				Description:      "trim reduces the size of x to match its value. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "set",
				Description:      "set assigns x = y, optionally resizing x to the appropriate size. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Bits",
				Description:      "Bits returns x as a little-endian slice of uint. The length of the slice matches the announced length of x. The result and x share the same underlying array. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns x as a zero-extended big-endian byte slice. The size of the slice will match the size of m. x must have the same size as m and it must be less than or equal to m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes assigns x = b, where b is a slice of big-endian bytes. SetBytes returns an error if b >= m. The output will be resized to the size of m and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetOverflowingBytes",
				Description:      "SetOverflowingBytes assigns x = b, where b is a slice of big-endian bytes. SetOverflowingBytes returns an error if b has a longer bit length than m, but reduces overflowing values up to 2^âlog2(m)â - 1. The output will be resized to the size of m and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setBytes",
				Description:      "",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetUint",
				Description:      "SetUint assigns x = y. The output will be resized to a single limb and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if x == y, and 0 otherwise. Both operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero returns 1 if x == 0, and 0 otherwise. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "IsOne",
				Description:      "IsOne returns 1 if x == 1, and 0 otherwise. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "IsMinusOne",
				Description:      "IsMinusOne returns 1 if x == -1 mod m, and 0 otherwise. The length of x must be the same as the modulus. x must already be reduced modulo m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "IsOdd",
				Description:      "IsOdd returns 1 if x is odd, and 0 otherwise. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "TrailingZeroBitsVarTime",
				Description:      "TrailingZeroBitsVarTime returns the number of trailing zero bits in x. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cmpGeq",
				Description:      "cmpGeq returns 1 if x >= y, and 0 otherwise. Both operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "choice",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "assign",
				Description:      "assign sets x <- y if on == 1, and does nothing otherwise. Both operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "add",
				Description:      "add computes x += y and returns the carry. Both operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sub",
				Description:      "sub computes x -= y. It returns the borrow of the subtraction. Both operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ShiftRightVarTime",
				Description:      "ShiftRightVarTime sets x = x >> n. The announced length of x is unchanged. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "BitLenVarTime",
				Description:      "BitLenVarTime returns the actual size of x in bits. The actual size of x (but nothing more) leaks through timing side-channels. Note that this is ordinarily secret, as opposed to the announced size of x. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shiftIn",
				Description:      "shiftIn calculates x = x << _W + y mod m. This assumes that x is already reduced mod m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Mod",
				Description:      "Mod calculates out = x mod m. This works regardless how large the value of x is. The output will be resized to the size of m and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "ExpandFor",
				Description:      "ExpandFor ensures x has the right size to work with operations modulo m. The announced size of x must be smaller than or equal to that of m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "resetFor",
				Description:      "resetFor ensures out has the right size to work with operations modulo m. out is zeroed and may start at any size. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "maybeSubtractModulus",
				Description:      "maybeSubtractModulus computes x -= m if and only if x >= m or if \"always\" is yes. It can be used to reduce modulo m a value up to 2m - 1, which is a common range for results computed by higher level operations. always is usually a carry that indicates that the operation that produced x overflowed its size, meaning abstractly x > 2^_W*n > m even if x < m. x and m operands must have the same announced length. ",
				ReceiverTypeName: "Nat",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub computes x = x - y mod m. The length of both operands must be the same as the modulus. Both operands must already be reduced modulo m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "SubOne",
				Description:      "SubOne computes x = x - 1 mod m. The length of x must be the same as the modulus. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add computes x = x + y mod m. The length of both operands must be the same as the modulus. Both operands must already be reduced modulo m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "montgomeryRepresentation",
				Description:      "montgomeryRepresentation calculates x = x * R mod m, with R = 2^(_W * n) and n = len(m.nat.limbs). Faster Montgomery multiplication replaces standard modular multiplication for numbers in this representation. This assumes that x is already reduced mod m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "montgomeryReduction",
				Description:      "montgomeryReduction calculates x = x / R mod m, with R = 2^(_W * n) and n = len(m.nat.limbs). This assumes that x is already reduced mod m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "montgomeryMul",
				Description:      "montgomeryMul calculates x = a * b / R mod m, with R = 2^(_W * n) and n = len(m.nat.limbs), also known as a Montgomery multiplication. All inputs should be the same length and already reduced modulo m. x will be resized to the size of m and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul calculates x = x * y mod m. The length of both operands must be the same as the modulus. Both operands must already be reduced modulo m. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "Exp",
				Description:      "Exp calculates out = x^e mod m. The exponent e is represented in big-endian order. The output will be resized to the size of m and overwritten. x must already be reduced modulo m. m must be odd, or Exp will panic. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "ExpShortVarTime",
				Description:      "ExpShortVarTime calculates out = x^e mod m. The output will be resized to the size of m and overwritten. x must already be reduced modulo m. This leaks the exponent through timing side-channels. m must be odd, or ExpShortVarTime will panic. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
				},
			},
			methodSet{
				Name:             "InverseVarTime",
				Description:      "InverseVarTime calculates x = aâ»Â¹ mod m and returns (x, true) if a is invertible. Otherwise, InverseVarTime returns (x, false) and x is not modified. a must be reduced modulo m, but doesn't need to have the same size. The output will be resized to the size of m and overwritten. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GCDVarTime",
				Description:      "GCDVarTime calculates x = GCD(a, b) where at least one of a or b is odd, and both are non-zero. If GCDVarTime returns an error, x is not modified. The output will be resized to the size of the larger of a and b. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nat",
						TypePkgName: "bigmod",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DivShortVarTime",
				Description:      "DivShortVarTime calculates x = x / y and returns the remainder. It panics if y is zero. ",
				ReceiverTypeName: "Nat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
		},
		"exec": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "String returns a human-readable description of c. It is intended only for debugging. In particular, it is not suitable for use as input to a shell. The output of String may vary across Go releases. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "argv",
				Description:      "",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "childStdin",
				Description:      "",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "childStdout",
				Description:      "",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "childStderr",
				Description:      "",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writerDescriptor",
				Description:      "writerDescriptor returns an os.File to which the child process can write to send data to w. If w is nil, writerDescriptor returns a File that writes to os.DevNull. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Run",
				Description:      "Run starts the specified command and waits for it to complete. The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. If the command starts but does not complete successfully, the error is of type [*ExitError]. Other error types may be returned for other situations. If the calling goroutine has locked the operating system thread with [runtime.LockOSThread] and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Start",
				Description:      "Start starts the specified command but does not wait for it to complete. If Start returns successfully, the c.Process field will be set. After a successful call to Start the [Cmd.Wait] method must be called in order to release associated system resources. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "watchCtx",
				Description:      "watchCtx watches c.ctx until it is able to send a result to resultc. If c.ctx is done before a result can be sent, watchCtx calls c.Cancel, and/or kills cmd.Process it after c.WaitDelay has elapsed. watchCtx manipulates c.goroutineErr, so its result must be received before c.awaitGoroutines is called. ",
				ReceiverTypeName: "Cmd",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Wait",
				Description:      "Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete. The command must have been started by [Cmd.Start]. The returned error is nil if the command runs, has no problems copying stdin, stdout, and stderr, and exits with a zero exit status. If the command fails to run or doesn't complete successfully, the error is of type [*ExitError]. Other error types may be returned for I/O problems. If any of c.Stdin, c.Stdout or c.Stderr are not an [*os.File], Wait also waits for the respective I/O loop copying to or from the process to complete. Wait releases any resources associated with the [Cmd]. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "awaitGoroutines",
				Description:      "awaitGoroutines waits for the results of the goroutines copying data to or from the command's I/O pipes. If c.WaitDelay elapses before the goroutines complete, awaitGoroutines forcibly closes their pipes and returns ErrWaitDelay. If timer is non-nil, it must send to timer.C at the end of c.WaitDelay. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Output",
				Description:      "Output runs the command and returns its standard output. Any returned error will usually be of type [*ExitError]. If c.Stderr was nil and the returned error is of type [*ExitError], Output populates the Stderr field of the returned error. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CombinedOutput",
				Description:      "CombinedOutput runs the command and returns its combined standard output and standard error. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StdinPipe",
				Description:      "StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after [Cmd.Wait] sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StdoutPipe",
				Description:      "StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts. [Cmd.Wait] will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to call [Cmd.Run] when using StdoutPipe. See the example for idiomatic usage. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StderrPipe",
				Description:      "StderrPipe returns a pipe that will be connected to the command's standard error when the command starts. [Cmd.Wait] will close the pipe after seeing the command exit, so most callers need not close the pipe themselves. It is thus incorrect to call Wait before all reads from the pipe have completed. For the same reason, it is incorrect to use [Cmd.Run] when using StderrPipe. See the StdoutPipe example for idiomatic usage. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "environ",
				Description:      "environ returns a best-effort copy of the environment in which the command would be run as it is currently configured. If an error occurs in computing the environment, it is returned alongside the best-effort copy. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Environ",
				Description:      "Environ returns a copy of the environment in which the command would be run as it is currently configured. ",
				ReceiverTypeName: "Cmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "Error",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"hex": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InvalidByteError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"driver": []methodSet{
			methodSet{
				Name:             "ConvertValue",
				Description:      "",
				ReceiverTypeName: "NotNull",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ConvertValue",
				Description:      "",
				ReceiverTypeName: "Null",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LastInsertId",
				Description:      "",
				ReceiverTypeName: "RowsAffected",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"comment": []methodSet{
			methodSet{
				Name:             "block",
				Description:      "block prints the block x to out. ",
				ReceiverTypeName: "Code",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "text",
				Description:      "text prints the text sequence x to out. ",
				ReceiverTypeName: "DocLink",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DefaultURL",
				Description:      "DefaultURL constructs and returns the documentation URL for l, using baseURL as a prefix for links to other packages. The possible forms returned by DefaultURL are: - baseURL/ImportPath, for a link to another package - baseURL/ImportPath#Name, for a link to a const, func, type, or var in another package - baseURL/ImportPath#Recv.Name, for a link to a method in another package - #Name, for a link to a const, func, type, or var in this package - #Recv.Name, for a link to a method in this package If baseURL ends in a trailing slash, then DefaultURL inserts a slash between ImportPath and # in the anchored forms. For example, here are some baseURL values and URLs they can generate: \"/pkg/\" â \"/pkg/math/#Sqrt\" \"/pkg\" â \"/pkg/math#Sqrt\" \"/\" â \"/math/#Sqrt\" \"\" â \"/math#Sqrt\" ",
				ReceiverTypeName: "DocLink",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "block",
				Description:      "block prints the block x to out. ",
				ReceiverTypeName: "Heading",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DefaultID",
				Description:      "DefaultID returns the default anchor ID for the heading h. The default anchor ID is constructed by converting every rune that is not alphanumeric ASCII to an underscore and then adding the prefix âhdr-â. For example, if the heading text is âGo Doc Commentsâ, the default ID is âhdr-Go_Doc_Commentsâ. ",
				ReceiverTypeName: "Heading",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "text",
				Description:      "text prints the text sequence x to out. ",
				ReceiverTypeName: "Italic",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "text",
				Description:      "text prints the text sequence x to out. ",
				ReceiverTypeName: "Link",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "block",
				Description:      "block prints the block x to out. ",
				ReceiverTypeName: "List",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "BlankBefore",
				Description:      "BlankBefore reports whether a reformatting of the comment should include a blank line before the list. The default rule is the same as for [BlankBetween]: if the list item content contains any blank lines (meaning at least one item has multiple paragraphs) then the list itself must be preceded by a blank line. A preceding blank line can be forced by setting [List].ForceBlankBefore. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlankBetween",
				Description:      "BlankBetween reports whether a reformatting of the comment should include a blank line between each pair of list items. The default rule is that if the list item content contains any blank lines (meaning at least one item has multiple paragraphs) then list items must themselves be separated by blank lines. Blank line separators can be forced by setting [List].ForceBlankBetween. ",
				ReceiverTypeName: "List",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "block",
				Description:      "block prints the block x to out. ",
				ReceiverTypeName: "Paragraph",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses the doc comment text and returns the *[Doc] form. Comment markers (/* // and */) in the text must have already been removed. ",
				ReceiverTypeName: "Parser",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Doc",
						TypePkgName: "comment",
					},
				},
			},
			methodSet{
				Name:             "text",
				Description:      "text prints the text sequence x to out. ",
				ReceiverTypeName: "Plain",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HTML",
				Description:      "HTML returns an HTML formatting of the [Doc]. See the [Printer] documentation for ways to customize the HTML output. ",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Markdown",
				Description:      "Markdown returns a Markdown formatting of the Doc. See the [Printer] documentation for ways to customize the Markdown output. ",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "headingLevel",
				Description:      "",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "headingID",
				Description:      "",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "docLinkURL",
				Description:      "",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Comment",
				Description:      "Comment returns the standard Go formatting of the [Doc], without any comment markers. ",
				ReceiverTypeName: "Printer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"plugin": []methodSet{
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines. ",
				ReceiverTypeName: "Plugin",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Symbol",
						TypePkgName: "plugin",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cookiejar": []methodSet{
			methodSet{
				Name:             "Cookies",
				Description:      "Cookies implements the Cookies method of the [http.CookieJar] interface. It returns an empty slice if the URL's scheme is not HTTP or HTTPS. ",
				ReceiverTypeName: "Jar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cookies",
				Description:      "cookies is like Cookies but takes the current time as a parameter. ",
				ReceiverTypeName: "Jar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetCookies",
				Description:      "SetCookies implements the SetCookies method of the [http.CookieJar] interface. It does nothing if the URL's scheme is not HTTP or HTTPS. ",
				ReceiverTypeName: "Jar",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setCookies",
				Description:      "setCookies is like SetCookies but takes the current time as parameter. ",
				ReceiverTypeName: "Jar",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "newEntry",
				Description:      "newEntry creates an entry from an http.Cookie c. now is the current time and is compared to c.Expires to determine deletion of c. defPath and host are the default-path and the canonical host name of the URL c was received from. remove records whether the jar should delete this cookie, as it has already expired with respect to now. In this case, e may be incomplete, but it will be valid to call e.id (which depends on e's Name, Domain and Path). A malformed c.Domain will result in an error. ",
				ReceiverTypeName: "Jar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "entry",
						TypePkgName: "cookiejar",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "domainAndType",
				Description:      "domainAndType determines the cookie's domain and hostOnly attribute. ",
				ReceiverTypeName: "Jar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"quick": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CheckEqualError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CheckError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getRand",
				Description:      "getRand returns the *rand.Rand to use for a given Config. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rand",
						TypePkgName: "rand",
					},
				},
			},
			methodSet{
				Name:             "getMaxCount",
				Description:      "getMaxCount returns the maximum number of iterations to run for a given Config. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SetupError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"profilerecord": []methodSet{
			methodSet{
				Name:             "InUseBytes",
				Description:      "",
				ReceiverTypeName: "MemProfileRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InUseObjects",
				Description:      "",
				ReceiverTypeName: "MemProfileRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
		},
		"runtime": []methodSet{
			methodSet{
				Name:             "Stop",
				Description:      "Stop cancels the cleanup call. Stop will have no effect if the cleanup call has already been queued for execution (because ptr became unreachable). To guarantee that Stop removes the cleanup function, the caller must ensure that the pointer that was passed to AddCleanup is reachable across the call to Stop. ",
				ReceiverTypeName: "Cleanup",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next returns a [Frame] representing the next call frame in the slice of PC values. If it has already returned all call frames, Next returns a zero [Frame]. The more result indicates whether the next call to Next will return a valid [Frame]. It does not necessarily indicate whether this call returned one. See the [Frames] example for idiomatic usage. ",
				ReceiverTypeName: "Frames",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Frame",
						TypePkgName: "runtime",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "raw",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "_func",
						TypePkgName: "runtime",
					},
				},
			},
			methodSet{
				Name:             "funcInfo",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "funcInfo",
						TypePkgName: "runtime",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the function. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Entry",
				Description:      "Entry returns the entry address of the function. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FileLine",
				Description:      "FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "startLine",
				Description:      "startLine returns the starting line number of the function. i.e., the line number of the func keyword. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InUseBytes",
				Description:      "InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes). ",
				ReceiverTypeName: "MemProfileRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InUseObjects",
				Description:      "InUseObjects returns the number of objects in use (AllocObjects - FreeObjects). ",
				ReceiverTypeName: "MemProfileRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stack",
				Description:      "Stack returns the stack trace associated with the record, a prefix of r.Stack0. ",
				ReceiverTypeName: "MemProfileRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RuntimeError",
				Description:      "",
				ReceiverTypeName: "PanicNilError",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pin",
				Description:      "Pin pins a Go object, preventing it from being moved or freed by the garbage collector until the [Pinner.Unpin] method has been called. A pointer to a pinned object can be directly stored in C memory or can be contained in Go memory passed to C functions. If the pinned object itself contains pointers to Go objects, these objects must be pinned separately if they are going to be accessed from C code. The argument must be a pointer of any type or an [unsafe.Pointer]. It's safe to call Pin on non-Go pointers, in which case Pin will do nothing. ",
				ReceiverTypeName: "Pinner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Unpin",
				Description:      "Unpin unpins all pinned objects of the [Pinner]. ",
				ReceiverTypeName: "Pinner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Stack",
				Description:      "Stack returns the stack trace associated with the record, a prefix of r.Stack0. ",
				ReceiverTypeName: "StackRecord",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RuntimeError",
				Description:      "",
				ReceiverTypeName: "TypeAssertionError",
				Returns:          []returnSet{},
			},
		},
		"drbg": []methodSet{
			methodSet{
				Name:             "update",
				Description:      "",
				ReceiverTypeName: "Counter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reseed",
				Description:      "",
				ReceiverTypeName: "Counter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Generate",
				Description:      "Generate produces at most maxRequestSize bytes of random data in out. ",
				ReceiverTypeName: "Counter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"rsa": []methodSet{
			methodSet{
				Name:             "Export",
				Description:      "Export returns the key parameters in big-endian byte slice format. P, Q, dP, dQ, and qInv may be nil if the key was created with NewPrivateKeyWithoutCRT. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HashFunc",
				Description:      "HashFunc returns opts.Hash so that [PSSOptions] implements [crypto.SignerOpts]. ",
				ReceiverTypeName: "PSSOptions",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "saltLength",
				Description:      "",
				ReceiverTypeName: "PSSOptions",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Public",
				Description:      "Public returns the public key corresponding to priv. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sign",
				Description:      "Sign signs digest with priv, reading randomness from rand. If opts is a *[PSSOptions] then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will be used. digest must be the result of hashing the input message using opts.HashFunc(). This method implements [crypto.Signer], which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Decrypt",
				Description:      "Decrypt decrypts ciphertext with priv. If opts is nil or of type *[PKCS1v15DecryptOptions] then PKCS #1 v1.5 decryption is performed. Otherwise opts must have type *[OAEPOptions] and OAEP decryption is done. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Validate",
				Description:      "Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem. It runs faster on valid keys if run after [PrivateKey.Precompute]. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Precompute",
				Description:      "Precompute performs some calculations that speed up private key operations in the future. It is safe to run on non-validated private keys. ",
				ReceiverTypeName: "PrivateKey",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "precompute",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrecomputedValues",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "precomputeLegacy",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrecomputedValues",
						TypePkgName: "rsa",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"fuzz": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "MalformedCorpusError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"synctest": []methodSet{
			methodSet{
				Name:             "Release",
				Description:      "Release releases the reference to the bubble, allowing it to become idle again. ",
				ReceiverTypeName: "Bubble",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Run",
				Description:      "",
				ReceiverTypeName: "Bubble",
				Returns:          []returnSet{},
			},
		},
		"unicode": []methodSet{
			methodSet{
				Name:             "ToUpper",
				Description:      "ToUpper maps the rune to upper case. ",
				ReceiverTypeName: "SpecialCase",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ToTitle",
				Description:      "ToTitle maps the rune to title case. ",
				ReceiverTypeName: "SpecialCase",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ToLower",
				Description:      "ToLower maps the rune to lower case. ",
				ReceiverTypeName: "SpecialCase",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
		},
		"asn1": []methodSet{
			methodSet{
				Name:             "At",
				Description:      "At returns the bit at the given index. If the index is out of range it returns 0. ",
				ReceiverTypeName: "BitString",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RightAlign",
				Description:      "RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString. ",
				ReceiverTypeName: "BitString",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether oi and other represent the same identifier. ",
				ReceiverTypeName: "ObjectIdentifier",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ObjectIdentifier",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "StructuralError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SyntaxError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"net": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "AddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "AddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "AddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [PacketConn] WriteTo method. ",
				ReceiverTypeName: "Buffers",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "Buffers",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "consume",
				Description:      "",
				ReceiverTypeName: "Buffers",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "DNSConfigError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "DNSConfigError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "DNSConfigError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "DNSConfigError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "DNSError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "DNSError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "DNSError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "DNSError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dualStack",
				Description:      "",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "deadline",
				Description:      "deadline returns the earliest of: - now+Timeout - d.Deadline - the context's deadline Or zero, if none of Timeout, Deadline, or context's deadline is set. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "resolver",
				Description:      "",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Resolver",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "fallbackDelay",
				Description:      "",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "MultipathTCP",
				Description:      "MultipathTCP reports whether MPTCP will be used. This method doesn't check if MPTCP is supported by the operating system or not. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetMultipathTCP",
				Description:      "SetMultipathTCP directs the [Dial] methods to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any. If MPTCP is not available on the host or not supported by the server, the Dial methods will fall back to TCP. ",
				ReceiverTypeName: "Dialer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Dial",
				Description:      "Dial connects to the address on the named network. Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\". For TCP and UDP networks, the address has the form \"host:port\". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions [JoinHostPort] and [SplitHostPort] manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds. Examples: Dial(\"tcp\", \"golang.org:http\") Dial(\"tcp\", \"192.0.2.1:http\") Dial(\"tcp\", \"198.51.100.1:80\") Dial(\"udp\", \"[2001:db8::1]:domain\") Dial(\"udp\", \"[fe80::1%lo0]:53\") Dial(\"tcp\", \":80\") For IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a literal protocol number or a protocol name, and the address has the form \"host\". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as \"0\" or \"255\". Examples: Dial(\"ip4:1\", \"192.0.2.1\") Dial(\"ip6:ipv6-icmp\", \"2001:db8::1\") Dial(\"ip6:58\", \"fe80::1%lo0\") For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for TCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is assumed. For Unix networks, the address must be a file system path. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DialContext",
				Description:      "DialContext connects to the address on the named network using the provided context. The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one. See func [Dial] for a description of the network and address parameters. ",
				ReceiverTypeName: "Dialer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Flags",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "HardwareAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsUnspecified",
				Description:      "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\". ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLoopback",
				Description:      "IsLoopback reports whether ip is a loopback address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsPrivate",
				Description:      "IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsMulticast",
				Description:      "IsMulticast reports whether ip is a multicast address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsInterfaceLocalMulticast",
				Description:      "IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLinkLocalMulticast",
				Description:      "IsLinkLocalMulticast reports whether ip is a link-local multicast address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLinkLocalUnicast",
				Description:      "IsLinkLocalUnicast reports whether ip is a link-local unicast address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsGlobalUnicast",
				Description:      "IsGlobalUnicast reports whether ip is a global unicast address. The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "To4",
				Description:      "To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "To16",
				Description:      "To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "DefaultMask",
				Description:      "DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IPMask",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "Mask",
				Description:      "Mask returns the result of masking the IP address ip with mask. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IP",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendTo",
				Description:      "appendTo appends the string representation of ip to b and returns the expanded b If len(ip) != IPv4len or IPv6len, it appends nothing. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements the [encoding.TextAppender] interface. The encoding is the same as returned by [IP.String], with one exception: When len(ip) is zero, it appends nothing. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements the [encoding.TextMarshaler] interface. The encoding is the same as returned by [IP.String], with one exception: When len(ip) is zero, it returns an empty slice. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The IP address is expected in a form accepted by [ParseIP]. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal. ",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "matchAddrFamily",
				Description:      "",
				ReceiverTypeName: "IP",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Network",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isWildcard",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "opAddr",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "family",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "toLocal",
				Description:      "",
				ReceiverTypeName: "IPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sockaddr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromIP",
				Description:      "ReadFromIP acts like ReadFrom but returns an IPAddr. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "IPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements the [PacketConn] ReadFrom method. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgIP",
				Description:      "ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "IPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToIP",
				Description:      "WriteToIP acts like [IPConn.WriteTo] but takes an [IPAddr]. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [PacketConn] WriteTo method. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgIP",
				Description:      "WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. ",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "IPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readMsg",
				Description:      "",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "IPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeMsg",
				Description:      "",
				ReceiverTypeName: "IPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0. ",
				ReceiverTypeName: "IPMask",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "IPMask",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Contains",
				Description:      "Contains reports whether the network includes ip. ",
				ReceiverTypeName: "IPNet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Network",
				Description:      "",
				ReceiverTypeName: "IPNet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "IPNet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Addrs",
				Description:      "Addrs returns a list of unicast interface addresses for a specific interface. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.Addr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MulticastAddrs",
				Description:      "MulticastAddrs returns a list of multicast, joined group addresses for a specific interface. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.Addr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InvalidAddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "InvalidAddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "InvalidAddrError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MultipathTCP",
				Description:      "MultipathTCP reports whether MPTCP will be used. This method doesn't check if MPTCP is supported by the operating system or not. ",
				ReceiverTypeName: "ListenConfig",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetMultipathTCP",
				Description:      "SetMultipathTCP directs the [Dial] methods to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any. If MPTCP is not available on the host or not supported by the server, the Dial methods will fall back to TCP. ",
				ReceiverTypeName: "ListenConfig",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Listen",
				Description:      "Listen announces on the local network address. See func Listen for a description of the network and address parameters. The ctx argument is used while resolving the address on which to listen; it does not affect the returned Listener. ",
				ReceiverTypeName: "ListenConfig",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Listener",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ListenPacket",
				Description:      "ListenPacket announces on the local network address. See func ListenPacket for a description of the network and address parameters. The ctx argument is used while resolving the address on which to listen; it does not affect the returned PacketConn. ",
				ReceiverTypeName: "ListenConfig",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PacketConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "OpError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "OpError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "OpError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "OpError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "resolveAddrList",
				Description:      "resolveAddrList resolves addr using hint and returns a list of addresses. The result contains at least one address when error is nil. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "addrList",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "exchange",
				Description:      "exchange sends a query on the connection and hopes for a response. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Parser",
						TypePkgName: "dnsmessage",
					},
					returnSet{
						TypeName:    "Header",
						TypePkgName: "dnsmessage",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tryOneName",
				Description:      "Do a lookup for a single name, which must be rooted (otherwise answer will not find the answers). ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Parser",
						TypePkgName: "dnsmessage",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookup",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Parser",
						TypePkgName: "dnsmessage",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupHostOrder",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupIP",
				Description:      "goLookupIP is the native Go implementation of LookupIP. The libc versions are in cgo_*.go. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IPAddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupIPCNAMEOrder",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IPAddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Name",
						TypePkgName: "dnsmessage",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupCNAME",
				Description:      "goLookupCNAME is the native Go (non-cgo) implementation of LookupCNAME. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupPTR",
				Description:      "goLookupPTR is the native Go implementation of LookupAddr. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "internetAddrList",
				Description:      "internetAddrList resolves addr, which may be a literal IP address or a DNS name, and returns a list of internet protocol family addresses. The result contains at least one address when error is nil. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "addrList",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "preferGo",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "strictErrors",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getLookupGroup",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Group",
						TypePkgName: "singleflight",
					},
				},
			},
			methodSet{
				Name:             "LookupHost",
				Description:      "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. LookupHost uses [context.Background] internally; to specify the context, use [Resolver.LookupHost]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupIPAddr",
				Description:      "LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IPAddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupIP",
				Description:      "LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IP",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupNetIP",
				Description:      "LookupNetIP looks up host using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. The network must be one of \"ip\", \"ip4\" or \"ip6\". ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net/netip.Addr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupIPAddr",
				Description:      "lookupIPAddr looks up host using the local resolver and particular network. It returns a slice of that host's IPv4 and IPv6 addresses. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IPAddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupPort",
				Description:      "LookupPort looks up the port for the given network and service. LookupPort uses [context.Background] internally; to specify the context, use [Resolver.LookupPort]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupCNAME",
				Description:      "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call [LookupHost] or [LookupIP] directly; both take care of resolving the canonical name as part of the lookup. A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records. The returned canonical name is validated to be a properly formatted presentation-format domain name. LookupCNAME uses [context.Background] internally; to specify the context, use [Resolver.LookupCNAME]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupSRV",
				Description:      "LookupSRV tries to resolve an [SRV] query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority. LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]*net.SRV",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupMX",
				Description:      "LookupMX returns the DNS MX records for the given domain name sorted by preference. The returned mail server names are validated to be properly formatted presentation-format domain names, or numeric IP addresses. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. LookupMX uses [context.Background] internally; to specify the context, use [Resolver.LookupMX]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.MX",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupNS",
				Description:      "LookupNS returns the DNS NS records for the given domain name. The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. LookupNS uses [context.Background] internally; to specify the context, use [Resolver.LookupNS]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.NS",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupTXT",
				Description:      "LookupTXT returns the DNS TXT records for the given domain name. If a DNS TXT record holds multiple strings, they are concatenated as a single string. LookupTXT uses [context.Background] internally; to specify the context, use [Resolver.LookupTXT]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupAddr",
				Description:      "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom [Resolver]. LookupAddr uses [context.Background] internally; to specify the context, use [Resolver.LookupAddr]. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dial",
				Description:      "dial makes a new connection to the provided server (which must be an IP address) with the provided network type, using either r.Dial (if both r and r.Dial are non-nil) or else Dialer.DialContext. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupSRV",
				Description:      "goLookupSRV returns the SRV records for a target name, built either from its component service (\"sip\"), protocol (\"tcp\"), and name (\"example.com.\"), or from name directly (if service and proto are both empty). In either case, the returned target name (\"_sip._tcp.example.com.\") is also returned on success. The records are sorted by weight. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]*net.SRV",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupMX",
				Description:      "goLookupMX returns the MX records for name. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.MX",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupNS",
				Description:      "goLookupNS returns the NS records for name. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.NS",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "goLookupTXT",
				Description:      "goLookupTXT returns the TXT records from name. ",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupHost",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupIP",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net.IPAddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupPort",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupCNAME",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupSRV",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]*net.SRV",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupMX",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.MX",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupNS",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net.NS",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupTXT",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupAddr",
				Description:      "",
				ReceiverTypeName: "Resolver",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddrPort",
				Description:      "AddrPort returns the [TCPAddr] a as a [netip.AddrPort]. If a.Port does not fit in a uint16, it's silently truncated. If a is nil, a zero value is returned. ",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "Network",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isWildcard",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "opAddr",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "family",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "toLocal",
				Description:      "",
				ReceiverTypeName: "TCPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sockaddr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements the [PacketConn] ReadFrom method. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [PacketConn] WriteTo method. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseRead",
				Description:      "CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseWrite",
				Description:      "CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLinger",
				Description:      "SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. If sec < 0 (the default), the operating system finishes sending the data in the background. If sec == 0, the operating system discards any unsent or unacknowledged data. If sec > 0, the data is sent in the background as with sec < 0. On some operating systems including Linux, this may cause Close to block until all data has been sent or discarded. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetKeepAlive",
				Description:      "SetKeepAlive sets whether the operating system should send keep-alive messages on the connection. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetKeepAlivePeriod",
				Description:      "SetKeepAlivePeriod sets the duration the connection needs to remain idle before TCP starts sending keepalive probes. Note that calling this method on Windows prior to Windows 10 version 1709 will reset the KeepAliveInterval to the default system value, which is normally 1 second. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetNoDelay",
				Description:      "SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MultipathTCP",
				Description:      "MultipathTCP reports whether MPTCP will be used. This method doesn't check if MPTCP is supported by the operating system or not. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetKeepAliveConfig",
				Description:      "SetKeepAliveConfig configures keep-alive messages sent by the operating system. ",
				ReceiverTypeName: "TCPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AcceptTCP",
				Description:      "AcceptTCP accepts the next incoming call and returns the new connection. ",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Accept",
				Description:      "Accept implements the Accept method in the [Listener] interface; it waits for the next call and returns a generic [Conn]. ",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetDeadline",
				Description:      "",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "File",
				Description:      "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. On Windows, the returned os.File's file descriptor is not usable on other processes. ",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ok",
				Description:      "",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "accept",
				Description:      "",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TCPConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "close",
				Description:      "",
				ReceiverTypeName: "TCPListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddrPort",
				Description:      "AddrPort returns the [TCPAddr] a as a [netip.AddrPort]. If a.Port does not fit in a uint16, it's silently truncated. If a is nil, a zero value is returned. ",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
				},
			},
			methodSet{
				Name:             "Network",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isWildcard",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "opAddr",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "family",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "toLocal",
				Description:      "",
				ReceiverTypeName: "UDPAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sockaddr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromUDP",
				Description:      "ReadFromUDP acts like [UDPConn.ReadFrom] but returns a UDPAddr. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFromUDP",
				Description:      "readFromUDP implements ReadFromUDP. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements the [PacketConn] ReadFrom method. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromUDPAddrPort",
				Description:      "ReadFromUDPAddrPort acts like ReadFrom but returns a [netip.AddrPort]. If c is bound to an unspecified address, the returned netip.AddrPort's address might be an IPv4-mapped IPv6 address. Use [netip.Addr.Unmap] to get the address without the IPv6 prefix. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgUDP",
				Description:      "ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be used to manipulate IP-level socket options in oob. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgUDPAddrPort",
				Description:      "ReadMsgUDPAddrPort is like [UDPConn.ReadMsgUDP] but returns an [netip.AddrPort] instead of a [UDPAddr]. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToUDP",
				Description:      "WriteToUDP acts like [UDPConn.WriteTo] but takes a [UDPAddr]. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToUDPAddrPort",
				Description:      "WriteToUDPAddrPort acts like [UDPConn.WriteTo] but takes a [netip.AddrPort]. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [PacketConn] WriteTo method. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgUDP",
				Description:      "WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written. The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be used to manipulate IP-level socket options in oob. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgUDPAddrPort",
				Description:      "WriteMsgUDPAddrPort is like [UDPConn.WriteMsgUDP] but takes a [netip.AddrPort] instead of a [UDPAddr]. ",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UDPAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFromAddrPort",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readMsg",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "AddrPort",
						TypePkgName: "netip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeToAddrPort",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeMsg",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeMsgAddrPort",
				Description:      "",
				ReceiverTypeName: "UDPConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Network",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isWildcard",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "opAddr",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "family",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "toLocal",
				Description:      "",
				ReceiverTypeName: "UnixAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sockaddr",
						TypePkgName: "net",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseRead",
				Description:      "CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseWrite",
				Description:      "CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFromUnix",
				Description:      "ReadFromUnix acts like [UnixConn.ReadFrom] but returns a [UnixAddr]. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UnixAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements the [PacketConn] ReadFrom method. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Addr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMsgUnix",
				Description:      "ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. Note that if len(b) == 0 and len(oob) > 0, this function will still read (and discard) 1 byte from the connection. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UnixAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteToUnix",
				Description:      "WriteToUnix acts like [UnixConn.WriteTo] but takes a [UnixAddr]. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [PacketConn] WriteTo method. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteMsgUnix",
				Description:      "WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. Note that if len(b) == 0 and len(oob) > 0, this function will still write 1 byte to the connection. ",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UnixAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readMsg",
				Description:      "",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "UnixAddr",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeMsg",
				Description:      "",
				ReceiverTypeName: "UnixConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ok",
				Description:      "",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SyscallConn",
				Description:      "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface. ",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawConn",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AcceptUnix",
				Description:      "AcceptUnix accepts the next incoming call and returns the new connection. ",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Accept",
				Description:      "Accept implements the Accept method in the [Listener] interface; it waits for the next call and returns a generic [Conn]. ",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetDeadline",
				Description:      "",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "File",
				Description:      "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. On Windows, the returned os.File's file descriptor is not usable on other processes. ",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "os",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "accept",
				Description:      "",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UnixConn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "close",
				Description:      "",
				ReceiverTypeName: "UnixListener",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetUnlinkOnClose",
				Description:      "SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed. The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file. ",
				ReceiverTypeName: "UnixListener",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownNetworkError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "UnknownNetworkError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "UnknownNetworkError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"httptrace": []methodSet{
			methodSet{
				Name:             "compose",
				Description:      "compose modifies t such that it respects the previously-registered hooks in old, subject to the composition policy requested in t.Compose. ",
				ReceiverTypeName: "ClientTrace",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "hasNetHooks",
				Description:      "",
				ReceiverTypeName: "ClientTrace",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"calloc": []methodSet{
			methodSet{
				Name:             "AllocateCounters",
				Description:      "",
				ReceiverTypeName: "BatchCounterAlloc",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint32",
						TypePkgName: "",
					},
				},
			},
		},
		"chacha8rand": []methodSet{
			methodSet{
				Name:             "Next",
				Description:      "Next returns the next random value, along with a boolean indicating whether one was available. If one is not available, the caller should call Refill and then repeat the call to Next. Next is //go:nosplit to allow its use in the runtime with per-m data without holding the per-m lock. ",
				ReceiverTypeName: "State",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init seeds the State with the given seed value. ",
				ReceiverTypeName: "State",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Init64",
				Description:      "Init64 seeds the state with the given seed value. ",
				ReceiverTypeName: "State",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Refill",
				Description:      "Refill refills the state with more random values. After a call to Refill, an immediate call to Next will succeed (unless multiple goroutines are incorrectly sharing a state). ",
				ReceiverTypeName: "State",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reseed",
				Description:      "Reseed reseeds the state with new random values. After a call to Reseed, any previously returned random values have been erased from the memory of the state and cannot be recovered. ",
				ReceiverTypeName: "State",
				Returns:          []returnSet{},
			},
		},
		"sync": []methodSet{
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "initSlow",
				Description:      "",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "V",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadOrStore",
				Description:      "LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "V",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "expand",
				Description:      "expand takes oldEntry and newEntry whose hashes conflict from bit 64 down to hashShift and produces a subtree of indirect nodes to hold the two new entries. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "node",
						TypePkgName: "sync",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store sets the value for a key. ",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap swaps the value for a key and returns the previous value if any. The loaded result reports whether the key was present. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "V",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap swaps the old and new values for key if the value stored in the map is equal to old. The value type must be of a comparable type, otherwise CompareAndSwap will panic. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadAndDelete",
				Description:      "LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "V",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Delete",
				Description:      "Delete deletes the value for a key. ",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CompareAndDelete",
				Description:      "CompareAndDelete deletes the entry for key if its value is equal to old. The value type must be comparable, otherwise this CompareAndDelete will panic. If there is no current value for key in the map, CompareAndDelete returns false (even if the old value is the nil interface value). ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "find",
				Description:      "find searches the tree for a node that contains key (hash must be the hash of key). If valEqual != nil, then it will also enforce that the values are equal as well. Returns a non-nil node, which will always be an entry, if found. If i != nil then i.mu is locked, and it is the caller's responsibility to unlock it. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "indirect",
						TypePkgName: "sync",
					},
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Pointer",
						TypePkgName: "atomic",
					},
					returnSet{
						TypeName:    "node",
						TypePkgName: "sync",
					},
				},
			},
			methodSet{
				Name:             "All",
				Description:      "All returns an iterator over each key and value present in the map. The iterator does not necessarily correspond to any consistent snapshot of the HashTrieMap's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently (including by yield), the iterator may reflect any mapping for that key from any point during iteration. The iterator does not block other methods on the receiver; even yield itself may call any method on the HashTrieMap. ",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(yield func(K, V) bool)",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Range",
				Description:      "Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration. This exists for compatibility with sync.Map; All should be preferred. It provides the same guarantees as sync.Map, and All. ",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "iter",
				Description:      "",
				ReceiverTypeName: "HashTrieMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clear",
				Description:      "Clear deletes all the entries, resulting in an empty HashTrieMap. ",
				ReceiverTypeName: "HashTrieMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lock",
				Description:      "Lock locks m. See package [sync.Mutex] documentation. ",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TryLock",
				Description:      "TryLock tries to lock m and reports whether it succeeded. See package [sync.Mutex] documentation. ",
				ReceiverTypeName: "Mutex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lockSlow",
				Description:      "",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Unlock",
				Description:      "Unlock unlocks m. See package [sync.Mutex] documentation. ",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "unlockSlow",
				Description:      "",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Wait",
				Description:      "Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal]. Because c.L is not locked while Wait is waiting, the caller typically cannot assume that the condition is true when Wait returns. Instead, the caller should Wait in a loop: c.L.Lock() for !condition() { c.Wait() } ... make use of condition ... c.L.Unlock() ",
				ReceiverTypeName: "Cond",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Signal",
				Description:      "Signal wakes one goroutine waiting on c, if there is any. It is allowed but not required for the caller to hold c.L during the call. Signal() does not affect goroutine scheduling priority; if other goroutines are attempting to lock c.L, they may be awoken before a \"waiting\" goroutine. ",
				ReceiverTypeName: "Cond",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Broadcast",
				Description:      "Broadcast wakes all goroutines waiting on c. It is allowed but not required for the caller to hold c.L during the call. ",
				ReceiverTypeName: "Cond",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Load",
				Description:      "Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Store",
				Description:      "Store sets the value for a key. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clear",
				Description:      "Clear deletes all the entries, resulting in an empty Map. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LoadOrStore",
				Description:      "LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LoadAndDelete",
				Description:      "LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Delete",
				Description:      "Delete deletes the value for a key. If the key is not in the map, Delete does nothing. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap swaps the value for a key and returns the previous value if any. The loaded result reports whether the key was present. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndSwap",
				Description:      "CompareAndSwap swaps the old and new values for key if the value stored in the map is equal to old. The old value must be of a comparable type. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CompareAndDelete",
				Description:      "CompareAndDelete deletes the entry for key if its value is equal to old. The old value must be of a comparable type. If there is no current value for key in the map, CompareAndDelete returns false (even if the old value is the nil interface value). ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Range",
				Description:      "Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration. Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently (including by f), Range may reflect any mapping for that key from any point during the Range call. Range does not block other methods on the receiver; even f itself may call any method on m. Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lock",
				Description:      "Lock is a no-op used by -copylocks checker from `go vet`. ",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TryLock",
				Description:      "TryLock tries to lock m and reports whether it succeeded. Note that while correct uses of TryLock do exist, they are rare, and use of TryLock is often a sign of a deeper problem in a particular use of mutexes. ",
				ReceiverTypeName: "Mutex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unlock",
				Description:      "",
				ReceiverTypeName: "Mutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Do",
				Description:      "Do calls the function f if and only if Do is being called for the first time for this instance of [Once]. In other words, given var once Once if once.Do(f) is called multiple times, only the first call will invoke f, even if f has a different value in each invocation. A new instance of Once is required for each function to execute. Do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by Do: config.once.Do(func() { config.init(filename) }) Because no call to Do returns until the one call to f returns, if f causes Do to be called, it will deadlock. If f panics, Do considers it to have returned; future calls of Do return without calling f. ",
				ReceiverTypeName: "Once",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "doSlow",
				Description:      "",
				ReceiverTypeName: "Once",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Put",
				Description:      "Put adds x to the pool. ",
				ReceiverTypeName: "Pool",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get selects an arbitrary item from the [Pool], removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to [Pool.Put] and the values returned by Get. If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New. ",
				ReceiverTypeName: "Pool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getSlow",
				Description:      "",
				ReceiverTypeName: "Pool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pin",
				Description:      "pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P and the P's id. Caller must call runtime_procUnpin() when done with the pool. ",
				ReceiverTypeName: "Pool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "poolLocal",
						TypePkgName: "sync",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pinSlow",
				Description:      "",
				ReceiverTypeName: "Pool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "poolLocal",
						TypePkgName: "sync",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RLock",
				Description:      "RLock locks rw for reading. It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the [RWMutex] type. ",
				ReceiverTypeName: "RWMutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TryRLock",
				Description:      "TryRLock tries to lock rw for reading and reports whether it succeeded. Note that while correct uses of TryRLock do exist, they are rare, and use of TryRLock is often a sign of a deeper problem in a particular use of mutexes. ",
				ReceiverTypeName: "RWMutex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RUnlock",
				Description:      "RUnlock undoes a single [RWMutex.RLock] call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock. ",
				ReceiverTypeName: "RWMutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rUnlockSlow",
				Description:      "",
				ReceiverTypeName: "RWMutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lock",
				Description:      "Lock is a no-op used by -copylocks checker from `go vet`. ",
				ReceiverTypeName: "RWMutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TryLock",
				Description:      "TryLock tries to lock m and reports whether it succeeded. Note that while correct uses of TryLock do exist, they are rare, and use of TryLock is often a sign of a deeper problem in a particular use of mutexes. ",
				ReceiverTypeName: "RWMutex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unlock",
				Description:      "",
				ReceiverTypeName: "RWMutex",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RLocker",
				Description:      "RLocker returns a [Locker] interface that implements the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock. ",
				ReceiverTypeName: "RWMutex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Locker",
						TypePkgName: "sync",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds delta, which may be negative, to the [WaitGroup] task counter. If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released. If the counter goes negative, Add panics. Callers should prefer [WaitGroup.Go]. Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example. ",
				ReceiverTypeName: "WaitGroup",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Done",
				Description:      "Done decrements the [WaitGroup] task counter by one. It is equivalent to Add(-1). Callers should prefer [WaitGroup.Go]. In the terminology of [the Go memory model], a call to Done \"synchronizes before\" the return of any Wait call that it unblocks. [the Go memory model]: https://go.dev/ref/mem ",
				ReceiverTypeName: "WaitGroup",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Wait",
				Description:      "Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal]. Because c.L is not locked while Wait is waiting, the caller typically cannot assume that the condition is true when Wait returns. Instead, the caller should Wait in a loop: c.L.Lock() for !condition() { c.Wait() } ... make use of condition ... c.L.Unlock() ",
				ReceiverTypeName: "WaitGroup",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Go",
				Description:      "Go calls f in a new goroutine and adds that task to the [WaitGroup]. When f returns, the task is removed from the WaitGroup. The function f must not panic. If the WaitGroup is empty, Go must happen before a [WaitGroup.Wait]. Typically, this simply means Go is called to start tasks before Wait is called. If the WaitGroup is not empty, Go may happen at any time. This means a goroutine started by Go may itself call Go. If a WaitGroup is reused to wait for several independent sets of tasks, new Go calls must happen after all previous Wait calls have returned. In the terminology of [the Go memory model], the return from f \"synchronizes before\" the return of any Wait call that it unblocks. [the Go memory model]: https://go.dev/ref/mem ",
				ReceiverTypeName: "WaitGroup",
				Returns:          []returnSet{},
			},
		},
		"gcm": []methodSet{
			methodSet{
				Name:             "deriveSubkeys",
				Description:      "",
				ReceiverTypeName: "CMAC",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MAC",
				Description:      "",
				ReceiverTypeName: "CMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DeriveKey",
				Description:      "DeriveKey derives a key from the given label and context. ",
				ReceiverTypeName: "CounterKDF",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonceSize",
				Description:      "",
				ReceiverTypeName: "GCM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overhead",
				Description:      "",
				ReceiverTypeName: "GCM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "GCM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sealAfterIndicator",
				Description:      "",
				ReceiverTypeName: "GCM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "GCM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonceSize",
				Description:      "",
				ReceiverTypeName: "GCMForSSH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overhead",
				Description:      "",
				ReceiverTypeName: "GCMForSSH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "GCMForSSH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "GCMForSSH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonceSize",
				Description:      "",
				ReceiverTypeName: "GCMForTLS12",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overhead",
				Description:      "",
				ReceiverTypeName: "GCMForTLS12",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "GCMForTLS12",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "GCMForTLS12",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonceSize",
				Description:      "",
				ReceiverTypeName: "GCMForTLS13",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overhead",
				Description:      "",
				ReceiverTypeName: "GCMForTLS13",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "GCMForTLS13",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "GCMForTLS13",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonceSize",
				Description:      "",
				ReceiverTypeName: "GCMWithCounterNonce",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Overhead",
				Description:      "",
				ReceiverTypeName: "GCMWithCounterNonce",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seal",
				Description:      "",
				ReceiverTypeName: "GCMWithCounterNonce",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "",
				ReceiverTypeName: "GCMWithCounterNonce",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"nistec": []methodSet{
			methodSet{
				Name:             "SetGenerator",
				Description:      "SetGenerator sets p to the canonical generator and returns p. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets p = q and returns p. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets p to the compressed, uncompressed, or infinity value encoded in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on the curve, it returns nil and an error, and the receiver is unchanged. Otherwise, it returns p. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the uncompressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesX",
				Description:      "BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1, Version 2.0, Section 2.3.5, or an error if p is the point at infinity. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesX",
				Description:      "",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesCompressed",
				Description:      "BytesCompressed returns the compressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesCompressed",
				Description:      "",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets q = p1 + p2, and returns q. The points may overlap. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Double",
				Description:      "Double sets q = p + p, and returns q. The points may overlap. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets q to p1 if cond == 1, and to p2 if cond == 0. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "ScalarMult sets p = scalar * q, and returns p. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "generatorTable",
				Description:      "generatorTable returns a sequence of p224Tables. The first table contains multiples of G. Each successive table is the previous table doubled four times. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*[56]crypto/internal/fips140/nistec.p224Table",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and returns p. ",
				ReceiverTypeName: "P224Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetGenerator",
				Description:      "SetGenerator sets p to the canonical generator and returns p. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets p = q and returns p. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets p to the compressed, uncompressed, or infinity value encoded in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on the curve, it returns nil and an error, and the receiver is unchanged. Otherwise, it returns p. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets q = p1 + p2, and returns q. The points may overlap. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Double",
				Description:      "Double sets q = p + p, and returns q. The points may overlap. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and returns p. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "ScalarMult sets p = scalar * q, and returns p. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isInfinity",
				Description:      "isInfinity returns 1 if p is the point at infinity and 0 otherwise. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the uncompressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "affineFromMont",
				Description:      "affineFromMont sets (x, y) to the affine coordinates of p, converted out of the Montgomery domain. ",
				ReceiverTypeName: "P256Point",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "BytesX",
				Description:      "BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1, Version 2.0, Section 2.3.5, or an error if p is the point at infinity. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesX",
				Description:      "",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesCompressed",
				Description:      "BytesCompressed returns the compressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesCompressed",
				Description:      "",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets q to p1 if cond == 1, and to p2 if cond == 0. ",
				ReceiverTypeName: "P256Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "p256BaseMult",
				Description:      "",
				ReceiverTypeName: "P256Point",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "p256ScalarMult",
				Description:      "",
				ReceiverTypeName: "P256Point",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetGenerator",
				Description:      "SetGenerator sets p to the canonical generator and returns p. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets p = q and returns p. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets p to the compressed, uncompressed, or infinity value encoded in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on the curve, it returns nil and an error, and the receiver is unchanged. Otherwise, it returns p. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the uncompressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesX",
				Description:      "BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1, Version 2.0, Section 2.3.5, or an error if p is the point at infinity. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesX",
				Description:      "",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesCompressed",
				Description:      "BytesCompressed returns the compressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesCompressed",
				Description:      "",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets q = p1 + p2, and returns q. The points may overlap. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Double",
				Description:      "Double sets q = p + p, and returns q. The points may overlap. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets q to p1 if cond == 1, and to p2 if cond == 0. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "ScalarMult sets p = scalar * q, and returns p. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "generatorTable",
				Description:      "generatorTable returns a sequence of p224Tables. The first table contains multiples of G. Each successive table is the previous table doubled four times. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*[96]crypto/internal/fips140/nistec.p384Table",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and returns p. ",
				ReceiverTypeName: "P384Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetGenerator",
				Description:      "SetGenerator sets p to the canonical generator and returns p. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets p = q and returns p. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets p to the compressed, uncompressed, or infinity value encoded in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on the curve, it returns nil and an error, and the receiver is unchanged. Otherwise, it returns p. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the uncompressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesX",
				Description:      "BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1, Version 2.0, Section 2.3.5, or an error if p is the point at infinity. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesX",
				Description:      "",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BytesCompressed",
				Description:      "BytesCompressed returns the compressed or infinity encoding of p, as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at infinity is shorter than all other encodings. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytesCompressed",
				Description:      "",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets q = p1 + p2, and returns q. The points may overlap. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Double",
				Description:      "Double sets q = p + p, and returns q. The points may overlap. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets q to p1 if cond == 1, and to p2 if cond == 0. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "ScalarMult sets p = scalar * q, and returns p. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "generatorTable",
				Description:      "generatorTable returns a sequence of p224Tables. The first table contains multiples of G. Each successive table is the previous table doubled four times. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*[132]crypto/internal/fips140/nistec.p521Table",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and returns p. ",
				ReceiverTypeName: "P521Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Point",
						TypePkgName: "nistec",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"field": []methodSet{
			methodSet{
				Name:             "Zero",
				Description:      "Zero sets v = 0, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "One",
				Description:      "One sets v = 1, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "reduce",
				Description:      "reduce reduces v modulo 2^255 - 19 and returns it. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets v = a + b, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Subtract",
				Description:      "Subtract sets v = a - b, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Negate",
				Description:      "Negate sets v = -a, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Invert",
				Description:      "Invert sets v = 1/z mod p, and returns v. If z == 0, Invert returns v = 0. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets v = a, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets v to x, where x is a 32-byte little-endian encoding. If x is not of the right length, SetBytes returns nil and an error, and the receiver is unchanged. Consistent with RFC 7748, the most significant bit (the high bit of the last byte) is ignored, and non-canonical values (2^255-19 through 2^255-1) are accepted. Note that this is laxer than specified by RFC 8032, but consistent with most Ed25519 implementations. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the canonical 32-byte little-endian encoding of v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if v and u are equal, and 0 otherwise. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets v to a if cond == 1, and to b if cond == 0. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "Swap swaps v and u if cond == 1 or leaves them unchanged if cond == 0, and returns v. ",
				ReceiverTypeName: "Element",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IsNegative",
				Description:      "IsNegative returns 1 if v is negative, and 0 otherwise. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Absolute",
				Description:      "Absolute sets v to |u|, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Multiply",
				Description:      "Multiply sets v = x * y, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Square",
				Description:      "Square sets v = x * x, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Mult32",
				Description:      "Mult32 sets v = x * y, and returns v. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "Pow22523",
				Description:      "Pow22523 set v = x^((p-5)/8), and returns v. (p-5)/8 is 2^252-3. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
			methodSet{
				Name:             "SqrtRatio",
				Description:      "SqrtRatio sets r to the non-negative square root of the ratio of u and v. If u/v is square, SqrtRatio returns r and 1. If u/v is not square, SqrtRatio sets r according to Section 4.3 of draft-irtf-cfrg-ristretto255-decaf448-00, and returns r and 0. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "carryPropagate",
				Description:      "carryPropagate brings the limbs below 52 bits by applying the reduction identity (a * 2Â²âµâµ + b = a * 19 + b) to the l4 carry. ",
				ReceiverTypeName: "Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Element",
						TypePkgName: "field",
					},
				},
			},
		},
		"edwards25519": []methodSet{
			methodSet{
				Name:             "Set",
				Description:      "Set sets v = u, and returns v. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the canonical 32-byte encoding of v, according to RFC 8032, Section 5.1.2. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets v = x, where x is a 32-byte encoding of v. If x does not represent a valid point on the curve, SetBytes returns nil and an error and the receiver is unchanged. Otherwise, SetBytes returns v. Note that SetBytes accepts all non-canonical encodings of valid points. That is, it follows decoding rules that match most implementations in the ecosystem rather than RFC 8032. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fromP1xP1",
				Description:      "",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "fromP2",
				Description:      "",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets v = p + q, and returns v. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Subtract",
				Description:      "Subtract sets v = p - q, and returns v. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Negate",
				Description:      "Negate sets v = -p, and returns v. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if v is equivalent to u, and 0 otherwise. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "ScalarBaseMult sets v = x * B, where B is the canonical generator, and returns v. The scalar multiplication is done in constant time. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "ScalarMult sets v = x * q, and returns v. The scalar multiplication is done in constant time. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "VarTimeDoubleScalarBaseMult",
				Description:      "VarTimeDoubleScalarBaseMult sets v = a * A + b * B, where B is the canonical generator, and returns v. Execution time depends on the inputs. ",
				ReceiverTypeName: "Point",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Point",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "MultiplyAdd",
				Description:      "MultiplyAdd sets s = x * y + z mod l, and returns s. It is equivalent to using Multiply and then Add. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets v = p + q, and returns v. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Subtract",
				Description:      "Subtract sets v = p - q, and returns v. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Negate",
				Description:      "Negate sets v = -p, and returns v. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Multiply",
				Description:      "Multiply sets s = x * y mod l, and returns s. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets v = u, and returns v. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "SetUniformBytes",
				Description:      "SetUniformBytes sets s = x mod l, where x is a 64-byte little-endian integer. If x is not of the right length, SetUniformBytes returns nil and an error, and the receiver is unchanged. SetUniformBytes can be used to set s to a uniformly distributed value given 64 uniformly distributed random bytes. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setShortBytes",
				Description:      "setShortBytes sets s = x mod l, where x is a little-endian integer shorter than 32 bytes. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
				},
			},
			methodSet{
				Name:             "SetCanonicalBytes",
				Description:      "SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes returns nil and an error, and the receiver is unchanged. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytesWithClamping",
				Description:      "SetBytesWithClamping applies the buffer pruning described in RFC 8032, Section 5.1.5 (also known as clamping) and sets s to the result. The input must be 32 bytes, and it is not modified. If x is not of the right length, SetBytesWithClamping returns nil and an error, and the receiver is unchanged. Note that since Scalar values are always reduced modulo the prime order of the curve, the resulting value will not preserve any of the cofactor-clearing properties that clamping is meant to provide. It will however work as expected as long as it is applied to points on the prime order subgroup, like in Ed25519. In fact, it is lost to history why RFC 8032 adopted the irrelevant RFC 7748 clamping, but it is now required for compatibility. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scalar",
						TypePkgName: "edwards25519",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the canonical 32-byte encoding of v, according to RFC 8032, Section 5.1.2. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if v is equivalent to u, and 0 otherwise. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nonAdjacentForm",
				Description:      "nonAdjacentForm computes a width-w non-adjacent form for this scalar. w must be between 2 and 8, or nonAdjacentForm will panic. ",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[256]int8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "signedRadix16",
				Description:      "",
				ReceiverTypeName: "Scalar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[64]int8",
						TypePkgName: "",
					},
				},
			},
		},
		"flag": []methodSet{
			methodSet{
				Name:             "Output",
				Description:      "Output returns the destination for usage and error messages. [os.Stderr] is returned if output was not set or was set to nil. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the flag set. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetOutput",
				Description:      "SetOutput sets the destination for usage and error messages. If output is nil, [os.Stderr] is used. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "VisitAll",
				Description:      "VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Visit",
				Description:      "Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the [Flag] structure of the named flag, returning nil if none exists. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Flag",
						TypePkgName: "flag",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "set",
				Description:      "",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PrintDefaults",
				Description:      "PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "defaultUsage",
				Description:      "defaultUsage is the default function to print a usage message. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "NFlag",
				Description:      "NFlag returns the number of flags that have been set. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Arg",
				Description:      "Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NArg",
				Description:      "NArg is the number of arguments remaining after flags have been processed. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Args",
				Description:      "Args returns the non-flag arguments. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BoolVar",
				Description:      "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Bool",
				Description:      "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IntVar",
				Description:      "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64Var",
				Description:      "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UintVar",
				Description:      "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Uint",
				Description:      "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64Var",
				Description:      "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StringVar",
				Description:      "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float64Var",
				Description:      "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DurationVar",
				Description:      "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Duration",
				Description:      "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "TextVar",
				Description:      "TextVar defines a flag with a specified name, default value, and usage string. The argument p must be a pointer to a variable that will hold the value of the flag, and p must implement encoding.TextUnmarshaler. If the flag is used, the flag value will be passed to p's UnmarshalText method. The type of the default value must be the same as the type of p. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Func",
				Description:      "Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "BoolFunc",
				Description:      "BoolFunc defines a flag with the specified name and usage string without requiring values. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Var",
				Description:      "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type [Value], which typically holds a user-defined implementation of [Value]. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of [Value]; in particular, [Set] would decompose the comma-separated string into the slice. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sprintf",
				Description:      "sprintf formats the message, prints it to output, and returns it. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "failf",
				Description:      "failf prints to standard error a formatted error and usage message and returns the error. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "usage",
				Description:      "usage calls the Usage method for the flag set if one is specified, or the appropriate default usage function otherwise. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "parseOne",
				Description:      "parseOne parses one flag. It reports whether a flag was seen. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the [FlagSet] are defined and before flags are accessed by the program. The return value will be [ErrHelp] if -help or -h were set but not defined. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parsed",
				Description:      "Parsed reports whether f.Parse has been called. ",
				ReceiverTypeName: "FlagSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init sets the name and error handling property for a flag set. By default, the zero [FlagSet] uses an empty name and the [ContinueOnError] error handling policy. ",
				ReceiverTypeName: "FlagSet",
				Returns:          []returnSet{},
			},
		},
		"multipart": []methodSet{
			methodSet{
				Name:             "Open",
				Description:      "Open opens and returns the [FileHeader]'s associated File. ",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RemoveAll",
				Description:      "RemoveAll removes any temporary files associated with a [Form]. ",
				ReceiverTypeName: "Form",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FormName",
				Description:      "FormName returns the name parameter if p has a Content-Disposition of type \"form-data\". Otherwise it returns the empty string. ",
				ReceiverTypeName: "Part",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FileName",
				Description:      "FileName returns the filename parameter of the [Part]'s Content-Disposition header. If not empty, the filename is passed through filepath.Base (which is platform dependent) before being returned. ",
				ReceiverTypeName: "Part",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseContentDisposition",
				Description:      "",
				ReceiverTypeName: "Part",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "populateHeaders",
				Description:      "",
				ReceiverTypeName: "Part",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "Part",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "Part",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadForm",
				Description:      "ReadForm parses an entire multipart message whose parts have a Content-Disposition of \"form-data\". It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns [ErrMessageTooLarge] if all non-file parts can't be stored in memory. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Form",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readForm",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Form",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NextPart",
				Description:      "NextPart returns the next part in the multipart or an error. When there are no more parts, the error [io.EOF] is returned. As a special case, if the \"Content-Transfer-Encoding\" header has a value of \"quoted-printable\", that header is instead hidden and the body is transparently decoded during Read calls. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Part",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NextRawPart",
				Description:      "NextRawPart returns the next part in the multipart or an error. When there are no more parts, the error [io.EOF] is returned. Unlike [Reader.NextPart], it does not have special handling for \"Content-Transfer-Encoding: quoted-printable\". ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Part",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nextPart",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Part",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isFinalBoundary",
				Description:      "isFinalBoundary reports whether line is the final boundary line indicating that all parts are over. It matches `^--boundary--[ \\t]*(\\r\\n)?$` ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isBoundaryDelimiterLine",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Boundary",
				Description:      "Boundary returns the [Writer]'s boundary. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBoundary",
				Description:      "SetBoundary overrides the [Writer]'s default randomly-generated boundary separator with an explicit value. SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FormDataContentType",
				Description:      "FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this [Writer]'s Boundary. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreatePart",
				Description:      "CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned [Writer]. After calling CreatePart, any previous part may no longer be written to. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreateFormFile",
				Description:      "CreateFormFile is a convenience wrapper around [Writer.CreatePart]. It creates a new form-data header with the provided field name and file name. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreateFormField",
				Description:      "CreateFormField calls [Writer.CreatePart] with a header using the given field name. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteField",
				Description:      "WriteField calls [Writer.CreateFormField] and then writes the given value. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"flate": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CorruptInputError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InternalError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ReadError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "WriteError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the [Writer] to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error. In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close flushes and closes the writer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards the writer's state and makes it equivalent to the result of [NewWriter] or [NewWriterDict] called with dst and w's level and dictionary. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
		},
		"sha512": []methodSet{
			methodSet{
				Name:             "Reset",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cloner",
						TypePkgName: "hash",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkSum",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[64]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"debug": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of a [BuildInfo]. ",
				ReceiverTypeName: "BuildInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"testing": []methodSet{
			methodSet{
				Name:             "StartTimer",
				Description:      "StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to [B.StopTimer]. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StopTimer",
				Description:      "StopTimer stops timing a test. This can be used to pause the timer while performing steps that you don't want to measure. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ResetTimer",
				Description:      "ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ReportAllocs",
				Description:      "ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "runN",
				Description:      "runN runs a single benchmark for the specified number of iterations. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "run1",
				Description:      "run1 runs the first iteration of benchFunc. It reports whether more iterations of this benchmarks should be run. ",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "run",
				Description:      "run executes the benchmark in a separate goroutine, including all of its subbenchmarks. b must not have subbenchmarks. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "doBench",
				Description:      "",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BenchmarkResult",
						TypePkgName: "testing",
					},
				},
			},
			methodSet{
				Name:             "launch",
				Description:      "launch launches the benchmark function. It gradually increases the number of benchmark iterations until the benchmark runs for the requested benchtime. launch is run by the doBench function as a separate goroutine. run1 must have been called on b. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Elapsed",
				Description:      "Elapsed returns the measured elapsed time of the benchmark. The duration reported by Elapsed matches the one measured by [B.StartTimer], [B.StopTimer], and [B.ResetTimer]. ",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "ReportMetric",
				Description:      "ReportMetric adds \"n unit\" to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in \"/op\". ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as \"allocs/op\"), ReportMetric will override that metric. Setting \"ns/op\" to 0 will suppress that built-in metric. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "stopOrScaleBLoop",
				Description:      "",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "loopSlowPath",
				Description:      "",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Loop",
				Description:      "Loop returns true as long as the benchmark should continue running. A typical benchmark is structured like: func Benchmark(b *testing.B) { ... setup ... for b.Loop() { ... code to measure ... } ... cleanup ... } Loop resets the benchmark timer the first time it is called in a benchmark, so any setup performed prior to starting the benchmark loop does not count toward the benchmark measurement. Likewise, when it returns false, it stops the timer so cleanup code is not measured. Within the body of a \"for b.Loop() { ... }\" loop, arguments to and results from function calls within the loop are kept alive, preventing the compiler from fully optimizing away the loop body. Currently, this is implemented by disabling inlining of functions called in a b.Loop loop. This applies only to calls syntactically between the curly braces of the loop, and the loop condition must be written exactly as \"b.Loop()\". Optimizations are performed as usual in any functions called by the loop. After Loop returns false, b.N contains the total number of iterations that ran, so the benchmark may use b.N to compute other average metrics. Prior to the introduction of Loop, benchmarks were expected to contain an explicit loop from 0 to b.N. Benchmarks should either use Loop or contain a loop to b.N, but not both. Loop offers more automatic management of the benchmark timer, and runs each benchmark function only once per measurement, whereas b.N-based benchmarks must run the benchmark function (and any associated setup and cleanup) several times. ",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Run",
				Description:      "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. ",
				ReceiverTypeName: "B",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "add",
				Description:      "add simulates running benchmarks in sequence in a single iteration. It is used to give some meaningful results in case func Benchmark is used in combination with Run. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "trimOutput",
				Description:      "trimOutput shortens the output from a benchmark, which can be very long. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RunParallel",
				Description:      "RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call [B.SetParallelism] before RunParallel. RunParallel is usually used with the go test -cpu flag. The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the [B.StartTimer], [B.StopTimer], or [B.ResetTimer] functions, because they have global effect. It should also not call [B.Run]. RunParallel reports ns/op values as wall time for the benchmark as a whole, not the sum of wall time or CPU time over each parallel goroutine. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetParallelism",
				Description:      "SetParallelism sets the number of goroutines used by [B.RunParallel] to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect. ",
				ReceiverTypeName: "B",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "NsPerOp",
				Description:      "NsPerOp returns the \"ns/op\" metric. ",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mbPerSec",
				Description:      "mbPerSec returns the \"MB/s\" metric. ",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AllocsPerOp",
				Description:      "AllocsPerOp returns the \"allocs/op\" metric, which is calculated as r.MemAllocs / r.N. ",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AllocedBytesPerOp",
				Description:      "AllocedBytesPerOp returns the \"B/op\" metric, which is calculated as r.MemBytes / r.N. ",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MemString",
				Description:      "MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'. ",
				ReceiverTypeName: "BenchmarkResult",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Helper",
				Description:      "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines. ",
				ReceiverTypeName: "F",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Fail",
				Description:      "Fail marks the function as having failed but continues execution. ",
				ReceiverTypeName: "F",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Skipped",
				Description:      "Skipped reports whether the test was skipped. ",
				ReceiverTypeName: "F",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add will add the arguments to the seed corpus for the fuzz test. This will be a no-op if called after or within the fuzz target, and args must match the arguments for the fuzz target. ",
				ReceiverTypeName: "F",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Fuzz",
				Description:      "Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of arguments, those arguments will be added to the seed corpus. ff must be a function with no return value whose first argument is [*T] and whose remaining arguments are the types to be fuzzed. For example: f.Fuzz(func(t *testing.T, b []byte, i int) { ... }) The following types are allowed: []byte, string, bool, byte, rune, float32, float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64. More types may be supported in the future. ff must not call any [*F] methods, e.g. [F.Log], [F.Error], [F.Skip]. Use the corresponding [*T] method instead. The only [*F] methods that are allowed in the F.Fuzz function are [F.Failed] and [F.Name]. This function should be fast and deterministic, and its behavior should not depend on shared state. No mutable input arguments, or pointers to them, should be retained between executions of the fuzz function, as the memory backing them may be mutated during a subsequent invocation. ff must not modify the underlying data of the arguments provided by the fuzzing engine. When fuzzing, F.Fuzz does not return until a problem is found, time runs out (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz should be called exactly once, unless [F.Skip] or [F.Fail] is called beforehand. ",
				ReceiverTypeName: "F",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "report",
				Description:      "",
				ReceiverTypeName: "F",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "processRunResult",
				Description:      "processRunResult computes a summary and status of the result of running an example test. stdout is the captured output from stdout of the test. recovered is the result of invoking recover after running the test, in case it panicked. If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout. If the test is chatty/verbose, it'll print a success message to stdout. If recovered is non-nil, it'll panic with that value. If the test panicked with nil, or invoked runtime.Goexit, it'll be made to fail and panic with errNilPanicOrGoexit ",
				ReceiverTypeName: "InternalExample",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Run",
				Description:      "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. ",
				ReceiverTypeName: "M",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "before",
				Description:      "before runs before all testing. ",
				ReceiverTypeName: "M",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "after",
				Description:      "after runs after all testing. ",
				ReceiverTypeName: "M",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeProfiles",
				Description:      "",
				ReceiverTypeName: "M",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "startAlarm",
				Description:      "startAlarm starts an alarm if requested. ",
				ReceiverTypeName: "M",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "stopAlarm",
				Description:      "stopAlarm turns off the alarm. ",
				ReceiverTypeName: "M",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next reports whether there are more iterations to execute. ",
				ReceiverTypeName: "PB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parallel",
				Description:      "Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other. ",
				ReceiverTypeName: "T",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "checkParallel",
				Description:      "",
				ReceiverTypeName: "T",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Setenv",
				Description:      "Setenv calls [os.Setenv] and uses Cleanup to restore the environment variable to its original value after the test. Because Setenv affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors. ",
				ReceiverTypeName: "T",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Chdir",
				Description:      "Chdir calls [os.Chdir] and uses Cleanup to restore the current working directory to its original value after the test. On Unix, it also sets PWD environment variable for the duration of the test. Because Chdir affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors. ",
				ReceiverTypeName: "T",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Run",
				Description:      "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. ",
				ReceiverTypeName: "T",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Deadline",
				Description:      "Deadline reports the time at which the test binary will have exceeded the timeout specified by the -timeout flag. The ok result is false if the -timeout flag indicates âno timeoutâ (0). ",
				ReceiverTypeName: "T",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "report",
				Description:      "",
				ReceiverTypeName: "T",
				Returns:          []returnSet{},
			},
		},
		"gosym": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "DecodingError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parse",
				Description:      "",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "slice",
				Description:      "",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "LineTable",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "PCToLine",
				Description:      "PCToLine returns the line number for the given program counter. Deprecated: Use Table's PCToLine method instead. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LineToPC",
				Description:      "LineToPC returns the program counter for the given line number, considering only program counters before maxpc. Deprecated: Use Table's LineToPC method instead. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isGo12",
				Description:      "isGo12 reports whether this is a Go 1.2 (or later) symbol table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "uintptr",
				Description:      "uintptr returns the pointer-sized value encoded at b. The pointer size is dictated by the table being read. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parsePclnTab",
				Description:      "parsePclnTab parses the pclntab, setting the version. ",
				ReceiverTypeName: "LineTable",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "go12Funcs",
				Description:      "go12Funcs returns a slice of Funcs derived from the Go 1.2+ pcln table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/gosym.Func",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "findFunc",
				Description:      "findFunc returns the funcData corresponding to the given program counter. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "funcData",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "readvarint",
				Description:      "readvarint reads, removes, and returns a varint from *pp. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "funcName",
				Description:      "funcName returns the name of the function found at off. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "stringFrom",
				Description:      "stringFrom returns a Go string found at off from a position. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "string",
				Description:      "string returns a Go string found at off. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "functabFieldSize",
				Description:      "functabFieldSize returns the size in bytes of a single functab field. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "funcTab",
				Description:      "funcTab returns t's funcTab. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "funcTab",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "step",
				Description:      "step advances to the next pc, value pair in the encoded table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pcvalue",
				Description:      "pcvalue reports the value associated with the target pc. off is the offset to the beginning of the pc-value table, and entry is the start PC for the corresponding function. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "findFileLine",
				Description:      "findFileLine scans one function in the binary looking for a program counter in the given file on the given line. It does so by running the pc-value tables mapping program counter to file number. Since most functions come from a single file, these are usually short and quick to scan. If a file match is found, then the code goes to the expense of looking for a simultaneous line number match. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "go12PCToLine",
				Description:      "go12PCToLine maps program counter to line number for the Go 1.2+ pcln table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "go12PCToFile",
				Description:      "go12PCToFile maps program counter to file name for the Go 1.2+ pcln table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "go12LineToPC",
				Description:      "go12LineToPC maps a (file, line) pair to a program counter for the Go 1.2+ pcln table. ",
				ReceiverTypeName: "LineTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "initFileMap",
				Description:      "initFileMap initializes the map from file name to file number. ",
				ReceiverTypeName: "LineTable",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "go12MapFiles",
				Description:      "go12MapFiles adds to m a key for every file in the Go 1.2 LineTable. Every key maps to obj. That's not a very interesting map, but it provides a way for callers to obtain the list of files in the program. ",
				ReceiverTypeName: "LineTable",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "lineFromAline",
				Description:      "",
				ReceiverTypeName: "Obj",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "alineFromLine",
				Description:      "",
				ReceiverTypeName: "Obj",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Static",
				Description:      "Static reports whether this symbol is static (not visible outside its file). ",
				ReceiverTypeName: "Sym",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nameWithoutInst",
				Description:      "nameWithoutInst returns s.Name if s.Name has no brackets (does not reference an instantiated type, function, or method). If s.Name contains brackets, then it returns s.Name with all the contents between (and including) the outermost left and right bracket removed. This is useful to ignore any extra slashes or dots inside the brackets from the string searches below, where needed. ",
				ReceiverTypeName: "Sym",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PackageName",
				Description:      "PackageName returns the package part of the symbol name, or the empty string if there is none. ",
				ReceiverTypeName: "Sym",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReceiverName",
				Description:      "ReceiverName returns the receiver type name of this symbol, or the empty string if there is none. A receiver name is only detected in the case that s.Name is fully-specified with a package name. ",
				ReceiverTypeName: "Sym",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BaseName",
				Description:      "BaseName returns the symbol name without the package or receiver name. ",
				ReceiverTypeName: "Sym",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PCToFunc",
				Description:      "PCToFunc returns the function containing the program counter pc, or nil if there is no such function. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "PCToLine",
				Description:      "PCToLine returns the line number for the given program counter. Deprecated: Use Table's PCToLine method instead. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Func",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "LineToPC",
				Description:      "LineToPC returns the program counter for the given line number, considering only program counters before maxpc. Deprecated: Use Table's LineToPC method instead. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Func",
						TypePkgName: "gosym",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LookupSym",
				Description:      "LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sym",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "LookupFunc",
				Description:      "LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "SymByAddr",
				Description:      "SymByAddr returns the text, data, or bss symbol starting at the given address. ",
				ReceiverTypeName: "Table",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sym",
						TypePkgName: "gosym",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownFileError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownLineError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"parse": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ActionNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "ActionNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "ActionNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "ActionNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "BoolNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "BoolNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "BoolNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "BoolNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "BranchNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "BranchNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "BranchNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "BranchNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "BreakNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "BreakNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "BreakNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "BreakNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds the named field (which should start with a period) to the end of the chain. ",
				ReceiverTypeName: "ChainNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ChainNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "ChainNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "ChainNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "ChainNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "",
				ReceiverTypeName: "CommandNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CommandNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "CommandNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "CommandNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "CommandNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CommentNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "CommentNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "CommentNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "CommentNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "ContinueNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ContinueNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "ContinueNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "ContinueNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes. ",
				ReceiverTypeName: "DotNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NodeType",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "DotNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "DotNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "DotNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "DotNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "FieldNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "FieldNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "FieldNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "FieldNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "SetPos",
				Description:      "SetPos sets the position. [NewIdentifier] is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? ",
				ReceiverTypeName: "IdentifierNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IdentifierNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "SetTree",
				Description:      "SetTree sets the parent tree for the node. [NewIdentifier] is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? ",
				ReceiverTypeName: "IdentifierNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IdentifierNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "IdentifierNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "IdentifierNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "IdentifierNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "IdentifierNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "IfNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CopyList",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ListNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "ListNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes. ",
				ReceiverTypeName: "NilNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NodeType",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "NilNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "NilNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "NilNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "NilNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes. ",
				ReceiverTypeName: "NodeType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NodeType",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "simplifyComplex",
				Description:      "simplifyComplex pulls out any other types that are represented by the complex number. These all require that the imaginary part be zero. ",
				ReceiverTypeName: "NumberNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "NumberNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "NumberNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "NumberNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "NumberNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "CopyPipe",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PipeNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "PipeNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Position",
				Description:      "",
				ReceiverTypeName: "Pos",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "RangeNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "StringNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "StringNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "StringNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "StringNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TemplateNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "TemplateNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "TemplateNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "TemplateNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TextNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "TextNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "TextNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "TextNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newList",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ListNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newText",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TextNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newComment",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommentNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newPipeline",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PipeNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newAction",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ActionNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newCommand",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommandNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newVariable",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "VariableNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newDot",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DotNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newNil",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NilNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newField",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FieldNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newChain",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ChainNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newBool",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BoolNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newNumber",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "NumberNode",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newString",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "StringNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newEnd",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "endNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newElse",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "elseNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newIf",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "IfNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newBreak",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BreakNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newContinue",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ContinueNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newRange",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RangeNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newWith",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WithNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "newTemplate",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TemplateNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "next",
				Description:      "next returns the next rune in the input. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "backup",
				Description:      "backup steps back one rune. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "backup2",
				Description:      "backup2 backs the input stream up two tokens. The zeroth token is already there. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "backup3",
				Description:      "backup3 backs the input stream up three tokens The zeroth token is already there. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "peek",
				Description:      "peek returns but does not consume the next rune in the input. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "nextNonSpace",
				Description:      "nextNonSpace returns the next non-space token. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "peekNonSpace",
				Description:      "peekNonSpace returns but does not consume the next non-space token. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "ErrorContext",
				Description:      "ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "errorf",
				Description:      "errorf returns an error token and terminates the scan by passing back a nil pointer that will be the next state, terminating l.nextItem. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "error",
				Description:      "error terminates processing. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "expect",
				Description:      "expect consumes the next token and guarantees it has the required type. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "expectOneOf",
				Description:      "expectOneOf consumes the next token and guarantees it has one of the required types. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "item",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "unexpected",
				Description:      "unexpected complains about the token and terminates processing. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recover",
				Description:      "recover is the handler that turns panics into returns from the top level of Parse. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "startParse",
				Description:      "startParse initializes the parser, using the lexer. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "stopParse",
				Description:      "stopParse terminates parsing. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse returns a map from template name to [Tree], created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "add",
				Description:      "add adds tree to t.treeSet. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "parse",
				Description:      "parse is the top-level parser for a template, essentially the same as itemList except it also parses {{define}} actions. It runs to EOF. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "parseDefinition",
				Description:      "parseDefinition parses a {{define}} ... {{end}} template definition and installs the definition in t.treeSet. The \"define\" keyword has already been scanned. ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "itemList",
				Description:      "itemList: textOrAction* Terminates at {{end}} or {{else}}, returned separately. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ListNode",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "textOrAction",
				Description:      "textOrAction: text | comment | action ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "clearActionLine",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "action",
				Description:      "Action: control command (\"|\" command)* Left delim is past. Now get actions. First word could be a keyword such as range. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "breakControl",
				Description:      "Break: {{break}} Break keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "continueControl",
				Description:      "Continue: {{continue}} Continue keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "pipeline",
				Description:      "Pipeline: declarations? command ('|' command)* ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PipeNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "checkPipeline",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "parseControl",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "PipeNode",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "ListNode",
						TypePkgName: "parse",
					},
					returnSet{
						TypeName:    "ListNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "ifControl",
				Description:      "If: {{if pipeline}} itemList {{end}} {{if pipeline}} itemList {{else}} itemList {{end}} If keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "rangeControl",
				Description:      "Range: {{range pipeline}} itemList {{end}} {{range pipeline}} itemList {{else}} itemList {{end}} Range keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "withControl",
				Description:      "With: {{with pipeline}} itemList {{end}} {{with pipeline}} itemList {{else}} itemList {{end}} If keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "endControl",
				Description:      "End: {{end}} End keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "elseControl",
				Description:      "Else: {{else}} Else keyword is past. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "blockControl",
				Description:      "Block: {{block stringValue pipeline}} Block keyword is past. The name must be something that can evaluate to a string. The pipeline is mandatory. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "templateControl",
				Description:      "Template: {{template stringValue pipeline}} Template keyword is past. The name must be something that can evaluate to a string. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "parseTemplateName",
				Description:      "",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "command",
				Description:      "command: operand (space operand)* space-separated arguments up to a pipeline character or right delimiter. we consume the pipe character but leave the right delim to terminate the action. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommandNode",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "operand",
				Description:      "operand: term .Field* An operand is a space-separated component of a command, a term possibly followed by field accesses. A nil return means the next item is not an operand. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "term",
				Description:      "term: literal (number, string, nil, boolean) function (identifier) . .Field $ '(' pipeline ')' A term is a simple \"expression\". A nil return means the next item is not a term. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "hasFunction",
				Description:      "hasFunction reports if a function name exists in the Tree's maps. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "popVars",
				Description:      "popVars trims the variable list to the specified length ",
				ReceiverTypeName: "Tree",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "useVar",
				Description:      "useVar returns a node for a variable reference. It errors if the variable is not defined. ",
				ReceiverTypeName: "Tree",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "VariableNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "",
				ReceiverTypeName: "VariableNode",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tree",
				Description:      "",
				ReceiverTypeName: "VariableNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tree",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "VariableNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "",
				ReceiverTypeName: "WithNode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "parse",
					},
				},
			},
		},
		"encodecounter": []methodSet{
			methodSet{
				Name:             "Write",
				Description:      "Write writes the contents of the count-data file to the writer previously supplied to NewCoverageDataWriter. Returns an error if something went wrong somewhere with the write. ",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "patchSegmentHeader",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeSegmentPreamble",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendSegment",
				Description:      "AppendSegment appends a new segment to a counter data, with a new args section followed by a payload of counter data clauses. ",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeHeader",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeBytes",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeCounters",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeFooter",
				Description:      "",
				ReceiverTypeName: "CoverageDataWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"slog": []methodSet{
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether a and b have equal keys and values. ",
				ReceiverTypeName: "Attr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns an Attr for a string value. ",
				ReceiverTypeName: "Attr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isEmpty",
				Description:      "isEmpty reports whether a has an empty key and a nil value. That can be written as Attr{} or Any(\"\", nil). ",
				ReceiverTypeName: "Attr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "",
				ReceiverTypeName: "JSONHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WithAttrs",
				Description:      "",
				ReceiverTypeName: "JSONHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "WithGroup",
				Description:      "",
				ReceiverTypeName: "JSONHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "Handle",
				Description:      "Collect the level, attributes and message in a string and write it with the default log.Logger. Let the log.Logger handle time and file/line. ",
				ReceiverTypeName: "JSONHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns an Attr for a string value. ",
				ReceiverTypeName: "Kind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns an Attr for a string value. ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalJSON",
				Description:      "MarshalJSON implements [encoding/json.Marshaler] by quoting the output of [Level.String]. ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalJSON",
				Description:      "UnmarshalJSON implements [encoding/json.Unmarshaler] It accepts any string produced by [Level.MarshalJSON], ignoring case. It also accepts numeric offsets that would result in a different string on output. For example, \"Error-8\" would marshal as \"INFO\". ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements [encoding.TextAppender] by calling [Level.String]. ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements [encoding.TextMarshaler] by calling [Level.AppendText]. ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements [encoding.TextUnmarshaler]. It accepts any string produced by [Level.MarshalText], ignoring case. It also accepts numeric offsets that would result in a different string on output. For example, \"Error-8\" would marshal as \"INFO\". ",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parse",
				Description:      "",
				ReceiverTypeName: "Level",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets v's level to l. ",
				ReceiverTypeName: "LevelVar",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns an Attr for a string value. ",
				ReceiverTypeName: "LevelVar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements [encoding.TextAppender] by calling [Level.String]. ",
				ReceiverTypeName: "LevelVar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements [encoding.TextMarshaler] by calling [Level.AppendText]. ",
				ReceiverTypeName: "LevelVar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements [encoding.TextUnmarshaler]. It accepts any string produced by [Level.MarshalText], ignoring case. It also accepts numeric offsets that would result in a different string on output. For example, \"Error-8\" would marshal as \"INFO\". ",
				ReceiverTypeName: "LevelVar",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "clone",
				Description:      "",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "With",
				Description:      "With returns a Logger that includes the given attributes in each output operation. Arguments are converted to attributes as if by [Logger.Log]. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "WithGroup",
				Description:      "",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Logger",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Log",
				Description:      "Log emits a log record with the current time and the given level and message. The Record's Attrs consist of the Logger's attributes followed by the Attrs specified by args. The attribute arguments are processed as follows: - If an argument is an Attr, it is used as is. - If an argument is a string and this is not the last argument, the following argument is treated as the value and the two are combined into an Attr. - Otherwise, the argument is treated as a value with key \"!BADKEY\". ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LogAttrs",
				Description:      "LogAttrs is a more efficient version of [Logger.Log] that accepts only Attrs. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Debug",
				Description:      "Debug logs at [LevelDebug]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DebugContext",
				Description:      "DebugContext logs at [LevelDebug] with the given context. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Info",
				Description:      "Info logs at [LevelInfo]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "InfoContext",
				Description:      "InfoContext logs at [LevelInfo] with the given context. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Warn",
				Description:      "Warn logs at [LevelWarn]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "WarnContext",
				Description:      "WarnContext logs at [LevelWarn] with the given context. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "Error logs at [LevelError]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ErrorContext",
				Description:      "ErrorContext logs at [LevelError] with the given context. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "log",
				Description:      "log is the low-level logging method for methods that take ...any. It must always be called directly by an exported logging method or function, because it uses a fixed call depth to obtain the pc. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "logAttrs",
				Description:      "logAttrs is like [Logger.log], but for methods that take ...Attr. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a copy of the record with no shared state. The original record and the clone can both be modified without interfering with each other. ",
				ReceiverTypeName: "Record",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Record",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "NumAttrs",
				Description:      "NumAttrs returns the number of attributes in the [Record]. ",
				ReceiverTypeName: "Record",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Attrs",
				Description:      "Attrs calls f on each Attr in the [Record]. Iteration stops if f returns false. ",
				ReceiverTypeName: "Record",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddAttrs",
				Description:      "AddAttrs appends the given Attrs to the [Record]'s list of Attrs. It omits empty groups. ",
				ReceiverTypeName: "Record",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add converts the args to Attrs as described in [Logger.Log], then appends the Attrs to the [Record]'s list of Attrs. It omits empty groups. ",
				ReceiverTypeName: "Record",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "group",
				Description:      "group returns the non-zero fields of s as a slice of attrs. It is similar to a LogValue method, but we don't want Source to implement LogValuer because it would be resolved before the ReplaceAttr function was called. ",
				ReceiverTypeName: "Source",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "isEmpty",
				Description:      "isEmpty reports whether a has an empty key and a nil value. That can be written as Attr{} or Any(\"\", nil). ",
				ReceiverTypeName: "Source",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "",
				ReceiverTypeName: "TextHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WithAttrs",
				Description:      "",
				ReceiverTypeName: "TextHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "WithGroup",
				Description:      "",
				ReceiverTypeName: "TextHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "Handle",
				Description:      "Collect the level, attributes and message in a string and write it with the default log.Logger. Let the log.Logger handle time and file/line. ",
				ReceiverTypeName: "TextHandler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Any",
				Description:      "Any returns an Attr for the supplied value. See [AnyValue] for how values are treated. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns an Attr for a string value. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "str",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 returns an Attr for an int64. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns an Attr for a uint64. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bool",
				Description:      "Bool returns an Attr for a bool. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bool",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Duration",
				Description:      "Duration returns an Attr for a [time.Duration]. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "duration",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns an Attr for a floating-point number. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "float",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Time",
				Description:      "Time returns an Attr for a [time.Time]. It discards the monotonic portion. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "time",
				Description:      "See TimeValue to understand how times are represented. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "LogValuer",
				Description:      "LogValuer returns v's value as a LogValuer. It panics if v is not a LogValuer. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "LogValuer",
						TypePkgName: "slog",
					},
				},
			},
			methodSet{
				Name:             "Group",
				Description:      "Group returns an Attr for a Group [Value]. The first argument is the key; the remaining arguments are converted to Attrs as in [Logger.Log]. Use Group to collect several key-value pairs under a single key on a log line, or as the result of LogValue in order to log a single value as multiple Attrs. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]log/slog.Attr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "group",
				Description:      "group returns the non-zero fields of s as a slice of attrs. It is similar to a LogValue method, but we don't want Source to implement LogValuer because it would be resolved before the ReplaceAttr function was called. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]log/slog.Attr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether a and b have equal keys and values. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isEmptyGroup",
				Description:      "isEmptyGroup reports whether v is a group that has no attributes. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "append appends a text representation of v to dst. v is formatted as with fmt.Sprint. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Resolve",
				Description:      "Resolve repeatedly calls LogValue on v while it implements [LogValuer], and returns the result. If v resolves to a group, the group's attributes' values are not recursively resolved. If the number of LogValue calls exceeds a threshold, a Value containing an error is returned. Resolve's return value is guaranteed not to be of Kind [KindLogValuer]. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "slog",
					},
				},
			},
		},
		"ecdsa": []methodSet{
			methodSet{
				Name:             "Bytes",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PublicKey",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdsa",
					},
				},
			},
			methodSet{
				Name:             "ECDH",
				Description:      "ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the Curve is not supported by crypto/ecdh. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PrivateKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Public",
				Description:      "Public returns the public key corresponding to priv. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. Two keys are only considered to have the same value if they have the same Curve value. Note that for example [elliptic.P256] and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes encodes the public key as an uncompressed point according to SEC 1, Version 2.0, Section 2.3.3 (also known as the X9.62 uncompressed format). It returns an error if the public key is invalid. PublicKey.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or Bytes returns an error. Bytes returns the same format as [ecdh.PublicKey.Bytes] does for NIST curves. Note that public keys are more commonly encoded in DER (or PEM) format, which can be generated with [crypto/x509.MarshalPKIXPublicKey] (and [encoding/pem]). ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sign",
				Description:      "Sign signs a hash (which should be the result of hashing a larger message with opts.HashFunc()) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature, like [SignASN1]. If rand is not nil, the signature is randomized. Most applications should use [crypto/rand.Reader] as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions. If rand is nil, Sign will produce a deterministic signature according to RFC 6979. When producing a deterministic signature, opts.HashFunc() must be the function used to produce digest and priv.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521]. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ECDH",
				Description:      "ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the Curve is not supported by crypto/ecdh. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "ecdh",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. Two keys are only considered to have the same value if they have the same Curve value. Note that for example [elliptic.P256] and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes encodes the public key as an uncompressed point according to SEC 1, Version 2.0, Section 2.3.3 (also known as the X9.62 uncompressed format). It returns an error if the public key is invalid. PublicKey.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or Bytes returns an error. Bytes returns the same format as [ecdh.PublicKey.Bytes] does for NIST curves. Note that public keys are more commonly encoded in DER (or PEM) format, which can be generated with [crypto/x509.MarshalPKIXPublicKey] (and [encoding/pem]). ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"trace": []methodSet{
			methodSet{
				Name:             "Start",
				Description:      "Start activates the flight recorder and begins recording trace data. Only one call to trace.Start may be active at any given time. In addition, currently only one flight recorder may be active in the program. Returns an error if the flight recorder cannot be started or is already started. ",
				ReceiverTypeName: "FlightRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stop",
				Description:      "Stop ends recording of trace data. It blocks until any concurrent WriteTo calls complete. ",
				ReceiverTypeName: "FlightRecorder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "Enabled returns true if the flight recorder is active. Specifically, it will return true if Start did not return an error, and Stop has not yet been called. It is safe to call from multiple goroutines simultaneously. ",
				ReceiverTypeName: "FlightRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo snapshots the moving window tracked by the flight recorder. The snapshot is expected to contain data that is up-to-date as of when WriteTo is called, though this is not a hard guarantee. Only one goroutine may execute WriteTo at a time. An error is returned upon failure to write to w, if another WriteTo call is already in-progress, or if the flight recorder is inactive. ",
				ReceiverTypeName: "FlightRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "End marks the end of the operation represented by the [Task]. ",
				ReceiverTypeName: "Region",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "End",
				Description:      "End marks the end of the operation represented by the [Task]. ",
				ReceiverTypeName: "Task",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the kind of event that this is. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EventKind",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Goroutine",
				Description:      "Goroutine returns the ID of the goroutine that was executing when this event happened. It describes part of the execution context for this event. Note that for goroutine state transitions this always refers to the state before the transition. For example, if a goroutine is just starting to run on this thread and/or proc, then this will return NoGoroutine. In this case, the goroutine starting to run will be can be found at Event.StateTransition().Resource. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GoID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Proc",
				Description:      "Proc returns the ID of the proc this event event pertains to. Note that for proc state transitions this always refers to the state before the transition. For example, if a proc is just starting to run on this thread, then this will return NoProc. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Thread",
				Description:      "Thread returns the ID of the thread this event pertains to. Note that for thread state transitions this always refers to the state before the transition. For example, if a thread is just starting to run, then this will return NoThread. Note: tracking thread state is not currently supported, so this will always return a valid thread ID. However thread state transitions may be tracked in the future, and callers must be robust to this possibility. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ThreadID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "RangeAttributes",
				Description:      "RangeAttributes returns attributes for a completed range. Panics if Kind != EventRangeEnd. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/trace.RangeAttribute",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StateTransition",
				Description:      "StateTransition returns details about a StateTransition event. Panics if Kind != EventStateTransition. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "StateTransition",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Sync",
				Description:      "Sync returns details that are relevant for the following events, up to but excluding the next EventSync event. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sync",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Experimental",
				Description:      "Experimental returns a view of the raw event for an experimental event. Panics if Kind != EventExperimental. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ExperimentalEvent",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "validateTableIDs",
				Description:      "validateTableIDs checks to make sure lookups in e.table will work. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "EventKind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ArgValue",
				Description:      "ArgValue returns a typed Value for the i'th argument in the experimental event. ",
				ReceiverTypeName: "ExperimentalEvent",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Executing",
				Description:      "Executing returns true if the state indicates that the goroutine is executing and bound to its thread. ",
				ReceiverTypeName: "GoState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "GoState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NonOverlappingStats",
				Description:      "",
				ReceiverTypeName: "GoroutineExecStats",
				Returns: []returnSet{
					returnSet{
						TypeName:    "map[string]time.Duration",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnknownTime",
				Description:      "UnknownTime returns whatever isn't accounted for in TotalTime. ",
				ReceiverTypeName: "GoroutineExecStats",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "sub",
				Description:      "sub returns the stats v-s. ",
				ReceiverTypeName: "GoroutineExecStats",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GoroutineExecStats",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "clone",
				Description:      "",
				ReceiverTypeName: "GoroutineExecStats",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GoroutineExecStats",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "snapshotStat",
				Description:      "snapshotStat returns the snapshot of the goroutine execution statistics. This is called as we process the ordered trace event stream. lastTs is used to process pending statistics if this is called before any goroutine end event. ",
				ReceiverTypeName: "GoroutineSummary",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GoroutineExecStats",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "finalize",
				Description:      "finalize is called when processing a goroutine end event or at the end of trace processing. This finalizes the execution stat and any active regions in the goroutine, in which case trigger is nil. ",
				ReceiverTypeName: "GoroutineSummary",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MMU",
				Description:      "MMU returns the minimum mutator utilization for the given time window. This is the minimum utilization for all windows of this duration across the execution. The returned value is in the range [0, 1]. ",
				ReceiverTypeName: "MMUCurve",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Examples",
				Description:      "Examples returns n specific examples of the lowest mutator utilization for the given window size. The returned windows will be disjoint (otherwise there would be a huge number of mostly-overlapping windows at the single lowest point). There are no guarantees on which set of disjoint windows this returns. ",
				ReceiverTypeName: "MMUCurve",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/trace.UtilWindow",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MUD",
				Description:      "MUD returns mutator utilization distribution quantiles for the given window size. The mutator utilization distribution is the distribution of mean mutator utilization across all windows of the given window size in the trace. The minimum mutator utilization is the minimum (0th percentile) of this distribution. (However, if only the minimum is desired, it's more efficient to use the MMU method.) ",
				ReceiverTypeName: "MMUCurve",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mmu",
				Description:      "",
				ReceiverTypeName: "MMUCurve",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Executing",
				Description:      "Executing returns true if the state indicates that the goroutine is executing and bound to its thread. ",
				ReceiverTypeName: "ProcState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ProcState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadEvent",
				Description:      "ReadEvent reads a single event from the stream. If the stream has been exhausted, it returns an invalid event and io.EOF. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "trace",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Goroutine",
				Description:      "Goroutine returns the ID of the goroutine that was executing when this event happened. It describes part of the execution context for this event. Note that for goroutine state transitions this always refers to the state before the transition. For example, if a goroutine is just starting to run on this thread and/or proc, then this will return NoGoroutine. In this case, the goroutine starting to run will be can be found at Event.StateTransition().Resource. ",
				ReceiverTypeName: "ResourceID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "GoID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Proc",
				Description:      "Proc returns the ID of the proc this event event pertains to. Note that for proc state transitions this always refers to the state before the transition. For example, if a proc is just starting to run on this thread, then this will return NoProc. ",
				ReceiverTypeName: "ResourceID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ProcID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Thread",
				Description:      "Thread returns the ID of the thread this event pertains to. Note that for thread state transitions this always refers to the state before the transition. For example, if a thread is just starting to run, then this will return NoThread. Note: tracking thread state is not currently supported, so this will always return a valid thread ID. However thread state transitions may be tracked in the future, and callers must be robust to this possibility. ",
				ReceiverTypeName: "ResourceID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ThreadID",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ResourceID",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ResourceKind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Frames",
				Description:      "Frames is an iterator over the frames in a Stack. ",
				ReceiverTypeName: "Stack",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "getOrAddTask",
				Description:      "",
				ReceiverTypeName: "Summarizer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UserTaskSummary",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Finalize",
				Description:      "Finalize indicates to the summarizer that we're done processing the trace. It cleans up any remaining state and returns the full summary. ",
				ReceiverTypeName: "Summarizer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Summary",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub subtracts t0 from t, returning the duration in nanoseconds. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Complete",
				Description:      "Complete returns true if we have complete information about the task from the trace: both a start and an end. ",
				ReceiverTypeName: "UserTaskSummary",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Descendents",
				Description:      "Descendents returns a slice consisting of itself (always the first task returned), and the transitive closure of all of its children. ",
				ReceiverTypeName: "UserTaskSummary",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*internal/trace.UserTaskSummary",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the kind of event that this is. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ValueKind",
						TypePkgName: "trace",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns the uint64 value for a ValueUint64. Panics if this Value's Kind is not ValueUint64. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"encodemeta": []methodSet{
			methodSet{
				Name:             "AddFunc",
				Description:      "AddFunc registers a new function with the meta data builder. ",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "emitFuncOffsets",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "emitFunc",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "reportWriteError",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "wrUint32",
				Description:      "",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Emit",
				Description:      "Emit writes the meta-data accumulated so far in this builder to 'w'. Returns a hash of the meta-data payload and an error. ",
				ReceiverTypeName: "CoverageMetaDataBuilder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[16]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "CoverageMetaFileWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"bufio": []methodSet{
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of the underlying buffer in bytes. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards any buffered data, resets all state, and switches the buffered reader to read from r. Calling Reset on the zero value of [Reader] initializes the internal buffer to the default size. Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "reset",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "fill",
				Description:      "fill reads a new chunk into the buffer. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "readErr",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Peek",
				Description:      "Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If necessary, Peek will read more bytes into the buffer in order to make n bytes available. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is [ErrBufferFull] if n is larger than b's buffer size. Calling Peek prevents a [Reader.UnreadByte] or [Reader.UnreadRune] call from succeeding until the next read operation. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Discard",
				Description:      "Discard skips the next n bytes, returning the number of bytes discarded. If Discard skips fewer than n bytes, it also returns an error. If 0 <= n <= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying [Reader], hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). If the underlying [Reader] can return a non-zero count with io.EOF, then this Read method can do so as well; see the [io.Reader] docs. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadByte",
				Description:      "ReadByte reads and returns a single byte. If no byte is available, returns an error. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadByte",
				Description:      "UnreadByte unreads the last byte. Only the most recently read byte can be unread. UnreadByte returns an error if the most recent method called on the [Reader] was not a read operation. Notably, [Reader.Peek], [Reader.Discard], and [Reader.WriteTo] are not considered read operations. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadRune",
				Description:      "ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadRune",
				Description:      "UnreadRune unreads the last rune. If the most recent method called on the [Reader] was not a [Reader.ReadRune], [Reader.UnreadRune] returns an error. (In this regard it is stricter than [Reader.UnreadByte], which will unread the last byte from any read operation.) ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Buffered",
				Description:      "Buffered returns the number of bytes that can be read from the current buffer. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadSlice",
				Description:      "ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error [ErrBufferFull] if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use [Reader.ReadBytes] or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadLine",
				Description:      "ReadLine is a low-level line-reading primitive. Most callers should use [Reader.ReadBytes]('\\n') or [Reader.ReadString]('\\n') instead or use a [Scanner]. ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both. The text returned from ReadLine does not include the line end (\"\\r\\n\" or \"\\n\"). No indication or error is given if the input ends without a final line end. Calling [Reader.UnreadByte] after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "collectFragments",
				Description:      "collectFragments reads until the first occurrence of delim in the input. It returns (slice of full buffers, remaining bytes before delim, total number of bytes in the combined first two elements, error). The complete result is equal to `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a length of `totalLen`. The result is structured in this way to allow callers to minimize allocations and copies. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadBytes",
				Description:      "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadString",
				Description:      "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements io.WriterTo. This may make multiple calls to the [Reader.Read] method of the underlying [Reader]. If the underlying reader supports the [Reader.WriteTo] method, this calls the underlying [Reader.WriteTo] without buffering. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeBuf",
				Description:      "writeBuf writes the [Reader]'s buffer to the writer. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err returns the first non-EOF error that was encountered by the [Scanner]. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the most recent token generated by a call to [Scanner.Scan]. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Text",
				Description:      "Text returns the most recent token generated by a call to [Scanner.Scan] as a newly allocated string holding its bytes. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan advances the [Scanner] to the next token, which will then be available through the [Scanner.Bytes] or [Scanner.Text] method. It returns false when there are no more tokens, either by reaching the end of the input or an error. After Scan returns false, the [Scanner.Err] method will return any error that occurred during scanning, except that if it was [io.EOF], [Scanner.Err] will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "advance",
				Description:      "advance consumes n bytes of the buffer. It reports whether the advance was legal. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setErr",
				Description:      "setErr records the first error encountered. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Buffer",
				Description:      "Buffer controls memory allocation by the Scanner. It sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The contents of the buffer are ignored. The maximum token size must be less than the larger of max and cap(buf). If max <= cap(buf), [Scanner.Scan] will use this buffer only and do no allocation. By default, [Scanner.Scan] uses an internal buffer and sets the maximum token size to [MaxScanTokenSize]. Buffer panics if it is called after scanning has started. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Split",
				Description:      "Split sets the split function for the [Scanner]. The default split function is [ScanLines]. Split panics if it is called after scanning has started. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of the underlying buffer in bytes. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards any buffered data, resets all state, and switches the buffered reader to read from r. Calling Reset on the zero value of [Reader] initializes the internal buffer to the default size. Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush writes any buffered data to the underlying [io.Writer]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Available",
				Description:      "Available returns how many bytes are unused in the buffer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AvailableBuffer",
				Description:      "AvailableBuffer returns an empty buffer with b.Available() capacity. This buffer is intended to be appended to and passed to an immediately succeeding [Writer.Write] call. The buffer is only valid until the next write operation on b. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Buffered",
				Description:      "Buffered returns the number of bytes that can be read from the current buffer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes the contents of p into the buffer. It returns the number of bytes written. If nn < len(p), it also returns an error explaining why the write is short. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteByte",
				Description:      "WriteByte writes a single byte. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteRune",
				Description:      "WriteRune writes a single Unicode code point, returning the number of bytes written and any error. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom implements [io.ReaderFrom]. If the underlying writer supports the ReadFrom method, this calls the underlying ReadFrom. If there is buffered data and an underlying ReadFrom, this fills the buffer and writes it before calling ReadFrom. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"sha256": []methodSet{
			methodSet{
				Name:             "MarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cloner",
						TypePkgName: "hash",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkSum",
				Description:      "",
				ReceiverTypeName: "Digest",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[32]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"fiat": []methodSet{
			methodSet{
				Name:             "One",
				Description:      "One sets e = 1, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if e == t, and zero otherwise. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero returns 1 if e == 0, and zero otherwise. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets e = t, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the 28-byte big-endian encoding of e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns e. If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1, SetBytes returns nil and an error, and e is unchanged. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets e = t1 + t2, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub sets e = t1 - t2, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul sets e = t1 * t2, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Square",
				Description:      "Square sets e = t * t, and returns e. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets v to a if cond == 1, and to b if cond == 0. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Invert",
				Description:      "Invert sets e = 1/x, and returns e. If x == 0, Invert returns e = 0. ",
				ReceiverTypeName: "P224Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P224Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "One",
				Description:      "One sets e = 1, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if e == t, and zero otherwise. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero returns 1 if e == 0, and zero otherwise. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets e = t, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the 28-byte big-endian encoding of e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns e. If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1, SetBytes returns nil and an error, and e is unchanged. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets e = t1 + t2, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub sets e = t1 - t2, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul sets e = t1 * t2, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Square",
				Description:      "Square sets e = t * t, and returns e. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets v to a if cond == 1, and to b if cond == 0. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Invert",
				Description:      "Invert sets e = 1/x, and returns e. If x == 0, Invert returns e = 0. ",
				ReceiverTypeName: "P256Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P256Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "One",
				Description:      "One sets e = 1, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if e == t, and zero otherwise. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero returns 1 if e == 0, and zero otherwise. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets e = t, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the 28-byte big-endian encoding of e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns e. If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1, SetBytes returns nil and an error, and e is unchanged. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets e = t1 + t2, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub sets e = t1 - t2, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul sets e = t1 * t2, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Square",
				Description:      "Square sets e = t * t, and returns e. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets v to a if cond == 1, and to b if cond == 0. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Invert",
				Description:      "Invert sets e = 1/x, and returns e. If x == 0, Invert returns e = 0. ",
				ReceiverTypeName: "P384Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P384Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "One",
				Description:      "One sets e = 1, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal returns 1 if e == t, and zero otherwise. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero returns 1 if e == 0, and zero otherwise. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets e = t, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the 28-byte big-endian encoding of e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBytes",
				Description:      "SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns e. If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1, SetBytes returns nil and an error, and e is unchanged. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets e = t1 + t2, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub sets e = t1 - t2, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul sets e = t1 * t2, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Square",
				Description:      "Square sets e = t * t, and returns e. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Select",
				Description:      "Select sets v to a if cond == 1, and to b if cond == 0. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
			methodSet{
				Name:             "Invert",
				Description:      "Invert sets e = 1/x, and returns e. If x == 0, Invert returns e = 0. ",
				ReceiverTypeName: "P521Element",
				Returns: []returnSet{
					returnSet{
						TypeName:    "P521Element",
						TypePkgName: "fiat",
					},
				},
			},
		},
		"routebsd": []methodSet{
			methodSet{
				Name:             "Family",
				Description:      "Family implements the Family method of Addr interface. ",
				ReceiverTypeName: "InetAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "message",
				Description:      "",
				ReceiverTypeName: "InterfaceAddrMessage",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "message",
				Description:      "",
				ReceiverTypeName: "InterfaceMessage",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MTU",
				Description:      "MTU returns the interface MTU. ",
				ReceiverTypeName: "InterfaceMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "message",
				Description:      "",
				ReceiverTypeName: "InterfaceMulticastAddrMessage",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Family",
				Description:      "Family implements the Family method of Addr interface. ",
				ReceiverTypeName: "LinkAddr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"http": []methodSet{
			methodSet{
				Name:             "send",
				Description:      "didTimeout is non-nil only if err != nil. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "func() bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "deadline",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "transport",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RoundTripper",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects: 301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect) 308 (Permanent Redirect) An error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type [*url.Error]. The url.Error value's Timeout method will report true if the request timed out. When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. Get is a wrapper around DefaultClient.Get. To make a request with custom headers, use [NewRequest] and DefaultClient.Do. To make a request with a specified context.Context, use [NewRequestWithContext] and DefaultClient.Do. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkRedirect",
				Description:      "checkRedirect calls either the user's configured CheckRedirect function, or the default. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Do",
				Description:      "Do sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client. An error is returned if caused by client policy (such as CheckRedirect), or failure to speak HTTP (such as a network connectivity problem). A non-2xx status code doesn't cause an error. If the returned error is nil, the [Response] will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the [Client]'s underlying [RoundTripper] (typically [Transport]) may not be able to re-use a persistent TCP connection to the server for a subsequent \"keep-alive\" request. The request Body, if non-nil, will be closed by the underlying Transport, even on errors. The Body may be closed asynchronously after Do returns. On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned [Response.Body] is already closed. Generally [Get], [Post], or [PostForm] will be used instead of Do. If the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the [Request.GetBody] function is defined. The [NewRequest] function automatically sets GetBody for common standard library body types. Any returned error will be of type [*url.Error]. The url.Error value's Timeout method will report true if the request timed out. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "do",
				Description:      "",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeHeadersCopier",
				Description:      "makeHeadersCopier makes a function that copies headers from the initial Request, ireq. For every redirect, this function must be called so that it can copy headers into the upcoming Request. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(req *net/http.Request, stripSensitiveHeaders bool)",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Post",
				Description:      "Post issues a POST to the specified URL. Caller should close resp.Body when done reading from it. If the provided body is an [io.Closer], it is closed after the request. Post is a wrapper around DefaultClient.Post. To set custom headers, use [NewRequest] and DefaultClient.Do. See the [Client.Do] method documentation for details on how redirects are handled. To make a request with a specified context.Context, use [NewRequestWithContext] and DefaultClient.Do. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PostForm",
				Description:      "PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. The Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use [NewRequest] and DefaultClient.Do. When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. PostForm is a wrapper around DefaultClient.PostForm. See the [Client.Do] method documentation for details on how redirects are handled. To make a request with a specified [context.Context], use [NewRequestWithContext] and DefaultClient.Do. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Head",
				Description:      "Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects: 301 (Moved Permanently) 302 (Found) 303 (See Other) 307 (Temporary Redirect) 308 (Permanent Redirect) Head is a wrapper around DefaultClient.Head. To make a request with a specified [context.Context], use [NewRequestWithContext] and DefaultClient.Do. ",
				ReceiverTypeName: "Client",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CloseIdleConnections",
				Description:      "CloseIdleConnections closes any connections on its [Transport] which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use. If [Client.Transport] does not have a [Client.CloseIdleConnections] method then this method does nothing. ",
				ReceiverTypeName: "Client",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the serialization of the cookie for use in a [Cookie] header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned. ",
				ReceiverTypeName: "ConnState",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the serialization of the cookie for use in a [Cookie] header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned. ",
				ReceiverTypeName: "Cookie",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Valid",
				Description:      "Valid reports whether the cookie is valid. ",
				ReceiverTypeName: "Cookie",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddTrustedOrigin",
				Description:      "AddTrustedOrigin allows all requests with an [Origin] header which exactly matches the given value. Origin header values are of the form \"scheme://host[:port]\". AddTrustedOrigin can be called concurrently with other methods or request handling, and applies to future requests. [Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddInsecureBypassPattern",
				Description:      "AddInsecureBypassPattern permits all requests that match the given pattern. The pattern syntax and precedence rules are the same as [ServeMux]. Only requests that match the pattern directly are permitted. Those that ServeMux would redirect to a pattern (e.g. after cleaning the path or adding a trailing slash) are not. AddInsecureBypassPattern can be called concurrently with other methods or request handling, and applies to future requests. ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetDenyHandler",
				Description:      "SetDenyHandler sets a handler to invoke when a request is rejected. The default error handler responds with a 403 Forbidden status. SetDenyHandler can be called concurrently with other methods or request handling, and applies to future requests. Check does not call the error handler. ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Check",
				Description:      "Check applies cross-origin checks to a request. It returns an error if the request should be rejected. ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isRequestExempt",
				Description:      "isRequestExempt checks the bypasses which require taking a lock, and should be deferred until the last moment. ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Handler",
				Description:      "Handler returns a handler that applies cross-origin checks before invoking the handler h. If a request fails cross-origin checks, the request is rejected with a 403 Forbidden status or handled with the handler passed to [CrossOriginProtection.SetDenyHandler]. ",
				ReceiverTypeName: "CrossOriginProtection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open implements [FileSystem] using [os.Open], opening files for reading rooted and relative to the directory d. ",
				ReceiverTypeName: "Dir",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServeHTTP",
				Description:      "",
				ReceiverTypeName: "HandlerFunc",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "MaxBytesError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ProtocolError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Is",
				Description:      "Is lets http.ErrNotSupported match errors.ErrUnsupported. ",
				ReceiverTypeName: "ProtocolError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HTTP1",
				Description:      "HTTP1 reports whether p includes HTTP/1. ",
				ReceiverTypeName: "Protocols",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetHTTP1",
				Description:      "SetHTTP1 adds or removes HTTP/1 from p. ",
				ReceiverTypeName: "Protocols",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HTTP2",
				Description:      "HTTP2 reports whether p includes HTTP/2. ",
				ReceiverTypeName: "Protocols",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetHTTP2",
				Description:      "SetHTTP2 adds or removes HTTP/2 from p. ",
				ReceiverTypeName: "Protocols",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "UnencryptedHTTP2",
				Description:      "UnencryptedHTTP2 reports whether p includes unencrypted HTTP/2. ",
				ReceiverTypeName: "Protocols",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetUnencryptedHTTP2",
				Description:      "SetUnencryptedHTTP2 adds or removes unencrypted HTTP/2 from p. ",
				ReceiverTypeName: "Protocols",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setBit",
				Description:      "",
				ReceiverTypeName: "Protocols",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the serialization of the cookie for use in a [Cookie] header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned. ",
				ReceiverTypeName: "Protocols",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Context",
				Description:      "Context returns the request's context. To change the context, use [Request.Clone] or [Request.WithContext]. The returned context is always non-nil; it defaults to the background context. For outgoing client requests, the context controls cancellation. For incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			methodSet{
				Name:             "WithContext",
				Description:      "WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil. For outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. To create a new request with a context, use [NewRequestWithContext]. To make a deep copy of a request with a new context, use [Request.Clone]. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a copy of h or nil if h is nil. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "ProtoAtLeast",
				Description:      "ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UserAgent",
				Description:      "UserAgent returns the client's User-Agent, if sent in the request. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Cookies",
				Description:      "Cookies parses and returns the HTTP cookies sent with the request. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CookiesNamed",
				Description:      "CookiesNamed parses and returns the named HTTP cookies sent with the request or an empty slice if none matched. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddCookie",
				Description:      "AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one [Cookie] header field. That means all cookies, if any, are written into the same line, separated by semicolon. AddCookie only sanitizes c's name and value, and does not sanitize a Cookie header already present in the request. ",
				ReceiverTypeName: "Request",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Referer",
				Description:      "Referer returns the referring URL, if sent in the request. Referer is misspelled as in the request itself, a mistake from the earliest days of HTTP. This value can also be fetched from the [Header] map as Header[\"Referer\"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[\"Referrer\"]. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MultipartReader",
				Description:      "MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of [Request.ParseMultipartForm] to process the request body as a stream. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "multipartReader",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isH2Upgrade",
				Description:      "isH2Upgrade reports whether r represents the http2 \"client preface\" magic string. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteProxy",
				Description:      "WriteProxy is like [Request.Write] but writes the request in the form expected by an HTTP proxy. In particular, [Request.WriteProxy] writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "either dataB or dataS is non-zero. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BasicAuth",
				Description:      "BasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetBasicAuth",
				Description:      "SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password. With HTTP Basic Authentication the provided username and password are not encrypted. It should generally only be used in an HTTPS request. The username may not contain a colon. Some protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with [url.QueryEscape]. ",
				ReceiverTypeName: "Request",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ParseForm",
				Description:      "ParseForm populates r.Form and r.PostForm. For all requests, ParseForm parses the raw query from the URL and updates r.Form. For POST, PUT, and PATCH requests, it also reads the request body, parses it as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form. If the request Body's size has not already been limited by [MaxBytesReader], the size is capped at 10MB. For other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value. [Request.ParseMultipartForm] calls ParseForm automatically. ParseForm is idempotent. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseMultipartForm",
				Description:      "ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls [Request.ParseForm] if necessary. If ParseForm returns an error, ParseMultipartForm returns it but also continues parsing the request body. After one call to ParseMultipartForm, subsequent calls have no effect. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FormValue",
				Description:      "FormValue returns the first value for the named component of the query. The precedence order: 1. application/x-www-form-urlencoded form body (POST, PUT, PATCH only) 2. query parameters (always) 3. multipart/form-data form body (always) FormValue calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect [Request.Form] directly. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PostFormValue",
				Description:      "PostFormValue returns the first value for the named component of the POST, PUT, or PATCH request body. URL query parameters are ignored. PostFormValue calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FormFile",
				Description:      "FormFile returns the first file for the provided form key. FormFile calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "FileHeader",
						TypePkgName: "multipart",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PathValue",
				Description:      "PathValue returns the value for the named path wildcard in the [ServeMux] pattern that matched the request. It returns the empty string if the request was not matched against a pattern or there is no such wildcard in the pattern. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetPathValue",
				Description:      "SetPathValue sets name to value, so that subsequent calls to r.PathValue(name) return value. ",
				ReceiverTypeName: "Request",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "patIndex",
				Description:      "patIndex returns the index of name in the list of named wildcards of the request's pattern, or -1 if there is no such name. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "expectsContinue",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wantsHttp10KeepAlive",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wantsClose",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "closeBody",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isReplayable",
				Description:      "",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "outgoingLength",
				Description:      "outgoingLength reports the Content-Length of this outgoing (Client) request. It maps 0 into -1 (unknown) when the Body is non-nil. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "requiresHTTP1",
				Description:      "requiresHTTP1 reports whether this request requires being sent on an HTTP/1 connection. ",
				ReceiverTypeName: "Request",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Cookies",
				Description:      "Cookies parses and returns the HTTP cookies sent with the request. ",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/http.Cookie",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Location",
				Description:      "Location returns the URL of the response's \"Location\" header, if present. Relative redirects are resolved relative to [Response.Request]. [ErrNoLocation] is returned if no Location header is present. ",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ProtoAtLeast",
				Description:      "ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. ",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "closeBody",
				Description:      "",
				ReceiverTypeName: "Response",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "bodyIsWritable",
				Description:      "bodyIsWritable reports whether the Body supports writing. The Transport returns Writable bodies for 101 Switching Protocols responses. The Transport uses this method to determine whether a persistent connection is done being managed from its perspective. Once we return a writable response body to a user, the net/http package is done managing that connection. ",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isProtocolSwitch",
				Description:      "isProtocolSwitch reports whether the response code and header indicate a successful protocol upgrade response. ",
				ReceiverTypeName: "Response",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "",
				ReceiverTypeName: "ResponseController",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Hijack",
				Description:      "Hijack lets the caller take over the connection. See the [Hijacker] interface for details. ",
				ReceiverTypeName: "ResponseController",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "ReadWriter",
						TypePkgName: "bufio",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetReadDeadline",
				Description:      "",
				ReceiverTypeName: "ResponseController",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetWriteDeadline",
				Description:      "",
				ReceiverTypeName: "ResponseController",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EnableFullDuplex",
				Description:      "",
				ReceiverTypeName: "ResponseController",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Handler",
				Description:      "Handler returns a handler that applies cross-origin checks before invoking the handler h. If a request fails cross-origin checks, the request is rejected with a 403 Forbidden status or handled with the handler passed to [CrossOriginProtection.SetDenyHandler]. ",
				ReceiverTypeName: "ServeMux",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "findHandler",
				Description:      "Formerly ServeMux.Handler. ",
				ReceiverTypeName: "ServeMux",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Handler",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "pattern",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "matchOrRedirect",
				Description:      "matchOrRedirect looks up a node in the tree that matches the host, method and path. If the url argument is non-nil, handler also deals with trailing-slash redirection: when a path doesn't match exactly, the match is tried again after appending \"/\" to the path. If that second match succeeds, the last return value is the URL to redirect to. ",
				ReceiverTypeName: "ServeMux",
				Returns: []returnSet{
					returnSet{
						TypeName:    "routingNode",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
				},
			},
			methodSet{
				Name:             "matchingMethods",
				Description:      "matchingMethods adds to methodSet all the methods that would result in a match if passed to routingNode.match with the given host and path. ",
				ReceiverTypeName: "ServeMux",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServeHTTP",
				Description:      "",
				ReceiverTypeName: "ServeMux",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Handle",
				Description:      "Handle registers the handler for the given pattern. If the given pattern conflicts with one that is already registered, Handle panics. ",
				ReceiverTypeName: "ServeMux",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HandleFunc",
				Description:      "HandleFunc registers the handler function for the given pattern. If the given pattern conflicts with one that is already registered, HandleFunc panics. ",
				ReceiverTypeName: "ServeMux",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "register",
				Description:      "",
				ReceiverTypeName: "ServeMux",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "registerErr",
				Description:      "",
				ReceiverTypeName: "ServeMux",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newConn",
				Description:      "Create new connection from rwc. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "conn",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "maxHeaderBytes",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "initialReadLimitSize",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tlsHandshakeTimeout",
				Description:      "tlsHandshakeTimeout returns the time limit permitted for the TLS handshake, or zero for unlimited. It returns the minimum of any positive ReadHeaderTimeout, ReadTimeout, or WriteTimeout. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Shutdown",
				Description:      "Shutdown gracefully closes the client connection, waiting for running streams to complete. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegisterOnShutdown",
				Description:      "RegisterOnShutdown registers a function to call on [Server.Shutdown]. This can be used to gracefully shutdown connections that have undergone ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closeIdleConns",
				Description:      "closeIdleConns closes all idle connections and reports whether the server is quiescent. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "closeListenersLocked",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ListenAndServe",
				Description:      "ListenAndServe listens on the TCP network address s.Addr and then calls [Serve] to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. If s.Addr is blank, \":http\" is used. ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed]. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shouldConfigureHTTP2ForServe",
				Description:      "shouldConfigureHTTP2ForServe reports whether Server.Serve should configure automatic HTTP/2. (which sets up the s.TLSNextProto map) ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Serve",
				Description:      "Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case [DefaultServeMux] is used. HTTP/2 support is only enabled if the Listener returns [*tls.Conn] connections and they were configured with \"h2\" in the TLS Config.NextProtos. Serve always returns a non-nil error. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServeTLS",
				Description:      "ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. The handler is typically nil, in which case [DefaultServeMux] is used. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. ServeTLS always returns a non-nil error. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "protocols",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Protocols",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "trackListener",
				Description:      "trackListener adds or removes a net.Listener to the set of tracked listeners. We store a pointer to interface in the map set, in case the net.Listener is not comparable. This is safe because we only call trackListener via Serve and can track+defer untrack the same pointer to local variable there. We never need to compare a Listener from another caller. It reports whether the server is still up (not Shutdown or Closed). ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "trackConn",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "idleTimeout",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "readHeaderTimeout",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "doKeepAlives",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shuttingDown",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetKeepAlivesEnabled",
				Description:      "SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "logf",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ListenAndServeTLS",
				Description:      "ListenAndServeTLS acts identically to [ListenAndServe], except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setupHTTP2_ServeTLS",
				Description:      "setupHTTP2_ServeTLS conditionally configures HTTP/2 on s and reports whether there was an error setting it up. If it is not configured for policy reasons, nil is returned. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setupHTTP2_Serve",
				Description:      "setupHTTP2_Serve is called from (*Server).Serve and conditionally configures HTTP/2 on s using a more conservative policy than setupHTTP2_ServeTLS because Serve is called after tls.Listen, and may be called concurrently. See shouldConfigureHTTP2ForServe. The tests named TestTransportAutomaticHTTP2* and TestConcurrentServerServe in server_test.go demonstrate some of the supported use cases and motivations. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "onceSetNextProtoDefaults_Serve",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "onceSetNextProtoDefaults",
				Description:      "onceSetNextProtoDefaults configures HTTP/2, if the user hasn't configured otherwise. (by setting s.TLSNextProto non-nil) It must only be called via s.nextProtoOnce (use s.setupHTTP2_*). ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RoundTrip",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeBufferSize",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readBufferSize",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone returns a copy of h or nil if h is nil. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Transport",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "hasCustomTLSDialer",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "onceSetNextProtoDefaults",
				Description:      "onceSetNextProtoDefaults configures HTTP/2, if the user hasn't configured otherwise. (by setting s.TLSNextProto non-nil) It must only be called via s.nextProtoOnce (use s.setupHTTP2_*). ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "protocols",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Protocols",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "useRegisteredProtocol",
				Description:      "useRegisteredProtocol reports whether an alternate protocol (as registered with Transport.RegisterProtocol) should be respected for this request. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "alternateRoundTripper",
				Description:      "alternateRoundTripper returns the alternate RoundTripper to use for this request if the Request's URL scheme requires one, or nil for the normal case of using the Transport. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RoundTripper",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "roundTrip",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegisterProtocol",
				Description:      "RegisterProtocol registers a new protocol with scheme. The [Transport] will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics. RegisterProtocol can be used by other packages to provide implementations of protocol schemes like \"ftp\" or \"file\". If rt.RoundTrip returns [ErrSkipAltProtocol], the Transport will handle the [Transport.RoundTrip] itself for that one request, as if the protocol were not registered. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CloseIdleConnections",
				Description:      "CloseIdleConnections closes any connections on its [Transport] which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use. If [Client.Transport] does not have a [Client.CloseIdleConnections] method then this method does nothing. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "prepareTransportCancel",
				Description:      "prepareTransportCancel sets up state to convert Transport.CancelRequest into context cancelation. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CancelCauseFunc",
						TypePkgName: "context",
					},
				},
			},
			methodSet{
				Name:             "CancelRequest",
				Description:      "CancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after [Transport.RoundTrip] has returned. Deprecated: Use [Request.WithContext] to create a request with a cancelable context instead. CancelRequest cannot cancel HTTP/2 requests. This may become a no-op in a future release of Go. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "connectMethodForRequest",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "connectMethod",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "putOrCloseIdleConn",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "maxIdleConnsPerHost",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tryPutIdleConn",
				Description:      "tryPutIdleConn adds pconn to the list of idle persistent connections awaiting a new request. If pconn is no longer needed or not in a good state, tryPutIdleConn returns an error explaining why it wasn't registered. tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "queueForIdleConn",
				Description:      "queueForIdleConn queues w to receive the next idle connection for w.cm. As an optimization hint to the caller, queueForIdleConn reports whether it successfully delivered an already-idle connection. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "removeIdleConn",
				Description:      "removeIdleConn marks pconn as dead. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "removeIdleConnLocked",
				Description:      "t.idleMu must be held. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dial",
				Description:      "run in its own goroutine. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "customDialTLS",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getConn",
				Description:      "getConn dials and creates a new persistConn to the target as specified in the connectMethod. This includes doing a proxy CONNECT and/or setting up TLS. If this doesn't return an error, the persistConn is ready to write requests to. ",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "persistConn",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "queueForDial",
				Description:      "queueForDial queues w to wait for permission to begin dialing. Once w receives permission to dial, it will do so in a separate goroutine. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "startDialConnForLocked",
				Description:      "startDialConnFor calls dialConn in a new goroutine. t.connsPerHostMu must be held. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "dialConnFor",
				Description:      "dialConnFor dials on behalf of w and delivers the result to w. dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()]. If the dial is canceled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()]. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decConnsPerHost",
				Description:      "decConnsPerHost decrements the per-host connection count for key, which may in turn give a different waiting goroutine permission to dial. ",
				ReceiverTypeName: "Transport",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "dialConn",
				Description:      "",
				ReceiverTypeName: "Transport",
				Returns: []returnSet{
					returnSet{
						TypeName:    "persistConn",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"buildcfg": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ExperimentFlags",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "Enabled returns a list of enabled experiments, as lower-cased experiment names. ",
				ReceiverTypeName: "ExperimentFlags",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "All",
				Description:      "All returns a list of all experiment settings. Disabled experiments appear in the list prefixed by \"no\". ",
				ReceiverTypeName: "ExperimentFlags",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Goarm64Features",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Supports",
				Description:      "Returns true if g supports giving ARM64 ISA Note that this function doesn't accept / test suffixes (like \",lse\" or \",crypto\") ",
				ReceiverTypeName: "Goarm64Features",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "GoarmFeatures",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"syslog": []methodSet{
			methodSet{
				Name:             "connect",
				Description:      "connect makes a connection to the syslog server. It must be called with w.mu held. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write sends a log message to the syslog daemon. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes a connection to the syslog daemon. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Emerg",
				Description:      "Emerg logs a message with severity [LOG_EMERG], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Alert",
				Description:      "Alert logs a message with severity [LOG_ALERT], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Crit",
				Description:      "Crit logs a message with severity [LOG_CRIT], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err logs a message with severity [LOG_ERR], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Warning",
				Description:      "Warning logs a message with severity [LOG_WARNING], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Notice",
				Description:      "Notice logs a message with severity [LOG_NOTICE], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Info",
				Description:      "Info logs a message with severity [LOG_INFO], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Debug",
				Description:      "Debug logs a message with severity [LOG_DEBUG], ignoring the severity passed to New. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeAndRetry",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "write generates and writes a syslog formatted string. The format is as follows: <PRI>TIMESTAMP HOSTNAME TAG[PID]: MSG ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"httputil": []methodSet{
			methodSet{
				Name:             "Hijack",
				Description:      "Hijack detaches the [ServerConn] and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while [ServerConn.Read] or [ServerConn.Write] is in progress. ",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "bufio",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the [ServerConn.Read] side. ",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pending",
				Description:      "Pending returns the number of unanswered requests that have been received on the connection. ",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Do",
				Description:      "Do is convenience method that writes a request and reads a response. ",
				ReceiverTypeName: "ClientConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetURL",
				Description:      "SetURL routes the outbound request to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for \"/base/dir\". To route requests without joining the incoming path, set r.Out.URL directly. SetURL rewrites the outbound Host header to match the target's host. To preserve the inbound request's Host header (the default behavior of [NewSingleHostReverseProxy]): rewriteFunc := func(r *httputil.ProxyRequest) { r.SetURL(url) r.Out.Host = r.In.Host } ",
				ReceiverTypeName: "ProxyRequest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetXForwarded",
				Description:      "SetXForwarded sets the X-Forwarded-For, X-Forwarded-Host, and X-Forwarded-Proto headers of the outbound request. - The X-Forwarded-For header is set to the client IP address. - The X-Forwarded-Host header is set to the host name requested by the client. - The X-Forwarded-Proto header is set to \"http\" or \"https\", depending on whether the inbound request was made on a TLS-enabled connection. If the outbound request contains an existing X-Forwarded-For header, SetXForwarded appends the client IP address to it. To append to the inbound request's X-Forwarded-For header (the default behavior of [ReverseProxy] when using a Director function), copy the header from the inbound request before calling SetXForwarded: rewriteFunc := func(r *httputil.ProxyRequest) { r.Out.Header[\"X-Forwarded-For\"] = r.In.Header[\"X-Forwarded-For\"] r.SetXForwarded() } ",
				ReceiverTypeName: "ProxyRequest",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "defaultErrorHandler",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "getErrorHandler",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(net/http.ResponseWriter, *net/http.Request, error)",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "modifyResponse",
				Description:      "modifyResponse conditionally runs the optional ModifyResponse hook and reports whether the request should proceed. ",
				ReceiverTypeName: "ReverseProxy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServeHTTP",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "flushInterval",
				Description:      "flushInterval returns the p.FlushInterval value, conditionally overriding its value for a specific request/response. ",
				ReceiverTypeName: "ReverseProxy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "copyResponse",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "copyBuffer",
				Description:      "copyBuffer returns any write errors or non-EOF read errors, and the amount of bytes written. ",
				ReceiverTypeName: "ReverseProxy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "logf",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "handleUpgradeResponse",
				Description:      "",
				ReceiverTypeName: "ReverseProxy",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Hijack",
				Description:      "Hijack detaches the [ServerConn] and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while [ServerConn.Read] or [ServerConn.Write] is in progress. ",
				ReceiverTypeName: "ServerConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "net",
					},
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "bufio",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "ServerConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "ServerConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Request",
						TypePkgName: "http",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pending",
				Description:      "Pending returns the number of unanswered requests that have been received on the connection. ",
				ReceiverTypeName: "ServerConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the [ServerConn.Read] side. ",
				ReceiverTypeName: "ServerConn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"rand": []methodSet{
			methodSet{
				Name:             "Seed",
				Description:      "Seed resets the ChaCha8 to behave the same way as NewChaCha8(seed). ",
				ReceiverTypeName: "ChaCha8",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a uniformly distributed random uint64 value. ",
				ReceiverTypeName: "ChaCha8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads exactly len(p) bytes into p. It always returns len(p) and a nil error. If calls to Read and Uint64 are interleaved, the order in which bits are returned by the two is undefined, and Read may return bits generated before the last call to Uint64. ",
				ReceiverTypeName: "ChaCha8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. ",
				ReceiverTypeName: "ChaCha8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements the [encoding.BinaryAppender] interface. ",
				ReceiverTypeName: "ChaCha8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements the [encoding.BinaryMarshaler] interface. ",
				ReceiverTypeName: "ChaCha8",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seed",
				Description:      "Seed resets the ChaCha8 to behave the same way as NewChaCha8(seed). ",
				ReceiverTypeName: "PCG",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements the [encoding.BinaryAppender] interface. ",
				ReceiverTypeName: "PCG",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements the [encoding.BinaryMarshaler] interface. ",
				ReceiverTypeName: "PCG",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. ",
				ReceiverTypeName: "PCG",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "next",
				Description:      "",
				ReceiverTypeName: "PCG",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a uniformly distributed random uint64 value. ",
				ReceiverTypeName: "PCG",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExpFloat64",
				Description:      "ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using: sample = ExpFloat64() / desiredRateParameter ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NormFloat64",
				Description:      "NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using: sample = NormFloat64() * desiredStdDev + desiredMean ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 returns a non-negative pseudo-random 63-bit integer as an int64. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint32",
				Description:      "Uint32 returns a pseudo-random 32-bit value as a uint32. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a uniformly distributed random uint64 value. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int32",
				Description:      "Int32 returns a non-negative pseudo-random 31-bit integer as an int32. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int returns a non-negative pseudo-random int. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint",
				Description:      "Uint returns a pseudo-random uint. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64N",
				Description:      "Int64N returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64N",
				Description:      "Uint64N returns, as a uint64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "uint64n",
				Description:      "uint64n is the no-bounds-checks version of Uint64N. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "uint32n",
				Description:      "uint32n is an identical computation to uint64n but optimized for 32-bit systems. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int32N",
				Description:      "Int32N returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint32N",
				Description:      "Uint32N returns, as a uint32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IntN",
				Description:      "IntN returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UintN",
				Description:      "UintN returns, as a uint, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n == 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float32",
				Description:      "Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Perm",
				Description:      "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval [0,n). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Shuffle",
				Description:      "Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j. ",
				ReceiverTypeName: "Rand",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "h",
				Description:      "",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hinv",
				Description:      "",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a uniformly distributed random uint64 value. ",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExpFloat64",
				Description:      "ExpFloat64 returns an exponentially distributed float64 in the range (0, +[math.MaxFloat64]] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using: sample = ExpFloat64() / desiredRateParameter ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NormFloat64",
				Description:      "NormFloat64 returns a normally distributed float64 in the range -[math.MaxFloat64] through +[math.MaxFloat64] inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using: sample = NormFloat64() * desiredStdDev + desiredMean ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seed",
				Description:      "Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other [Rand] method. ",
				ReceiverTypeName: "Rand",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Int63",
				Description:      "Int63 returns a non-negative pseudo-random 63-bit integer as an int64. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint32",
				Description:      "Uint32 returns a pseudo-random 32-bit value as a uint32. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a pseudo-random 64-bit value as a uint64. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int31",
				Description:      "Int31 returns a non-negative pseudo-random 31-bit integer as an int32. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int returns a non-negative pseudo-random int. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int63n",
				Description:      "Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int31n",
				Description:      "Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "int31n",
				Description:      "int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). n must be > 0, but int31n does not check this; the caller must ensure it. int31n exists because Int31n is inefficient, but Go 1 compatibility requires that the stream of values produced by math/rand remain unchanged. int31n can thus only be used internally, by newly introduced APIs. For implementation details, see: https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction https://lemire.me/blog/2016/06/30/fast-random-shuffling ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Intn",
				Description:      "Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n). It panics if n <= 0. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float32",
				Description:      "Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Perm",
				Description:      "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers in the half-open interval [0,n). ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Shuffle",
				Description:      "Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j. ",
				ReceiverTypeName: "Rand",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method. ",
				ReceiverTypeName: "Rand",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "h",
				Description:      "",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hinv",
				Description:      "",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns a pseudo-random 64-bit value as a uint64. ",
				ReceiverTypeName: "Zipf",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
		},
		"weak": []methodSet{
			methodSet{
				Name:             "Value",
				Description:      "Value returns the original pointer used to create the weak pointer. It returns nil if the value pointed to by the original pointer was reclaimed by the garbage collector. If a weak pointer points to an object with a finalizer, then Value will return nil as soon as the object's finalizer is queued for execution. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*T",
						TypePkgName: "",
					},
				},
			},
		},
		"token": []methodSet{
			methodSet{
				Name:             "Name",
				Description:      "Name returns the file name of file f as registered with AddFile. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Base",
				Description:      "Base returns the base offset of file f as registered with AddFile. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of file f as registered with AddFile. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LineCount",
				Description:      "LineCount returns the number of lines in file f. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddLine",
				Description:      "AddLine adds the line offset for a new line. The line offset must be larger than the offset for the previous line and smaller than the file size; otherwise the line offset is ignored. ",
				ReceiverTypeName: "File",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MergeLine",
				Description:      "MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. [Position.Line]. MergeLine will panic if given an invalid line number. ",
				ReceiverTypeName: "File",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lines",
				Description:      "Lines returns the effective line offset table of the form described by [File.SetLines]. Callers must not mutate the result. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLines",
				Description:      "SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content \"ab\\nc\\n\" the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLinesForContent",
				Description:      "SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments. ",
				ReceiverTypeName: "File",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LineStart",
				Description:      "LineStart returns the [Pos] value of the start of the specified line. It ignores any alternative positions set using [File.AddLineColumnInfo]. LineStart panics if the 1-based line number is invalid. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "AddLineInfo",
				Description:      "AddLineInfo is like [File.AddLineColumnInfo] with a column = 1 argument. It is here for backward-compatibility for code prior to Go 1.11. ",
				ReceiverTypeName: "File",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddLineColumnInfo",
				Description:      "AddLineColumnInfo adds alternative file, line, and column number information for a given file offset. The offset must be larger than the offset for the previously added alternative line info and smaller than the file size; otherwise the information is ignored. AddLineColumnInfo is typically used to register alternative position information for line directives such as //line filename:line:column. ",
				ReceiverTypeName: "File",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "fixOffset",
				Description:      "fixOffset fixes an out-of-bounds offset such that 0 <= offset <= f.size. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Offset",
				Description:      "Offset returns the offset for the given file position p. If p is before the file's start position (or if p is NoPos), the result is 0; if p is past the file's end position, the result is the file size (see also go.dev/issue/57490). The following invariant, though not true for offset values in general, holds for the result offset: f.Offset(f.Pos(offset)) == offset ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Line",
				Description:      "Line returns the line number for the given file position p; p must be a [Pos] value in that file or [NoPos]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unpack",
				Description:      "unpack returns the filename and line and column number for a file offset. If adjusted is set, unpack will return the filename and line information possibly adjusted by //line comments; otherwise those comments are ignored. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "position",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Position",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "PositionFor",
				Description:      "PositionFor returns the Position value for the given file position p. If p is out of bounds, it is adjusted to match the File.Offset behavior. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Position",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Base",
				Description:      "Base returns the base offset of file f as registered with AddFile. ",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddFile",
				Description:      "AddFile adds a new file with a given filename, base offset, and file size to the file set s and returns the file. Multiple files may have the same name. The base offset must not be smaller than the [FileSet.Base], and size must not be negative. As a special case, if a negative base is provided, the current value of the [FileSet.Base] is used instead. Adding the file will set the file set's [FileSet.Base] value to base + size + 1 as the minimum base value for the next file. The following relationship exists between a [Pos] value p for a given file offset offs: int(p) = base + offs with offs in the range [0, size] and thus p in the range [base, base+size]. For convenience, [File.Pos] may be used to create file-specific position values from a file offset. ",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "AddExistingFiles",
				Description:      "AddExistingFiles adds the specified files to the FileSet if they are not already present. The caller must ensure that no pair of Files that would appear in the resulting FileSet overlap. ",
				ReceiverTypeName: "FileSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RemoveFile",
				Description:      "RemoveFile removes a file from the [FileSet] so that subsequent queries for its [Pos] interval yield a negative result. This reduces the memory usage of a long-lived [FileSet] that encounters an unbounded stream of files. Removing a file that does not belong to the set has no effect. ",
				ReceiverTypeName: "FileSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Iterate",
				Description:      "Iterate calls yield for the files in the file set in ascending Base order until yield returns false. ",
				ReceiverTypeName: "FileSet",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "file",
				Description:      "",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "PositionFor",
				Description:      "PositionFor returns the Position value for the given file position p. If p is out of bounds, it is adjusted to match the File.Offset behavior. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos. ",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Position",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read calls decode to deserialize a file set into s; s must not be nil. ",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write calls encode to serialize the file set s. ",
				ReceiverTypeName: "FileSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether the position is valid. ",
				ReceiverTypeName: "Pos",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether the position is valid. ",
				ReceiverTypeName: "Position",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string in one of several forms: file:line:column valid position with file name file:line valid position with file name but no column (column == 0) line:column valid position without file name line valid position without file name and no column (column == 0) file invalid position with file name - invalid position without file name ",
				ReceiverTypeName: "Position",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string in one of several forms: file:line:column valid position with file name file:line valid position with file name but no column (column == 0) line:column valid position without file name line valid position without file name and no column (column == 0) file invalid position with file name - invalid position without file name ",
				ReceiverTypeName: "Token",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Precedence",
				Description:      "Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence. ",
				ReceiverTypeName: "Token",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsLiteral",
				Description:      "IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise. ",
				ReceiverTypeName: "Token",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsOperator",
				Description:      "IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise. ",
				ReceiverTypeName: "Token",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsKeyword",
				Description:      "IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise. ",
				ReceiverTypeName: "Token",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"ast": []methodSet{
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ArrayType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ArrayType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "ArrayType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "AssignStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "AssignStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "AssignStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BadDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BadDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "declNode",
				Description:      "declNode() ensures that only declaration nodes can be assigned to a Decl. ",
				ReceiverTypeName: "BadDecl",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BadExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BadExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "BadExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BadStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BadStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "BadStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BasicLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BasicLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "BasicLit",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BinaryExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BinaryExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "BinaryExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BlockStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BlockStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "BlockStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "BranchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "BranchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "BranchStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "CallExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "CallExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "CallExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "CaseClause",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "CaseClause",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "CaseClause",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ChanType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ChanType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "ChanType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "CommClause",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "CommClause",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "CommClause",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Comment",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "Comment",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "CommentGroup",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "CommentGroup",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Text",
				Description:      "Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like \"//line\" and \"//go:noinline\" are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated. ",
				ReceiverTypeName: "CommentGroup",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "addComment",
				Description:      "",
				ReceiverTypeName: "CommentMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Update",
				Description:      "Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node. ",
				ReceiverTypeName: "CommentMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "ast",
					},
				},
			},
			methodSet{
				Name:             "Filter",
				Description:      "Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node. ",
				ReceiverTypeName: "CommentMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommentMap",
						TypePkgName: "ast",
					},
				},
			},
			methodSet{
				Name:             "Comments",
				Description:      "Comments returns the list of comment groups in the comment map. The result is sorted in source order. ",
				ReceiverTypeName: "CommentMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/ast.CommentGroup",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CommentMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "CompositeLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "CompositeLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "CompositeLit",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "DeclStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "DeclStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "DeclStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "DeferStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "DeferStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "DeferStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Ellipsis",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "Ellipsis",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "Ellipsis",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "EmptyStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "EmptyStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "EmptyStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ExprStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ExprStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "ExprStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Field",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "Field",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "FieldList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "FieldList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "NumFields",
				Description:      "NumFields returns the number of parameters or struct fields represented by a [FieldList]. ",
				ReceiverTypeName: "FieldList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ForStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ForStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "ForStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "FuncDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "FuncDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "declNode",
				Description:      "declNode() ensures that only declaration nodes can be assigned to a Decl. ",
				ReceiverTypeName: "FuncDecl",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "FuncLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "FuncLit",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "FuncLit",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "FuncType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "FuncType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "FuncType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "GenDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "GenDecl",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "declNode",
				Description:      "declNode() ensures that only declaration nodes can be assigned to a Decl. ",
				ReceiverTypeName: "GenDecl",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "GoStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "GoStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "GoStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Ident",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "Ident",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "Ident",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IsExported",
				Description:      "IsExported reports whether name starts with an upper-case letter. ",
				ReceiverTypeName: "Ident",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Ident",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "IfStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "IfStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "IfStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ImportSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ImportSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "specNode",
				Description:      "specNode() ensures that only spec nodes can be assigned to a Spec. ",
				ReceiverTypeName: "ImportSpec",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "IncDecStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "IncDecStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "IncDecStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "IndexExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "IndexExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "IndexExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "IndexListExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "IndexListExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "IndexListExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "InterfaceType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "InterfaceType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "InterfaceType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "KeyValueExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "KeyValueExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "KeyValueExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "LabeledStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "LabeledStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "LabeledStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "MapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "MapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "MapType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ObjKind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Object",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ParenExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ParenExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "ParenExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "RangeStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "RangeStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "RangeStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ReturnStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ReturnStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "ReturnStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored. ",
				ReceiverTypeName: "Scope",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "ast",
					},
				},
			},
			methodSet{
				Name:             "Insert",
				Description:      "Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil. ",
				ReceiverTypeName: "Scope",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "ast",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Scope",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "SelectStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "SelectStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "SelectStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "SelectorExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "SelectorExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "SelectorExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "SendStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "SendStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "SendStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "SliceExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "SliceExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "SliceExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "StarExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "StarExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "StarExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "StructType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "StructType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "StructType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "SwitchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "SwitchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "SwitchStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "TypeAssertExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "TypeAssertExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "TypeAssertExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "TypeSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "TypeSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "specNode",
				Description:      "specNode() ensures that only spec nodes can be assigned to a Spec. ",
				ReceiverTypeName: "TypeSpec",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "TypeSwitchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "TypeSwitchStmt",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "stmtNode",
				Description:      "stmtNode() ensures that only statement nodes can be assigned to a Stmt. ",
				ReceiverTypeName: "TypeSwitchStmt",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "UnaryExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "UnaryExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "exprNode",
				Description:      "exprNode() ensures that only expression/type nodes can be assigned to an Expr. ",
				ReceiverTypeName: "UnaryExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pos",
				Description:      "",
				ReceiverTypeName: "ValueSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "End",
				Description:      "",
				ReceiverTypeName: "ValueSpec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "specNode",
				Description:      "specNode() ensures that only spec nodes can be assigned to a Spec. ",
				ReceiverTypeName: "ValueSpec",
				Returns:          []returnSet{},
			},
		},
		"fips140cache": []methodSet{
			methodSet{
				Name:             "Get",
				Description:      "Get returns the result of new, for an associated key k. If Get was called with k before and didn't return an error, Get may return the same value it returned from the previous call if check returns true on it. If check returns false, Get will call new again and return the result. The cache is evicted some time after k becomes unreachable. ",
				ReceiverTypeName: "Cache",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*V",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "evict",
				Description:      "",
				ReceiverTypeName: "Cache",
				Returns:          []returnSet{},
			},
		},
		"mlkem": []methodSet{
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulationKey",
				Description:      "EncapsulationKey returns the public encapsulation key necessary to produce ciphertexts. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey1024",
						TypePkgName: "mlkem",
					},
				},
			},
			methodSet{
				Name:             "Decapsulate",
				Description:      "Decapsulate generates a shared key from a ciphertext and a decapsulation key. If the ciphertext is not valid, Decapsulate returns an error. The shared key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulationKey",
				Description:      "EncapsulationKey returns the public encapsulation key necessary to produce ciphertexts. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey768",
						TypePkgName: "mlkem",
					},
				},
			},
			methodSet{
				Name:             "Decapsulate",
				Description:      "Decapsulate generates a shared key from a ciphertext and a decapsulation key. If the ciphertext is not valid, Decapsulate returns an error. The shared key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encapsulate",
				Description:      "Encapsulate generates a shared key and an associated ciphertext from an encapsulation key, drawing random bytes from a DRBG. The shared key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encapsulate",
				Description:      "",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulateInternal",
				Description:      "EncapsulateInternal is a derandomized version of Encapsulate, exclusively for use in tests. ",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bytes",
				Description:      "",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encapsulate",
				Description:      "Encapsulate generates a shared key and an associated ciphertext from an encapsulation key, drawing random bytes from a DRBG. The shared key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encapsulate",
				Description:      "",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulateInternal",
				Description:      "EncapsulateInternal is a derandomized version of Encapsulate, exclusively for use in tests. ",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Decapsulate",
				Description:      "Decapsulate generates a shared key from a ciphertext and a decapsulation key. If the ciphertext is not valid, Decapsulate returns an error. The shared key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulationKey",
				Description:      "EncapsulationKey returns the public encapsulation key necessary to produce ciphertexts. ",
				ReceiverTypeName: "DecapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey1024",
						TypePkgName: "mlkem",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Decapsulate",
				Description:      "Decapsulate generates a shared key from a ciphertext and a decapsulation key. If the ciphertext is not valid, Decapsulate returns an error. The shared key must be kept secret. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncapsulationKey",
				Description:      "EncapsulationKey returns the public encapsulation key necessary to produce ciphertexts. ",
				ReceiverTypeName: "DecapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EncapsulationKey768",
						TypePkgName: "mlkem",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encapsulate",
				Description:      "Encapsulate generates a shared key and an associated ciphertext from an encapsulation key, drawing random bytes from the default crypto/rand source. The shared key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey1024",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form. The decapsulation key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encapsulate",
				Description:      "Encapsulate generates a shared key and an associated ciphertext from an encapsulation key, drawing random bytes from the default crypto/rand source. The shared key must be kept secret. ",
				ReceiverTypeName: "EncapsulationKey768",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"constant": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Kind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"suffixarray": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "Read reads the index from r into x; x must not be nil. ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes the index x to w. ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns the data over which the index was created. It must not be modified. ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "at",
				Description:      "",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupAll",
				Description:      "lookupAll returns a slice into the matching region of the index. The runtime is O(log(N)*len(s)). ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ints",
						TypePkgName: "suffixarray",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n < 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data. ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindAllIndex",
				Description:      "FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n < 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0. ",
				ReceiverTypeName: "Index",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]int",
						TypePkgName: "",
					},
				},
			},
		},
		"fstest": []methodSet{
			methodSet{
				Name:             "Open",
				Description:      "Open opens the named file after following any symbolic links. ",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "resolveSymlinks",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadLink",
				Description:      "ReadLink returns the destination of the named symbolic link. ",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Lstat",
				Description:      "Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. ",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lstat",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "mapFileInfo",
						TypePkgName: "fstest",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFile",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stat",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadDir",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]io/fs.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Glob",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "",
				ReceiverTypeName: "MapFS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FS",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gzip": []methodSet{
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards the [Reader] z's state and makes it equivalent to the result of its original state from [NewReader], but reading from r instead. This permits reusing a [Reader] rather than allocating a new one. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Multistream",
				Description:      "Multistream controls whether the reader supports multistream files. If enabled (the default), the [Reader] expects the input to be a sequence of individually gzipped data streams, each with its own header and trailer, ending at EOF. The effect is that the concatenation of a sequence of gzipped files is treated as equivalent to the gzip of the concatenation of the sequence. This is standard behavior for gzip readers. Calling Multistream(false) disables this behavior; disabling the behavior can be useful when reading file formats that distinguish individual gzip data streams or mix gzip data streams with other data streams. In this mode, when the [Reader] reaches the end of the data stream, [Reader.Read] returns [io.EOF]. The underlying reader must implement [io.ByteReader] in order to be left positioned just after the gzip stream. To start the next stream, call z.Reset(r) followed by z.Multistream(false). If there is no next stream, z.Reset(r) will return [io.EOF]. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "readString",
				Description:      "readString reads a NUL-terminated string from z.r. It treats the bytes read as being encoded as ISO 8859-1 (Latin-1) and will output a string encoded using UTF-8. This method always updates z.digest with the data read. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHeader",
				Description:      "readHeader reads the GZIP header according to section 2.3.1. This method does not set z.err. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "gzip",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read implements [io.Reader], reading uncompressed bytes from its underlying reader. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [Reader]. It does not close the underlying reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the [io.EOF]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards the [Reader] z's state and makes it equivalent to the result of its original state from [NewReader], but reading from r instead. This permits reusing a [Reader] rather than allocating a new one. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeBytes",
				Description:      "writeBytes writes a length-prefixed byte slice to z.w. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeString",
				Description:      "writeString writes a UTF-8 string s in GZIP's format to z.w. GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1). ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes a compressed form of p to the underlying [io.Writer]. The compressed bytes are not necessarily flushed until the [Writer] is closed. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush flushes any pending compressed data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. If the underlying writer returns an error, Flush returns that error. In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [Reader]. It does not close the underlying reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the [io.EOF]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"big": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Accuracy",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ErrNaN",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetPrec",
				Description:      "SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to Â±0; infinite values remain unchanged. If prec > [MaxPrec], it is set to [MaxPrec]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetMode",
				Description:      "SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to [Exact]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Prec",
				Description:      "Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MinPrec",
				Description:      "MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Mode",
				Description:      "Mode returns the rounding mode of x. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RoundingMode",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Acc",
				Description:      "Acc returns the accuracy of x produced by the most recent operation, unless explicitly documented otherwise by that operation. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Sign",
				Description:      "Sign returns: - -1 if x < 0; - 0 if x is Â±0; - +1 if x > 0. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MantExp",
				Description:      "MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant Ã 2**exp, with 0.5 <= |mant| < 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver. Special cases are: ( Â±0).MantExp(mant) = 0, with mant set to Â±0 (Â±Inf).MantExp(mant) = 0, with mant set to Â±Inf x and mant may be the same in which case x is set to its mantissa value. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setExpAndRound",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetMantExp",
				Description:      "SetMantExp sets z to mant Ã 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of [Float.MantExp] but does not require 0.5 <= |mant| < 1.0. Specifically, for a given x of type *[Float], SetMantExp relates to [Float.MantExp] as follows: mant := new(Float) new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0 Special cases are: z.SetMantExp( Â±0, exp) = Â±0 z.SetMantExp(Â±Inf, exp) = Â±Inf z and mant may be the same in which case z's exponent is set to exp. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Signbit",
				Description:      "Signbit reports whether x is negative or negative zero. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsInf",
				Description:      "IsInf reports whether x is +Inf or -Inf. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsInt",
				Description:      "IsInt reports whether x is an integer. Â±Inf values are not integers. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "validate",
				Description:      "debugging support ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "validate0",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "round",
				Description:      "round sets x to (at most) n mantissa digits by rounding it to the nearest even value with n (or fever) mantissa digits. If n < 0, x remains unchanged. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setBits64",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetUint64",
				Description:      "SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetInt64",
				Description:      "SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetFloat64",
				Description:      "SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with [ErrNaN] if x is a NaN. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetInt",
				Description:      "SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect). ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetRat",
				Description:      "SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "SetInf",
				Description:      "SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always [Exact]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy sets z to x, with the same precision, rounding mode, and accuracy as x. Copy returns z. If x and z are identical, Copy is a no-op. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 <= x <= [math.MaxUint64], the result is [Exact] if x is an integer and [Below] otherwise. The result is (0, [Above]) for x < 0, and ([math.MaxUint64], [Below]) for x > [math.MaxUint64]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 returns the integer resulting from truncating x towards zero. If [math.MinInt64] <= x <= [math.MaxInt64], the result is [Exact] if x is an integer, and [Above] (x < 0) or [Below] (x > 0) otherwise. The result is ([math.MinInt64], [Above]) for x < [math.MinInt64], and ([math.MaxInt64], [Below]) for x > [math.MaxInt64]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Float32",
				Description:      "Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| < [math.SmallestNonzeroFloat32]), the result is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| > [math.MaxFloat32]), the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float32",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| < [math.SmallestNonzeroFloat64]), the result is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| > [math.MaxFloat64]), the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is [Exact] if x.IsInt(); otherwise it is [Below] for x > 0, and [Above] for x < 0. If a non-nil *[Int] argument z is provided, [Int] stores the result in z instead of allocating a new [Int]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Rat",
				Description:      "Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is [Exact] if x is not an Inf. If a non-nil *[Rat] argument z is provided, [Rat] stores the result in z instead of allocating a new [Rat]. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rat",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Accuracy",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Abs",
				Description:      "Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Neg",
				Description:      "Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "uadd",
				Description:      "z = x + y, ignoring signs of x and y for the addition but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "usub",
				Description:      "z = x - y for |x| > |y|, ignoring signs of x and y for the subtraction but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "umul",
				Description:      "z = x * y, ignoring signs of x and y for the multiplication but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "uquo",
				Description:      "z = x / y, ignoring signs of x and y for the division but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ucmp",
				Description:      "ucmp returns -1, 0, or +1, depending on whether |x| < |y|, |x| == |y|, or |x| > |y|. x and y must have a non-empty mantissa and valid exponent. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with [ErrNaN] if x and y are infinities with opposite signs. The value of z is undefined in that case. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Sub panics with [ErrNaN] if x and y are infinities with equal signs. The value of z is undefined in that case. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Mul",
				Description:      "Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Mul panics with [ErrNaN] if one operand is zero and the other operand an infinity. The value of z is undefined in that case. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Quo",
				Description:      "Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Quo panics with [ErrNaN] if both operands are zero or infinities. The value of z is undefined in that case. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Cmp",
				Description:      "Cmp compares x and y and returns: - -1 if x < y; - 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf); - +1 if x > y. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ord",
				Description:      "ord classifies x and returns: -2 if -Inf == x -1 if -Inf < x < 0 0 if x == 0 (signed or unsigned) +1 if 0 < x < +Inf +2 if x == +Inf ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetString",
				Description:      "SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by [Float.Parse], with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scan",
				Description:      "scan is like Parse but reads the longest possible prefix representing a valid floating point number from an io.ByteScanner rather than a string. It serves as the implementation of Parse. It does not recognize Â±Inf and does not expect EOF at the end. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pow5",
				Description:      "pow5 sets z to 5**n and returns z. n must not be negative. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value. For base 0, an underscore character â_â may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit. It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form: number = [ sign ] ( float | \"inf\" | \"Inf\" ) . sign = \"+\" | \"-\" . float = ( mantissa | prefix pmantissa ) [ exponent ] . prefix = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] . mantissa = digits \".\" [ digits ] | digits | \".\" digits . pmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits . exponent = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits . digits = digit { [ \"_\" ] digit } . digit = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" . The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic. For base 0, the number prefix determines the actual base: A prefix of â0bâ or â0Bâ selects base 2, â0oâ or â0Oâ selects base 8, and â0xâ or â0Xâ selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix \"0\" is not supported (a leading \"0\" is simply considered a \"0\"). A \"p\" or \"P\" exponent indicates a base 2 (rather than base 10) exponent; for instance, \"0x1.fffffffffffffp1023\" (using base 0) represents the maximum float64 value. For hexadecimal mantissae, the exponent character must be one of 'p' or 'P', if present (an \"e\" or \"E\" exponent indicator cannot be distinguished from a mantissa digit). The returned *Float f is nil and the value of z is valid but not defined if an error is reported. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan is a support routine for [fmt.Scanner]; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by [fmt.Scan] for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle Â±Inf. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GobEncode",
				Description:      "GobEncode implements the [encoding/gob.GobEncoder] interface. The [Float] value and all its attributes (precision, rounding mode, accuracy) are marshaled. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GobDecode",
				Description:      "GobDecode implements the [encoding/gob.GobDecoder] interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements the [encoding.TextAppender] interface. Only the [Float] value is marshaled (in full precision), other attributes such as precision or accuracy are ignored. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements the [encoding.TextMarshaler] interface. Only the [Float] value is marshaled (in full precision), other attributes such as precision or accuracy are ignored. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Text",
				Description:      "Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of: 'e' -d.ddddeÂ±dd, decimal exponent, at least two (possibly 0) exponent digits 'E' -d.ddddEÂ±dd, decimal exponent, at least two (possibly 0) exponent digits 'f' -ddddd.dddd, no exponent 'g' like 'e' for large exponents, like 'f' otherwise 'G' like 'E' for large exponents, like 'f' otherwise 'x' -0xd.dddddpÂ±dd, hexadecimal mantissa, decimal power of two exponent 'p' -0x.dddpÂ±dd, hexadecimal mantissa, decimal power of two exponent (non-standard) 'b' -ddddddpÂ±dd, decimal mantissa, decimal power of two exponent (non-standard) For the power-of-two exponent formats, the mantissa is printed in normalized form: 'x' hexadecimal mantissa in [1, 2), or 0 'p' hexadecimal mantissa in [Â½, 1), or 0 'b' decimal integer mantissa using x.Prec() bits, or 0 Note that the 'x' form is the one used by most other languages and libraries. If format is a different character, Text returns a \"%\" followed by the unrecognized format character. The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Append",
				Description:      "Append appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fmtB",
				Description:      "fmtB appends the string of x in the format mantissa \"p\" exponent with a decimal mantissa and a binary exponent, or \"0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that is uses x.Prec() bits in binary representation. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtB.) ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fmtX",
				Description:      "fmtX appends the string of x in the format \"0x1.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0x0p0\" if x is zero, and returns the extended buffer. A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtX.) ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fmtP",
				Description:      "fmtP appends the string of x in the format \"0x.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtP.) ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Format",
				Description:      "Format implements [fmt.Formatter]. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sqrt",
				Description:      "Sqrt sets z to ââxâ, the largest integer such that zÂ² â¤ x, and returns z. It panics if x is negative. ",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "sqrtInverse",
				Description:      "Compute âx (to z.prec precision) by solving 1/tÂ² - x = 0 for t (using Newton's method), and then inverting. ",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "RoundingMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"types": []methodSet{
			methodSet{
				Name:             "Obj",
				Description:      "Obj returns the type name for the declaration defining the alias type a. For instantiated types, this is same as the type name of the origin type. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeName",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Origin",
				Description:      "Origin returns the generic Alias type of which a is an instance. If a is not an instance of a generic alias, Origin returns a. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alias",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "TypeParams",
				Description:      "TypeParams returns the type parameters of the alias type a, or nil. A generic Alias and its instances have the same type parameters. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParamList",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "SetTypeParams",
				Description:      "SetTypeParams sets the type parameters of the alias type a. The alias a must not have type arguments. ",
				ReceiverTypeName: "Alias",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TypeArgs",
				Description:      "TypeArgs returns the type arguments used to instantiate the Alias type. If a is not an instance of a generic alias, the result is nil. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeList",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Rhs",
				Description:      "Rhs returns the type R on the right-hand side of an alias declaration \"type A = R\", which may be another alias. ",
				ReceiverTypeName: "Alias",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "cleanup",
				Description:      "",
				ReceiverTypeName: "Alias",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "ArgumentError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "Array",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns element type of array a. ",
				ReceiverTypeName: "Array",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Array",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Array",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the kind of basic type b. ",
				ReceiverTypeName: "Basic",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BasicKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of basic type b. ",
				ReceiverTypeName: "Basic",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Basic",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Basic",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Builtin",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dir",
				Description:      "Dir returns the direction of channel c. ",
				ReceiverTypeName: "Chan",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ChanDir",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns element type of array a. ",
				ReceiverTypeName: "Chan",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Chan",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Chan",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newAlias",
				Description:      "newAlias creates a new Alias type with the given type name and rhs. rhs must not be nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alias",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "newAliasInstance",
				Description:      "newAliasInstance creates a new alias instance for the given origin and type arguments, recording pos as the position of its synthetic object (for error reporting). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Alias",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "assignment",
				Description:      "assignment reports whether x can be assigned to a variable of type T, if necessary by attempting to convert untyped values to the appropriate type. context describes the context in which the assignment takes place. Use T == nil to indicate assignment to an untyped blank identifier. If the assignment check fails, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "initConst",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "initVar",
				Description:      "initVar checks the initialization lhs = x in a variable declaration. If lhs doesn't have a type yet, it is given the type of x, or Typ[Invalid] in case of an error. If the initialization check fails, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "lhsVar",
				Description:      "lhsVar checks a lhs variable in an assignment and returns its type. lhsVar takes care of not counting a lhs identifier as a \"use\" of that identifier. The result is nil if it is the blank identifier, and Typ[Invalid] if it is an invalid lhs expression. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "assignVar",
				Description:      "assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil). If x != nil, it must be the evaluation of rhs (and rhs will be ignored). If the assignment check fails and x != nil, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "typesSummary",
				Description:      "typesSummary returns a string of the form \"(t1, t2, ...)\" where the ti's are user-friendly string representations for the given types. If variadic is set and the last type is a slice, its string is of the form \"...E\" where E is the slice's element type. If hasDots is set, the last argument string is of the form \"T...\" where T is the last type. Only one of variadic and hasDots may be set. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "assignError",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "returnError",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "initVars",
				Description:      "initVars type-checks assignments of initialization expressions orig_rhs to variables lhs. If returnStmt is non-nil, initVars type-checks the implicit assignment of result expressions orig_rhs to function result parameters lhs. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "assignVars",
				Description:      "assignVars type-checks assignments of expressions orig_rhs to variables lhs. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "shortVarDecl",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "builtin",
				Description:      "builtin type-checks a call to the built-in specified by id and reports whether the call is valid, with *x holding the result; but x.expr is not set. If the call is invalid, the result is false, and *x is undefined. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyTypeFunc",
				Description:      "applyTypeFunc applies f to x. If x is a type parameter, the result is a type parameter constrained by a new interface bound. The type bounds for that interface are computed by applying f to each of the type bounds of x. If any of these applications of f return nil, applyTypeFunc returns nil. If x is not a type parameter, the result is f(x). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "funcInst",
				Description:      "funcInst type-checks a function instantiation. The incoming x must be a generic function. If ix != nil, it provides some or all of the type arguments (ix.Indices). If target != nil, it may be used to infer missing type arguments of x, if any. At least one of T or ix must be provided. There are two modes of operation: 1. If infer == true, funcInst infers missing type arguments as needed and instantiates the function x. The returned results are nil. 2. If infer == false and inst provides all type arguments, funcInst instantiates the function x. The returned results are nil. If inst doesn't provide enough type arguments, funcInst returns the available arguments; x remains unchanged. If an error (other than a version error) occurs in any case, it is reported and x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]go/types.Type",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "instantiateSignature",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "callExpr",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "exprKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "exprList",
				Description:      "exprList evaluates a list of expressions and returns the corresponding operands. A single-element expression list may evaluate to multiple operands. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.operand",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "genericExprList",
				Description:      "genericExprList is like exprList but result operands may be uninstantiated or partially instantiated generic functions (where constraint information is insufficient to infer the missing type arguments) for Go 1.21 and later. For each non-generic or uninstantiated generic operand, the corresponding targsList and elements do not exist (targsList is nil) or the elements are nil. For each partially instantiated generic function operand, the corresponding targsList elements are the operand's partial type arguments. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.operand",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[][]go/types.Type",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "arguments",
				Description:      "arguments type-checks arguments passed to a function call with the given signature. The function and its arguments may be generic, and possibly partially instantiated. targs and xlist are the function's type arguments (and corresponding expressions). args are the function arguments. If an argument args[i] is a partially instantiated generic function, atargs[i] are the corresponding type arguments. If the callee is variadic, arguments adjusts its signature to match the provided arguments. The type parameters and arguments of the callee and all its arguments are used together to infer any missing type arguments, and the callee and argument functions are instantiated as necessary. The result signature is the (possibly adjusted and instantiated) function signature. If an error occurred, the result signature is the incoming sig. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "selector",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "use",
				Description:      "use type-checks each argument. Useful to make sure expressions are evaluated (and variables are \"used\") in the presence of other errors. Arguments may be nil. Reports if all arguments evaluated without error. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "useLHS",
				Description:      "useLHS is like use, but doesn't \"use\" top-level identifiers. It should be called instead of use if the arguments are expressions on the lhs of an assignment. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "useN",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "use1",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "addDeclDep",
				Description:      "addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "brokenAlias",
				Description:      "brokenAlias records that alias doesn't have a determined type yet. It also sets alias.typ to Typ[Invalid]. Not used if check.conf._EnableAlias is set. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "validAlias",
				Description:      "validAlias records that alias has the valid type typ (possibly Typ[Invalid]). ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isBrokenAlias",
				Description:      "isBrokenAlias reports whether alias doesn't have a determined type yet. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rememberUntyped",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "later",
				Description:      "later pushes f on to the stack of actions that will be processed later; either at the end of the current statement, or in case of a local constant or variable declaration, before the constant or variable is in scope (so that f still sees the scope before any new declarations). later returns the pushed action so one can provide a description via action.describef for debugging, if desired. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "action",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "push",
				Description:      "push pushes obj onto the object path and returns its index in the path. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pop",
				Description:      "pop pops and returns the topmost object from the object path. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "needsCleanup",
				Description:      "needsCleanup records objects/types that implement the cleanup method which will be called at the end of type-checking. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "initFiles",
				Description:      "initFiles initializes the files-specific portion of checker. The provided files must all belong to the same package. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "pushPos",
				Description:      "pushPos pushes pos onto the pos stack. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "popPos",
				Description:      "popPos pops from the pos stack. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "handleBailout",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Files",
				Description:      "Files checks the provided files as part of the checker's package. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkFiles",
				Description:      "checkFiles type-checks the specified files. Errors are reported as a side effect, not by returning early, to ensure that well-formed syntax is properly type annotated even in a package containing errors. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "processDelayed",
				Description:      "processDelayed processes all delayed actions pushed after top. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "cleanup",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordTypeAndValueInSyntax",
				Description:      "go/types doesn't support recording of types directly in the AST. dummy function to match types2 code. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordCommaOkTypesInSyntax",
				Description:      "go/types doesn't support recording of types directly in the AST. dummy function to match types2 code. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "overflow",
				Description:      "overflow checks that the constant x is representable by its type. For untyped constants, it checks that the value doesn't become arbitrarily large. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "representable",
				Description:      "representable checks that a constant operand is representable in the given basic type. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "representation",
				Description:      "representation returns the representation of the constant operand x as the basic type typ. If no such representation is possible, it returns a non-zero error code. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
					returnSet{
						TypeName:    "Code",
						TypePkgName: "errors",
					},
				},
			},
			methodSet{
				Name:             "invalidConversion",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "convertUntyped",
				Description:      "convertUntyped attempts to set the type of an untyped value to the target type. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "conversion",
				Description:      "conversion type-checks the conversion T(x). The result is in x. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "declare",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "objDecl",
				Description:      "objDecl type-checks the declaration of obj in its respective (file) environment. For the meaning of def, see Checker.definedType, in typexpr.go. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "validCycle",
				Description:      "validCycle checks if the cycle starting with obj is valid and reports an error if it is not. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cycleError",
				Description:      "cycleError reports a declaration cycle starting with the object at cycle[start]. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "walkDecls",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "walkDecl",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isImportedConstraint",
				Description:      "isImportedConstraint reports whether typ is an imported type constraint. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "collectTypeParams",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "bound",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "declareTypeParam",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParam",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "collectMethods",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "checkFieldUniqueness",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "declStmt",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "newError",
				Description:      "newError returns a new error_ with the given error code. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error_",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "handleError",
				Description:      "handleError should only be called by error_.report. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "error",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "errorf",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "softErrorf",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "versionErrorf",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "lookupError",
				Description:      "lookupError returns a case-specific error when a lookup of selector sel in the given type fails but an object with alternative spelling (case folding) is found. If structLit is set, the error message is specifically for struct literal fields. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "op",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unary",
				Description:      "The unary expression e may be nil. It's passed in for better error messages only. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "chanElem",
				Description:      "chanElem returns the channel element type of x for a receive from x (recv == true) or send to x (recv == false) operation. If the operation is not valid, chanElem reports an error and returns nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "updateExprType",
				Description:      "updateExprType updates the type of x to typ and invokes itself recursively for the operands of x, depending on expression kind. If typ is still an untyped and not the final type, updateExprType only updates the recorded untyped type for x and possibly its operands. Otherwise (i.e., typ is not an untyped type anymore, or it is the final type for x), the type and value are recorded. Also, if x is a constant, it must be representable as a value of typ, and if x is the (formerly untyped) lhs operand of a non-constant shift, it must be an integer value. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "updateExprVal",
				Description:      "updateExprVal updates the value of x to val. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "implicitTypeAndValue",
				Description:      "implicitTypeAndValue returns the implicit type of x when used in a context where the target type is expected. If no such implicit conversion is possible, it returns a nil Type and non-zero error code. If x is a constant operand, the returned constant.Value will be the representation of x in this context. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
					returnSet{
						TypeName:    "Code",
						TypePkgName: "errors",
					},
				},
			},
			methodSet{
				Name:             "comparison",
				Description:      "If switchCase is true, the operator op is ignored. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "incomparableCause",
				Description:      "incomparableCause returns a more specific cause why typ is not comparable. If there is no more specific cause, the result is \"\". ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shift",
				Description:      "If e != nil, it must be the shift expression; it may be nil for non-constant shifts. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "binary",
				Description:      "If e != nil, it must be the binary expression; it may be nil for non-constant expressions (when invoked for an assignment operation where the binary expression is implicit). ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "matchTypes",
				Description:      "matchTypes attempts to convert any untyped types x and y such that they match. If an error occurs, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rawExpr",
				Description:      "rawExpr typechecks expression e and initializes x with the expression value or type. If an error occurred, x.mode is set to invalid. If a non-nil target T is given and e is a generic function, T is used to infer the type arguments for e. If hint != nil, it is the type of a composite literal element. If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function value. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "exprKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "nonGeneric",
				Description:      "If x is a generic type, or a generic function whose type arguments cannot be inferred from a non-nil target T, nonGeneric reports an error and invalidates x.mode and x.typ. Otherwise it leaves x alone. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "exprInternal",
				Description:      "exprInternal contains the core of type checking of expressions. Must only be called by rawExpr. (See rawExpr for an explanation of the parameters.) ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "exprKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "typeAssertion",
				Description:      "typeAssertion checks x.(T). The type of x must be an interface. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "expr",
				Description:      "expr typechecks expression e and initializes x with the expression value. If a non-nil target T is given and e is a generic function or a function call, T is used to infer the type arguments for e. The result must be a single value. If an error occurred, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "genericExpr",
				Description:      "genericExpr is like expr but the result may also be generic. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "multiExpr",
				Description:      "multiExpr typechecks e and returns its value (or values) in list. If allowCommaOk is set and e is a map index, comma-ok, or comma-err expression, the result is a two-element list containing the value of e, and an untyped bool value or an error value, respectively. If an error occurred, list[0] is not valid. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.operand",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "exprWithHint",
				Description:      "exprWithHint typechecks expression e and initializes x with the expression value; hint is the type of a composite literal element. If an error occurred, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "exprOrType",
				Description:      "exprOrType typechecks expression or type e and initializes x with the expression value or type. If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function value. If an error occurred, x.mode is set to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "exclude",
				Description:      "exclude reports an error if x.mode is in modeset and sets x.mode to invalid. The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "singleValue",
				Description:      "singleValue reports an error if x describes a tuple and sets x.mode to invalid. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sprintf",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "trace",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "dump",
				Description:      "dump is only needed for debugging ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "qualifier",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "markImports",
				Description:      "markImports recursively walks pkg and its imports, to record unique import paths in pkgPathMap. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "indexExpr",
				Description:      "If e is a valid function instantiation, indexExpr returns true. In that case x represents the uninstantiated function value and it is the caller's responsibility to instantiate the function. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sliceExpr",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "singleIndex",
				Description:      "singleIndex returns the (single) index from the index expression e. If the index is missing, or if there are multiple indices, an error is reported and the result is nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "ast",
					},
				},
			},
			methodSet{
				Name:             "index",
				Description:      "index checks an index expression for validity. If max >= 0, it is the upper bound for index. If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type. If the result val >= 0, index is valid and val is its constant int value. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isValidIndex",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "infer",
				Description:      "infer attempts to infer the complete set of type arguments for generic function instantiation/call based on the given type parameters tparams, type arguments targs, function parameters params, and function arguments args, if any. There must be at least one type parameter, no more type arguments than type parameters, and params and args must match in number (incl. zero). If reverse is set, an error message's contents are reversed for a better error message for some errors related to reverse type inference (where the function call is synthetic). If successful, infer returns the complete list of given and inferred type arguments, one for each type parameter. Otherwise the result is nil. Errors are reported through the err parameter. Note: infer may fail (return nil) due to invalid args operands without reporting additional errors. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]go/types.Type",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "renameTParams",
				Description:      "renameTParams renames the type parameters in the given type such that each type parameter is given a new identity. renameTParams returns the new type parameters and updated type. If the result type is unchanged from the argument type, none of the type parameters in tparams occurred in the type. If typ is a generic function, type parameters held with typ are not changed and must be updated separately if desired. The positions is only used for debug traces. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.TypeParam",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "initOrder",
				Description:      "initOrder computes the Info.InitOrder for package variables. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "reportCycle",
				Description:      "reportCycle reports an error for the given cycle. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "instance",
				Description:      "instance instantiates the given original (generic) function or type with the provided type arguments and returns the resulting instance. If an identical instance exists already in the given contexts, it returns that instance, otherwise it creates a new one. If there is an error (such as wrong number of type arguments), the result is Typ[Invalid]. If expanding is non-nil, it is the Named instance type currently being expanded. If ctxt is non-nil, it is the context associated with the current type-checking pass or call to Instantiate. At least one of expanding or ctxt must be non-nil. For Named types the resulting instance may be unexpanded. check may be nil (when not type-checking syntax); pos is used only only if check is non-nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "validateTArgLen",
				Description:      "validateTArgLen checks that the number of type arguments (got) matches the number of type parameters (want); if they don't match an error is reported. If validation fails and check is nil, validateTArgLen panics. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "verify",
				Description:      "check may be nil; pos is used only if check is non-nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "implements",
				Description:      "implements checks if V implements T. The receiver may be nil if implements is called through an exported API call such as AssignableTo. If constraint is set, T is a type constraint. If the provided cause is non-nil, it may be set to an error string explaining why V does not implement (or satisfy, for constraints) T. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newInterface",
				Description:      "check may be nil ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "interfaceType",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "labels",
				Description:      "labels checks correct label use in body. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "blockBranches",
				Description:      "blockBranches processes a block's statement list and returns the set of outgoing forward jumps. all is the scope of all declared labels, parent the set of labels declared in the immediately enclosing block, and lstmt is the labeled statement this block is associated with (or nil). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/ast.BranchStmt",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "langCompat",
				Description:      "langCompat reports an error if the representation of a numeric literal is not compatible with the current language version. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "basicLit",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "funcLit",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "compositeLit",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "indexedElts",
				Description:      "indexedElts checks the elements (elts) of an array or slice composite literal against the literal's element type (typ), and the element indices against the literal length if known (length >= 0). It returns the length of the literal (maximum index value + 1). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "missingMethod",
				Description:      "missingMethod is like MissingMethod but accepts a *Checker as receiver, a comparator equivalent for type comparison, and a *string for error causes. The receiver may be nil if missingMethod is invoked through an exported API call (such as MissingMethod), i.e., when all methods have been type- checked. The underlying type of T must be an interface; T (rather than its under- lying type) is used for better error messages (reported through *cause). The comparator is used to compare signatures. If a method is missing and cause is not nil, *cause describes the error. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasAllMethods",
				Description:      "hasAllMethods is similar to checkMissingMethod but instead reports whether all methods are present. If V is not a valid type, or if it is a struct containing embedded fields with invalid types, the result is true because it is not possible to say with certainty whether a method is missing or not (an embedded field may have the method in question). If the result is false and cause is not nil, *cause describes the error. Use hasAllMethods to avoid follow-on errors due to incorrect types. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "interfacePtrError",
				Description:      "check may be nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "funcString",
				Description:      "funcString returns a string of the form name + signature for f. check may be nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "assertableTo",
				Description:      "assertableTo reports whether a value of type V can be asserted to have type T. The receiver may be nil if assertableTo is invoked through an exported API call (such as AssertableTo), i.e., when all methods have been type-checked. The underlying type of V must be an interface. If the result is false and cause is not nil, *cause describes the error. TODO(gri) replace calls to this function with calls to newAssertableTo. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newAssertableTo",
				Description:      "newAssertableTo reports whether a value of type V can be asserted to have type T. It also implements behavior for interfaces that currently are only permitted in constraint position (we have not yet defined that behavior in the spec). The underlying type of V must be an interface. If the result is false and cause is not nil, *cause is set to the error cause. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "monomorph",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "reportInstanceLoop",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "newNamed",
				Description:      "newNamed is like NewNamed but with a *Checker receiver. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "newNamedInstance",
				Description:      "newNamedInstance creates a new named instance for the given origin and type arguments, recording pos as the position of its synthetic object (for error reporting). If set, expanding is the named type instance currently being expanded, that led to the creation of this instance. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "context",
				Description:      "context returns the type-checker context. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "rangeStmt",
				Description:      "rangeStmt type-checks a range statement of form for sKey, sValue = range rangeVar { ... } where sKey, sValue, sExtra may be nil. isDef indicates whether these variables are assigned to only (=) or whether there is a short variable declaration (:=). If the latter and there are no variables, an error is reported at noNewVarPos. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "record",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordUntyped",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordTypeAndValue",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordBuiltinType",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordCommaOkTypes",
				Description:      "recordCommaOkTypes updates recorded types to reflect that x is used in a commaOk context (and therefore has tuple type). ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordInstance",
				Description:      "recordInstance records that the given type parameters were instantiated with the corresponding type arguments. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordDef",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordUse",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordImplicit",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordSelection",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recordScope",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "arityMatch",
				Description:      "arityMatch checks that the lhs and rhs of a const or var decl have the appropriate number of names and init exprs. For const decls, init is the value spec providing the init exprs; for var decls, init is nil (the init exprs are in s in this case). ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "declarePkgObj",
				Description:      "declarePkgObj declares obj in the package scope, records its ident -> obj mapping, and updates check.objMap. The object must not be a function or method. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "filename",
				Description:      "filename returns a filename suitable for debugging output. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "importPackage",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "collectObjects",
				Description:      "collectObjects collects all file and package objects and inserts them into their respective scopes. It also performs imports and associates methods with receiver base type names. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "unpackRecv",
				Description:      "unpackRecv unpacks a receiver type expression and returns its components: ptr indicates whether rtyp is a pointer receiver, base is the receiver base type expression stripped of its type parameters (if any), and tparams are its type parameter names, if any. The type parameters are only unpacked if unpackParams is set. For instance, given the rtyp *T[A, _] ptr is true, base is T, and tparams is [A, _] (assuming unpackParams is set). Note that base may not be a *ast.Ident for erroneous programs. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Expr",
						TypePkgName: "ast",
					},
					returnSet{
						TypeName:    "[]*go/ast.Ident",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "resolveBaseTypeName",
				Description:      "resolveBaseTypeName returns the non-alias base type name for the given name, and whether there was a pointer indirection to get to it. The base type name must be declared in package scope, and there can be at most one pointer indirection. Traversals through generic alias types are not permitted. If no such type name exists, the returned base is nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "TypeName",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "packageObjects",
				Description:      "packageObjects typechecks all package objects, but not function bodies. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "unusedImports",
				Description:      "unusedImports checks for unused imports. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "errorUnusedPkg",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isTerminating",
				Description:      "isTerminating reports if s is a terminating statement. If s is labeled, label is the label name; otherwise s is \"\". ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isTerminatingList",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isTerminatingSwitch",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "funcType",
				Description:      "funcType type-checks a function or method type. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "collectRecv",
				Description:      "collectRecv extracts the method receiver and its type parameters (if any) from rparam. It declares the type parameters (but not the receiver) in the current scope, and returns the receiver variable and its type parameter list (if any). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "TypeParamList",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "recordParenthesizedRecvTypes",
				Description:      "recordParenthesizedRecvTypes records parenthesized intermediate receiver type expressions that all map to the same type, by recursively unpacking expr and recording the corresponding type for it. Example: expression --> type ---------------------- (*(T[P])) *T[P] *(T[P]) *T[P] (T[P]) T[P] T[P] T[P] ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "collectParams",
				Description:      "collectParams collects (but does not declare) all parameter/result variables of list and returns the list of names and corresponding variables, and whether the (parameter) list is variadic. Anonymous parameters are recorded with nil names. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/ast.Ident",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]*go/types.Var",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "declareParams",
				Description:      "declareParams declares each named parameter in the current scope. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "validRecv",
				Description:      "validRecv verifies that the receiver satisfies its respective spec requirements and reports an error otherwise. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "funcBody",
				Description:      "decl may be nil ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "usage",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "simpleStmt",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "stmtList",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "multipleDefaults",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "openScope",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closeScope",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "suspendedCall",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "caseValues",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isNil",
				Description:      "isNil reports whether x is the (untyped) nil value. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "caseTypes",
				Description:      "caseTypes typechecks the type expressions of a type case, checks for duplicate types using the seen map, and verifies that each type is valid with respect to the type of the operand x corresponding to the type switch expression. If that expression is not valid, x must be nil. switch <x>.(type) { case <types>: ... ... } caseTypes returns the case-specific type for a variable v introduced through a short variable declaration by the type switch: switch v := <x>.(type) { case <types>: // T is the type of <v> in this case ... } If there is exactly one type expression, T is the type of that expression. If there are multiple type expressions, or if predeclared nil is among the types, the result is the type of x. If x is invalid (nil), the result is the invalid type. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "caseTypes_currently_unused",
				Description:      "TODO(gri) Once we are certain that typeHash is correct in all situations, use this version of caseTypes instead. (Currently it may be possible that different types have identical names and import paths due to ImporterFrom.) ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "stmt",
				Description:      "stmt typechecks statement s. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "structType",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "declareInSet",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tag",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "subst",
				Description:      "subst returns the type typ with its type parameters tpars replaced by the corresponding type arguments targs, recursively. subst doesn't modify the incoming type. If a substitution took place, the result type is different from the incoming type. If expanding is non-nil, it is the instance type currently being expanded. One of expanding or ctxt must be non-nil. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "newTypeParam",
				Description:      "check may be nil ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParam",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "ident",
				Description:      "ident type-checks identifier e and initializes x with the value or type of e. If an error occurred, x.mode is set to invalid. For the meaning of def, see Checker.definedType, below. If wantType is set, the identifier e is expected to denote a type. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "typ",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "varType",
				Description:      "varType type-checks the type expression e and returns its type, or Typ[Invalid]. The type must not be an (uninstantiated) generic type and it must not be a constraint interface. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "validVarType",
				Description:      "validVarType reports an error if typ is a constraint interface. The expression e is used for error reporting, if any. ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "definedType",
				Description:      "definedType is like typ but also accepts a type name def. If def != nil, e is the type specification for the type named def, declared in a type declaration, and def.typ.underlying will be set to the type of e before any components of e are type-checked. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "typInternal",
				Description:      "typInternal drives type checking of types. Must only be called by definedType or genericType. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "instantiatedType",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "arrayLength",
				Description:      "arrayLength type-checks the array length expression e and returns the constant length >= 0, or a value < 0 to indicate an error (and thus an unknown length). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "typeList",
				Description:      "",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]go/types.Type",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "validType",
				Description:      "validType verifies that the given type does not \"expand\" indefinitely producing a cycle in the type graph. (Cycles involving alias types, as in \"type A = [10]A\" are detected earlier, via the objDecl cycle detection mechanism.) ",
				ReceiverTypeName: "Checker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "validType0",
				Description:      "validType0 checks if the given type is valid. If typ is a type parameter its value is looked up in the type argument list of the instantiated (enclosing) type, if it exists. Otherwise the type parameter must be from an enclosing function and can be ignored. The nest list describes the stack (the \"nest in memory\") of types which contain (or embed in the case of interfaces) other types. For instance, a struct named S which contains a field of named type F contains (the memory of) F in S, leading to the nest S->F. If a type appears in its own nest (say S->F->S) we have an invalid recursive type. The path list is the full path of named types in a cycle, it is only needed for error reporting. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "allowVersion",
				Description:      "allowVersion reports whether the current effective Go version (which may vary from one file to another) is allowed to use the feature version (want). ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "verifyVersionf",
				Description:      "verifyVersionf is like allowVersion but also accepts a format string and arguments which are used to report a version error if allowVersion returns false. ",
				ReceiverTypeName: "Checker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Check",
				Description:      "Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the [Info] struct. The package is marked as complete if no errors occurred, otherwise it is incomplete. See [Config.Error] for controlling behavior in the presence of errors. The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (\".\"). ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "alignof",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "offsetsof",
				Description:      "",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "offsetof",
				Description:      "offsetof returns the offset of the field specified via the index sequence relative to T. All embedded fields must be structs (rather than pointers to structs). If the offset is too large (because T is too large), the result is negative. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sizeof",
				Description:      "sizeof returns the size of T. If T is too large, the result is negative. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Val",
				Description:      "Val returns the constant's value. ",
				ReceiverTypeName: "Const",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			methodSet{
				Name:             "isDependency",
				Description:      "",
				ReceiverTypeName: "Const",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Const",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "instanceHash",
				Description:      "instanceHash returns a string representation of typ instantiated with targs. The hash should be a perfect hash, though out of caution the type checker does not assume this. The result is guaranteed to not contain blanks. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookup",
				Description:      "lookup is like lookupScope but it only returns the object (or nil). ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "update",
				Description:      "update de-duplicates inst against previously seen types with the hash h. If an identical type is found with the type hash h, the previously seen type is returned. Otherwise, inst is returned, and recorded in the Context for the hash h. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "getID",
				Description:      "getID returns a unique ID for the type t. ",
				ReceiverTypeName: "Context",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Signature",
				Description:      "Signature returns the signature (type) of the function or method. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signature",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "FullName",
				Description:      "FullName returns the package- or receiver-type-qualified name of function or method obj. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scope",
				Description:      "Scope returns the scope of the function's body block. The result is nil for imported or instantiated functions and methods (but there is also no mechanism to get to an instantiated function). ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scope",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Origin",
				Description:      "Origin returns the generic Alias type of which a is an instance. If a is not an instance of a generic alias, Origin returns a. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Pkg",
				Description:      "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "hasPtrRecv",
				Description:      "hasPtrRecv reports whether the receiver is of the form *T for the given method obj. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isDependency",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "recordTypes",
				Description:      "",
				ReceiverTypeName: "Info",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "TypeOf",
				Description:      "TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated. ",
				ReceiverTypeName: "Info",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "ObjectOf",
				Description:      "ObjectOf returns the object denoted by the specified id, or nil if not found. If id is an embedded struct field, [Info.ObjectOf] returns the field (*[Var]) it defines, not the type (*[TypeName]) it uses. Precondition: the Uses and Defs maps are populated. ",
				ReceiverTypeName: "Info",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "PkgNameOf",
				Description:      "PkgNameOf returns the local package name defined by the import, or nil if not found. For dot-imports, the package name is \".\". Precondition: the Defs and Implicts maps are populated. ",
				ReceiverTypeName: "Info",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PkgName",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Initializer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "typeSet",
				Description:      "typeSet returns the type set for interface t. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "_TypeSet",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "MarkImplicit",
				Description:      "MarkImplicit marks the interface t as implicit, meaning this interface corresponds to a constraint literal such as ~T or A|B without explicit interface embedding. MarkImplicit should be called before any concurrent use of implicit interfaces. ",
				ReceiverTypeName: "Interface",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "NumExplicitMethods",
				Description:      "NumExplicitMethods returns the number of explicitly declared methods of interface t. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExplicitMethod",
				Description:      "ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods(). The methods are ordered by their unique [Id]. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "NumEmbeddeds",
				Description:      "NumEmbeddeds returns the number of embedded types in interface t. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Embedded",
				Description:      "Embedded returns the i'th embedded defined (*[Named]) type of interface t for 0 <= i < t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type. Deprecated: Use [Interface.EmbeddedType] which is not restricted to defined (*[Named]) types. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "EmbeddedType",
				Description:      "EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds(). ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "NumMethods",
				Description:      "NumMethods returns the total number of methods of interface t. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Method",
				Description:      "Method returns the i'th method of interface t for 0 <= i < t.NumMethods(). The methods are ordered by their unique Id. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Empty",
				Description:      "Empty reports whether t is the empty interface. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsComparable",
				Description:      "IsComparable reports whether each type in interface t's type set is comparable. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsMethodSet",
				Description:      "IsMethodSet reports whether the interface t is fully described by its method set. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsImplicit",
				Description:      "IsImplicit reports whether the interface t is a wrapper for a type set literal. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Complete",
				Description:      "Complete computes the interface's type set. It must be called by users of [NewInterfaceType] and [NewInterface] after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. The interface must not contain duplicate methods or a panic occurs. Complete returns the receiver. Interface types that have been completed are safe for concurrent use. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cleanup",
				Description:      "",
				ReceiverTypeName: "Interface",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Methods",
				Description:      "Methods returns a go1.23 iterator over all the methods of an interface, ordered by Id. Example: for m := range t.Methods() { ... } ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "ExplicitMethods",
				Description:      "ExplicitMethods returns a go1.23 iterator over the explicit methods of an interface, ordered by Id. Example: for m := range t.ExplicitMethods() { ... } ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "EmbeddedTypes",
				Description:      "EmbeddedTypes returns a go1.23 iterator over the types embedded within an interface. Example: for e := range t.EmbeddedTypes() { ... } ",
				ReceiverTypeName: "Interface",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Label",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Key",
				Description:      "Key returns the key type of map m. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns element type of array a. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Methods",
				Description:      "Methods returns a go1.23 iterator over all the methods of an interface, ordered by Id. Example: for m := range t.Methods() { ... } ",
				ReceiverTypeName: "MethodSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "MethodSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "MethodSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At returns the i'th method in s for 0 <= i < s.Len(). ",
				ReceiverTypeName: "MethodSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Selection",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup returns the method with matching package and name, or nil if not found. ",
				ReceiverTypeName: "MethodSet",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Selection",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Methods",
				Description:      "Methods returns a go1.23 iterator over all the methods of an interface, ordered by Id. Example: for m := range t.Methods() { ... } ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "resolve",
				Description:      "resolve resolves the type parameters, methods, and underlying type of n. This information may be loaded from a provided loader function, or computed from an origin type (in the case of instances). After resolution, the type parameters, methods, and underlying type of n are accessible; but if n is an instantiated type, its methods may still be unexpanded. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "state",
				Description:      "state atomically accesses the current state of the receiver. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "namedState",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "setState",
				Description:      "setState atomically stores the given state for n. Must only be called while holding n.mu. ",
				ReceiverTypeName: "Named",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "cleanup",
				Description:      "",
				ReceiverTypeName: "Named",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Obj",
				Description:      "Obj returns the type name for the declaration defining the alias type a. For instantiated types, this is same as the type name of the origin type. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeName",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Origin",
				Description:      "Origin returns the generic Alias type of which a is an instance. If a is not an instance of a generic alias, Origin returns a. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Named",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "TypeParams",
				Description:      "TypeParams returns the type parameters of the alias type a, or nil. A generic Alias and its instances have the same type parameters. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParamList",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "SetTypeParams",
				Description:      "SetTypeParams sets the type parameters of the alias type a. The alias a must not have type arguments. ",
				ReceiverTypeName: "Named",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TypeArgs",
				Description:      "TypeArgs returns the type arguments used to instantiate the Alias type. If a is not an instance of a generic alias, the result is nil. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeList",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "NumMethods",
				Description:      "NumMethods returns the total number of methods of interface t. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Method",
				Description:      "Method returns the i'th method of interface t for 0 <= i < t.NumMethods(). The methods are ordered by their unique Id. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "expandMethod",
				Description:      "expandMethod substitutes type arguments in the i'th method for an instantiated receiver. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "SetUnderlying",
				Description:      "SetUnderlying sets the underlying type and marks t as complete. t must not have type arguments. ",
				ReceiverTypeName: "Named",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddMethod",
				Description:      "AddMethod adds method m unless it is already in the method list. The method must be in the same package as t, and t must not have type arguments. ",
				ReceiverTypeName: "Named",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "methodIndex",
				Description:      "methodIndex returns the index of and method with matching package and name, or (-1, nil). See Object.sameId for the meaning of foldCase. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "under",
				Description:      "under returns the expanded underlying type of n0; possibly by following forward chains of named types. If an underlying type is found, resolve the chain by setting the underlying type for each defined type in the chain before returning it. If no underlying type is found or a cycle is detected, the result is Typ[Invalid]. If a cycle is detected and n0.check != nil, the cycle is reported. This is necessary because the underlying type of named may be itself a named type that is incomplete: type ( A B B *C C A ) The type of C is the (named) type of A which is incomplete, and which has as its underlying type the named type B. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "lookupMethod",
				Description:      "",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Func",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "expandUnderlying",
				Description:      "expandUnderlying substitutes type arguments in the underlying type n.orig, returning the result. Returns Typ[Invalid] if there was an error. ",
				ReceiverTypeName: "Named",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Nil",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Path",
				Description:      "Path returns the package path. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of basic type b. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetName",
				Description:      "SetName sets the package name. ",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "GoVersion",
				Description:      "GoVersion returns the minimum Go version required by this package. If the minimum version is unknown, GoVersion returns the empty string. Individual source files may specify a different minimum Go version, as reported in the [go/ast.File.GoVersion] field. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scope",
				Description:      "Scope returns the scope of the function's body block. The result is nil for imported or instantiated functions and methods (but there is also no mechanism to get to an instantiated function). ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scope",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Complete",
				Description:      "Complete computes the interface's type set. It must be called by users of [NewInterfaceType] and [NewInterface] after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. The interface must not contain duplicate methods or a panic occurs. Complete returns the receiver. Interface types that have been completed are safe for concurrent use. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarkComplete",
				Description:      "MarkComplete marks a package as complete. ",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Imports",
				Description:      "Imports returns the list of packages directly imported by pkg; the list is in source order. If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code. If pkg uses cgo and the FakeImportC configuration option was enabled, the imports list may contain a fake \"C\" package. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.Package",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetImports",
				Description:      "SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique. ",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Imported",
				Description:      "Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement. ",
				ReceiverTypeName: "PkgName",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Package",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "PkgName",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns element type of array a. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Pointer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the kind of basic type b. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SelectionKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Recv",
				Description:      "Recv returns the type of x in x.f. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Obj",
				Description:      "Obj returns the type name for the declaration defining the alias type a. For instantiated types, this is same as the type name of the origin type. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Object",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns the object's type. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Index",
				Description:      "Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either: 1. the list of declared methods of a named type; or 2. the list of methods of an interface type; or 3. the list of fields of a struct type. The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Indirect",
				Description:      "Indirect reports whether any pointer indirection was required to get from x to f in x.f. Beware: Indirect spuriously returns true (Go issue #8353) for a MethodVal selection in which the receiver argument and parameter both have type *T so there is no indirection. Unfortunately, a fix is too risky. ",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Selection",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns element type of array a. ",
				ReceiverTypeName: "Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Alignof",
				Description:      "",
				ReceiverTypeName: "StdSizes",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Offsetsof",
				Description:      "",
				ReceiverTypeName: "StdSizes",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sizeof",
				Description:      "",
				ReceiverTypeName: "StdSizes",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fields",
				Description:      "Fields returns a go1.23 iterator over the fields of a struct type. Example: for field := range s.Fields() { ... } ",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "NumFields",
				Description:      "NumFields returns the number of fields in the struct (including blank and embedded fields). ",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Field",
				Description:      "Field returns the i'th field for 0 <= i < NumFields(). ",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Tag",
				Description:      "Tag returns the i'th field tag for 0 <= i < NumFields(). ",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Struct",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "markComplete",
				Description:      "",
				ReceiverTypeName: "Struct",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Variables",
				Description:      "Variables returns a go1.23 iterator over the variables of a tuple type. Example: for v := range tuple.Variables() { ... } ",
				ReceiverTypeName: "Tuple",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "Tuple",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At returns the i'th method in s for 0 <= i < s.Len(). ",
				ReceiverTypeName: "Tuple",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Tuple",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Tuple",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsVoid",
				Description:      "IsVoid reports whether the corresponding expression is a function call without results. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsType",
				Description:      "IsType reports whether the corresponding expression specifies a type. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsBuiltin",
				Description:      "IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValue",
				Description:      "IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsNil",
				Description:      "IsNil reports whether the corresponding expression denotes the predeclared value nil. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Addressable",
				Description:      "Addressable reports whether the corresponding expression is addressable (https://golang.org/ref/spec#Address_operators). ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Assignable",
				Description:      "Assignable reports whether the corresponding expression is assignable to (provided a value of the right type). ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HasOk",
				Description:      "HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment. ",
				ReceiverTypeName: "TypeAndValue",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Types",
				Description:      "Types returns a go1.23 iterator over the elements of a list of types. Example: for t := range l.Types() { ... } ",
				ReceiverTypeName: "TypeList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "TypeList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At returns the i'th method in s for 0 <= i < s.Len(). ",
				ReceiverTypeName: "TypeList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "list",
				Description:      "list is for internal use where we expect a []*TypeParam. TODO(rfindley): list should probably be eliminated: we can pass around a TypeParamList instead. ",
				ReceiverTypeName: "TypeList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]go/types.Type",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsAlias",
				Description:      "IsAlias reports whether obj is an alias name for a type. ",
				ReceiverTypeName: "TypeName",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TypeName",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Obj",
				Description:      "Obj returns the type name for the declaration defining the alias type a. For instantiated types, this is same as the type name of the origin type. ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeName",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Index",
				Description:      "Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either: 1. the list of declared methods of a named type; or 2. the list of methods of an interface type; or 3. the list of fields of a struct type. The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0. ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Constraint",
				Description:      "Constraint returns the type constraint specified for t. ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "SetConstraint",
				Description:      "SetConstraint sets the type constraint for t. It must be called by users of NewTypeParam after the bound's underlying is fully defined, and before using the type parameter in any way other than to form other types. Once SetConstraint returns the receiver, t is safe for concurrent use. ",
				ReceiverTypeName: "TypeParam",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "cleanup",
				Description:      "",
				ReceiverTypeName: "TypeParam",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "iface",
				Description:      "iface returns the constraint interface of t. ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Interface",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "is",
				Description:      "is calls f with the specific type terms of t's constraint and reports whether all calls to f returned true. If there are no specific terms, is returns the result of f(nil). ",
				ReceiverTypeName: "TypeParam",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "typeset",
				Description:      "typeset is an iterator over the (type/underlying type) pairs of the specific type terms of t's constraint. If there are no specific terms, typeset calls yield with (nil, nil). In any case, typeset is guaranteed to call yield at least once. ",
				ReceiverTypeName: "TypeParam",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TypeParams",
				Description:      "TypeParams returns the type parameters of the alias type a, or nil. A generic Alias and its instances have the same type parameters. ",
				ReceiverTypeName: "TypeParamList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "TypeParamList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "At",
				Description:      "At returns the i'th method in s for 0 <= i < s.Len(). ",
				ReceiverTypeName: "TypeParamList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "TypeParam",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "list",
				Description:      "list is for internal use where we expect a []*TypeParam. TODO(rfindley): list should probably be eliminated: we can pass around a TypeParamList instead. ",
				ReceiverTypeName: "TypeParamList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*go/types.TypeParam",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Terms",
				Description:      "Terms returns a go1.23 iterator over the terms of a union. Example: for term := range union.Terms() { ... } ",
				ReceiverTypeName: "Union",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Seq",
						TypePkgName: "iter",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of array a. A negative result indicates an unknown length. ",
				ReceiverTypeName: "Union",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Term",
				Description:      "",
				ReceiverTypeName: "Union",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Term",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "Underlying",
				Description:      "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types. [underlying type]: https://go.dev/ref/spec#Underlying_types. ",
				ReceiverTypeName: "Union",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Union",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the kind of basic type b. ",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "VarKind",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "SetKind",
				Description:      "SetKind sets the kind of the variable. It should be used only immediately after [NewVar] or [NewParam]. ",
				ReceiverTypeName: "Var",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Anonymous",
				Description:      "Anonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility. ",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Embedded",
				Description:      "Embedded returns the i'th embedded defined (*[Named]) type of interface t for 0 <= i < t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type. Deprecated: Use [Interface.EmbeddedType] which is not restricted to defined (*[Named]) types. ",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsField",
				Description:      "IsField reports whether the variable is a struct field. ",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Origin",
				Description:      "Origin returns the generic Alias type of which a is an instance. If a is not an instance of a generic alias, Origin returns a. ",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "types",
					},
				},
			},
			methodSet{
				Name:             "isDependency",
				Description:      "",
				ReceiverTypeName: "Var",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Var",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "VarKind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"tracev1": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "grow",
				Description:      "grow grows the slice by one and returns a pointer to the new element, without overwriting it. ",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "tracev1",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "append appends v to the slice and returns a pointer to the new element. ",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "tracev1",
					},
				},
			},
			methodSet{
				Name:             "Ptr",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "tracev1",
					},
				},
			},
			methodSet{
				Name:             "index",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Less",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Pop",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "tracev1",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Peek",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "tracev1",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "All",
				Description:      "",
				ReceiverTypeName: "Events",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func(yield func(ev *internal/trace/internal/tracev1.Event) bool)",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "STWReason",
				Description:      "",
				ReceiverTypeName: "Trace",
				Returns: []returnSet{
					returnSet{
						TypeName:    "STWReason",
						TypePkgName: "tracev1",
					},
				},
			},
		},
		"user": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownGroupError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownGroupIdError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownUserError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnknownUserIdError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GroupIds",
				Description:      "GroupIds returns the list of group IDs that the user is a member of. ",
				ReceiverTypeName: "User",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"des": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "KeySizeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"bcache": []methodSet{
			methodSet{
				Name:             "Register",
				Description:      "Register registers the cache with the runtime, so that c.ptable can be cleared at the start of each GC. Register must be called during package initialization. ",
				ReceiverTypeName: "Cache",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "table",
				Description:      "table returns a pointer to the current cache hash table, coping with the possibility of the GC clearing it out from under us. ",
				ReceiverTypeName: "Cache",
				Returns: []returnSet{
					returnSet{
						TypeName:    "cacheTable",
						TypePkgName: "bcache",
					},
				},
			},
			methodSet{
				Name:             "Clear",
				Description:      "Clear clears the cache. The runtime does this automatically at each garbage collection; this method is exposed only for testing. ",
				ReceiverTypeName: "Cache",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get returns the cached value associated with v, which is either the value v corresponding to the most recent call to Put(k, v) or nil if that cache entry has been dropped. ",
				ReceiverTypeName: "Cache",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*V",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Put",
				Description:      "Put sets the cached value associated with k to v. ",
				ReceiverTypeName: "Cache",
				Returns:          []returnSet{},
			},
		},
		"pkix": []methodSet{
			methodSet{
				Name:             "HasExpired",
				Description:      "HasExpired reports whether certList should have been updated by now. ",
				ReceiverTypeName: "CertificateList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FillFromRDNSequence",
				Description:      "FillFromRDNSequence populates n from the provided [RDNSequence]. Multi-entry RDNs are flattened, all entries are added to the relevant n fields, and the grouping is not preserved. ",
				ReceiverTypeName: "Name",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "appendRDNs",
				Description:      "appendRDNs appends a relativeDistinguishedNameSET to the given RDNSequence and returns the new value. The relativeDistinguishedNameSET contains an attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and search for AttributeTypeAndValue. ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RDNSequence",
						TypePkgName: "pkix",
					},
				},
			},
			methodSet{
				Name:             "ToRDNSequence",
				Description:      "ToRDNSequence converts n into a single [RDNSequence]. The following attributes are encoded as multi-value RDNs: - Country - Organization - OrganizationalUnit - Locality - Province - StreetAddress - PostalCode Each ExtraNames entry is encoded as an individual RDN. ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RDNSequence",
						TypePkgName: "pkix",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax. ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax. ",
				ReceiverTypeName: "RDNSequence",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"mime": []methodSet{
			methodSet{
				Name:             "Decode",
				Description:      "Decode decodes an RFC 2047 encoded-word. ",
				ReceiverTypeName: "WordDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodeHeader",
				Description:      "DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if [WordDecoder.CharsetReader] of d returns an error. ",
				ReceiverTypeName: "WordDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "convert",
				Description:      "",
				ReceiverTypeName: "WordDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive. ",
				ReceiverTypeName: "WordEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encodeWord",
				Description:      "encodeWord encodes a string into an encoded-word. ",
				ReceiverTypeName: "WordEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bEncode",
				Description:      "bEncode encodes s using base64 encoding and writes it to buf. ",
				ReceiverTypeName: "WordEncoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "qEncode",
				Description:      "qEncode encodes s using Q encoding and writes it to buf. It splits the encoded-words when necessary. ",
				ReceiverTypeName: "WordEncoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "openWord",
				Description:      "openWord writes the beginning of an encoded-word into buf. ",
				ReceiverTypeName: "WordEncoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "splitWord",
				Description:      "splitWord closes the current encoded-word and opens a new one. ",
				ReceiverTypeName: "WordEncoder",
				Returns:          []returnSet{},
			},
		},
		"raw": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "String returns the canonical string representation of the event. This format is the same format that is parsed by the TextReader and emitted by the TextWriter. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodedSize",
				Description:      "EncodedSize returns the canonical encoded size of an event. ",
				ReceiverTypeName: "Event",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Version",
				Description:      "Version returns the version of the trace that we're reading. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "version",
					},
				},
			},
			methodSet{
				Name:             "ReadEvent",
				Description:      "ReadEvent reads and returns the next trace event in the byte stream. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readArgs",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readData",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Version",
				Description:      "Version returns the version of the trace that we're reading. ",
				ReceiverTypeName: "TextReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "version",
					},
				},
			},
			methodSet{
				Name:             "ReadEvent",
				Description:      "ReadEvent reads and returns the next trace event in the byte stream. ",
				ReceiverTypeName: "TextReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "raw",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nextLine",
				Description:      "",
				ReceiverTypeName: "TextReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteEvent",
				Description:      "WriteEvent writes a single event to the stream. ",
				ReceiverTypeName: "TextWriter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteEvent",
				Description:      "WriteEvent writes a single event to the stream. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"expvar": []methodSet{
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendJSON",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Float",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Int",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Int",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendJSON",
				Description:      "",
				ReceiverTypeName: "Int",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "",
				ReceiverTypeName: "Int",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Int",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendJSON",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendJSONMayExpand",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init removes all keys from the map. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "expvar",
					},
				},
			},
			methodSet{
				Name:             "addKey",
				Description:      "addKey updates the sorted list of keys in v.keys. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Get",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Var",
						TypePkgName: "expvar",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddFloat",
				Description:      "AddFloat adds delta to the *[Float] value stored under the given map key. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Delete",
				Description:      "Delete deletes the given key from the map. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Do",
				Description:      "Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
		},
		"elliptic": []methodSet{
			methodSet{
				Name:             "Params",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CurveParams",
						TypePkgName: "elliptic",
					},
				},
			},
			methodSet{
				Name:             "polynomial",
				Description:      "polynomial returns xÂ³ - 3x + b. ",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "IsOnCurve",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "affineFromJacobian",
				Description:      "affineFromJacobian reverses the Jacobian transform. See the comment at the top of the file. If the point is â it returns 0, 0. ",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "addJacobian",
				Description:      "addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and (x2, y2, z2) and returns their sum, also in Jacobian form. ",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Double",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "doubleJacobian",
				Description:      "doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and returns its double, also in Jacobian form. ",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "ScalarMult",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "ScalarBaseMult",
				Description:      "",
				ReceiverTypeName: "CurveParams",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
		},
		"url": []methodSet{
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "Error",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "Error",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "Error",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setPath",
				Description:      "setPath sets the Path and RawPath fields of the URL based on the provided escaped path p. It maintains the invariant that RawPath is only specified when it differs from the default encoding of the path. For example: - setPath(\"/foo/bar\") will set Path=\"/foo/bar\" and RawPath=\"\" - setPath(\"/foo%2fbar\") will set Path=\"/foo/bar\" and RawPath=\"/foo%2fbar\" setPath will return an error only if the provided path contains an invalid escaping. setPath should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include: - github.com/sagernet/sing Do not remove or change the type signature. See go.dev/issue/67401. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EscapedPath",
				Description:      "EscapedPath returns the escaped form of u.Path. In general there are multiple possible escaped forms of any path. EscapedPath returns u.RawPath when it is a valid escaping of u.Path. Otherwise EscapedPath ignores u.RawPath and computes an escaped form on its own. The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct their results. In general, code should call EscapedPath instead of reading u.RawPath directly. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setFragment",
				Description:      "setFragment is like setPath but for Fragment/RawFragment. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EscapedFragment",
				Description:      "EscapedFragment returns the escaped form of u.Fragment. In general there are multiple possible escaped forms of any fragment. EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment. Otherwise EscapedFragment ignores u.RawFragment and computes an escaped form on its own. The [URL.String] method uses EscapedFragment to construct its result. In general, code should call EscapedFragment instead of reading u.RawFragment directly. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the encoded userinfo information in the standard form of \"username[:password]\". ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Redacted",
				Description:      "Redacted is like [URL.String] but replaces any password with \"xxxxx\". Only the password in u.User is redacted. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsAbs",
				Description:      "IsAbs reports whether the [URL] is absolute. Absolute means that it has a non-empty scheme. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses a raw url into a [URL] structure. The url may be relative (a path, without a host) or absolute (starting with a scheme). Trying to parse a hostname and path without a scheme is invalid but may not necessarily return an error, due to parsing ambiguities. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ResolveReference",
				Description:      "ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new [URL] instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
				},
			},
			methodSet{
				Name:             "Query",
				Description:      "Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use [ParseQuery]. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Values",
						TypePkgName: "url",
					},
				},
			},
			methodSet{
				Name:             "RequestURI",
				Description:      "RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Hostname",
				Description:      "Hostname returns u.Host, stripping any valid port number if present. If the result is enclosed in square brackets, as literal IPv6 addresses are, the square brackets are removed from the result. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Port",
				Description:      "Port returns the port part of u.Host, without the leading colon. If u.Host doesn't contain a valid numeric port, Port returns an empty string. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "JoinPath",
				Description:      "JoinPath returns a new [URL] with the provided path elements joined to any existing path and the resulting path cleaned of any ./ or ../ elements. Any sequences of multiple / characters will be reduced to a single /. ",
				ReceiverTypeName: "URL",
				Returns: []returnSet{
					returnSet{
						TypeName:    "URL",
						TypePkgName: "url",
					},
				},
			},
			methodSet{
				Name:             "Username",
				Description:      "Username returns the username. ",
				ReceiverTypeName: "Userinfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Password",
				Description:      "Password returns the password in case it is set, and whether it is set. ",
				ReceiverTypeName: "Userinfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the encoded userinfo information in the standard form of \"username[:password]\". ",
				ReceiverTypeName: "Userinfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly. ",
				ReceiverTypeName: "Values",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets the key to value. It replaces any existing values. ",
				ReceiverTypeName: "Values",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds the value to key. It appends to any existing values associated with key. ",
				ReceiverTypeName: "Values",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Del",
				Description:      "Del deletes the values associated with key. ",
				ReceiverTypeName: "Values",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Has",
				Description:      "Has checks whether a given key is set. ",
				ReceiverTypeName: "Values",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode encodes the values into âURL encodedâ form (\"bar=baz&foo=quux\") sorted by key. ",
				ReceiverTypeName: "Values",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"quotedprintable": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "Read reads and decodes quoted-printable data from the underlying reader. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write encodes p using quoted-printable encoding and writes it to the underlying [io.Writer]. It limits line length to 76 characters. The encoded bytes are not necessarily flushed until the [Writer] is closed. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [Writer], flushing any unwritten data to the underlying [io.Writer], but does not close the underlying io.Writer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "write",
				Description:      "write limits text encoded in quoted-printable to 76 characters per line. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkLastByte",
				Description:      "checkLastByte encodes the last buffered byte if it is a space or a tab. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "insertSoftLineBreak",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "insertCRLF",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "flush",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"gccgoimporter": []methodSet{
			methodSet{
				Name:             "InitFromDriver",
				Description:      "Ask the driver at the given path for information for this GccgoInstallation. The given arguments are passed directly to the call of the driver. ",
				ReceiverTypeName: "GccgoInstallation",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SearchPaths",
				Description:      "Return the list of export search paths for this GccgoInstallation. ",
				ReceiverTypeName: "GccgoInstallation",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetImporter",
				Description:      "Return an importer that searches incpaths followed by the gcc installation's built-in search paths and the current directory. ",
				ReceiverTypeName: "GccgoInstallation",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Importer",
						TypePkgName: "gccgoimporter",
					},
				},
			},
		},
		"syscall": []methodSet{
			methodSet{
				Name:             "data",
				Description:      "",
				ReceiverTypeName: "Cmsghdr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLen",
				Description:      "",
				ReceiverTypeName: "Cmsghdr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "Errno",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Is",
				Description:      "",
				ReceiverTypeName: "Errno",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Temporary",
				Description:      "",
				ReceiverTypeName: "Errno",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Timeout",
				Description:      "",
				ReceiverTypeName: "Errno",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "InterfaceAddrMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.Sockaddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "InterfaceMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.Sockaddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "InterfaceMulticastAddrMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.Sockaddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLen",
				Description:      "",
				ReceiverTypeName: "Iovec",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetControllen",
				Description:      "",
				ReceiverTypeName: "Msghdr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "RouteMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]syscall.Sockaddr",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "SockaddrDatalink",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "_Socklen",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "SockaddrInet4",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "_Socklen",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "SockaddrInet6",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "_Socklen",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sockaddr",
				Description:      "",
				ReceiverTypeName: "SockaddrUnix",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "_Socklen",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unix",
				Description:      "Unix returns the time stored in ts as seconds plus nanoseconds. ",
				ReceiverTypeName: "Timespec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Nano",
				Description:      "Nano returns the time stored in ts as nanoseconds. ",
				ReceiverTypeName: "Timespec",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unix",
				Description:      "Unix returns the time stored in ts as seconds plus nanoseconds. ",
				ReceiverTypeName: "Timeval",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Nano",
				Description:      "Nano returns the time stored in ts as nanoseconds. ",
				ReceiverTypeName: "Timeval",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Exited",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExitStatus",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Signaled",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Signal",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signal",
						TypePkgName: "syscall",
					},
				},
			},
			methodSet{
				Name:             "CoreDump",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stopped",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Continued",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StopSignal",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Signal",
						TypePkgName: "syscall",
					},
				},
			},
			methodSet{
				Name:             "TrapCause",
				Description:      "",
				ReceiverTypeName: "WaitStatus",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"ed25519": []methodSet{
			methodSet{
				Name:             "Bytes",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seed",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PublicKey",
				Description:      "",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HashFunc",
				Description:      "HashFunc returns o.Hash. ",
				ReceiverTypeName: "Options",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Hash",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "Public",
				Description:      "Public returns the [PublicKey] corresponding to priv. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "PublicKey",
						TypePkgName: "crypto",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seed",
				Description:      "Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sign",
				Description:      "Sign signs the given message with priv. rand is ignored and can be nil. If opts.HashFunc() is [crypto.SHA512], the pre-hashed variant Ed25519ph is used and message is expected to be a SHA-512 hash, otherwise opts.HashFunc() must be [crypto.Hash](0) and the message must not be hashed, as Ed25519 performs two passes over messages to be signed. A value of type [Options] can be used as opts, or crypto.Hash(0) or crypto.SHA512 directly to select plain Ed25519 or Ed25519ph, respectively. ",
				ReceiverTypeName: "PrivateKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether pub and x have the same value. ",
				ReceiverTypeName: "PublicKey",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"elf": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Class",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Class",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CompressionType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "CompressionType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "DynFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "DynFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "DynFlag1",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "DynFlag1",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "DynTag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "DynTag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "stringTable",
				Description:      "stringTable reads and returns the string table given by the specified link value. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SectionByType",
				Description:      "SectionByType returns the first section in f with the given type, or nil if there is no such section. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Section",
						TypePkgName: "elf",
					},
				},
			},
			methodSet{
				Name:             "getSymbols",
				Description:      "getSymbols returns a slice of Symbols from parsing the symbol table with the given type, along with the associated string table. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.Symbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getSymbols32",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.Symbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getSymbols64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.Symbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocations",
				Description:      "applyRelocations applies relocations to dst. rels is a relocations section in REL or RELA format. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsAMD64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocations386",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsARM",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsARM64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsPPC",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsPPC64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsMIPS",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsMIPS64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsLOONG64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsRISCV64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationss390x",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "applyRelocationsSPARC64",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DWARF",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Data",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Symbols",
				Description:      "Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f. For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.Symbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DynamicSymbols",
				Description:      "DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f. If f has a symbol version table, the returned [File.Symbols] will have initialized Version and Library fields. For compatibility with [File.Symbols], [File.DynamicSymbols] omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.Symbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedSymbols",
				Description:      "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.ImportedSymbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dynamicVersions",
				Description:      "dynamicVersions returns version information for a dynamic object. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DynamicVersions",
				Description:      "DynamicVersions returns version information for a dynamic object. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.DynamicVersion",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dynamicVersionNeeds",
				Description:      "dynamicVersionNeeds returns version dependencies for a dynamic object. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DynamicVersionNeeds",
				Description:      "DynamicVersionNeeds returns version dependencies for a dynamic object. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/elf.DynamicVersionNeed",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "gnuVersionInit",
				Description:      "gnuVersionInit parses the GNU version tables for use by calls to gnuVersion. It reports whether any version tables were found. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "gnuVersion",
				Description:      "gnuVersion adds Library and Version information to sym, which came from offset i of the symbol table. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "VersionIndex",
						TypePkgName: "elf",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedLibraries",
				Description:      "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DynString",
				Description:      "DynString returns the strings listed for the given tag in the file's dynamic section. The tag must be one that takes string values: [DT_NEEDED], [DT_SONAME], [DT_RPATH], or [DT_RUNPATH]. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DynValue",
				Description:      "DynValue returns the values listed for the given tag in the file's dynamic section. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "FormatError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Machine",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Machine",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "NType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "NType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "OSABI",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "OSABI",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data. For an [SHT_NOBITS] section, all calls to the opened reader will return a non-nil error. ",
				ReceiverTypeName: "Prog",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadSeeker",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ProgFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "ProgFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ProgType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "ProgType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_386",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_386",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_390",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_390",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_AARCH64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_AARCH64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_ALPHA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_ALPHA",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_ARM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_ARM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_LARCH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_LARCH",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_MIPS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_MIPS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_PPC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_PPC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_PPC64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_PPC64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_RISCV",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_RISCV",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_SPARC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_SPARC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "R_X86_64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "R_X86_64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data. For an [SHT_NOBITS] section, all calls to the opened reader will return a non-nil error. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadSeeker",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SectionFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SectionFlag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SectionIndex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SectionIndex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SectionType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SectionType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SymBind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SymBind",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SymType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SymType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "SymVis",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "SymVis",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Version",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Version",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsHidden",
				Description:      "IsHidden reports whether the symbol is hidden within the version. This means that the symbol can only be seen by specifying the exact version. ",
				ReceiverTypeName: "VersionIndex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Index",
				Description:      "Index returns the version index. If this is the value 0, it means that the symbol is local, and is not visible externally. If this is the value 1, it means that the symbol is in the base version, and has no specific version; it may or may not match a [DynamicVersion.Index] in the slice returned by [File.DynamicVersions]. Other values will match either [DynamicVersion.Index] in the slice returned by [File.DynamicVersions], or [DynamicVersionDep.Index] in the Needs field of the elements of the slice returned by [File.DynamicVersionNeeds]. In general, a defined symbol will have an index referring to DynamicVersions, and an undefined symbol will have an index referring to some version in DynamicVersionNeeds. ",
				ReceiverTypeName: "VersionIndex",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint16",
						TypePkgName: "",
					},
				},
			},
		},
		"mail": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047. ",
				ReceiverTypeName: "Address",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parse",
				Description:      "Parse parses a single RFC 5322 address of the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\". ",
				ReceiverTypeName: "AddressParser",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Address",
						TypePkgName: "mail",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ParseList",
				Description:      "ParseList parses the given string as a list of comma-separated addresses of the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\". ",
				ReceiverTypeName: "AddressParser",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/mail.Address",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To access multiple values of a key, or to use non-canonical keys, access the map directly. ",
				ReceiverTypeName: "Header",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Date",
				Description:      "Date parses the Date header field. ",
				ReceiverTypeName: "Header",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddressList",
				Description:      "AddressList parses the named header field as a list of addresses. ",
				ReceiverTypeName: "Header",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*net/mail.Address",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"abi": []methodSet{
			methodSet{
				Name:             "Set",
				Description:      "Set sets the i'th bit of the bitmap to 1. ",
				ReceiverTypeName: "IntArgRegBitmap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get returns whether the i'th bit of the bitmap is set. nosplit because it's called in extremely sensitive contexts, like on the reflectcall return path. ",
				ReceiverTypeName: "IntArgRegBitmap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DataChecked",
				Description:      "DataChecked does pointer arithmetic on n's Bytes, and that arithmetic is asserted to be safe for the reason in whySafe (which can appear in a backtrace, etc.) ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data does pointer arithmetic on n's Bytes, and that arithmetic is asserted to be safe because the runtime made the call (other packages use DataChecked) ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsExported",
				Description:      "IsExported returns \"is n exported?\" ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HasTag",
				Description:      "HasTag returns true iff there is tag data following this name ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsEmbedded",
				Description:      "IsEmbedded returns true iff n is embedded (an anonymous field). ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadVarint",
				Description:      "ReadVarint parses a varint as encoded by encoding/binary. It returns the number of encoded bytes and the encoded value. ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsBlank",
				Description:      "IsBlank indicates whether n is \"_\". ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Tag",
				Description:      "Tag returns the tag string for n, or empty if there is none. ",
				ReceiverTypeName: "Name",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IndirectKey",
				Description:      "Note: flag values must match those used in the TMAP case in ../cmd/compile/internal/reflectdata/reflect.go:writeType. ",
				ReceiverTypeName: "OldMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IndirectElem",
				Description:      "",
				ReceiverTypeName: "OldMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReflexiveKey",
				Description:      "",
				ReceiverTypeName: "OldMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NeedKeyUpdate",
				Description:      "",
				ReceiverTypeName: "OldMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HashMightPanic",
				Description:      "",
				ReceiverTypeName: "OldMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Dump",
				Description:      "",
				ReceiverTypeName: "RegArgs",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IntRegArgAddr",
				Description:      "IntRegArgAddr returns a pointer inside of r.Ints[reg] that is appropriately offset for an argument of size argSize. argSize must be non-zero, fit in a register, and a power-of-two. This method is a helper for dealing with the endianness of different CPU architectures, since sub-word-sized arguments in big endian architectures need to be \"aligned\" to the upper edge of the register to be interpreted by the CPU correctly. ",
				ReceiverTypeName: "RegArgs",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Embedded",
				Description:      "",
				ReceiverTypeName: "StructField",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NeedKeyUpdate",
				Description:      "",
				ReceiverTypeName: "SwissMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HashMightPanic",
				Description:      "",
				ReceiverTypeName: "SwissMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IndirectKey",
				Description:      "Note: flag values must match those used in the TMAP case in ../cmd/compile/internal/reflectdata/reflect.go:writeType. ",
				ReceiverTypeName: "SwissMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IndirectElem",
				Description:      "",
				ReceiverTypeName: "SwissMapType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HasName",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pointers",
				Description:      "Pointers reports whether t contains pointers. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IfaceIndir",
				Description:      "IfaceIndir reports whether t is stored indirectly in an interface value. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsDirectIface",
				Description:      "isDirectIface reports whether t is stored directly in an interface value. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GcSlice",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the length of t if t is an array type, otherwise 0 ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Common",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "Uncommon",
				Description:      "Uncommon returns a pointer to T's \"uncommon\" data if there is any, otherwise nil ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "UncommonType",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Elem returns the element type for t if t is an array, channel, map, pointer, or slice, otherwise nil. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "StructType",
				Description:      "StructType returns t cast to a *StructType, or nil if its tag does not match. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "StructType",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "MapType",
				Description:      "MapType returns t cast to a *OldMapType or *SwissMapType, or nil if its tag does not match. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "*internal/abi.mapType",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FuncType",
				Description:      "FuncType returns t cast to a *FuncType, or nil if its tag does not match. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FuncType",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "InterfaceType",
				Description:      "InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not match. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "InterfaceType",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the size of data with type t. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Align",
				Description:      "Align returns the alignment of data with type t. ",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FieldAlign",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExportedMethods",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/abi.Method",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumMethod",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Key",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "Methods",
				Description:      "",
				ReceiverTypeName: "UncommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/abi.Method",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExportedMethods",
				Description:      "",
				ReceiverTypeName: "UncommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/abi.Method",
						TypePkgName: "",
					},
				},
			},
		},
		"bytes": []methodSet{
			methodSet{
				Name:             "Bytes",
				Description:      "Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like [Buffer.Read], [Buffer.Write], [Buffer.Reset], or [Buffer.Truncate]). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AvailableBuffer",
				Description:      "AvailableBuffer returns an empty buffer with b.Available() capacity. This buffer is intended to be appended to and passed to an immediately succeeding [Buffer.Write] call. The buffer is only valid until the next write operation on b. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the contents of the unread portion of the buffer as a string. If the [Buffer] is a nil pointer, it returns \"<nil>\". To build strings more efficiently, see the [strings.Builder] type. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "empty",
				Description:      "empty reports whether the unread portion of the buffer is empty. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Cap",
				Description:      "Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Available",
				Description:      "Available returns how many bytes are unused in the buffer. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Truncate",
				Description:      "Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer. ",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as [Buffer.Truncate](0). ",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tryGrowByReslice",
				Description:      "tryGrowByReslice is an inlineable version of grow for the fast-case where the internal buffer only needs to be resliced. It returns the index where bytes should be written and whether it succeeded. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "grow",
				Description:      "grow grows the buffer to guarantee space for n more bytes. It returns the index where bytes should be written. If the buffer can't grow it will panic with ErrTooLarge. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Grow",
				Description:      "Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFrom",
				Description:      "ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the [io.WriterTo] interface. Any error encountered during the write is also returned. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteByte",
				Description:      "WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match [bufio.Writer]'s WriteByte. If the buffer becomes too large, WriteByte will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteRune",
				Description:      "WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match [bufio.Writer]'s WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with [ErrTooLarge]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is [io.EOF] (unless len(p) is zero); otherwise it is nil. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by [Buffer.Read]. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadByte",
				Description:      "ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error [io.EOF]. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadRune",
				Description:      "ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadRune",
				Description:      "UnreadRune unreads the last rune returned by [Buffer.ReadRune]. If the most recent read or write operation on the buffer was not a successful [Buffer.ReadRune], UnreadRune returns an error. (In this regard it is stricter than [Buffer.UnreadByte], which will unread the last byte from any read operation.) ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadByte",
				Description:      "UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadBytes",
				Description:      "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often [io.EOF]). ReadBytes returns err != nil if and only if the returned data does not end in delim. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readSlice",
				Description:      "readSlice is like ReadBytes but returns a reference to internal buffer data. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadString",
				Description:      "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often [io.EOF]). ReadString returns err != nil if and only if the returned data does not end in delim. ",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via [Reader.ReadAt]. The result is unaffected by any method calls except [Reader.Reset]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is [io.EOF] (unless len(p) is zero); otherwise it is nil. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadAt",
				Description:      "ReadAt implements the [io.ReaderAt] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadByte",
				Description:      "ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error [io.EOF]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadByte",
				Description:      "UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadRune",
				Description:      "ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadRune",
				Description:      "UnreadRune unreads the last rune returned by [Buffer.ReadRune]. If the most recent read or write operation on the buffer was not a successful [Buffer.ReadRune], UnreadRune returns an error. (In this regard it is stricter than [Buffer.UnreadByte], which will unread the last byte from any read operation.) ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek implements the [io.Seeker] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the [io.WriterTo] interface. Any error encountered during the write is also returned. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as [Buffer.Truncate](0). ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
		},
		"hmac": []methodSet{
			methodSet{
				Name:             "Sum",
				Description:      "",
				ReceiverTypeName: "HMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "HMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "HMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "",
				ReceiverTypeName: "HMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "",
				ReceiverTypeName: "HMAC",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone implements [hash.Cloner] if the underlying hash does. Otherwise, it returns an error wrapping [errors.ErrUnsupported]. ",
				ReceiverTypeName: "HMAC",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cloner",
						TypePkgName: "hash",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"embed": []methodSet{
			methodSet{
				Name:             "lookup",
				Description:      "lookup returns the named file, or nil if it is not present. ",
				ReceiverTypeName: "FS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "file",
						TypePkgName: "embed",
					},
				},
			},
			methodSet{
				Name:             "readDir",
				Description:      "readDir returns the list of files corresponding to the directory dir. ",
				ReceiverTypeName: "FS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]embed.file",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open opens the named file for reading and returns it as an [fs.File]. The returned file implements [io.Seeker] and [io.ReaderAt] when the file is not a directory. ",
				ReceiverTypeName: "FS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadDir",
				Description:      "ReadDir reads and returns the entire named directory. ",
				ReceiverTypeName: "FS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]io/fs.DirEntry",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadFile",
				Description:      "ReadFile reads and returns the content of the named file. ",
				ReceiverTypeName: "FS",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"syntax": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ErrorCode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "op",
				Description:      "op pushes a regexp with the given op onto the stack and returns that regexp. ",
				ReceiverTypeName: "Inst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "InstOp",
						TypePkgName: "syntax",
					},
				},
			},
			methodSet{
				Name:             "MatchRune",
				Description:      "MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == [InstRune]. ",
				ReceiverTypeName: "Inst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchRunePos",
				Description:      "MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == [InstRune]. ",
				ReceiverTypeName: "Inst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MatchEmptyWidth",
				Description:      "MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == [InstEmptyWidth]. ",
				ReceiverTypeName: "Inst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Inst",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "InstOp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Op",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Prog",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "skipNop",
				Description:      "skipNop follows any no-op or capturing instructions. ",
				ReceiverTypeName: "Prog",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Inst",
						TypePkgName: "syntax",
					},
				},
			},
			methodSet{
				Name:             "Prefix",
				Description:      "Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. ",
				ReceiverTypeName: "Prog",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StartCond",
				Description:      "StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible. ",
				ReceiverTypeName: "Prog",
				Returns: []returnSet{
					returnSet{
						TypeName:    "EmptyOp",
						TypePkgName: "syntax",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether x and y have identical structure. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MaxCap",
				Description:      "MaxCap walks the regexp to find the maximum capture index. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CapNames",
				Description:      "CapNames walks the regexp to find the names of capturing groups. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "capNames",
				Description:      "",
				ReceiverTypeName: "Regexp",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Simplify",
				Description:      "Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original. ",
				ReceiverTypeName: "Regexp",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Regexp",
						TypePkgName: "syntax",
					},
				},
			},
		},
		"slicereader": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Offset",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadUint8",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint8",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadUint32",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadUint64",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadULEB128",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadString",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"socktest": []methodSet{
			methodSet{
				Name:             "apply",
				Description:      "",
				ReceiverTypeName: "AfterFilter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Family",
				Description:      "Family returns an address family. ",
				ReceiverTypeName: "Cookie",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Type",
				Description:      "Type returns a socket type. ",
				ReceiverTypeName: "Cookie",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Protocol",
				Description:      "Protocol returns a protocol number. ",
				ReceiverTypeName: "Cookie",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "apply",
				Description:      "",
				ReceiverTypeName: "Filter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "AfterFilter",
						TypePkgName: "socktest",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Stat",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Status",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Switch",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Stats",
				Description:      "Stats returns a list of per-cookie socket statistics. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]net/internal/socktest.Stat",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sockets",
				Description:      "Sockets returns mappings of socket descriptor to socket status. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Sockets",
						TypePkgName: "socktest",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set deploys the socket system call filter f for the filter type t. ",
				ReceiverTypeName: "Switch",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sockso",
				Description:      "",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Status",
						TypePkgName: "socktest",
					},
				},
			},
			methodSet{
				Name:             "addLocked",
				Description:      "addLocked returns a new Status without locking. sw.smu must be held before call. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Status",
						TypePkgName: "socktest",
					},
				},
			},
			methodSet{
				Name:             "Socket",
				Description:      "Socket wraps [syscall.Socket]. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close wraps syscall.Close. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Connect",
				Description:      "Connect wraps syscall.Connect. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Listen",
				Description:      "Listen wraps syscall.Listen. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Accept",
				Description:      "Accept wraps syscall.Accept. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Sockaddr",
						TypePkgName: "syscall",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetsockoptInt",
				Description:      "GetsockoptInt wraps syscall.GetsockoptInt. ",
				ReceiverTypeName: "Switch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"ascii85": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CorruptInputError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"log": []methodSet{
			methodSet{
				Name:             "SetOutput",
				Description:      "SetOutput sets the output destination for the logger. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Output",
				Description:      "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "output",
				Description:      "output can take either a calldepth or a pc to get source line information. It uses the pc if it is non-zero. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Print",
				Description:      "Print calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Print]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Printf",
				Description:      "Printf calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Printf]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Println",
				Description:      "Println calls l.Output to print to the logger. Arguments are handled in the manner of [fmt.Println]. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Fatal",
				Description:      "Fatal is equivalent to l.Print() followed by a call to [os.Exit](1). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Fatalf",
				Description:      "Fatalf is equivalent to l.Printf() followed by a call to [os.Exit](1). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Fatalln",
				Description:      "Fatalln is equivalent to l.Println() followed by a call to [os.Exit](1). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Panic",
				Description:      "Panic is equivalent to l.Print() followed by a call to panic(). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Panicf",
				Description:      "Panicf is equivalent to l.Printf() followed by a call to panic(). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Panicln",
				Description:      "Panicln is equivalent to l.Println() followed by a call to panic(). ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flags",
				Description:      "Flags returns the output flags for the logger. The flag bits are [Ldate], [Ltime], and so on. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetFlags",
				Description:      "SetFlags sets the output flags for the logger. The flag bits are [Ldate], [Ltime], and so on. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Prefix",
				Description:      "Prefix returns the output prefix for the logger. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetPrefix",
				Description:      "SetPrefix sets the output prefix for the logger. ",
				ReceiverTypeName: "Logger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Writer",
				Description:      "Writer returns the output destination for the logger. ",
				ReceiverTypeName: "Logger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
		},
		"asmgen": []methodSet{
			methodSet{
				Name:             "HasShiftWide",
				Description:      "HasShiftWide reports whether the Arch has working LshWide/RshWide instructions. If not, calling them will panic. ",
				ReceiverTypeName: "Arch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fatalf",
				Description:      "Fatalf reports a fatal error by panicking. Panicking is appropriate because there is a bug in the generator, and panicking will show the exact source lines leading to that bug. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "hint",
				Description:      "hint returns the register name for the given hint. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ZR",
				Description:      "ZR returns the zero register (the specific register guaranteed to hold the integer 0), or else the zero Reg (Reg{}, which has r.Valid() == false). ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "tmp",
				Description:      "tmp returns the temporary register, or else the zero Reg. The temporary register is one available for use implementing logical instructions that compile into multiple actual instructions on a given system. The assembler sometimes uses it for that purpose, as do we. Of course, if we are using it, we'd better not emit an instruction that will cause the assembler to smash it while we want it to be holding a live value. In general it is the architecture implementation's responsibility not to suggest the use of any such pseudo-instructions in situations where they would cause problems. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "Imm",
				Description:      "Imm returns a Reg representing an immediate (constant) value. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero reports whether r is a zero immediate or the zero register. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegHint",
				Description:      "RegHint allocates a new register, with a hint as to its purpose. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "Free",
				Description:      "Free frees a previously allocated register. If r is not a register (if it's an immediate or a memory reference), Free is a no-op. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Unfree",
				Description:      "Unfree reallocates a previously freed register r. If r is not a register (if it's an immediate or a memory reference), Unfree is a no-op. If r is not free for allocation, Unfree panics. A Free paired with Unfree can release a register for use temporarily but then reclaim it, such as at the end of a loop body when it must be restored. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetRegsUsed",
				Description:      "SetRegsUsed sets which registers are currently allocated. The argument should have been returned from a previous call to [Asm.RegsUsed]. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "FreeAll",
				Description:      "FreeAll frees all known registers. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Printf",
				Description:      "Printf emits to the assembly output. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Comment",
				Description:      "Comment emits a line comment to the assembly output. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "EOL",
				Description:      "EOL appends an end-of-line comment to the previous line. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "JmpEnable",
				Description:      "JmpEnable emits a test for the optional CPU feature that jumps to label if the feature is present. If JmpEnable returns false, the feature is not available on this architecture and no code was emitted. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Enabled",
				Description:      "Enabled reports whether the optional CPU feature is considered to be enabled at this point in the assembly output. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetOption",
				Description:      "SetOption changes whether the optional CPU feature should be considered to be enabled. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "op3",
				Description:      "op3 emits a 3-operand instruction op src1, src2, dst, taking care to handle 2-operand machines and also to simplify the printout when src2==dst. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Mov",
				Description:      "Mov emits dst = src. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddWords",
				Description:      "AddWords emits dst = src1*WordBytes + src2. It does not set or use the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "And",
				Description:      "And emits dst = src1 & src2 It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Or",
				Description:      "Or emits dst = src1 | src2 It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Xor",
				Description:      "Xor emits dst = src1 ^ src2 It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Neg",
				Description:      "Neg emits dst = -src. It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HasRegShift",
				Description:      "HasRegShift reports whether the architecture can use shift expressions as operands. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "LshReg",
				Description:      "LshReg returns a shift-expression operand src<<shift. If a.HasRegShift() == false, LshReg panics. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "Lsh",
				Description:      "Lsh emits dst = src << shift. It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LshWide",
				Description:      "LshWide emits dst = src << shift with low bits shifted from adj. It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RshReg",
				Description:      "RshReg returns a shift-expression operand src>>shift. If a.HasRegShift() == false, RshReg panics. ",
				ReceiverTypeName: "Asm",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "Rsh",
				Description:      "Rsh emits dst = src >> shift. It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RshWide",
				Description:      "RshWide emits dst = src >> shift with high bits shifted from adj. It may modify the carry flag. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SLTU",
				Description:      "SLTU emits dst = src2 < src1 (0 or 1), using an unsigned comparison. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add emits dst = src1+src2, with the specified carry behavior. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub emits dst = src2-src1, with the specified carry behavior. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ClearCarry",
				Description:      "ClearCarry clears the carry flag. The âwhichâ parameter must be AddCarry or SubCarry to specify how the flag will be used. (On some systems, the sub carry's actual processor bit is inverted from its usual value.) ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SaveCarry",
				Description:      "SaveCarry saves the carry flag into dst. The meaning of the bits in dst is architecture-dependent. The carry flag is left in an undefined state. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RestoreCarry",
				Description:      "RestoreCarry restores the carry flag from src. src is left in an undefined state. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ConvertCarry",
				Description:      "ConvertCarry converts the carry flag in dst from the internal format to a 0 or 1. The carry flag is left in an undefined state. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SaveConvertCarry",
				Description:      "SaveConvertCarry saves and converts the carry flag into dst: 0 unset, 1 set. The carry flag is left in an undefined state. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MulWide",
				Description:      "MulWide emits dstlo = src1 * src2 and dsthi = (src1 * src2) >> WordBits. The carry flag is left in an undefined state. If dstlo or dsthi is the zero Reg, then those outputs are discarded. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Jmp",
				Description:      "Jmp jumps to the label. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "JmpZero",
				Description:      "JmpZero jumps to the label if src is zero. It may modify the carry flag unless a.Arch.CarrySafeLoop is true. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "JmpNonZero",
				Description:      "JmpNonZero jumps to the label if src is non-zero. It may modify the carry flag unless a.Arch,CarrySafeLoop is true. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Label",
				Description:      "Label emits a label with the given name. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Ret",
				Description:      "Ret returns. ",
				ReceiverTypeName: "Asm",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Arg",
				Description:      "Arg allocates a new register, copies the named argument (or result) into it, and returns that register. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "ArgHint",
				Description:      "ArgHint is like Arg but uses a register allocation hint. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "ArgPtr",
				Description:      "ArgPtr is like Arg but returns a RegPtr. ",
				ReceiverTypeName: "Func",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RegPtr",
						TypePkgName: "asmgen",
					},
				},
			},
			methodSet{
				Name:             "StoreArg",
				Description:      "StoreArg stores src into the named argument (or result). ",
				ReceiverTypeName: "Func",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetBackward",
				Description:      "SetBackward sets the pipe to process the input and output columns in reverse order. This is needed for left shifts, which might otherwise overwrite data they will read later. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetUseIndexCounter",
				Description:      "SetUseIndexCounter sets the pipe to use an index counter if possible, meaning the loop counter is also used as an index for accessing the slice data. This clever trick is slower on modern processors, but it is still necessary on 386. On non-386 systems, SetUseIndexCounter is a no-op. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetLabel",
				Description:      "SetLabel sets the label prefix for the loops emitted by the pipe. The default prefix is \"loop\". ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetMaxColumns",
				Description:      "SetMaxColumns sets the maximum number of columns processed in a single loop body call. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetHint",
				Description:      "SetHint records that the inputs from the named vector should be allocated with the given register hint. If the hint indicates a single register on the target architecture, then SetHint calls SetMaxColumns(1), since the hinted register can only be used for one value at a time. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LoadPtrs",
				Description:      "LoadPtrs loads the slice pointer arguments into registers, assuming that the slice length n has already been loaded into the register n. Start will call LoadPtrs if it has not been called already. LoadPtrs only needs to be called explicitly when code needs to use LoadN before Start, like when the shift.go generators read an initial word before the loop. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "LoadN",
				Description:      "LoadN returns the next n columns of input words as a slice of rows. Regs for inputs that have been marked using p.SetMemOK will be direct memory references. Regs for other inputs will be newly allocated registers and must be freed. ",
				ReceiverTypeName: "Pipe",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]math/big/internal/asmgen.Reg",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StoreN",
				Description:      "StoreN writes regs (a slice of rows) to the next n columns of output, where n = len(regs[0]). ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "advancePtrs",
				Description:      "advancePtrs advances the pointers by step or handles bookkeeping for an imminent index advance by step that the caller will do. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DropInput",
				Description:      "DropInput deletes the named input from the pipe, usually because it has been exhausted. (This is not used yet but will be used in a future generator.) ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Start",
				Description:      "Start prepares to loop over n columns. The factors give a sequence of unrolling factors to use, which must be either strictly increasing or strictly decreasing and must include 1. For example, 4, 1 means to process 4 elements at a time and then 1 at a time for the final 0-3; specifying 1,4 instead handles 0-3 elements first and then 4 at a time. Similarly, 32, 4, 1 means to process 32 at a time, then 4 at a time, then 1 at a time. One benefit of using 1, 4 instead of 4, 1 is that the body processing 4 at a time needs more registers, and if it is the final body, the register holding the fragment count (0-3) has been freed and is available for use. Start may modify the carry flag. Start must be followed by a call to Loop1 or LoopN, but it is permitted to emit other instructions first, for example to set an initial carry flag. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Restart",
				Description:      "Restart prepares to loop over an additional n columns, beyond a previous loop run by p.Start/p.Loop. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Done",
				Description:      "Done frees all the registers allocated by the pipe. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Loop",
				Description:      "Loop emits code for the loop, calling block repeatedly to emit code that handles a block of N input columns (for arbitrary N = len(in[0]) chosen by p). block must call p.StoreN(out) to write N output columns. The out slice is a pre-allocated matrix of uninitialized Reg values. block is expected to set each entry to the Reg that should be written before calling p.StoreN(out). For example, if the loop is to be unrolled 4x in blocks of 2 columns each, the sequence of calls to emit the unrolled loop body is: start() // set by pAtUnrollStart ... reads for 2 columns ... block() ... writes for 2 columns ... ... reads for 2 columns ... block() ... writes for 2 columns ... end() // set by p.AtUnrollEnd Any registers allocated during block are freed automatically when block returns. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AtUnrollStart",
				Description:      "AtUnrollStart sets a function to call at the start of an unrolled sequence. See [Pipe.Loop] for details. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AtUnrollEnd",
				Description:      "AtUnrollEnd sets a function to call at the end of an unrolled sequence. See [Pipe.Loop] for details. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "unroll",
				Description:      "unroll emits a single unrolled loop for the given factor, iterating n times. ",
				ReceiverTypeName: "Pipe",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IsImm",
				Description:      "IsImm reports whether r is an immediate value. ",
				ReceiverTypeName: "Reg",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsMem",
				Description:      "IsMem reports whether r is a memory value. ",
				ReceiverTypeName: "Reg",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the assembly syntax for r. ",
				ReceiverTypeName: "Reg",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Valid",
				Description:      "Valid reports whether is valid, meaning r is not the zero value of Reg (a register with no name). ",
				ReceiverTypeName: "Reg",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the assembly syntax for r. ",
				ReceiverTypeName: "RegPtr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Valid",
				Description:      "Valid reports whether is valid, meaning r is not the zero value of Reg (a register with no name). ",
				ReceiverTypeName: "RegPtr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mem",
				Description:      "mem returns a memory reference to off bytes from the pointer r. ",
				ReceiverTypeName: "RegPtr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reg",
						TypePkgName: "asmgen",
					},
				},
			},
		},
		"maps": []methodSet{
			methodSet{
				Name:             "Init",
				Description:      "Init initializes Iter for iteration. ",
				ReceiverTypeName: "Iter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Initialized",
				Description:      "",
				ReceiverTypeName: "Iter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Key",
				Description:      "Key returns a pointer to the current key. nil indicates end of iteration. Must not be called prior to Next. ",
				ReceiverTypeName: "Iter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "Key returns a pointer to the current element. nil indicates end of iteration. Must not be called prior to Next. ",
				ReceiverTypeName: "Iter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nextDirIdx",
				Description:      "",
				ReceiverTypeName: "Iter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "grownKeyElem",
				Description:      "Return the appropriate key/elem for key at slotIdx index within it.group, if any. ",
				ReceiverTypeName: "Iter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next proceeds to the next element in iteration, which can be accessed via the Key and Elem methods. The table can be mutated during iteration, though there is no guarantee that the mutations will be visible to the iteration. Init must be called prior to Next. ",
				ReceiverTypeName: "Iter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "directoryIndex",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uintptr",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "directoryAt",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "table",
						TypePkgName: "maps",
					},
				},
			},
			methodSet{
				Name:             "directorySet",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "replaceTable",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "installTableSplit",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Used",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get performs a lookup of the key that key points to. It returns a pointer to the element, or false if the key doesn't exist. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getWithKey",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getWithoutKey",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getWithKeySmall",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Put",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "PutSlot",
				Description:      "PutSlot returns a pointer to the element slot where an inserted element should be written. PutSlot never returns nil. ",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "putSlotSmall",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "growToSmall",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "growToTable",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Delete",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "deleteSmall",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clear",
				Description:      "Clear deletes all entries from the map resulting in an empty map. ",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "clearSmall",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Clone",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Map",
						TypePkgName: "maps",
					},
				},
			},
			methodSet{
				Name:             "putSlotSmallFast32",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "putSlotSmallFast64",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "putSlotSmallFastPtr",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getWithoutKeySmallFastStr",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "putSlotSmallFastStr",
				Description:      "",
				ReceiverTypeName: "Map",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
		},
		"reflectlite": []methodSet{
			methodSet{
				Name:             "typ",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "abi",
					},
				},
			},
			methodSet{
				Name:             "pointer",
				Description:      "pointer returns the underlying pointer represented by v. v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "unsafe.Pointer",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CanSet",
				Description:      "CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Elem",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflectlite",
					},
				},
			},
			methodSet{
				Name:             "IsNil",
				Description:      "IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "numMethod",
				Description:      "NumMethod returns the number of exported methods in the value's method set. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type. ",
				ReceiverTypeName: "Value",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "assignTo",
				Description:      "assignTo returns a value v that can be assigned directly to typ. It panics if v is not assignable to typ. For a conversion to an interface type, target is a suggested scratch space to use. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "reflectlite",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ValueError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"bzip2": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "StructuralError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"macho": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Cpu",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Cpu",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "FatFile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseSymtab",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Symtab",
						TypePkgName: "macho",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pushSection",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DWARF",
				Description:      "DWARF returns the DWARF debug information for the Mach-O file. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Data",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedSymbols",
				Description:      "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedLibraries",
				Description:      "ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "FormatError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Raw",
				Description:      "",
				ReceiverTypeName: "LoadBytes",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "LoadCmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "LoadCmd",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "RelocTypeARM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "RelocTypeARM",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "RelocTypeARM64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "RelocTypeARM64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "RelocTypeGeneric",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "RelocTypeGeneric",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "RelocTypeX86_64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "RelocTypeX86_64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data reads and returns the contents of the segment. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a new ReadSeeker reading the segment. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadSeeker",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data reads and returns the contents of the segment. ",
				ReceiverTypeName: "Segment",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a new ReadSeeker reading the segment. ",
				ReceiverTypeName: "Segment",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadSeeker",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Type",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"textproto": []methodSet{
			methodSet{
				Name:             "Close",
				Description:      "Close closes the connection. ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Cmd",
				Description:      "Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \\r\\n. Cmd returns the id of the command, for use with StartResponse and EndResponse. For example, a client might run a HELP command that returns a dot-body by using: id, err := c.Cmd(\"HELP\") if err != nil { return nil, err } c.StartResponse(id) defer c.EndResponse(id) if _, _, err = c.ReadCodeLine(110); err != nil { return nil, err } text, err := c.ReadDotBytes() if err != nil { return nil, err } return c.ReadCodeLine(250) ",
				ReceiverTypeName: "Conn",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds the key, value pair to the header. It appends to any existing values associated with key. ",
				ReceiverTypeName: "MIMEHeader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Set",
				Description:      "Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key. ",
				ReceiverTypeName: "MIMEHeader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get gets the first value associated with the given key. It is case insensitive; [CanonicalMIMEHeaderKey] is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To use non-canonical keys, access the map directly. ",
				ReceiverTypeName: "MIMEHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Values",
				Description:      "Values returns all values associated with the given key. It is case insensitive; [CanonicalMIMEHeaderKey] is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy. ",
				ReceiverTypeName: "MIMEHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Del",
				Description:      "Del deletes the values associated with key. ",
				ReceiverTypeName: "MIMEHeader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next returns the next id for a request/response pair. ",
				ReceiverTypeName: "Pipeline",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StartRequest",
				Description:      "StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id. ",
				ReceiverTypeName: "Pipeline",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "EndRequest",
				Description:      "EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received). ",
				ReceiverTypeName: "Pipeline",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StartResponse",
				Description:      "StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id. ",
				ReceiverTypeName: "Pipeline",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "EndResponse",
				Description:      "EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent). ",
				ReceiverTypeName: "Pipeline",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ReadLine",
				Description:      "ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the returned string. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadLineBytes",
				Description:      "ReadLineBytes is like [Reader.ReadLine] but returns a []byte instead of a string. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLineSlice",
				Description:      "readLineSlice reads a single line from r, up to lim bytes long (or unlimited if lim is less than 0), eliding the final \\r or \\r\\n from the returned string. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadContinuedLine",
				Description:      "ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed. For example, consider this input: Line 1 continued... Line 2 The first call to ReadContinuedLine will return \"Line 1 continued...\" and the second will return \"Line 2\". Empty lines are never continued. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadContinuedLineBytes",
				Description:      "ReadContinuedLineBytes is like [Reader.ReadContinuedLine] but returns a []byte instead of a string. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readContinuedLineSlice",
				Description:      "readContinuedLineSlice reads continued lines from the reader buffer, returning a byte slice with all lines. The validateFirstLine function is run on the first read line, and if it returns an error then this error is returned from readContinuedLineSlice. It reads up to lim bytes of data (or unlimited if lim is less than 0). ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "skipSpace",
				Description:      "skipSpace skips R over all spaces and returns the number of bytes skipped. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readCodeLine",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadCodeLine",
				Description:      "ReadCodeLine reads a response code line of the form code message where code is a three-digit status code and the message extends to the rest of the line. An example of such a line is: 220 plan9.bell-labs.com ESMTP If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to &Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319]. If the response is multi-line, ReadCodeLine returns an error. An expectCode <= 0 disables the check of the status code. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadResponse",
				Description:      "ReadResponse reads a multi-line response of the form: code-message line 1 code-message line 2 ... code message line n where code is a three-digit status code. The first line starts with the code and a hyphen. The response is terminated by a line that starts with the same code followed by a space. Each line in message is separated by a newline (\\n). See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for details of another form of response accepted: code-message line 1 message line 2 ... code message line n If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319]. An expectCode <= 0 disables the check of the status code. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DotReader",
				Description:      "DotReader returns a new [Reader] that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r. Dot encoding is a common framing used for data blocks in text protocols such as SMTP. The data consists of a sequence of lines, each of which ends in \"\\r\\n\". The sequence itself ends at a line containing just a dot: \".\\r\\n\". Lines beginning with a dot are escaped with an additional dot to avoid looking like the end of the sequence. The decoded form returned by the Reader's Read method rewrites the \"\\r\\n\" line endings into the simpler \"\\n\", removes leading dot escapes if present, and stops with error [io.EOF] after consuming (and discarding) the end-of-sequence line. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "closeDot",
				Description:      "closeDot drains the current DotReader if any, making sure that it reads until the ending dot line. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ReadDotBytes",
				Description:      "ReadDotBytes reads a dot-encoding and returns the decoded data. See the documentation for the [Reader.DotReader] method for details about dot-encoding. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadDotLines",
				Description:      "ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \\r\\n or \\n elided from each. See the documentation for the [Reader.DotReader] method for details about dot-encoding. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadMIMEHeader",
				Description:      "ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps [CanonicalMIMEHeaderKey](key) to a sequence of values in the same order encountered in the input. For example, consider this input: My-Key: Value 1 Long-Key: Even Longer Value My-Key: Value 2 Given that input, ReadMIMEHeader returns the map: map[string][]string{ \"My-Key\": {\"Value 1\", \"Value 2\"}, \"Long-Key\": {\"Even Longer Value\"}, } ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "MIMEHeader",
						TypePkgName: "textproto",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "upcomingHeaderKeys",
				Description:      "upcomingHeaderKeys returns an approximation of the number of keys that will be in this header. If it gets confused, it returns 0. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PrintfLine",
				Description:      "PrintfLine writes the formatted output followed by \\r\\n. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DotWriter",
				Description:      "DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w. See the documentation for the [Reader.DotReader] method for details about dot-encoding. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "WriteCloser",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "closeDot",
				Description:      "closeDot drains the current DotReader if any, making sure that it reads until the ending dot line. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
		},
		"constraint": []methodSet{
			methodSet{
				Name:             "isExpr",
				Description:      "",
				ReceiverTypeName: "AndExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Eval",
				Description:      "",
				ReceiverTypeName: "AndExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "AndExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isExpr",
				Description:      "",
				ReceiverTypeName: "NotExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Eval",
				Description:      "",
				ReceiverTypeName: "NotExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "NotExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isExpr",
				Description:      "",
				ReceiverTypeName: "OrExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Eval",
				Description:      "",
				ReceiverTypeName: "OrExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "OrExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SyntaxError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "isExpr",
				Description:      "",
				ReceiverTypeName: "TagExpr",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Eval",
				Description:      "",
				ReceiverTypeName: "TagExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TagExpr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"doc": []methodSet{
			methodSet{
				Name:             "collectValues",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "collectTypes",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "collectFuncs",
				Description:      "",
				ReceiverTypeName: "Package",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "lookupSym",
				Description:      "lookupSym reports whether the package has a given symbol or method. If recv == \"\", HasSym reports whether the package has a top-level const, func, type, or var named name. If recv != \"\", HasSym reports whether the package has a type named recv with a method named name. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lookupPackage",
				Description:      "lookupPackage returns the import path identified by name in the given package. If name uniquely identifies a single import, then lookupPackage returns that import. If multiple packages are imported as name, importPath returns \"\", false. Otherwise, if name is the name of p itself, importPath returns \"\", true, to signal a reference to p. Otherwise, importPath returns \"\", false. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Parser",
				Description:      "Parser returns a doc comment parser configured for parsing doc comments from package p. Each call returns a new parser, so that the caller may customize it before use. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Parser",
						TypePkgName: "comment",
					},
				},
			},
			methodSet{
				Name:             "Printer",
				Description:      "Printer returns a doc comment printer configured for printing doc comments from package p. Each call returns a new printer, so that the caller may customize it before use. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Printer",
						TypePkgName: "comment",
					},
				},
			},
			methodSet{
				Name:             "HTML",
				Description:      "HTML returns formatted HTML for the doc comment text. To customize details of the HTML, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its HTML method. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Markdown",
				Description:      "Markdown returns formatted Markdown for the doc comment text. To customize details of the Markdown, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its Markdown method. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Text",
				Description:      "Text returns formatted text for the doc comment text, wrapped to 80 Unicode code points and using tabs for code block indentation. To customize details of the formatting, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its Text method. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Synopsis",
				Description:      "Synopsis returns a cleaned version of the first sentence in text. Deprecated: New programs should use [Package.Synopsis] instead, which handles links in text properly. ",
				ReceiverTypeName: "Package",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"pkgbits": []methodSet{
			methodSet{
				Name:             "Marker",
				Description:      "",
				ReceiverTypeName: "CodeObj",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SyncMarker",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "CodeObj",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Marker",
				Description:      "",
				ReceiverTypeName: "CodeType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SyncMarker",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "CodeType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Marker",
				Description:      "",
				ReceiverTypeName: "CodeVal",
				Returns: []returnSet{
					returnSet{
						TypeName:    "SyncMarker",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "CodeVal",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkErr",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rawUvarint",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rawVarint",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rawReloc",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "internal/pkgbits.RelElemIdx",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sync",
				Description:      "Sync decodes a sync marker from the element bitstream and asserts that it matches the expected marker. If EnableSync is false, then Sync is a no-op. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Bool",
				Description:      "Bool decodes and returns a bool value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 decodes and returns an int64 value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 decodes and returns a uint64 value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len decodes and returns a non-negative int value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int decodes and returns an int value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Uint",
				Description:      "Uint decodes and returns a uint value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reloc",
				Description:      "Reloc decodes a relocation of expected section k from the element bitstream and returns an index to the referenced element. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "internal/pkgbits.RelElemIdx",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String decodes and returns a string value from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Strings",
				Description:      "Strings decodes and returns a variable-length slice of strings from the element bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			methodSet{
				Name:             "scalar",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "constant",
					},
				},
			},
			methodSet{
				Name:             "bigInt",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Int",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "bigFloat",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Float",
						TypePkgName: "big",
					},
				},
			},
			methodSet{
				Name:             "Version",
				Description:      "Version reports the version of the bitstream. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush finalizes the element's bitstream and returns its [RelElemIdx]. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "internal/pkgbits.RelElemIdx",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "checkErr",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rawUvarint",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rawVarint",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "rawReloc",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sync",
				Description:      "Sync decodes a sync marker from the element bitstream and asserts that it matches the expected marker. If EnableSync is false, then Sync is a no-op. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Bool",
				Description:      "Bool decodes and returns a bool value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 decodes and returns an int64 value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 decodes and returns a uint64 value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len decodes and returns a non-negative int value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Int",
				Description:      "Int decodes and returns an int value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Uint",
				Description:      "Uint decodes and returns a uint value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reloc",
				Description:      "Reloc decodes a relocation of expected section k from the element bitstream and returns an index to the referenced element. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String decodes and returns a string value from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StringRef",
				Description:      "StringRef writes a reference to the given index, which must be a previously encoded string value. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Strings",
				Description:      "Strings decodes and returns a variable-length slice of strings from the element bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "scalar",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "bigInt",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "bigFloat",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Version",
				Description:      "Version reports the version of the bitstream. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Version",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "PkgPath",
				Description:      "PkgPath returns the package path for the package TODO(mdempsky): Remove; unneeded since CL 391014. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SyncMarkers",
				Description:      "SyncMarkers reports whether pr uses sync markers. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumElems",
				Description:      "NumElems returns the number of elements in section k. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "TotalElems",
				Description:      "TotalElems returns the total number of elements across all sections. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fingerprint",
				Description:      "Fingerprint returns the package fingerprint. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[8]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AbsIdx",
				Description:      "AbsIdx returns the absolute index for the given (section, index) pair. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DataIdx",
				Description:      "DataIdx returns the raw element bitstream for the given (section, index) pair. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StringIdx",
				Description:      "StringIdx returns the string value for the given string index. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NewDecoder",
				Description:      "NewDecoder returns a Decoder for the given (section, index) pair, and decodes the given SyncMarker from the element bitstream. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "TempDecoder",
				Description:      "TempDecoder returns a Decoder for the given (section, index) pair, and decodes the given SyncMarker from the element bitstream. If possible the Decoder should be RetireDecoder'd when it is no longer needed, this will avoid heap allocations. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "RetireDecoder",
				Description:      "",
				ReceiverTypeName: "PkgDecoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "NewDecoderRaw",
				Description:      "NewDecoderRaw returns a Decoder for the given (section, index) pair. Most callers should use NewDecoder instead. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "TempDecoderRaw",
				Description:      "",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "PeekPkgPath",
				Description:      "PeekPkgPath returns the package path for the specified package index. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PeekObj",
				Description:      "PeekObj returns the package path, object name, and CodeObj for the specified object index. ",
				ReceiverTypeName: "PkgDecoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "CodeObj",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "SyncMarkers",
				Description:      "SyncMarkers reports whether pr uses sync markers. ",
				ReceiverTypeName: "PkgEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DumpTo",
				Description:      "DumpTo writes the package's encoded data to out0 and returns the package fingerprint. ",
				ReceiverTypeName: "PkgEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[8]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StringIdx",
				Description:      "StringIdx returns the string value for the given string index. ",
				ReceiverTypeName: "PkgEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "internal/pkgbits.RelElemIdx",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NewEncoder",
				Description:      "NewEncoder returns an Encoder for a new element within the given section, and encodes the given SyncMarker as the start of the element bitstream. ",
				ReceiverTypeName: "PkgEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "NewEncoderRaw",
				Description:      "NewEncoderRaw returns an Encoder for a new element within the given section. Most callers should use NewEncoder instead. ",
				ReceiverTypeName: "PkgEncoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoder",
						TypePkgName: "pkgbits",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String decodes and returns a string value from the element bitstream. ",
				ReceiverTypeName: "SyncMarker",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"base64": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "CorruptInputError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WithPadding",
				Description:      "WithPadding creates a new encoding identical to enc except with a specified padding character, or [NoPadding] to disable padding. The padding character must not be '\\r' or '\\n', must not be contained in the encoding's alphabet, must not be negative, and must be a rune equal or below '\\xff'. Padding characters above '\\x7f' are encoded as their exact byte value rather than using the UTF-8 representation of the codepoint. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoding",
						TypePkgName: "base64",
					},
				},
			},
			methodSet{
				Name:             "Strict",
				Description:      "Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5. Note that the input is still malleable, as new line characters (CR and LF) are still ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Encoding",
						TypePkgName: "base64",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode encodes src using the encoding enc, writing [Encoding.EncodedLen](len(src)) bytes to dst. The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use [NewEncoder] instead. ",
				ReceiverTypeName: "Encoding",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AppendEncode",
				Description:      "AppendEncode appends the base64 encoded src to dst and returns the extended buffer. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodeToString",
				Description:      "EncodeToString returns the base64 encoding of src. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EncodedLen",
				Description:      "EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decodeQuantum",
				Description:      "decodeQuantum decodes up to 4 base64 bytes. The received parameters are the destination buffer dst, the source buffer src and an index in the source buffer si. It returns the number of bytes read from src, the number of bytes written to dst, and an error, if any. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendDecode",
				Description:      "AppendDecode appends the base64 decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error. New line characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodeString",
				Description:      "DecodeString returns the bytes represented by the base64 string s. If the input is malformed, it returns the partially decoded data and [CorruptInputError]. New line characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Decode",
				Description:      "Decode decodes src using the encoding enc. It writes at most [Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes written. The caller must ensure that dst is large enough to hold all the decoded data. If src contains invalid base64 data, it will return the number of bytes successfully written and [CorruptInputError]. New line characters (\\r and \\n) are ignored. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodedLen",
				Description:      "DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data. ",
				ReceiverTypeName: "Encoding",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"unique": []methodSet{
			methodSet{
				Name:             "Value",
				Description:      "Value returns a shallow copy of the T value that produced the Handle. Value is safe for concurrent use by multiple goroutines. ",
				ReceiverTypeName: "Handle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "T",
						TypePkgName: "",
					},
				},
			},
		},
		"csv": []methodSet{
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error [ErrFieldCount]. If the record contains a field that cannot be parsed, Read returns a partial record along with the parse error. The partial record contains all fields read before the error. If there is no data left to be read, Read returns nil, [io.EOF]. If [Reader.ReuseRecord] is true, the returned slice may be shared between multiple calls to Read. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FieldPos",
				Description:      "FieldPos returns the line and column corresponding to the start of the field with the given index in the slice most recently returned by [Reader.Read]. Numbering of lines and columns starts at 1; columns are counted in bytes, not runes. If this is called with an out-of-bounds index, it panics. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InputOffset",
				Description:      "InputOffset returns the input stream byte offset of the current reader position. The offset gives the location of the end of the most recently read row and the beginning of the next row. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadAll",
				Description:      "ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == [io.EOF]. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLine",
				Description:      "readLine reads the next line (with the trailing endline). If EOF is hit without a trailing endline, it will be omitted. If some bytes were read, then the error is never [io.EOF]. The result is only valid until the next call to readLine. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readRecord",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so [Writer.Flush] must eventually be called to ensure that the record is written to the underlying [io.Writer]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush writes any buffered data to the underlying [io.Writer]. To check if an error occurred during Flush, call [Writer.Error]. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteAll",
				Description:      "WriteAll writes multiple CSV records to w using [Writer.Write] and then calls [Writer.Flush], returning any error from the Flush. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fieldNeedsQuotes",
				Description:      "fieldNeedsQuotes reports whether our field must be enclosed in quotes. Fields with a Comma, fields with a quote or newline, and fields which start with a space must be enclosed in quotes. We used to quote empty strings, but we do not anymore (as of Go 1.4). The two representations should be equivalent, but Postgres distinguishes quoted vs non-quoted empty string during database imports, and it has an option to force the quoted behavior for non-quoted CSV but it has no option to force the non-quoted behavior for quoted CSV, making CSV with quoted empty strings strictly less useful. Not quoting the empty string also makes this package match the behavior of Microsoft Excel and Google Drive. For Postgres, quote the data terminating string `\\.`. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"maphash": []methodSet{
			methodSet{
				Name:             "initSeed",
				Description:      "initSeed seeds the hash if necessary. initSeed is called lazily before any operation that actually uses h.seed/h.state. Note that this does not include Write/WriteByte/WriteString in the case where they only add to h.buf. (If they write too much, they call h.flush, which does call h.initSeed.) ",
				ReceiverTypeName: "Hash",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "WriteByte",
				Description:      "WriteByte adds b to the sequence of bytes hashed by h. It never fails; the error result is for implementing [io.ByteWriter]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write adds b to the sequence of bytes hashed by h. It always writes all of b and never fails; the count and error result are for implementing [io.Writer]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString adds the bytes of s to the sequence of bytes hashed by h. It always writes all of s and never fails; the count and error result are for implementing [io.StringWriter]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetSeed",
				Description:      "SetSeed sets h to use seed, which must have been returned by [MakeSeed] or by another [Hash.Seed] method. Two [Hash] objects with the same seed behave identically. Two [Hash] objects with different seeds will very likely behave differently. Any bytes added to h before this call will be discarded. ",
				ReceiverTypeName: "Hash",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards all bytes added to h. (The seed remains the same.) ",
				ReceiverTypeName: "Hash",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "flush",
				Description:      "precondition: buffer is full. ",
				ReceiverTypeName: "Hash",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sum64",
				Description:      "Sum64 returns h's current 64-bit value, which depends on h's seed and the sequence of bytes added to h since the last call to [Hash.Reset] or [Hash.SetSeed]. All bits of the Sum64 result are close to uniformly and independently distributed, so it can be safely reduced by using bit masking, shifting, or modular arithmetic. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum appends the hash's current 64-bit value to b. It exists for implementing [hash.Hash]. For direct calls, it is more efficient to use [Hash.Sum64]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns h's hash value size, 8 bytes. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BlockSize",
				Description:      "BlockSize returns h's block size. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clone",
				Description:      "Clone implements [hash.Cloner]. ",
				ReceiverTypeName: "Hash",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Cloner",
						TypePkgName: "hash",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"traceviewer": []methodSet{
			methodSet{
				Name:             "Gomaxprocs",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Resource",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetResourceType",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetResourceFilter",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Task",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Slice",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TaskSlice",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "slice",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AsyncSlice",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Instant",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Arrow",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "TaskArrow",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "arrow",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Event",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HeapAlloc",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Focus",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "GoroutineTransition",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "IncThreadStateCount",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "HeapGoal",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "emitHeapCounters",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err returns an error if the emitter is in an invalid state. ",
				ReceiverTypeName: "Emitter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tsWithinRange",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OptionalEvent",
				Description:      "OptionalEvent emits ev if it's within the time range of the consumer, i.e. the selected trace split range. ",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flush",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "threadMeta",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "processMeta",
				Description:      "",
				ReceiverTypeName: "Emitter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Stack",
				Description:      "Stack emits the given frames and returns a unique id for the stack. No pointers to the given data are being retained beyond the call to Stack. ",
				ReceiverTypeName: "Emitter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "buildBranch",
				Description:      "buildBranch builds one branch in the prefix tree rooted at ctx.frameTree. ",
				ReceiverTypeName: "Emitter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "URL",
				Description:      "",
				ReceiverTypeName: "Range",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds a single sample to the histogram. ",
				ReceiverTypeName: "TimeHistogram",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "BucketMin",
				Description:      "BucketMin returns the minimum duration value for a provided bucket. ",
				ReceiverTypeName: "TimeHistogram",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "ToHTML",
				Description:      "ToHTML renders the histogram as HTML. ",
				ReceiverTypeName: "TimeHistogram",
				Returns: []returnSet{
					returnSet{
						TypeName:    "HTML",
						TypePkgName: "template",
					},
				},
			},
			methodSet{
				Name:             "URL",
				Description:      "",
				ReceiverTypeName: "View",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"buffer": []methodSet{
			methodSet{
				Name:             "Free",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteByte",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetLen",
				Description:      "",
				ReceiverTypeName: "Buffer",
				Returns:          []returnSet{},
			},
		},
		"metrics": []methodSet{
			methodSet{
				Name:             "Kind",
				Description:      "Kind returns the tag representing the kind of value this is. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ValueKind",
						TypePkgName: "metrics",
					},
				},
			},
			methodSet{
				Name:             "Uint64",
				Description:      "Uint64 returns the internal uint64 value for the metric. If v.Kind() != KindUint64, this method panics. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns the internal float64 value for the metric. If v.Kind() != KindFloat64, this method panics. ",
				ReceiverTypeName: "Value",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
		},
		"sort": []methodSet{
			methodSet{
				Name:             "Search",
				Description:      "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n). A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered. For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] >= 23 }) returns the smallest index i such that data[i] >= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately. Searching data sorted in descending order would use the <= operator instead of the >= operator. To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order: x := 23 i := sort.Search(len(data), func(i int) bool { return data[i] >= x }) if i < len(data) && data[i] == x { // x is present at data[i] } else { // x is not present in data, // but i is the index where it would be inserted. } As a more whimsical example, this program guesses your number: func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number <= %d? \", i) fmt.Scanf(\"%s\", &s) return s != \"\" && s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ",
				ReceiverTypeName: "Float64Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "Float64Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Less",
				Description:      "Less returns the opposite of the embedded implementation's Less method. ",
				ReceiverTypeName: "Float64Slice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "",
				ReceiverTypeName: "Float64Slice",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sort",
				Description:      "Sort sorts data in ascending order as determined by the Less method. It makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable. Note: in many situations, the newer [slices.SortFunc] function is more ergonomic and runs faster. ",
				ReceiverTypeName: "Float64Slice",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Search",
				Description:      "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n). A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered. For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] >= 23 }) returns the smallest index i such that data[i] >= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately. Searching data sorted in descending order would use the <= operator instead of the >= operator. To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order: x := 23 i := sort.Search(len(data), func(i int) bool { return data[i] >= x }) if i < len(data) && data[i] == x { // x is present at data[i] } else { // x is not present in data, // but i is the index where it would be inserted. } As a more whimsical example, this program guesses your number: func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number <= %d? \", i) fmt.Scanf(\"%s\", &s) return s != \"\" && s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ",
				ReceiverTypeName: "IntSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "IntSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Less",
				Description:      "Less returns the opposite of the embedded implementation's Less method. ",
				ReceiverTypeName: "IntSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "",
				ReceiverTypeName: "IntSlice",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sort",
				Description:      "Sort sorts data in ascending order as determined by the Less method. It makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable. Note: in many situations, the newer [slices.SortFunc] function is more ergonomic and runs faster. ",
				ReceiverTypeName: "IntSlice",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Search",
				Description:      "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n). A common use of Search is to find the index i for a value x in a sorted, indexable data structure such as an array or slice. In this case, the argument f, typically a closure, captures the value to be searched for, and how the data structure is indexed and ordered. For instance, given a slice data sorted in ascending order, the call Search(len(data), func(i int) bool { return data[i] >= 23 }) returns the smallest index i such that data[i] >= 23. If the caller wants to find whether 23 is in the slice, it must test data[i] == 23 separately. Searching data sorted in descending order would use the <= operator instead of the >= operator. To complete the example above, the following code tries to find the value x in an integer slice data sorted in ascending order: x := 23 i := sort.Search(len(data), func(i int) bool { return data[i] >= x }) if i < len(data) && data[i] == x { // x is present at data[i] } else { // x is not present in data, // but i is the index where it would be inserted. } As a more whimsical example, this program guesses your number: func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number <= %d? \", i) fmt.Scanf(\"%s\", &s) return s != \"\" && s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ",
				ReceiverTypeName: "StringSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "",
				ReceiverTypeName: "StringSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Less",
				Description:      "Less returns the opposite of the embedded implementation's Less method. ",
				ReceiverTypeName: "StringSlice",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "",
				ReceiverTypeName: "StringSlice",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sort",
				Description:      "Sort sorts data in ascending order as determined by the Less method. It makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable. Note: in many situations, the newer [slices.SortFunc] function is more ergonomic and runs faster. ",
				ReceiverTypeName: "StringSlice",
				Returns:          []returnSet{},
			},
		},
		"platform": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "OSArch",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"testtrace": []methodSet{
			methodSet{
				Name:             "Check",
				Description:      "Check validates whether err conforms to the expectation. Returns an error if it does not conform. Conformance means that if failure is true, then err must be non-nil. If err is non-nil, then it must match errorMatcher. ",
				ReceiverTypeName: "Expectation",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SkipClockSnapshotChecks",
				Description:      "SkipClockSnapshotChecks causes the validator to skip checks on the clock snapshots. Some platforms like Windows, with a small enough trace period, are unable to produce monotonically increasing timestamps due to very coarse clock granularity. ",
				ReceiverTypeName: "Validator",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Event",
				Description:      "Event validates ev as the next event in a stream of trace.Events. Returns an error if validation fails. ",
				ReceiverTypeName: "Validator",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasRange",
				Description:      "",
				ReceiverTypeName: "Validator",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "addRange",
				Description:      "",
				ReceiverTypeName: "Validator",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "hasAnyRange",
				Description:      "",
				ReceiverTypeName: "Validator",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "deleteRange",
				Description:      "",
				ReceiverTypeName: "Validator",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "getOrCreateThread",
				Description:      "",
				ReceiverTypeName: "Validator",
				Returns: []returnSet{
					returnSet{
						TypeName:    "schedContext",
						TypePkgName: "testtrace",
					},
				},
			},
		},
		"time": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "String returns the time formatted using the format string \"2006-01-02 15:04:05.999999999 -0700 MST\" If the time has a monotonic clock reading, the returned string includes a final field \"m=Â±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "format",
				Description:      "format formats the representation of d into the end of buf and returns the offset of the first character. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Nanoseconds",
				Description:      "Nanoseconds returns the duration as an integer nanosecond count. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Microseconds",
				Description:      "Microseconds returns the duration as an integer microsecond count. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Milliseconds",
				Description:      "Milliseconds returns the duration as an integer millisecond count. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seconds",
				Description:      "Seconds returns the duration as a floating point number of seconds. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Minutes",
				Description:      "Minutes returns the duration as a floating point number of minutes. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Hours",
				Description:      "Hours returns the duration as a floating point number of hours. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Truncate",
				Description:      "Truncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Round",
				Description:      "Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a [Duration], Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Abs",
				Description:      "Abs returns the absolute value of d. As a special case, Duration([math.MinInt64]) is converted to Duration([math.MaxInt64]), reducing its magnitude by 1 nanosecond. ",
				ReceiverTypeName: "Duration",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the time formatted using the format string \"2006-01-02 15:04:05.999999999 -0700 MST\" If the time has a monotonic clock reading, the returned string includes a final field \"m=Â±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. ",
				ReceiverTypeName: "Month",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "Error returns the string representation of a ParseError. ",
				ReceiverTypeName: "ParseError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stop",
				Description:      "Stop prevents the [Timer] from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. For a func-based timer created with [AfterFunc](d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra <-t.C if Stop returned false to drain a potential stale value. See the [NewTimer] documentation for more details. ",
				ReceiverTypeName: "Ticker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. For a func-based timer created with [AfterFunc](d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call [Timer.Stop] and explicitly drain the timer first. See the [NewTimer] documentation for more details. ",
				ReceiverTypeName: "Ticker",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the time formatted using the format string \"2006-01-02 15:04:05.999999999 -0700 MST\" If the time has a monotonic clock reading, the returned string includes a final field \"m=Â±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "GoString implements [fmt.GoStringer] and formats t to be printed in Go source code. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Format",
				Description:      "Format returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called [Layout] to see how to represent the layout format. The executable example for [Time.Format] demonstrates the working of the layout string in detail and is a good reference. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendFormat",
				Description:      "AppendFormat is like [Time.Format] but appends the textual representation to b and returns the extended buffer. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendFormat",
				Description:      "",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendFormatRFC3339",
				Description:      "",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendStrictRFC3339",
				Description:      "",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nsec",
				Description:      "nsec returns the time's nanoseconds. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sec",
				Description:      "sec returns the time's seconds since Jan 1 year 1. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "unixSec",
				Description:      "unixSec returns the time's seconds since Jan 1 1970 (Unix time). ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "addSec",
				Description:      "addSec adds d seconds to the time. ",
				ReceiverTypeName: "Time",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setLoc",
				Description:      "setLoc sets the location associated with the time. ",
				ReceiverTypeName: "Time",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "stripMono",
				Description:      "stripMono strips the monotonic clock reading in t. ",
				ReceiverTypeName: "Time",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setMono",
				Description:      "setMono sets the monotonic clock reading in t. If t cannot hold a monotonic clock reading, because its wall time is too large, setMono is a no-op. ",
				ReceiverTypeName: "Time",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "mono",
				Description:      "mono returns t's monotonic clock reading. It returns 0 for a missing reading. This function is used only for testing, so it's OK that technically 0 is a valid monotonic clock reading as well. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsZero",
				Description:      "IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "After",
				Description:      "After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to [NewTimer](d).C. Before Go 1.23, this documentation warned that the underlying [Timer] would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call [Timer.Stop] if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Before",
				Description:      "Before reports whether the time instant t is before u. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Compare",
				Description:      "Compare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Equal",
				Description:      "Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "absSec",
				Description:      "absSec returns the time t as an absolute seconds, adjusted by the zone offset. It is called when computing a presentation property like Month or Hour. We'd rather call it abs, but there are linknames to abs that make that problematic. See timeAbs below. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "absSeconds",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "locabs",
				Description:      "locabs is a combination of the Zone and abs methods, extracting both return values from a single zone lookup. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "absSeconds",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Date",
				Description:      "Date returns the year, month, and day in which t occurs. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "Month",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Year",
				Description:      "Year returns the year in which t occurs. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Day",
				Description:      "Day returns the day of the month specified by t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ISOWeek",
				Description:      "ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Clock",
				Description:      "Clock returns the hour, minute, and second within the day specified by t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Hour",
				Description:      "Hour returns the hour within the day specified by t, in the range [0, 23]. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Minute",
				Description:      "Minute returns the minute offset within the hour specified by t, in the range [0, 59]. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Second",
				Description:      "Second returns the second offset within the minute specified by t, in the range [0, 59]. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Nanosecond",
				Description:      "Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "YearDay",
				Description:      "YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add returns the time t+d. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Sub",
				Description:      "Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a [Duration], the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d). ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "AddDate",
				Description:      "AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010. Note that dates are fundamentally coupled to timezones, and calendrical periods like days don't have fixed durations. AddDate uses the Location of the Time value to determine these durations. That means that the same AddDate arguments can produce a different shift in absolute time depending on the base Time value and its Location. For example, AddDate(0, 0, 1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some locations and in some years this is a 24 hour shift. In others it's a 23 hour shift due to daylight savings time transitions. AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "UTC",
				Description:      "UTC returns t with the location set to UTC. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Local",
				Description:      "Local returns t with the location set to local time. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "In",
				Description:      "In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes. In panics if loc is nil. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Location",
				Description:      "Location returns the time zone information associated with t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Location",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Zone",
				Description:      "Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ZoneBounds",
				Description:      "ZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Unix",
				Description:      "Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnixMilli",
				Description:      "UnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnixMicro",
				Description:      "UnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnixNano",
				Description:      "UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendBinary",
				Description:      "AppendBinary implements the [encoding.BinaryAppender] interface. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalBinary",
				Description:      "MarshalBinary implements the [encoding.BinaryMarshaler] interface. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalBinary",
				Description:      "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GobEncode",
				Description:      "GobEncode implements the gob.GobEncoder interface. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GobDecode",
				Description:      "GobDecode implements the gob.GobDecoder interface. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalJSON",
				Description:      "MarshalJSON implements the [encoding/json.Marshaler] interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalJSON",
				Description:      "UnmarshalJSON implements the [encoding/json.Unmarshaler] interface. The time must be a quoted string in the RFC 3339 format. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "appendTo",
				Description:      "",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AppendText",
				Description:      "AppendText implements the [encoding.TextAppender] interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is returned. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalText",
				Description:      "MarshalText implements the [encoding.TextMarshaler] interface. The output matches that of calling the [Time.AppendText] method. See [Time.AppendText] for more information. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalText",
				Description:      "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The time must be in the RFC 3339 format. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsDST",
				Description:      "IsDST reports whether the time in the configured location is in Daylight Savings Time. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Truncate",
				Description:      "Truncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Round",
				Description:      "Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a [Duration], Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged. ",
				ReceiverTypeName: "Time",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "Stop",
				Description:      "Stop prevents the [Timer] from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. For a func-based timer created with [AfterFunc](d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra <-t.C if Stop returned false to drain a potential stale value. See the [NewTimer] documentation for more details. ",
				ReceiverTypeName: "Timer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. For a func-based timer created with [AfterFunc](d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call [Timer.Stop] and explicitly drain the timer first. See the [NewTimer] documentation for more details. ",
				ReceiverTypeName: "Timer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the time formatted using the format string \"2006-01-02 15:04:05.999999999 -0700 MST\" If the time has a monotonic clock reading, the returned string includes a final field \"m=Â±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. ",
				ReceiverTypeName: "Weekday",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"json": []methodSet{
			methodSet{
				Name:             "UseNumber",
				Description:      "UseNumber causes the Decoder to unmarshal a number into an interface value as a [Number] instead of as a float64. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DisallowUnknownFields",
				Description:      "DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Decode",
				Description:      "Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. See the documentation for [Unmarshal] for details about the conversion of JSON into a Go value. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Buffered",
				Description:      "Buffered returns a reader of the data remaining in the Decoder's buffer. The reader is valid until the next call to [Decoder.Decode]. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "readValue",
				Description:      "readValue reads a JSON value into dec.buf. It returns the length of the encoding. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "refill",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tokenPrepareForDecode",
				Description:      "advance tokenstate from a separator state to a value state ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tokenValueAllowed",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "tokenValueEnd",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "tokenError",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "json",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "More",
				Description:      "More reports whether there is another element in the current array or object being parsed. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "peek",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InputOffset",
				Description:      "InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the literal text of the number. ",
				ReceiverTypeName: "Delim",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode writes the JSON encoding of v to the stream, with insignificant space characters elided, followed by a newline character. See the documentation for [Marshal] for details about the conversion of Go values to JSON. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetIndent",
				Description:      "SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(\"\", \"\") disables indentation. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetEscapeHTML",
				Description:      "SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &, <, and > to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML. In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InvalidUTF8Error",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "InvalidUnmarshalError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "MarshalerError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Unwrap",
				Description:      "Unwrap returns the underlying error. ",
				ReceiverTypeName: "MarshalerError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the literal text of the number. ",
				ReceiverTypeName: "Number",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Float64",
				Description:      "Float64 returns the number as a float64. ",
				ReceiverTypeName: "Number",
				Returns: []returnSet{
					returnSet{
						TypeName:    "float64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Int64",
				Description:      "Int64 returns the number as an int64. ",
				ReceiverTypeName: "Number",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "MarshalJSON",
				Description:      "MarshalJSON returns m as the JSON encoding of m. ",
				ReceiverTypeName: "RawMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnmarshalJSON",
				Description:      "UnmarshalJSON sets *m to a copy of data. ",
				ReceiverTypeName: "RawMessage",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "SyntaxError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnmarshalFieldError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnmarshalTypeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnsupportedTypeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "UnsupportedValueError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"sql": []methodSet{
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name or alias of the column. ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Length",
				Description:      "Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be [math.MaxInt64] (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false. ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecimalSize",
				Description:      "DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false. ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ScanType",
				Description:      "ScanType returns a Go type suitable for scanning into using [Rows.Scan]. If a driver does not support this property ScanType will return the type of an empty interface. ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "reflect",
					},
				},
			},
			methodSet{
				Name:             "Nullable",
				Description:      "Nullable reports whether the column may be null. If a driver does not support this property ok will be false. ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DatabaseTypeName",
				Description:      "DatabaseTypeName returns the database system name of the column type. If an empty string is returned, then the driver type name is not supported. Consult your driver documentation for a list of driver data types. [ColumnType.Length] specifiers are not included. Common type names include \"VARCHAR\", \"TEXT\", \"NVARCHAR\", \"DECIMAL\", \"BOOL\", \"INT\", and \"BIGINT\". ",
				ReceiverTypeName: "ColumnType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "addDep",
				Description:      "addDep notes that x now depends on dep, and x's finalClose won't be called until all of x's dependencies are removed with removeDep. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "addDepLocked",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "removeDep",
				Description:      "removeDep notes that x no longer depends on dep. If x still has dependencies, nil is returned. If x no longer has any dependencies, its finalClose method will be called and its error value will be returned. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "removeDepLocked",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "func() error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "pingDC",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PingContext",
				Description:      "PingContext verifies a connection to the database is still alive, establishing a connection if necessary. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Ping",
				Description:      "Ping verifies a connection to the database is still alive, establishing a connection if necessary. Ping uses [context.Background] internally; to specify the context, use [DB.PingContext]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "maxIdleConnsLocked",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "shortestIdleTimeLocked",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "SetMaxIdleConns",
				Description:      "SetMaxIdleConns sets the maximum number of connections in the idle connection pool. If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit. If n <= 0, no idle connections are retained. The default max idle connections is currently 2. This may change in a future release. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetMaxOpenConns",
				Description:      "SetMaxOpenConns sets the maximum number of open connections to the database. If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit. If n <= 0, then there is no limit on the number of open connections. The default is 0 (unlimited). ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetConnMaxLifetime",
				Description:      "SetConnMaxLifetime sets the maximum amount of time a connection may be reused. Expired connections may be closed lazily before reuse. If d <= 0, connections are not closed due to a connection's age. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "SetConnMaxIdleTime",
				Description:      "SetConnMaxIdleTime sets the maximum amount of time a connection may be idle. Expired connections may be closed lazily before reuse. If d <= 0, connections are not closed due to a connection's idle time. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "startCleanerLocked",
				Description:      "startCleanerLocked starts connectionCleaner if needed. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "connectionCleaner",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "connectionCleanerRunLocked",
				Description:      "connectionCleanerRunLocked removes connections that should be closed from freeConn and returns them along side an updated duration to the next check if a quicker check is required to ensure connections are checked appropriately. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Duration",
						TypePkgName: "time",
					},
					returnSet{
						TypeName:    "[]*database/sql.driverConn",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stats",
				Description:      "Stats returns database statistics. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "DBStats",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "maybeOpenNewConnections",
				Description:      "Assumes db.mu is locked. If there are connRequests and the connection limit hasn't been reached, then tell the connectionOpener to open new connections. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "connectionOpener",
				Description:      "Runs in a separate goroutine, opens new connections when requested. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "openNewConnection",
				Description:      "Open one new connection ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "conn",
				Description:      "conn returns a newly-opened or cached *driverConn. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "driverConn",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "noteUnusedDriverStatement",
				Description:      "noteUnusedDriverStatement notes that ds is no longer used and should be closed whenever possible (when c is next not in use), unless c is already closed. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "putConn",
				Description:      "putConn adds a connection to the db's free pool. err is optionally the last error that occurred on this connection. ",
				ReceiverTypeName: "DB",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "putConnDBLocked",
				Description:      "Satisfy a connRequest or put the driverConn in the idle pool and return true or return false. putConnDBLocked will satisfy a connRequest if there is one, or it will return the *driverConn to the freeConn list if err == nil and the idle connection limit will not be exceeded. If err != nil, the value of dc is ignored. If err == nil, then dc must not equal nil. If a connRequest was fulfilled or the *driverConn was placed in the freeConn list, then true is returned, otherwise false is returned. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "retry",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PrepareContext",
				Description:      "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed. The provided context is used for the preparation of the statement, not for the execution of the statement. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Prepare",
				Description:      "Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed. Prepare uses [context.Background] internally; to specify the context, use [DB.PrepareContext]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "prepare",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "prepareDC",
				Description:      "prepareDC prepares a query on the driverConn and calls release before returning. When cg == nil it implies that a connection pool is used, and when cg != nil only a single driver connection is used. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ExecContext",
				Description:      "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Exec",
				Description:      "Exec executes a query without returning any rows. The args are for any placeholder parameters in the query. Exec uses [context.Background] internally; to specify the context, use [DB.ExecContext]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "exec",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "execDC",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "QueryContext",
				Description:      "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Query",
				Description:      "Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. Query uses [context.Background] internally; to specify the context, use [DB.QueryContext]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "query",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "queryDC",
				Description:      "queryDC executes a query on the given connection. The connection gets released by the releaseConn function. The ctx context is from a query method and the txctx context is from an optional transaction context. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "QueryRowContext",
				Description:      "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Row",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "QueryRow",
				Description:      "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest. QueryRow uses [context.Background] internally; to specify the context, use [DB.QueryRowContext]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Row",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "BeginTx",
				Description:      "BeginTx starts a transaction. The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. [Tx.Commit] will return an error if the context provided to BeginTx is canceled. The provided [TxOptions] is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tx",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Begin",
				Description:      "Begin starts a transaction. The default isolation level is dependent on the driver. Begin uses [context.Background] internally; to specify the context, use [DB.BeginTx]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tx",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "begin",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tx",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "beginDC",
				Description:      "beginDC starts a transaction. The provided dc must be valid and ready to use. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Tx",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Driver",
				Description:      "",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Driver",
						TypePkgName: "driver",
					},
				},
			},
			methodSet{
				Name:             "Conn",
				Description:      "Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session. Every Conn must be returned to the database pool after use by calling [Conn.Close]. ",
				ReceiverTypeName: "DB",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Conn",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the name of the transaction isolation level. ",
				ReceiverTypeName: "IsolationLevel",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "Null",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "Null",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullBool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullBool",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullByte",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullByte",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullFloat64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullFloat64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullInt16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullInt16",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullInt32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullInt32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullInt64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullInt64",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullString",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullString",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "NullTime",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value implements the [driver.Valuer] interface. ",
				ReceiverTypeName: "NullTime",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Value",
						TypePkgName: "driver",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "Row",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit [Rows.Close]. ",
				ReceiverTypeName: "Row",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "lasterrOrErrLocked",
				Description:      "lasterrOrErrLocked returns either lasterr or the provided err. rs.closemu must be read-locked. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "initContextClose",
				Description:      "",
				ReceiverTypeName: "Rows",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "awaitDone",
				Description:      "awaitDone blocks until the context in Tx is canceled and rolls back the transaction if it's not already done. ",
				ReceiverTypeName: "Rows",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next prepares the next result row for reading with the [Rows.Scan] method. It returns true on success, or false if there is no next result row or an error happened while preparing it. [Rows.Err] should be consulted to distinguish between the two cases. Every call to [Rows.Scan], even the first one, must be preceded by a call to [Rows.Next]. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nextLocked",
				Description:      "",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NextResultSet",
				Description:      "NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The [Rows.Err] method should be consulted to distinguish between the two cases. After calling NextResultSet, the [Rows.Next] method should always be called before scanning. If there are further result sets they may not have rows in the result set. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit [Rows.Close]. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rawbuf",
				Description:      "rawbuf returns the buffer to append RawBytes values to. This buffer is reused across calls to Rows.Scan. Usage: rawBytes = rows.setrawbuf(append(rows.rawbuf(), value...)) ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setrawbuf",
				Description:      "setrawbuf updates the RawBytes buffer with the result of appending a new value to it. It returns the new value. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "RawBytes",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "Columns",
				Description:      "Columns returns the column names. Columns returns an error if the rows are closed. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ColumnTypes",
				Description:      "ColumnTypes returns column information such as column type, length, and nullable. Some information may not be available from some drivers. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*database/sql.ColumnType",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan implements the [Scanner] interface. ",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanLocked",
				Description:      "",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "closemuRUnlockIfHeldByScan",
				Description:      "closemuRUnlockIfHeldByScan releases any closemu.RLock held open by a previous call to Scan with *RawBytes. ",
				ReceiverTypeName: "Rows",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Close",
				Description:      "",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "close",
				Description:      "",
				ReceiverTypeName: "Rows",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "awaitDone",
				Description:      "awaitDone blocks until the context in Tx is canceled and rolls back the transaction if it's not already done. ",
				ReceiverTypeName: "Tx",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isDone",
				Description:      "",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "close",
				Description:      "",
				ReceiverTypeName: "Tx",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "grabConn",
				Description:      "grabConn takes a context to implement stmtConnGrabber but the context is not used. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "driverConn",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "releaseConn",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "txCtx",
				Description:      "",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Context",
						TypePkgName: "context",
					},
				},
			},
			methodSet{
				Name:             "closemuRUnlockRelease",
				Description:      "closemuRUnlockRelease is used as a func(error) method value in [DB.ExecContext] and [DB.QueryContext]. Unlocking in the releaseConn keeps the driver conn from being returned to the connection pool until the Rows has been closed. ",
				ReceiverTypeName: "Tx",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closePrepared",
				Description:      "Closes all Stmts prepared for this transaction. ",
				ReceiverTypeName: "Tx",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Commit",
				Description:      "Commit commits the transaction. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "rollback",
				Description:      "rollback aborts the transaction and optionally forces the pool to discard the connection. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Rollback",
				Description:      "Rollback aborts the transaction. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "PrepareContext",
				Description:      "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed. The provided context is used for the preparation of the statement, not for the execution of the statement. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Prepare",
				Description:      "Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed. Prepare uses [context.Background] internally; to specify the context, use [DB.PrepareContext]. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "StmtContext",
				Description:      "StmtContext returns a transaction-specific prepared statement from an existing statement. Example: updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\") ... tx, err := db.Begin() ... res, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203) The provided context is used for the preparation of the statement, not for the execution of the statement. The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "Stmt",
				Description:      "Stmt returns a transaction-specific prepared statement from an existing statement. Example: updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\") ... tx, err := db.Begin() ... res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203) The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back. Stmt uses [context.Background] internally; to specify the context, use [Tx.StmtContext]. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Stmt",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "ExecContext",
				Description:      "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Exec",
				Description:      "Exec executes a query without returning any rows. The args are for any placeholder parameters in the query. Exec uses [context.Background] internally; to specify the context, use [DB.ExecContext]. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Result",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "QueryContext",
				Description:      "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Query",
				Description:      "Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query. Query uses [context.Background] internally; to specify the context, use [DB.QueryContext]. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Rows",
						TypePkgName: "sql",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "QueryRowContext",
				Description:      "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Row",
						TypePkgName: "sql",
					},
				},
			},
			methodSet{
				Name:             "QueryRow",
				Description:      "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest. QueryRow uses [context.Background] internally; to specify the context, use [DB.QueryRowContext]. ",
				ReceiverTypeName: "Tx",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Row",
						TypePkgName: "sql",
					},
				},
			},
		},
		"dwarf": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "ArrayType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "ArrayType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Attr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Attr",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Basic",
				Description:      "",
				ReceiverTypeName: "BasicType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "BasicType",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "BasicType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Class",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Class",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Common",
				Description:      "",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CommonType",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseAbbrev",
				Description:      "parseAbbrev returns the abbreviation table that starts at byte off in the .debug_abbrev section. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "abbrevTable",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Ranges",
				Description:      "Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as [TagCompileUnit] or [TagSubprogram], have PC ranges; for others, this will return nil with no error. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][2]uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "baseAddressForEntry",
				Description:      "baseAddressForEntry returns the initial base address to be used when looking up the range list of entry e. DWARF specifies that this should be the lowpc attribute of the enclosing compilation unit, however comments in gdb/dwarf2read.c say that some versions of GCC use the entrypc attribute, so we check that too. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Entry",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dwarf2Ranges",
				Description:      "",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][2]uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "dwarf5Ranges",
				Description:      "dwarf5Ranges interprets a debug_rnglists sequence, see DWARFv5 section 2.17.3 (page 53). ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[][2]uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "debugAddr",
				Description:      "debugAddr returns the address at idx in debug_addr ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddTypes",
				Description:      "AddTypes will add one .debug_types section to the DWARF data. A typical object with DWARF version 4 debug info will have multiple .debug_types sections. The name is used for error reporting only, and serves to distinguish one .debug_types section from another. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddSection",
				Description:      "AddSection adds another DWARF section by name. The name should be a DWARF section name such as \".debug_addr\", \".debug_str_offsets\", and so forth. This approach is used for new DWARF sections added in DWARF 5 and later. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readType",
				Description:      "readType reads a type from r at off of name. It adds types to the type cache, appends new typedef types to typedefs, and computes the sizes of types. Callers should pass nil for typedefs; this is used for internal recursion. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseTypes",
				Description:      "Parse a .debug_types section. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sigToType",
				Description:      "Return the type for a type signature. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Type",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "parseUnits",
				Description:      "",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/dwarf.unit",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "offsetToUnit",
				Description:      "offsetToUnit returns the index of the unit containing offset off. It returns -1 if no unit contains this offset. ",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "collectDwarf5BaseOffsets",
				Description:      "",
				ReceiverTypeName: "Data",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "DecodeError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "DotDotDotType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Val",
				Description:      "Val returns the value associated with attribute [Attr] in [Entry], or nil if there is no such attribute. A common idiom is to merge the check for nil return with the check that the value has the expected dynamic type, as in: v, ok := e.Val(AttrSibling).(int64) ",
				ReceiverTypeName: "Entry",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AttrField",
				Description:      "AttrField returns the [Field] associated with attribute [Attr] in [Entry], or nil if there is no such attribute. ",
				ReceiverTypeName: "Entry",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Field",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "EnumType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "FuncType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHeader",
				Description:      "readHeader reads the line number program header from r.buf and sets all of the header fields in r. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLNCTFormat",
				Description:      "readLNCTFormat reads an LNCT format description. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/dwarf.lnctForm",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLNCT",
				Description:      "readLNCT reads a sequence of LNCT entries and returns path information. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFileEntry",
				Description:      "readFileEntry reads a file entry from either the header or a DW_LNE_define_file extended opcode and adds it to r.fileEntries. A true return value indicates that there are no more entries to read. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "updateFile",
				Description:      "updateFile updates r.state.File after r.fileIndex has changed or r.fileEntries has changed. ",
				ReceiverTypeName: "LineReader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid [Entry]. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "step",
				Description:      "step processes the next opcode and updates r.state. If the opcode emits a row in the line table, this updates *entry and returns true. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "advancePC",
				Description:      "advancePC advances \"operation pointer\" (the combination of Address and OpIndex) in r.state by opAdvance steps. ",
				ReceiverTypeName: "LineReader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Tell",
				Description:      "Tell returns the current position in the line table. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "LineReaderPos",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek positions the [Reader] at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry. ",
				ReceiverTypeName: "LineReader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset repositions the line table reader at the beginning of the line table. ",
				ReceiverTypeName: "LineReader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "resetState",
				Description:      "resetState resets r.state to its default values ",
				ReceiverTypeName: "LineReader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Files",
				Description:      "Files returns the file name table of this compilation unit as of the current position in the line table. The file name table may be referenced from attributes in this compilation unit such as [AttrDeclFile]. Entry 0 is always nil, since file index 0 represents \"no file\". The file name table of a compilation unit is not fixed. Files returns the file table as of the current position in the line table. This may contain more entries than the file table at an earlier position in the line table, though existing entries never change. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*debug/dwarf.LineFile",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SeekPC",
				Description:      "SeekPC returns the [Entry] for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns [ErrUnknownPC] and the position of the reader is undefined. Because compilation units can describe multiple regions of the executable, in the worst case SeekPC must search through all the ranges in all the compilation units. Each call to SeekPC starts the search at the compilation unit of the last call, so in general looking up a series of PCs will be faster if they are sorted. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index using the Ranges method. ",
				ReceiverTypeName: "LineReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "PtrType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "QualType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "QualType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddressSize",
				Description:      "AddressSize returns the size in bytes of addresses in the current compilation unit. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ByteOrder",
				Description:      "ByteOrder returns the byte order in the current compilation unit. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ByteOrder",
						TypePkgName: "binary",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek positions the [Reader] at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "maybeNextUnit",
				Description:      "maybeNextUnit advances to the next unit if this one is finished. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "nextUnit",
				Description:      "nextUnit advances to the next unit. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "collectDwarf5BaseOffsets",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid [Entry]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Entry",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SkipChildren",
				Description:      "SkipChildren skips over the child entries associated with the last [Entry] returned by [Reader.Next]. If that [Entry] did not have children or [Reader.Next] has not been called, SkipChildren is a no-op. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "clone",
				Description:      "clone returns a copy of the reader. This is used by the typeReader interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "typeReader",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "offset",
				Description:      "offset returns the current buffer offset. This is used by the typeReader interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Offset",
						TypePkgName: "dwarf",
					},
				},
			},
			methodSet{
				Name:             "SeekPC",
				Description:      "SeekPC returns the [Entry] for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns [ErrUnknownPC] and the position of the reader is undefined. Because compilation units can describe multiple regions of the executable, in the worst case SeekPC must search through all the ranges in all the compilation units. Each call to SeekPC starts the search at the compilation unit of the last call, so in general looking up a series of PCs will be faster if they are sorted. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index using the Ranges method. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Entry",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "bitOffset",
				Description:      "",
				ReceiverTypeName: "StructField",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "StructType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Defn",
				Description:      "",
				ReceiverTypeName: "StructType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GoString",
				Description:      "",
				ReceiverTypeName: "Tag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Tag",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "TypedefType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "",
				ReceiverTypeName: "TypedefType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "UnsupportedType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "VoidType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"zstd": []methodSet{
			methodSet{
				Name:             "makeBitReader",
				Description:      "makeBitReader makes a bit reader starting at off. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bitReader",
						TypePkgName: "zstd",
					},
				},
			},
			methodSet{
				Name:             "makeReverseBitReader",
				Description:      "makeReverseBitReader makes a reverseBitReader reading backward from off to start. The bitstream starts with a 1 bit in the last byte, at off. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "reverseBitReader",
						TypePkgName: "zstd",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "compressedBlock",
				Description:      "compressedBlock decompresses a compressed block, storing the decompressed data in r.buffer. The blockSize argument is the compressed size. RFC 3.1.1.3. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "initSeqs",
				Description:      "initSeqs reads the Sequences_Section_Header and sets up the FSE tables used to read the sequence codes. It returns the number of sequences and the new offset. RFC 3.1.1.3.2.1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setSeqTable",
				Description:      "setSeqTable uses the Compression_Mode in mode to set up r.seqTables and r.seqTableBits for kind. We store these in the Reader because one of the modes simply reuses the value from the last block in the frame. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "execSeqs",
				Description:      "execSeqs reads and executes the sequences. RFC 3.1.1.3.2.1.2. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "copyFromWindow",
				Description:      "Copy match bytes from the decoded output, or the window, at offset. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFSE",
				Description:      "readFSE reads an FSE table from data starting at off. maxSym is the maximum symbol value. maxBits is the maximum number of bits permitted for symbols in the table. The FSE is written into table, which must be at least 1<<maxBits in size. This returns the number of bits in the FSE table and the new offset. RFC 4.1.1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "buildFSE",
				Description:      "buildFSE builds an FSE decoding table from a list of probabilities. The probabilities are in norm. next is scratch space. The number of bits in the table is tableBits. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeLiteralBaselineFSE",
				Description:      "makeLiteralBaselineFSE converts the literal length fseTable to baselineTable. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeOffsetBaselineFSE",
				Description:      "makeOffsetBaselineFSE converts the offset length fseTable to baselineTable. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeMatchBaselineFSE",
				Description:      "makeMatchBaselineFSE converts the match length fseTable to baselineTable. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHuff",
				Description:      "readHuff reads Huffman table from data starting at off into table. Each entry in a Huffman table is a pair of bytes. The high byte is the encoded value. The low byte is the number of bits used to encode that value. We index into the table with a value of size tableBits. A value that requires fewer bits appear in the table multiple times. This returns the number of bits in the Huffman table and the new offset. RFC 4.2.1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLiterals",
				Description:      "readLiterals reads and decompresses the literals from data at off. The literals are appended to outbuf, which is returned. Also returns the new input offset. RFC 3.1.1.3.1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readRawRLELiterals",
				Description:      "readRawRLELiterals reads and decompresses a Raw_Literals_Block or a RLE_Literals_Block. RFC 3.1.1.3.1.1. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHuffLiterals",
				Description:      "readHuffLiterals reads and decompresses a Compressed_Literals_Block or a Treeless_Literals_Block. RFC 3.1.1.3.1.4. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLiteralsOneStream",
				Description:      "readLiteralsOneStream reads a single stream of compressed literals. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readLiteralsFourStreams",
				Description:      "readLiteralsFourStreams reads four interleaved streams of compressed literals. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset discards the current state and starts reading a new stream from r. This permits reusing a Reader rather than allocating a new one. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read implements [io.Reader]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadByte",
				Description:      "ReadByte implements [io.ByteReader]. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "refillIfNeeded",
				Description:      "refillIfNeeded reads the next block if necessary. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "refill",
				Description:      "refill reads and decompresses the next block. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrameHeader",
				Description:      "readFrameHeader reads the frame header and prepares to read a block. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "skipFrame",
				Description:      "skipFrame skips a skippable frame. RFC 3.1.2. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readBlock",
				Description:      "readBlock reads the next block from a frame. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "setBufferSize",
				Description:      "setBufferSize sets the decompressed buffer size. When this is called the buffer is empty. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "makeEOFError",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wrapNonEOFError",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "makeError",
				Description:      "makeError returns an error at the current offset wrapping a string. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "wrapError",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"version": []methodSet{
			methodSet{
				Name:             "Specs",
				Description:      "Specs returns the set of event.Specs for this version. ",
				ReceiverTypeName: "Version",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/trace/tracev2.EventSpec",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EventName",
				Description:      "EventName returns a string name of a wire format event for a particular trace version. ",
				ReceiverTypeName: "Version",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Valid",
				Description:      "",
				ReceiverTypeName: "Version",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"pprof": []methodSet{
			methodSet{
				Name:             "Name",
				Description:      "Name returns this profile's name, which can be passed to [Lookup] to reobtain the profile. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Count",
				Description:      "Count returns the number of execution stacks currently in the profile. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "Add adds the current execution stack to the profile, associated with value. Add stores value in an internal map, so value must be suitable for use as a map key and will not be garbage collected until the corresponding call to [Profile.Remove]. Add panics if the profile already contains a stack for value. The skip parameter has the same meaning as [runtime.Caller]'s skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack: Add called from rpc.NewClient called from mypkg.Run called from main.main Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run. ",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Remove",
				Description:      "Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile. ",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil. The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in https://github.com/google/pprof/tree/main/proto#overview. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools. The predefined profiles may assign meaning to other debug values; for example, when printing the \"goroutine\" profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"strings": []methodSet{
			methodSet{
				Name:             "copyCheck",
				Description:      "copyCheck implements a dynamic check to prevent modification after copying a non-zero Builder, which would be unsafe (see #25907, #47276). We cannot add a noCopy field to Builder, to cause vet's copylocks check to report copying, because copylocks cannot reliably discriminate the zero and nonzero cases. ",
				ReceiverTypeName: "Builder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns the accumulated string. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the number of accumulated bytes; b.Len() == len(b.String()). ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Cap",
				Description:      "Cap returns the capacity of the builder's underlying byte slice. It is the total space allocated for the string being built and includes any bytes already written. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the [Builder] to be empty. ",
				ReceiverTypeName: "Builder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "grow",
				Description:      "grow copies the buffer to a new, larger buffer so that there are at least n bytes of capacity beyond len(b.buf). ",
				ReceiverTypeName: "Builder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Grow",
				Description:      "Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics. ",
				ReceiverTypeName: "Builder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write appends the contents of p to b's buffer. Write always returns len(p), nil. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteByte",
				Description:      "WriteByte appends the byte c to b's buffer. The returned error is always nil. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteRune",
				Description:      "WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error. ",
				ReceiverTypeName: "Builder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Len",
				Description:      "Len returns the number of accumulated bytes; b.Len() == len(b.String()). ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size returns the original length of the underlying string. Size is the number of bytes available for reading via [Reader.ReadAt]. The returned value is always the same and is not affected by calls to any other method. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read implements the [io.Reader] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadAt",
				Description:      "ReadAt implements the [io.ReaderAt] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadByte",
				Description:      "ReadByte implements the [io.ByteReader] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadByte",
				Description:      "UnreadByte implements the [io.ByteScanner] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ReadRune",
				Description:      "ReadRune implements the [io.RuneReader] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "UnreadRune",
				Description:      "UnreadRune implements the [io.RuneScanner] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Seek",
				Description:      "Seek implements the [io.Seeker] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteTo",
				Description:      "WriteTo implements the [io.WriterTo] interface. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets the [Builder] to be empty. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "buildOnce",
				Description:      "",
				ReceiverTypeName: "Replacer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "build",
				Description:      "",
				ReceiverTypeName: "Replacer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "replacer",
						TypePkgName: "strings",
					},
				},
			},
			methodSet{
				Name:             "Replace",
				Description:      "Replace returns a copy of s with all replacements performed. ",
				ReceiverTypeName: "Replacer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error. ",
				ReceiverTypeName: "Replacer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"zip": []methodSet{
			methodSet{
				Name:             "DataOffset",
				Description:      "DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file. Most callers should instead use [File.Open], which transparently decompresses data and verifies checksums. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a [ReadCloser] that provides access to the [File]'s contents. Multiple files may be read concurrently. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadCloser",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OpenRaw",
				Description:      "OpenRaw returns a [Reader] that provides access to the [File]'s contents without decompression. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Reader",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "findBodyOffset",
				Description:      "findBodyOffset does the minimum work to verify the file has a header and returns the file body offset. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FileInfo",
				Description:      "FileInfo returns an fs.FileInfo for the [FileHeader]. ",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "ModTime",
				Description:      "",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Time",
						TypePkgName: "time",
					},
				},
			},
			methodSet{
				Name:             "SetModTime",
				Description:      "SetModTime sets the [Modified], [ModifiedTime], and [ModifiedDate] fields to the given time in UTC. Deprecated: Use [Modified] instead. ",
				ReceiverTypeName: "FileHeader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Mode",
				Description:      "",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileMode",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "SetMode",
				Description:      "SetMode changes the permission and mode bits for the [FileHeader]. ",
				ReceiverTypeName: "FileHeader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isZip64",
				Description:      "isZip64 reports whether the file size exceeds the 32 bit limit ",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "hasDataDescriptor",
				Description:      "",
				ReceiverTypeName: "FileHeader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the Zip file, rendering it unusable for I/O. ",
				ReceiverTypeName: "ReadCloser",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "init",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegisterDecompressor",
				Description:      "RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, [Reader] will default to looking up the decompressor at the package level. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decompressor",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Decompressor",
						TypePkgName: "zip",
					},
				},
			},
			methodSet{
				Name:             "initFileList",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a [ReadCloser] that provides access to the [File]'s contents. Multiple files may be read concurrently. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "fs",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "openLookup",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "fileListEntry",
						TypePkgName: "zip",
					},
				},
			},
			methodSet{
				Name:             "openReadDir",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]archive/zip.fileListEntry",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetOffset",
				Description:      "SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetComment",
				Description:      "SetComment sets the end-of-central-directory comment field. It can only be called before [Writer.Close]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the Zip file, rendering it unusable for I/O. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Create",
				Description:      "Create adds a file to the zip file using the provided name. It returns a [Writer] to which the file contents should be written. The file contents will be compressed using the [Deflate] method. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. To create a directory instead of a file, add a trailing slash to the name. Duplicate names will not overwrite previous entries and are appended to the zip file. The file's contents must be written to the [io.Writer] before the next call to [Writer.Create], [Writer.CreateHeader], or [Writer.Close]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "prepare",
				Description:      "prepare performs the bookkeeping operations required at the start of CreateHeader and CreateRaw. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreateHeader",
				Description:      "CreateHeader adds a file to the zip archive using the provided [FileHeader] for the file metadata. [Writer] takes ownership of fh and may mutate its fields. The caller must not modify fh after calling [Writer.CreateHeader]. This returns a [Writer] to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to [Writer.Create], [Writer.CreateHeader], [Writer.CreateRaw], or [Writer.Close]. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CreateRaw",
				Description:      "CreateRaw adds a file to the zip archive using the provided [FileHeader] and returns a [Writer] to which the file contents should be written. The file's contents must be written to the io.Writer before the next call to [Writer.Create], [Writer.CreateHeader], [Writer.CreateRaw], or [Writer.Close]. In contrast to [Writer.CreateHeader], the bytes passed to Writer are not compressed. CreateRaw's argument is stored in w. If the argument is a pointer to the embedded [FileHeader] in a [File] obtained from a [Reader] created from in-memory data, then w will refer to all of that memory. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy copies the file f (obtained from a [Reader]) into w. It copies the raw form directly bypassing decompression, compression, and validation. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "RegisterCompressor",
				Description:      "RegisterCompressor registers custom compressors for a specified method ID. The common methods [Store] and [Deflate] are built in. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddFS",
				Description:      "AddFS adds the files from fs.FS to the archive. It walks the directory tree starting at the root of the filesystem adding each file to the zip using deflate while maintaining the directory structure. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "compressor",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Compressor",
						TypePkgName: "zip",
					},
				},
			},
		},
		"plan9obj": []methodSet{
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Symbols",
				Description:      "Symbols returns the symbol table for f. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]debug/plan9obj.Sym",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data reads and returns the contents of the Plan 9 a.out section. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Open",
				Description:      "Open returns a new ReadSeeker reading the Plan 9 a.out section. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ReadSeeker",
						TypePkgName: "io",
					},
				},
			},
		},
		"printer": []methodSet{
			methodSet{
				Name:             "fprint",
				Description:      "fprint implements Fprint and takes a nodesSizes map for setting up the printer state. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Fprint",
				Description:      "Fprint \"pretty-prints\" an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *[ast.File], *[CommentedNode], [][ast.Decl], [][ast.Stmt], or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt]. ",
				ReceiverTypeName: "Config",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"profile": []methodSet{
			methodSet{
				Name:             "WeightValue",
				Description:      "WeightValue returns the weight value for this edge, normalizing if a divisor is available. ",
				ReceiverTypeName: "Edge",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindTo",
				Description:      "",
				ReceiverTypeName: "EdgeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Edge",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "Add",
				Description:      "",
				ReceiverTypeName: "EdgeMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Delete",
				Description:      "",
				ReceiverTypeName: "EdgeMap",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Sort",
				Description:      "Sort returns a slice of the edges in the map, in a consistent order. The sort order is first based on the edge weight (higher-to-lower) and then by the node names to avoid flakiness. ",
				ReceiverTypeName: "EdgeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]*internal/profile.Edge",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum adds the flat and cum values of a set of nodes. ",
				ReceiverTypeName: "EdgeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Function",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Function",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "key",
				Description:      "key generates sampleKey to be used as a key for maps. ",
				ReceiverTypeName: "Function",
				Returns: []returnSet{
					returnSet{
						TypeName:    "functionKey",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a text representation of a graph, for debugging purposes. ",
				ReceiverTypeName: "Graph",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Label",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Label",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Line",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Line",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Location",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Location",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "key",
				Description:      "key generates sampleKey to be used as a key for maps. ",
				ReceiverTypeName: "Location",
				Returns: []returnSet{
					returnSet{
						TypeName:    "locationKey",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Mapping",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Mapping",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "key",
				Description:      "key generates sampleKey to be used as a key for maps. ",
				ReceiverTypeName: "Mapping",
				Returns: []returnSet{
					returnSet{
						TypeName:    "mappingKey",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "FlatValue",
				Description:      "FlatValue returns the exclusive value for this node, computing the mean if a divisor is available. ",
				ReceiverTypeName: "Node",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CumValue",
				Description:      "CumValue returns the inclusive value for this node, computing the mean if a divisor is available. ",
				ReceiverTypeName: "Node",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddToEdge",
				Description:      "AddToEdge increases the weight of an edge between two nodes. If there isn't such an edge one is created. ",
				ReceiverTypeName: "Node",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddToEdgeDiv",
				Description:      "AddToEdgeDiv increases the weight of an edge between two nodes. If there isn't such an edge one is created. ",
				ReceiverTypeName: "Node",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "addSample",
				Description:      "",
				ReceiverTypeName: "Node",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "PrintableName",
				Description:      "PrintableName calls the Node's Formatter function with a single space separator. ",
				ReceiverTypeName: "NodeInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NameComponents",
				Description:      "NameComponents returns the components of the printable name to be used for a node. ",
				ReceiverTypeName: "NodeInfo",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FindOrInsertNode",
				Description:      "FindOrInsertNode takes the info for a node and either returns a matching node from the node map if one exists, or adds one to the map if one does not. If kept is non-nil, nodes are only added if they can be located on it. ",
				ReceiverTypeName: "NodeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "nodes",
				Description:      "",
				ReceiverTypeName: "NodeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Nodes",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "findOrInsertLine",
				Description:      "",
				ReceiverTypeName: "NodeMap",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Node",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "Sum",
				Description:      "Sum adds the flat and cum values of a set of nodes. ",
				ReceiverTypeName: "Nodes",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "preEncode",
				Description:      "preEncode populates the unexported fields to be used by encode (with suffix X) from the corresponding exported fields. The exported fields are cleared up to facilitate testing. ",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "postDecode",
				Description:      "postDecode takes the unexported fields populated by decode (with suffix X) and populates the corresponding exported fields. The unexported fields are cleared up to facilitate testing. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FilterSamplesByTag",
				Description:      "FilterSamplesByTag removes all samples from the profile, except those that match focus and do not match the ignore regular expression. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Normalize",
				Description:      "Normalize normalizes the source profile by multiplying each value in profile by the ratio of the sum of the base profile's values of that sample type to the sum of the source profile's value of that sample type. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "compatible",
				Description:      "compatible determines if two profiles can be compared/merged. returns nil if the profiles are compatible; otherwise an error with details on the incompatibility. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes the profile as a gzip-compressed marshaled protobuf. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "CheckValid",
				Description:      "CheckValid tests whether the profile is valid. Checks include, but are not limited to: - len(Profile.Sample[n].value) == len(Profile.value_unit) - Sample.id has a corresponding Profile.Location ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Aggregate",
				Description:      "Aggregate merges the locations in the profile into equivalence classes preserving the request attributes. It also updates the samples to point to the merged locations. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a text representation of a graph, for debugging purposes. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Merge",
				Description:      "Merge merges all the profiles in profs into a single Profile. Returns a new profile independent of the input profiles. The merged profile is compacted to eliminate unused samples, locations, functions and mappings. Profiles must have identical profile sample and period types or the merge will fail. profile.Period of the resulting profile will be the maximum of all profiles, and profile.TimeNanos will be the earliest nonzero one. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Compatible",
				Description:      "Compatible determines if two profiles can be compared/merged. returns nil if the profiles are compatible; otherwise an error with details on the incompatibility. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HasFunctions",
				Description:      "HasFunctions determines if all locations in this profile have symbolized function information. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "HasFileLines",
				Description:      "HasFileLines determines if all locations in this profile have symbolized file and line number information. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Copy",
				Description:      "Copy makes a fully independent copy of a profile. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Profile",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "Demangle",
				Description:      "Demangle attempts to demangle and optionally simplify any function names referenced in the profile. It works on a best-effort basis: it will silently preserve the original names in case of any errors. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Empty",
				Description:      "Empty reports whether the profile contains no samples. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scale",
				Description:      "Scale multiplies all sample values in a profile by a constant. ",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ScaleN",
				Description:      "ScaleN multiplies each sample values in a sample by a different amount. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Prune",
				Description:      "Prune removes all nodes beneath a node matching dropRx, and not matching keepRx. If the root node of a Sample matches, the sample will have an empty stack. ",
				ReceiverTypeName: "Profile",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RemoveUninteresting",
				Description:      "RemoveUninteresting prunes and elides profiles using built-in tables of uninteresting function names. ",
				ReceiverTypeName: "Profile",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "Sample",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Sample",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "key",
				Description:      "key generates sampleKey to be used as a key for maps. ",
				ReceiverTypeName: "Sample",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sampleKey",
						TypePkgName: "profile",
					},
				},
			},
			methodSet{
				Name:             "decoder",
				Description:      "",
				ReceiverTypeName: "ValueType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/profile.decoder",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "ValueType",
				Returns:          []returnSet{},
			},
		},
		"tls13": []methodSet{
			methodSet{
				Name:             "ResumptionBinderKey",
				Description:      "",
				ReceiverTypeName: "EarlySecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ClientEarlyTrafficSecret",
				Description:      "ClientEarlyTrafficSecret derives the client_early_traffic_secret from the early secret and the transcript up to the ClientHello. ",
				ReceiverTypeName: "EarlySecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EarlyExporterMasterSecret",
				Description:      "EarlyExporterMasterSecret derives the exporter_master_secret from the early secret and the transcript up to the ClientHello. ",
				ReceiverTypeName: "EarlySecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "ExporterMasterSecret",
						TypePkgName: "tls13",
					},
				},
			},
			methodSet{
				Name:             "Exporter",
				Description:      "",
				ReceiverTypeName: "ExporterMasterSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ClientHandshakeTrafficSecret",
				Description:      "ClientHandshakeTrafficSecret derives the client_handshake_traffic_secret from the handshake secret and the transcript up to the ServerHello. ",
				ReceiverTypeName: "HandshakeSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServerHandshakeTrafficSecret",
				Description:      "ServerHandshakeTrafficSecret derives the server_handshake_traffic_secret from the handshake secret and the transcript up to the ServerHello. ",
				ReceiverTypeName: "HandshakeSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ClientApplicationTrafficSecret",
				Description:      "ClientApplicationTrafficSecret derives the client_application_traffic_secret_0 from the master secret and the transcript up to the server Finished. ",
				ReceiverTypeName: "MasterSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ServerApplicationTrafficSecret",
				Description:      "ServerApplicationTrafficSecret derives the server_application_traffic_secret_0 from the master secret and the transcript up to the server Finished. ",
				ReceiverTypeName: "MasterSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ResumptionMasterSecret",
				Description:      "ResumptionMasterSecret derives the resumption_master_secret from the master secret and the transcript up to the client Finished. ",
				ReceiverTypeName: "MasterSecret",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
		},
		"gob": []methodSet{
			methodSet{
				Name:             "id",
				Description:      "",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "typeId",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "setId",
				Description:      "",
				ReceiverTypeName: "CommonType",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "string",
				Description:      "string returns the string representation of the type associated with the typeId. ",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "safeString",
				Description:      "",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "name",
				Description:      "Name returns the name of the type associated with the typeId. ",
				ReceiverTypeName: "CommonType",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newDecoderState",
				Description:      "We pass the bytes.Buffer separately for easier testing of the infrastructure without requiring a full Decoder. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decoderState",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "freeDecoderState",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeSingle",
				Description:      "decodeSingle decodes a top-level value that is not a struct and stores it in value. Such values are preceded by a zero, making them have the memory layout of a struct field (although with an illegal field number). ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeStruct",
				Description:      "decodeStruct decodes a top-level struct and stores it in value. Indir is for the value, not the type. At the time of the call it may differ from ut.indir, which was computed when the engine was built. This state cannot arise for decodeSingle, which is called directly from the user's value, not from the innards of an engine. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreStruct",
				Description:      "ignoreStruct discards the data for a struct with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreSingle",
				Description:      "ignoreSingle discards the data for a top-level non-struct value with no destination. It's used when calling Decode with a nil value. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeArrayHelper",
				Description:      "decodeArrayHelper does the work for decoding arrays and slices. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeArray",
				Description:      "decodeArray decodes an array and stores it in value. The length is an unsigned integer preceding the elements. Even though the length is redundant (it's part of the type), it's a useful check and is included in the encoding. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeMap",
				Description:      "decodeMap decodes a map and stores it in value. Maps are encoded as a length followed by key:value pairs. Because the internals of maps are not visible to us, we must use reflection rather than pointer magic. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreArrayHelper",
				Description:      "ignoreArrayHelper does the work for discarding arrays and slices. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreArray",
				Description:      "ignoreArray discards the data for an array value with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreMap",
				Description:      "ignoreMap discards the data for a map value with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeSlice",
				Description:      "decodeSlice decodes a slice and stores it in value. Slices are encoded as an unsigned length followed by the elements. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreSlice",
				Description:      "ignoreSlice skips over the data for a slice value with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeInterface",
				Description:      "decodeInterface decodes an interface value and stores it in value. Interfaces are encoded as the name of a concrete type followed by a value. If the name is empty, the value is nil and no value is sent. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreInterface",
				Description:      "ignoreInterface discards the data for an interface value with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeGobDecoder",
				Description:      "decodeGobDecoder decodes something implementing the GobDecoder interface. The data is encoded as a byte slice. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ignoreGobDecoder",
				Description:      "ignoreGobDecoder discards the data for a GobDecoder value with no destination. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decOpFor",
				Description:      "decOpFor returns the decoding op for the base type under rt and the indirection count to reach it. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decOp",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "decIgnoreOpFor",
				Description:      "decIgnoreOpFor returns the decoding op for a field that has no destination. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decOp",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "gobDecodeOpFor",
				Description:      "gobDecodeOpFor returns the op for a type that is known to implement GobDecoder. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decOp",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "compatibleType",
				Description:      "compatibleType asks: Are these two gob Types compatible? Answers the question for basic types, arrays, maps and slices, plus GobEncoder/Decoder pairs. Structs are considered ok; fields will be checked later. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "typeString",
				Description:      "typeString returns a human-readable description of the type identified by remoteId. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "compileSingle",
				Description:      "compileSingle compiles the decoder engine for a non-struct top-level value, including GobDecoders. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decEngine",
						TypePkgName: "gob",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "compileIgnoreSingle",
				Description:      "compileIgnoreSingle compiles the decoder engine for a non-struct top-level value that will be discarded. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decEngine",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "compileDec",
				Description:      "compileDec compiles the decoder engine for a value. If the value is not a struct, it calls out to compileSingle. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "decEngine",
						TypePkgName: "gob",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getDecEnginePtr",
				Description:      "getDecEnginePtr returns the engine for the specified type. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "**encoding/gob.decEngine",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "getIgnoreEnginePtr",
				Description:      "getIgnoreEnginePtr returns the engine for the specified type when the value is to be discarded. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "**encoding/gob.decEngine",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decodeValue",
				Description:      "decodeValue decodes the data stream representing a value and stores it in value. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "decodeIgnoredValue",
				Description:      "decodeIgnoredValue decodes the data stream representing a value of the specified type and discards it. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recvType",
				Description:      "recvType loads the definition of a type. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "recvMessage",
				Description:      "recvMessage reads the next count-delimited item from the input. It is the converse of Encoder.writeMessage. It returns false on EOF or other error reading the message. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readMessage",
				Description:      "readMessage reads the next nbytes bytes from the input. ",
				ReceiverTypeName: "Decoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "nextInt",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "nextUint",
				Description:      "",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint64",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "decodeTypeSequence",
				Description:      "decodeTypeSequence parses: TypeSequence (TypeDefinition DelimitedTypeDefinition*)? and returns the type id of the next value. It returns -1 at EOF. Upon return, the remainder of dec.buf is the value to be decoded. If this is an interface value, it can be ignored by resetting that buffer. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "typeId",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "Decode",
				Description:      "Decode reads the next value from the input stream and stores it in the data represented by the empty interface value. If e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received. If the input is at EOF, Decode returns [io.EOF] and does not modify e. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DecodeValue",
				Description:      "DecodeValue reads the next value from the input stream. If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value. Otherwise, it stores the value into v. In that case, v must represent a non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If the input is at EOF, DecodeValue returns [io.EOF] and does not modify v. ",
				ReceiverTypeName: "Decoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "newEncoderState",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "encoderState",
						TypePkgName: "gob",
					},
				},
			},
			methodSet{
				Name:             "freeEncoderState",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeSingle",
				Description:      "encodeSingle encodes a single top-level non-struct value. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeStruct",
				Description:      "encodeStruct encodes a single struct value. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeArray",
				Description:      "encodeArray encodes an array. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeMap",
				Description:      "encodeMap encodes a map as unsigned count followed by key:value pairs. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeInterface",
				Description:      "encodeInterface encodes the interface value iv. To send an interface, we send a string identifying the concrete type, followed by the type identifier (which might require defining that type right now), followed by the concrete value. A nil value gets sent as the empty string for the name, followed by no value. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encodeGobEncoder",
				Description:      "encodeGobEncoder encodes a value that implements the GobEncoder interface. The data is sent as a byte array. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "encode",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writer",
				Description:      "writer returns the innermost writer the encoder is using. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "pushWriter",
				Description:      "pushWriter adds a writer to the encoder. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "popWriter",
				Description:      "popWriter pops the innermost writer. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "setError",
				Description:      "",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeMessage",
				Description:      "writeMessage sends the data item preceded by an unsigned count of its length. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sendActualType",
				Description:      "sendActualType sends the requested type, without further investigation, unless it's been sent before. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendType",
				Description:      "sendType sends the type info to the other side, if necessary. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Encode",
				Description:      "Encode transmits the data item represented by the empty interface value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to Encoder will panic, as they cannot be transmitted by gob. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "sendTypeDescriptor",
				Description:      "sendTypeDescriptor makes sure the remote side knows about this type. It will send a descriptor if this is the first time the type has been sent. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "sendTypeId",
				Description:      "sendTypeId sends the id, which must have already been defined. ",
				ReceiverTypeName: "Encoder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "EncodeValue",
				Description:      "EncodeValue transmits the data item represented by the reflection value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to EncodeValue will panic, as they cannot be transmitted by gob. ",
				ReceiverTypeName: "Encoder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cmerge": []methodSet{
			methodSet{
				Name:             "SetModeMergePolicy",
				Description:      "",
				ReceiverTypeName: "Merger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "MergeCounters",
				Description:      "MergeCounters takes the counter values in 'src' and merges them into 'dst' according to the correct counter mode. ",
				ReceiverTypeName: "Merger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SaturatingAdd",
				Description:      "Saturating add does a saturating addition of 'dst' and 'src', returning added value or math.MaxUint32 if there is an overflow. Overflows are recorded in case the client needs to track them. ",
				ReceiverTypeName: "Merger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SetModeAndGranularity",
				Description:      "SetModeAndGranularity records the counter mode and granularity for the current merge. In the specific case of merging across coverage data files from different binaries, where we're combining data from more than one meta-data file, we need to check for and resolve mode/granularity clashes. ",
				ReceiverTypeName: "Merger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ResetModeAndGranularity",
				Description:      "",
				ReceiverTypeName: "Merger",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Mode",
				Description:      "",
				ReceiverTypeName: "Merger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterMode",
						TypePkgName: "coverage",
					},
				},
			},
			methodSet{
				Name:             "Granularity",
				Description:      "",
				ReceiverTypeName: "Merger",
				Returns: []returnSet{
					returnSet{
						TypeName:    "CounterGranularity",
						TypePkgName: "coverage",
					},
				},
			},
		},
		"testgen": []methodSet{
			methodSet{
				Name:             "ExpectFailure",
				Description:      "ExpectFailure writes down that the trace should be broken. The caller must provide a pattern matching the expected error produced by the parser. ",
				ReceiverTypeName: "Trace",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "ExpectSuccess",
				Description:      "ExpectSuccess writes down that the trace should successfully parse. ",
				ReceiverTypeName: "Trace",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RawEvent",
				Description:      "RawEvent emits an event into the trace. name must correspond to one of the names in Specs() result for the version that was passed to this trace. ",
				ReceiverTypeName: "Trace",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "DisableTimestamps",
				Description:      "DisableTimestamps makes the timestamps for all events generated after this call zero. Raw events are exempted from this because the caller has to pass their own timestamp into those events anyway. ",
				ReceiverTypeName: "Trace",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Generation",
				Description:      "Generation creates a new trace generation. This provides more structure than Event to allow for more easily creating complex traces that are mostly or completely correct. ",
				ReceiverTypeName: "Trace",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Generation",
						TypePkgName: "testgen",
					},
				},
			},
			methodSet{
				Name:             "Generate",
				Description:      "Generate creates a test file for the trace. ",
				ReceiverTypeName: "Trace",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "createEvent",
				Description:      "",
				ReceiverTypeName: "Trace",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Event",
						TypePkgName: "raw",
					},
				},
			},
		},
		"httptest": []methodSet{
			methodSet{
				Name:             "Header",
				Description:      "Header implements [http.ResponseWriter]. It returns the response headers to mutate within a handler. To test the headers that were written after a handler completes, use the [ResponseRecorder.Result] method and see the returned Response value's Header. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "writeHeader",
				Description:      "writeHeader writes a header if it was not written yet and detects Content-Type if needed. bytes or str are the beginning of the response body. We pass both to avoid unnecessarily generate garbage in rw.WriteString which was created for performance reasons. Non-nil bytes win. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write implements http.ResponseWriter. The data in buf is written to rw.Body, if not nil. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteString",
				Description:      "WriteString implements [io.StringWriter]. The data in str is written to rw.Body, if not nil. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteHeader",
				Description:      "WriteHeader implements [http.ResponseWriter]. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush implements [http.Flusher]. To test whether Flush was called, see rw.Flushed. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Result",
				Description:      "Result returns the response generated by the handler. The returned Response will have at least its StatusCode, Header, Body, and optionally Trailer populated. More fields may be populated in the future, so callers should not DeepEqual the result in tests. The Response.Header is a snapshot of the headers at the time of the first write call, or at the time of this call, if the handler never did a write. The Response.Body is guaranteed to be non-nil and Body.Read call is guaranteed to not return any error other than [io.EOF]. Result must only be called after the handler has finished running. ",
				ReceiverTypeName: "ResponseRecorder",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Response",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "Start",
				Description:      "Start starts a server from NewUnstartedServer. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "StartTLS",
				Description:      "StartTLS starts TLS on a server from NewUnstartedServer. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close shuts down the server and blocks until all outstanding requests on this server have completed. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "logCloseHangDebugInfo",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "CloseClientConnections",
				Description:      "CloseClientConnections closes any open HTTP connections to the test Server. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Certificate",
				Description:      "Certificate returns the certificate used by the server, or nil if the server doesn't use TLS. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Certificate",
						TypePkgName: "x509",
					},
				},
			},
			methodSet{
				Name:             "Client",
				Description:      "Client returns an HTTP client configured for making requests to the server. It is configured to trust the server's TLS test certificate and will close its idle connections on [Server.Close]. Use Server.URL as the base URL to send requests to the server. ",
				ReceiverTypeName: "Server",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Client",
						TypePkgName: "http",
					},
				},
			},
			methodSet{
				Name:             "goServe",
				Description:      "",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "wrap",
				Description:      "wrap installs the connection state-tracking hook to know which connections are idle. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closeConn",
				Description:      "closeConn closes c. s.mu must be held. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "closeConnChan",
				Description:      "closeConnChan is like closeConn, but takes an optional channel to receive a value when the goroutine closing c is done. ",
				ReceiverTypeName: "Server",
				Returns:          []returnSet{},
			},
		},
		"bisect": []methodSet{
			methodSet{
				Name:             "MarkerOnly",
				Description:      "MarkerOnly reports whether it is okay to print only the marker for a given change, omitting the identifying information. MarkerOnly returns true when bisect is using the printed reports only for an intermediate search step, not for showing to users. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ShouldEnable",
				Description:      "ShouldEnable reports whether the change with the given id should be enabled. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ShouldPrint",
				Description:      "ShouldPrint reports whether to print identifying information about the change with the given id. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "matchResult",
				Description:      "matchResult returns the result from the first condition that matches id. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FileLine",
				Description:      "FileLine reports whether the change identified by file and line should be enabled. If the change should be printed, FileLine prints a one-line report to w. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fileLine",
				Description:      "fileLine does the real work for FileLine. This lets FileLine's body handle m == nil and potentially be inlined. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Stack",
				Description:      "MatchStack assigns the current call stack a change ID. If the stack should be printed, MatchStack prints it. Then MatchStack reports whether a change at the current call stack should be enabled. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "stack",
				Description:      "stack does the real work for Stack. This lets stack's body handle m == nil and potentially be inlined. ",
				ReceiverTypeName: "Matcher",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
		},
		"scanner": []methodSet{
			methodSet{
				Name:             "Add",
				Description:      "Add adds an [Error] with given position and error message to an [ErrorList]. ",
				ReceiverTypeName: "ErrorList",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Reset",
				Description:      "Reset resets an [ErrorList] to no errors. ",
				ReceiverTypeName: "ErrorList",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Len",
				Description:      "[ErrorList] implements the sort Interface. ",
				ReceiverTypeName: "ErrorList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Swap",
				Description:      "",
				ReceiverTypeName: "ErrorList",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Less",
				Description:      "",
				ReceiverTypeName: "ErrorList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Sort",
				Description:      "Sort sorts an [ErrorList]. *[Error] entries are sorted by position, other errors are sorted by error message, and before any *[Error] entry. ",
				ReceiverTypeName: "ErrorList",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "RemoveMultiples",
				Description:      "RemoveMultiples sorts an [ErrorList] and removes all but the first error per line. ",
				ReceiverTypeName: "ErrorList",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Err",
				Description:      "Err returns an error equivalent to this error list. If the list is empty, Err returns nil. ",
				ReceiverTypeName: "ErrorList",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "next",
				Description:      "Read the next Unicode char into s.ch. s.ch < 0 means end-of-file. For optimization, there is some overlap between this method and s.scanIdentifier. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "peek",
				Description:      "peek returns the byte following the most recently read character without advancing the scanner. If the scanner is at EOF, peek returns 0. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size. Calls to [Scanner.Scan] will invoke the error handler err if they encounter a syntax error and err is not nil. Also, for each error encountered, the [Scanner] field ErrorCount is incremented by one. The mode parameter determines how comments are handled. Note that Init may call err if there is an error in the first character of the file. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "error",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "errorf",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "scanComment",
				Description:      "scanComment returns the text of the comment and (if nonzero) the offset of the first newline within it, which implies a /*...*/ comment. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "updateLineInfo",
				Description:      "updateLineInfo parses the incoming comment text at offset offs as a line directive. If successful, it updates the line info table for the position next per the line directive. ",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "scanIdentifier",
				Description:      "scanIdentifier reads the string of valid identifier characters at s.offset. It must only be called when s.ch is known to be a valid letter. Be careful when making changes to this function: it is optimized and affects scanning performance significantly. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "digits",
				Description:      "digits accepts the sequence { digit | '_' }. If base <= 10, digits accepts any decimal digit but records the offset (relative to the source start) of a digit >= base in *invalid, if *invalid < 0. digits returns a bitset describing whether the sequence contained digits (bit 0 is set), or separators '_' (bit 1 is set). ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanNumber",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanEscape",
				Description:      "scanEscape parses an escape sequence where rune is the accepted escaped quote. In case of a syntax error, it stops at the offending character (without consuming it) and returns false. Otherwise it returns true. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanRune",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanString",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanRawString",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "skipWhitespace",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "switch2",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "switch3",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "switch4",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by [token.EOF]. If the returned token is a literal ([token.IDENT], [token.INT], [token.FLOAT], [token.IMAG], [token.CHAR], [token.STRING]) or [token.COMMENT], the literal string has the corresponding value. If the returned token is a keyword, the literal string is the keyword. If the returned token is [token.SEMICOLON], the corresponding literal string is \";\" if the semicolon was present in the source, and \"\\n\" if the semicolon was inserted because of a newline or at EOF. If the returned token is [token.ILLEGAL], the literal string is the offending character. In all other cases, Scan returns an empty literal string. For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed. Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Pos",
						TypePkgName: "token",
					},
					returnSet{
						TypeName:    "Token",
						TypePkgName: "token",
					},
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IsValid",
				Description:      "IsValid reports whether the position is valid. ",
				ReceiverTypeName: "Position",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Position",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Init",
				Description:      "Init initializes a [Scanner] with a new source and returns s. [Scanner.Error] is set to nil, [Scanner.ErrorCount] is set to 0, [Scanner.Mode] is set to [GoTokens], and [Scanner.Whitespace] is set to [GoWhitespace]. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Scanner",
						TypePkgName: "scanner",
					},
				},
			},
			methodSet{
				Name:             "next",
				Description:      "next reads and returns the next Unicode character. It is designed such that only a minimal amount of work needs to be done in the common ASCII case (one test to check for both ASCII and end-of-buffer, and one test to check for newlines). ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next reads and returns the next Unicode character. It returns [EOF] at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to [os.Stderr]. Next does not update the [Scanner.Position] field; use [Scanner.Pos]() to get the current position. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Peek",
				Description:      "Peek returns the next Unicode character in the source without advancing the scanner. It returns [EOF] if the scanner's position is at the last character of the source. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "error",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "errorf",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "isIdentRune",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanIdentifier",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "digits",
				Description:      "digits accepts the sequence { digit | '_' } starting with ch0. If base <= 10, digits accepts any decimal digit but records the first invalid digit >= base in *invalid if *invalid == 0. digits returns the first rune that is not part of the sequence anymore, and a bitset describing whether the sequence contained digits (bit 0 is set), or separators '_' (bit 1 is set). ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanNumber",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanDigits",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanEscape",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanString",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "scanRawString",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "scanChar",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "scanComment",
				Description:      "",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Scan",
				Description:      "Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective [Scanner.Mode] bit (1<<-t) is set. It returns [EOF] at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to [os.Stderr]. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "rune",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Pos",
				Description:      "Pos returns the position of the character immediately after the character or token returned by the last call to [Scanner.Next] or [Scanner.Scan]. Use the [Scanner.Position] field for the start position of the most recently scanned token. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Position",
						TypePkgName: "scanner",
					},
				},
			},
			methodSet{
				Name:             "TokenText",
				Description:      "TokenText returns the string corresponding to the most recently scanned token. Valid after calling [Scanner.Scan] and in calls of [Scanner.Error]. ",
				ReceiverTypeName: "Scanner",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"decodecounter": []methodSet{
			methodSet{
				Name:             "readFooter",
				Description:      "",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readSegmentPreamble",
				Description:      "readSegmentPreamble reads and consumes the segment header, segment string table, and segment args table. ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readStringTable",
				Description:      "",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readArgs",
				Description:      "",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "OsArgs",
				Description:      "OsArgs returns the program arguments (saved from os.Args during the run of the instrumented binary) read from the counter data file. Not all coverage data files will have os.Args values; for example, if a data file is produced by merging coverage data from two distinct runs, no os args will be available (an empty list is returned). ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Goos",
				Description:      "Goos returns the GOOS setting in effect for the \"-cover\" binary that produced this counter data file. The GOOS value may be empty in the case where the counter data file was produced from a merge in which more than one GOOS value was present. ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Goarch",
				Description:      "Goarch returns the GOARCH setting in effect for the \"-cover\" binary that produced this counter data file. The GOARCH value may be empty in the case where the counter data file was produced from a merge in which more than one GOARCH value was present. ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumSegments",
				Description:      "NumSegments returns the number of execution segments in the file. ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "BeginNextSegment",
				Description:      "BeginNextSegment sets up the reader to read the next segment, returning TRUE if we do have another segment to read, or FALSE if we're done with all the segments (also an error if something went wrong). ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NumFunctionsInSegment",
				Description:      "NumFunctionsInSegment returns the number of live functions in the currently selected segment. ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "NextFunc",
				Description:      "NextFunc reads data for the next function in this current segment into \"p\", returning TRUE if the read was successful or FALSE if we've read all the functions already (also an error if something went wrong with the read or we hit a premature EOF). ",
				ReceiverTypeName: "CounterDataReader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cgi": []methodSet{
			methodSet{
				Name:             "stderr",
				Description:      "",
				ReceiverTypeName: "Handler",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "io",
					},
				},
			},
			methodSet{
				Name:             "ServeHTTP",
				Description:      "",
				ReceiverTypeName: "Handler",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "printf",
				Description:      "",
				ReceiverTypeName: "Handler",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "handleInternalRedirect",
				Description:      "",
				ReceiverTypeName: "Handler",
				Returns:          []returnSet{},
			},
		},
		"tar": []methodSet{
			methodSet{
				Name:             "has",
				Description:      "",
				ReceiverTypeName: "Format",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "mayBe",
				Description:      "",
				ReceiverTypeName: "Format",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "mayOnlyBe",
				Description:      "",
				ReceiverTypeName: "Format",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "mustNotBe",
				Description:      "",
				ReceiverTypeName: "Format",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "Format",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "allowedFormats",
				Description:      "allowedFormats determines which formats can be used. The value returned is the logical OR of multiple possible formats. If the value is FormatUnknown, then the input Header cannot be encoded and an error is returned explaining why. As a by-product of checking the fields, this function returns paxHdrs, which contain all fields that could not be directly encoded. A value receiver ensures that this method does not mutate the source Header. ",
				ReceiverTypeName: "Header",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Format",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "map[string]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "FileInfo",
				Description:      "FileInfo returns an fs.FileInfo for the Header. ",
				ReceiverTypeName: "Header",
				Returns: []returnSet{
					returnSet{
						TypeName:    "FileInfo",
						TypePkgName: "fs",
					},
				},
			},
			methodSet{
				Name:             "Next",
				Description:      "Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded. At the end of the archive, Next returns the error io.EOF. If Next encounters a non-local name (as defined by [filepath.IsLocal]) and the GODEBUG environment variable contains `tarinsecurepath=0`, Next returns the header with an [ErrInsecurePath] error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the [ErrInsecurePath] error and use the returned header. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "next",
				Description:      "",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleRegularFile",
				Description:      "handleRegularFile sets up the current file reader and padding such that it can only read the following logical data section. It will properly handle special headers that contain no data section. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handleSparseFile",
				Description:      "handleSparseFile checks if the current file is a sparse format of any type and sets the curr reader appropriately. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readGNUSparsePAXHeaders",
				Description:      "readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers. If they are found, then this function reads the sparse map and returns it. This assumes that 0.0 headers have already been converted to 0.1 headers by the PAX header parsing logic. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sparseDatas",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readHeader",
				Description:      "readHeader reads the next block header and assumes that the underlying reader is already aligned to a block boundary. It returns the raw block of the header in case further processing is required. The err will be set to io.EOF only when one of the following occurs: - Exactly 0 bytes are read and EOF is hit. - Exactly 1 block of zeros is read and EOF is hit. - At least 2 blocks of zeros are read. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Header",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "block",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readOldGNUSparseMap",
				Description:      "readOldGNUSparseMap reads the sparse map from the old GNU sparse format. The sparse map is stored in the tar header if it's small enough. If it's larger than four entries, then one or more extension headers are used to store the rest of the sparse map. The Header.Size does not reflect the size of any extended headers used. Thus, this function will read from the raw io.Reader to fetch extra headers. This method mutates blk in the process. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "sparseDatas",
						TypePkgName: "tar",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Read",
				Description:      "Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until [Next] is called to advance to the next file. If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes. Calling Read on special types like [TypeLink], [TypeSymlink], [TypeChar], [TypeBlock], [TypeDir], and [TypeFifo] returns (0, [io.EOF]) regardless of what the [Header.Size] claims. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeTo",
				Description:      "writeTo writes the content of the current file to w. The bytes written matches the number of remaining bytes in the current file. If the current file is sparse and w is an io.WriteSeeker, then writeTo uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are filled with NULs. This always writes the last byte to ensure w is the right size. TODO(dsnet): Re-export this when adding sparse file support. See https://golang.org/issue/22735 ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called. This is unnecessary as the next call to [Writer.WriteHeader] or [Writer.Close] will implicitly flush out the file's padding. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "WriteHeader",
				Description:      "WriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeUSTARHeader",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writePAXHeader",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeGNUHeader",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "templateV7Plus",
				Description:      "templateV7Plus fills out the V7 fields of a block using values from hdr. It also fills out fields (uname, gname, devmajor, devminor) that are shared in the USTAR, PAX, and GNU formats using the provided formatters. The block returned is only valid until the next call to templateV7Plus or writeRawFile. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "block",
						TypePkgName: "tar",
					},
				},
			},
			methodSet{
				Name:             "writeRawFile",
				Description:      "writeRawFile writes a minimal file with the given name and flag type. It uses format to encode the header format and will write data as the body. It uses default values for all of the other fields (as BSD and GNU tar does). ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "writeRawHeader",
				Description:      "writeRawHeader writes the value of blk, regardless of its value. It sets up the Writer such that it can accept a file of the given size. If the flag is a special header-only flag, then the size is treated as zero. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "AddFS",
				Description:      "AddFS adds the files from fs.FS to the archive. It walks the directory tree starting at the root of the filesystem adding each file to the tar archive while maintaining the directory structure. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes to the current file in the tar archive. Write returns the error [ErrWriteTooLong] if more than Header.Size bytes are written after [Writer.WriteHeader]. Calling Write on special types like [TypeLink], [TypeSymlink], [TypeChar], [TypeBlock], [TypeDir], and [TypeFifo] returns (0, [ErrWriteTooLong]) regardless of what the [Header.Size] claims. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readFrom",
				Description:      "readFrom populates the content of the current file by reading from r. The bytes read must match the number of remaining bytes in the current file. If the current file is sparse and r is an io.ReadSeeker, then readFrom uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are all NULs. This always reads the last byte to ensure r is the right size. TODO(dsnet): Re-export this when adding sparse file support. See https://golang.org/issue/22735 ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int64",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the tar archive by flushing the padding, and writing the footer. If the current file (from a prior call to [Writer.WriteHeader]) is not fully written, then this returns an error. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"tabwriter": []methodSet{
			methodSet{
				Name:             "addLine",
				Description:      "addLine adds a new line. flushed is a hint indicating whether the underlying writer was just flushed. If so, the previous line is not likely to be a good indicator of the new line's cells. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "reset",
				Description:      "Reset the current state. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Init",
				Description:      "A [Writer] must be initialized with a call to Init. The first parameter (output) specifies the filter output. The remaining parameters control the formatting: minwidth minimal cell width including any padding tabwidth width of tab characters (equivalent number of spaces) padding padding added to a cell before computing its width padchar ASCII char used for padding if padchar == '\\t', the Writer will assume that the width of a '\\t' in the formatted output is tabwidth, and cells are left-aligned independent of align_left (for correct-looking results, tabwidth must correspond to the tab width in the viewer displaying the result) flags formatting control ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Writer",
						TypePkgName: "tabwriter",
					},
				},
			},
			methodSet{
				Name:             "dump",
				Description:      "debugging support (keep code around) ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "write0",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeN",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writePadding",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "writeLines",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "format",
				Description:      "Format the text between line0 and line1 (excluding line1); pos is the buffer position corresponding to the beginning of line0. Returns the buffer position corresponding to the beginning of line1 and an error, if any. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "append",
				Description:      "Append text to current cell. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "updateWidth",
				Description:      "Update the cell width. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "startEscape",
				Description:      "Start escaped mode. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "endEscape",
				Description:      "Terminate escaped mode. If the escaped text was an HTML tag, its width is assumed to be zero for formatting purposes; if it was an HTML entity, its width is assumed to be one. In all other cases, the width is the unicode width of the text. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "terminateCell",
				Description:      "Terminate the current cell by adding it to the list of cells of the current line. Returns the number of cells in that line. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "handlePanic",
				Description:      "",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Flush",
				Description:      "Flush should be called after the last call to [Writer.Write] to ensure that any data buffered in the [Writer] is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "flush",
				Description:      "flush is the internal version of Flush, with a named return value which we don't want to expose. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "flushNoDefers",
				Description:      "flushNoDefers is like flush, but without a deferred handlePanic call. This can be called from other methods which already have their own deferred handlePanic calls, such as Write, and avoid the extra defer work. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes buf to the writer b. The only errors returned are ones encountered while writing to the underlying output stream. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"coverage": []methodSet{
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CounterGranularity",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "",
				ReceiverTypeName: "CounterMode",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"stringtab": []methodSet{
			methodSet{
				Name:             "Read",
				Description:      "Read reads/decodes a string table using the reader provided. ",
				ReceiverTypeName: "Reader",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Entries",
				Description:      "Entries returns the number of decoded entries in a string table. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Get",
				Description:      "Get returns string 'idx' within the string table. ",
				ReceiverTypeName: "Reader",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "InitWriter",
				Description:      "InitWriter initializes a stringtab.Writer. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Nentries",
				Description:      "Nentries returns the number of strings interned so far. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Lookup",
				Description:      "Lookup looks up string 's' in the writer's table, adding a new entry if need be, and returning an index into the table. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Size",
				Description:      "Size computes the memory in bytes needed for the serialized version of a stringtab.Writer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "uint32",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Write",
				Description:      "Write writes the string table in serialized form to the specified io.Writer. ",
				ReceiverTypeName: "Writer",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Freeze",
				Description:      "Freeze sends a signal to the writer that no more additions are allowed, only lookups of existing strings (if a lookup triggers addition, a panic will result). Useful as a mechanism for \"finalizing\" a string table prior to writing it out. ",
				ReceiverTypeName: "Writer",
				Returns:          []returnSet{},
			},
		},
		"godebug": []methodSet{
			methodSet{
				Name:             "Name",
				Description:      "Name returns the name of the setting. ",
				ReceiverTypeName: "Setting",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Undocumented",
				Description:      "Undocumented reports whether this is an undocumented setting. ",
				ReceiverTypeName: "Setting",
				Returns: []returnSet{
					returnSet{
						TypeName:    "bool",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String returns a printable form for the setting: name=value. ",
				ReceiverTypeName: "Setting",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "IncNonDefault",
				Description:      "IncNonDefault increments the non-default behavior counter associated with the given setting. This counter is exposed in the runtime/metrics value /godebug/non-default-behavior/<name>:events. Note that Value must be called at least once before IncNonDefault. ",
				ReceiverTypeName: "Setting",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "register",
				Description:      "",
				ReceiverTypeName: "Setting",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "Value",
				Description:      "Value returns the current value for the GODEBUG setting s. Value maintains an internal cache that is synchronized with changes to the $GODEBUG environment variable, making Value efficient to call as frequently as needed. Clients should therefore typically not attempt their own caching of Value's result. ",
				ReceiverTypeName: "Setting",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Value",
				Description:      "",
				ReceiverTypeName: "Setting",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
		},
		"pe": []methodSet{
			methodSet{
				Name:             "FullName",
				Description:      "FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead. ",
				ReceiverTypeName: "COFFSymbol",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Section",
				Description:      "Section returns the first section with the given name, or nil if no such section exists. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Section",
						TypePkgName: "pe",
					},
				},
			},
			methodSet{
				Name:             "DWARF",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Data",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedSymbols",
				Description:      "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedLibraries",
				Description:      "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "COFFSymbolReadSectionDefAux",
				Description:      "COFFSymbolReadSectionDefAux returns a blob of auxiliary information (including COMDAT info) for a section definition symbol. Here 'idx' is the index of a section symbol in the main [COFFSymbol] array for the File. Return value is a pointer to the appropriate aux symbol struct. For more info, see: auxiliary symbols: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-symbol-records COMDAT sections: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#comdat-sections-object-only auxiliary info for section definitions: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "COFFSymbolAuxFormat5",
						TypePkgName: "pe",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Error",
				Description:      "",
				ReceiverTypeName: "FormatError",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "fullName",
				Description:      "fullName finds real name of section sh. Normally name is stored in sh.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead. ",
				ReceiverTypeName: "SectionHeader32",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "String",
				Description:      "String extracts string from COFF string table st at offset start. ",
				ReceiverTypeName: "StringTable",
				Returns: []returnSet{
					returnSet{
						TypeName:    "string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"xcoff": []methodSet{
			methodSet{
				Name:             "Close",
				Description:      "Close closes the Archive. If the Archive was created using NewArchive directly instead of OpenArchive, Close has no effect. ",
				ReceiverTypeName: "Archive",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "GetFile",
				Description:      "GetFile returns the XCOFF file defined by member name. FIXME: This doesn't work if an archive has two members with the same name which can occur if an archive has both 32-bits and 64-bits files. ",
				ReceiverTypeName: "Archive",
				Returns: []returnSet{
					returnSet{
						TypeName:    "File",
						TypePkgName: "xcoff",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Close",
				Description:      "Close closes the Archive. If the Archive was created using NewArchive directly instead of OpenArchive, Close has no effect. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "SectionByType",
				Description:      "SectionByType returns the first section in f with the given type, or nil if there is no such section. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Section",
						TypePkgName: "xcoff",
					},
				},
			},
			methodSet{
				Name:             "CSect",
				Description:      "CSect reads and returns the contents of a csect. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "DWARF",
				Description:      "",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Data",
						TypePkgName: "dwarf",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "readImportIDs",
				Description:      "readImportID returns the import file IDs stored inside the .loader section. Library name pattern is either path/base/member or base/member ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedSymbols",
				Description:      "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]internal/xcoff.ImportedSymbol",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "ImportedLibraries",
				Description:      "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. ",
				ReceiverTypeName: "File",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]string",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Data",
				Description:      "Data reads and returns the contents of the XCOFF section s. ",
				ReceiverTypeName: "Section",
				Returns: []returnSet{
					returnSet{
						TypeName:    "[]byte",
						TypePkgName: "",
					},
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"color": []methodSet{
			methodSet{
				Name:             "Convert",
				Description:      "",
				ReceiverTypeName: "Palette",
				Returns: []returnSet{
					returnSet{
						TypeName:    "Color",
						TypePkgName: "color",
					},
				},
			},
			methodSet{
				Name:             "Index",
				Description:      "Index returns the index of the palette color closest to c in Euclidean R,G,B,A space. ",
				ReceiverTypeName: "Palette",
				Returns: []returnSet{
					returnSet{
						TypeName:    "int",
						TypePkgName: "",
					},
				},
			},
		},
		"draw": []methodSet{
			methodSet{
				Name:             "Draw",
				Description:      "Draw implements the [Drawer] interface by calling the Draw function with this [Op]. ",
				ReceiverTypeName: "Op",
				Returns:          []returnSet{},
			},
		},
		"cformat": []methodSet{
			methodSet{
				Name:             "SetPackage",
				Description:      "SetPackage tells the formatter that we're about to visit the coverage data for the package with the specified import path. Note that it's OK to call SetPackage more than once with the same import path; counter data values will be accumulated. ",
				ReceiverTypeName: "Formatter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "AddUnit",
				Description:      "AddUnit passes info on a single coverable unit (file, funcname, literal flag, range of lines, and counter value) to the formatter. Counter values will be accumulated where appropriate. ",
				ReceiverTypeName: "Formatter",
				Returns:          []returnSet{},
			},
			methodSet{
				Name:             "EmitTextual",
				Description:      "EmitTextual writes the accumulated coverage data for 'pkgs' in the legacy cmd/cover text format to the writer 'w'; if pkgs is empty, text output is emitted for all packages recorded. We sort the data items by importpath, source file, and line number before emitting (this sorting is not explicitly mandated by the format, but seems like a good idea for repeatable/deterministic dumps). ",
				ReceiverTypeName: "Formatter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EmitPercent",
				Description:      "EmitPercent writes out a \"percentage covered\" string to the writer 'w', selecting the set of packages in 'pkgs' and suffixing the printed string with 'inpkgs'. ",
				ReceiverTypeName: "Formatter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "EmitFuncs",
				Description:      "EmitFuncs writes out a function-level summary to the writer 'w'. A note on handling function literals: although we collect coverage data for unnamed literals, it probably does not make sense to include them in the function summary since there isn't any good way to name them (this is also consistent with the legacy cmd/cover implementation). We do want to include their counts in the overall summary however. ",
				ReceiverTypeName: "Formatter",
				Returns: []returnSet{
					returnSet{
						TypeName:    "error",
						TypePkgName: "",
					},
				},
			},
		},
		"cgo": []methodSet{
			methodSet{
				Name:             "Value",
				Description:      "Value returns the associated Go value for a valid handle. The method panics if the handle is invalid. ",
				ReceiverTypeName: "Handle",
				Returns: []returnSet{
					returnSet{
						TypeName:    "any",
						TypePkgName: "",
					},
				},
			},
			methodSet{
				Name:             "Delete",
				Description:      "Delete invalidates a handle. This method should only be called once the program no longer needs to pass the handle to C and the C code no longer has a copy of the handle value. The method panics if the handle is invalid. ",
				ReceiverTypeName: "Handle",
				Returns:          []returnSet{},
			},
		},
	},
	Vars: map[types.PkgName][]varSet{
		"tracev2": []varSet{
			varSet{
				Name:        "EventArgTypes",
				Description: "EventArgTypes is a list of valid argument types for use in Args. See the documentation of Args for more details. ",
				TypeName:    "[10]string",
				TypePkgName: "",
			},
		},
		"crc32": []varSet{
			varSet{
				Name:        "IEEETable",
				Description: "IEEETable is the table for the [IEEE] polynomial. ",
				TypeName:    "Table",
				TypePkgName: "crc32",
			},
		},
		"sysinfo": []varSet{
			varSet{
				Name:        "CPUName",
				Description: "",
				TypeName:    "func() string",
				TypePkgName: "",
			},
		},
		"multipart": []varSet{
			varSet{
				Name:        "ErrMessageTooLarge",
				Description: "ErrMessageTooLarge is returned by ReadForm if the message form data is too large to be processed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"runtime": []varSet{
			varSet{
				Name:        "MemProfileRate",
				Description: "MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated. To include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0. The tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main). ",
				TypeName:    "int",
				TypePkgName: "",
			},
		},
		"oserror": []varSet{
			varSet{
				Name:        "ErrClosed",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrExist",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInvalid",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotExist",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrPermission",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"path": []varSet{
			varSet{
				Name:        "ErrBadPattern",
				Description: "ErrBadPattern indicates a pattern was malformed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"exithook": []varSet{
			varSet{
				Name:        "Goid",
				Description: "",
				TypeName:    "func() uint64",
				TypePkgName: "",
			},
			varSet{
				Name:        "Gosched",
				Description: "runtime sets these for us ",
				TypeName:    "func()",
				TypePkgName: "",
			},
			varSet{
				Name:        "Throw",
				Description: "",
				TypeName:    "func(string)",
				TypePkgName: "",
			},
		},
		"fs": []varSet{
			varSet{
				Name:        "ErrClosed",
				Description: "Generic file system errors. Errors returned by file systems can be tested against these errors using [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrExist",
				Description: "Generic file system errors. Errors returned by file systems can be tested against these errors using [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInvalid",
				Description: "Generic file system errors. Errors returned by file systems can be tested against these errors using [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotExist",
				Description: "Generic file system errors. Errors returned by file systems can be tested against these errors using [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrPermission",
				Description: "Generic file system errors. Errors returned by file systems can be tested against these errors using [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "SkipAll",
				Description: "SkipAll is used as a return value from [WalkDirFunc] to indicate that all remaining files and directories are to be skipped. It is not returned as an error by any function. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "SkipDir",
				Description: "SkipDir is used as a return value from [WalkDirFunc] to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"tar": []varSet{
			varSet{
				Name:        "ErrFieldTooLong",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrHeader",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInsecurePath",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrWriteAfterClose",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrWriteTooLong",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"platform": []varSet{
			varSet{
				Name:        "List",
				Description: "List is the list of all valid GOOS/GOARCH combinations, including known-broken ports. ",
				TypeName:    "[]internal/platform.OSArch",
				TypePkgName: "",
			},
		},
		"exec": []varSet{
			varSet{
				Name:        "ErrDot",
				Description: "ErrDot indicates that a path lookup resolved to an executable in the current directory due to â.â being in the path, either implicitly or explicitly. See the package documentation for details. Note that functions in this package do not return ErrDot directly. Code should use errors.Is(err, ErrDot), not err == ErrDot, to test whether a returned error err is due to this condition. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotFound",
				Description: "ErrNotFound is the error resulting if a path search failed to find an executable file. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrWaitDelay",
				Description: "ErrWaitDelay is returned by [Cmd.Wait] if the process exits with a successful status code but its output pipes are not closed before the command's WaitDelay expires. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"rsa": []varSet{
			varSet{
				Name:        "ErrDecryption",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrMessageTooLong",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrVerification",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrDecryption",
				Description: "ErrDecryption represents a failure to decrypt a message. It is deliberately vague to avoid adaptive attacks. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrMessageTooLong",
				Description: "ErrMessageTooLong is returned when attempting to encrypt or sign a message which is too large for the size of the key. When using [SignPSS], this can also be returned if the size of the salt is too large. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrVerification",
				Description: "ErrVerification represents a failure to verify a signature. It is deliberately vague to avoid adaptive attacks. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"hex": []varSet{
			varSet{
				Name:        "ErrLength",
				Description: "ErrLength reports an attempt to decode an odd-length input using [Decode] or [DecodeString]. The stream-based Decoder returns [io.ErrUnexpectedEOF] instead of ErrLength. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"internal": []varSet{
			varSet{
				Name:        "DefaultOutput",
				Description: "DefaultOutput holds a function which calls the default log.Logger's output function. It allows slog.defaultHandler to call into an unexported function of the log package. ",
				TypeName:    "func(pc uintptr, data []byte) error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrLineTooLong",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "IgnorePC",
				Description: "If IgnorePC is true, do not invoke runtime.Callers to get the pc. This is solely for benchmarking the slowdown from runtime.Callers. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"check": []varSet{
			varSet{
				Name:        "Linkinfo",
				Description: "Linkinfo holds the go:fipsinfo symbol prepared by the linker. See cmd/link/internal/ld/fips.go for details. ",
				TypeName:    "struct{Magic [16]byte; Sum [32]byte; Self uintptr; Sects [4]struct{Start unsafe.Pointer; End unsafe.Pointer}}",
				TypePkgName: "",
			},
			varSet{
				Name:        "Verified",
				Description: "Verified is set when verification succeeded. It can be expected to always be true when [fips140.Enabled] is true, or init would have panicked. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"x509": []varSet{
			varSet{
				Name:        "ErrUnsupportedAlgorithm",
				Description: "ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "IncorrectPasswordError",
				Description: "IncorrectPasswordError is returned when an incorrect password is detected. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"http": []varSet{
			varSet{
				Name:        "DefaultClient",
				Description: "DefaultClient is the default [Client] and is used by [Get], [Head], and [Post]. ",
				TypeName:    "Client",
				TypePkgName: "http",
			},
			varSet{
				Name:        "DefaultServeMux",
				Description: "DefaultServeMux is the default [ServeMux] used by [Serve]. ",
				TypeName:    "ServeMux",
				TypePkgName: "http",
			},
			varSet{
				Name:        "DefaultTransport",
				Description: "DefaultTransport is the default implementation of [Transport] and is used by [DefaultClient]. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). ",
				TypeName:    "RoundTripper",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrAbortHandler",
				Description: "ErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrBodyNotAllowed",
				Description: "ErrBodyNotAllowed is returned by ResponseWriter.Write calls when the HTTP method or response code does not permit a body. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrBodyReadAfterClose",
				Description: "ErrBodyReadAfterClose is returned when reading a [Request] or [Response] Body after the body has been closed. This typically happens when the body is read after an HTTP [Handler] calls WriteHeader or Write on its [ResponseWriter]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrContentLength",
				Description: "ErrContentLength is returned by ResponseWriter.Write calls when a Handler set a Content-Length response header with a declared size and then attempted to write more bytes than declared. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrHandlerTimeout",
				Description: "ErrHandlerTimeout is returned on [ResponseWriter] Write calls in handlers which have timed out. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrHeaderTooLong",
				Description: "Deprecated: ErrHeaderTooLong is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrHijacked",
				Description: "ErrHijacked is returned by ResponseWriter.Write calls when the underlying connection has been hijacked using the Hijacker interface. A zero-byte write on a hijacked connection will return ErrHijacked without any other side effects. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrLineTooLong",
				Description: "ErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrMissingBoundary",
				Description: "ErrMissingBoundary is returned by Request.MultipartReader when the request's Content-Type does not include a \"boundary\" parameter. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrMissingContentLength",
				Description: "Deprecated: ErrMissingContentLength is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrMissingFile",
				Description: "ErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNoCookie",
				Description: "ErrNoCookie is returned by Request's Cookie method when a cookie is not found. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNoLocation",
				Description: "ErrNoLocation is returned by the [Response.Location] method when no Location header is present. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotMultipart",
				Description: "ErrNotMultipart is returned by Request.MultipartReader when the request's Content-Type is not multipart/form-data. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrNotSupported",
				Description: "ErrNotSupported indicates that a feature is not supported. It is returned by ResponseController methods to indicate that the handler does not support the method, and by the Push method of Pusher implementations to indicate that HTTP/2 Push support is not available. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrSchemeMismatch",
				Description: "ErrSchemeMismatch is returned when a server returns an HTTP response to an HTTPS client. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrServerClosed",
				Description: "ErrServerClosed is returned by the [Server.Serve], [ServeTLS], [ListenAndServe], and [ListenAndServeTLS] methods after a call to [Server.Shutdown] or [Server.Close]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrShortBody",
				Description: "Deprecated: ErrShortBody is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrSkipAltProtocol",
				Description: "ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrUnexpectedTrailer",
				Description: "Deprecated: ErrUnexpectedTrailer is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrUseLastResponse",
				Description: "ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrWriteAfterFlush",
				Description: "Deprecated: ErrWriteAfterFlush is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "LocalAddrContextKey",
				Description: "LocalAddrContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the local address the connection arrived on. The associated value will be of type net.Addr. ",
				TypeName:    "contextKey",
				TypePkgName: "http",
			},
			varSet{
				Name:        "NoBody",
				Description: "NoBody is an [io.ReadCloser] with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set [Request.Body] to nil. ",
				TypeName:    "noBody",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ServerContextKey",
				Description: "ServerContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the server that started the handler. The associated value will be of type *Server. ",
				TypeName:    "contextKey",
				TypePkgName: "http",
			},
		},
		"testgen": []varSet{
			varSet{
				Name:        "NoStack",
				Description: "",
				TypeName:    "[]internal/trace.StackFrame",
				TypePkgName: "",
			},
			varSet{
				Name:        "NoString",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
		},
		"fcgi": []varSet{
			varSet{
				Name:        "ErrConnClosed",
				Description: "ErrConnClosed is returned by Read when a handler attempts to read the body of a request after the connection to the web server has been closed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrRequestAborted",
				Description: "ErrRequestAborted is returned by Read when a handler attempts to read the body of a request that has been aborted by the web server. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"httputil": []varSet{
			varSet{
				Name:        "ErrClosed",
				Description: "Deprecated: No longer used. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrLineTooLong",
				Description: "ErrLineTooLong is returned when reading malformed chunked data with lines that are too long. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrPersistEOF",
				Description: "Deprecated: No longer used. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
			varSet{
				Name:        "ErrPipeline",
				Description: "Deprecated: No longer used. ",
				TypeName:    "ProtocolError",
				TypePkgName: "http",
			},
		},
		"rpc": []varSet{
			varSet{
				Name:        "DefaultServer",
				Description: "DefaultServer is the default instance of [*Server]. ",
				TypeName:    "Server",
				TypePkgName: "rpc",
			},
			varSet{
				Name:        "ErrShutdown",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"sys": []varSet{
			varSet{
				Name:        "DITSupported",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"checktest": []varSet{
			varSet{
				Name:        "BSS",
				Description: "",
				TypeName:    "*int",
				TypePkgName: "",
			},
			varSet{
				Name:        "DATA",
				Description: "DATA needs to have both a pointer and an int so that _some_ of it gets initialized at link time, so it is treated as DATA and not BSS. The pointer is deferred to init time. ",
				TypeName:    "struct{P *int; X int}",
				TypePkgName: "",
			},
			varSet{
				Name:        "NOPTRBSS",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "NOPTRDATA",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "RODATA",
				Description: "The linkname here disables asan registration of this global, because asan gets mad about rodata globals. ",
				TypeName:    "int32",
				TypePkgName: "",
			},
		},
		"csv": []varSet{
			varSet{
				Name:        "ErrBareQuote",
				Description: "These are the errors that can be returned in [ParseError.Err]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrFieldCount",
				Description: "These are the errors that can be returned in [ParseError.Err]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrQuote",
				Description: "These are the errors that can be returned in [ParseError.Err]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrTrailingComma",
				Description: "Deprecated: ErrTrailingComma is no longer used. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"httpcommon": []varSet{
			varSet{
				Name:        "ErrRequestHeaderListSize",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"testpty": []varSet{
			varSet{
				Name:        "ErrNotSupported",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"io": []varSet{
			varSet{
				Name:        "Discard",
				Description: "Discard is a [Writer] on which all Write calls succeed without doing anything. ",
				TypeName:    "Writer",
				TypePkgName: "io",
			},
			varSet{
				Name:        "EOF",
				Description: "EOF is the error returned by Read when no more input is available. (Read must return EOF itself, not an error wrapping EOF, because callers will test for EOF using ==.) Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either [ErrUnexpectedEOF] or some other error giving more detail. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrClosedPipe",
				Description: "ErrClosedPipe is the error used for read or write operations on a closed pipe. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNoProgress",
				Description: "ErrNoProgress is returned by some clients of a [Reader] when many calls to Read have failed to return any data or error, usually the sign of a broken [Reader] implementation. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrShortBuffer",
				Description: "ErrShortBuffer means that a read required a longer buffer than was provided. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrShortWrite",
				Description: "ErrShortWrite means that a write accepted fewer bytes than requested but failed to return an explicit error. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrUnexpectedEOF",
				Description: "ErrUnexpectedEOF means that EOF was encountered in the middle of reading a fixed-size block or data structure. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"syscall": []varSet{
			varSet{
				Name:        "ForkLock",
				Description: "ForkLock is used to synchronize creation of new file descriptors with fork. We want the child in a fork/exec sequence to inherit only the file descriptors we intend. To do that, we mark all file descriptors close-on-exec and then, in the child, explicitly unmark the ones we want the exec'ed program to keep. Unix doesn't make this easy: there is, in general, no way to allocate a new file descriptor close-on-exec. Instead you have to allocate the descriptor and then mark it close-on-exec. If a fork happens between those two events, the child's exec will inherit an unwanted file descriptor. This lock solves that race: the create new fd/mark close-on-exec operation is done holding ForkLock for reading, and the fork itself is done holding ForkLock for writing. At least, that's the idea. There are some complications. Some system calls that create new file descriptors can block for arbitrarily long times: open on a hung NFS server or named pipe, accept on a socket, and so on. We can't reasonably grab the lock across those operations. It is worse to inherit some file descriptors than others. If a non-malicious child accidentally inherits an open ordinary file, that's not a big deal. On the other hand, if a long-lived child accidentally inherits the write end of a pipe, then the reader of that pipe will not see EOF until that child exits, potentially causing the parent program to hang. This is a common problem in threaded C programs that use popen. Luckily, the file descriptors that are most important not to inherit are not the ones that can take an arbitrarily long time to create: pipe returns instantly, and the net package uses non-blocking I/O to accept on a listening socket. The rules for which file descriptor-creating operations use the ForkLock are as follows: - [Pipe]. Use pipe2 if available. Otherwise, does not block, so use ForkLock. - [Socket]. Use SOCK_CLOEXEC if available. Otherwise, does not block, so use ForkLock. - [Open]. Use [O_CLOEXEC] if available. Otherwise, may block, so live with the race. - [Dup]. Use [F_DUPFD_CLOEXEC] or dup3 if available. Otherwise, does not block, so use ForkLock. ",
				TypeName:    "RWMutex",
				TypePkgName: "sync",
			},
			varSet{
				Name:        "SocketDisableIPv6",
				Description: "For testing: clients can set this flag to force creation of IPv6 sockets to return [EAFNOSUPPORT]. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "Stderr",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "Stdin",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "Stdout",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
		},
		"zip": []varSet{
			varSet{
				Name:        "ErrAlgorithm",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrChecksum",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrFormat",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInsecurePath",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"gzip": []varSet{
			varSet{
				Name:        "ErrChecksum",
				Description: "ErrChecksum is returned when reading GZIP data that has an invalid checksum. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrHeader",
				Description: "ErrHeader is returned when reading GZIP data that has an invalid header. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"macho": []varSet{
			varSet{
				Name:        "ErrNotFat",
				Description: "ErrNotFat is returned from [NewFatFile] or [OpenFat] when the file is not a universal binary but may be a thin binary, based on its magic number. ",
				TypeName:    "FormatError",
				TypePkgName: "macho",
			},
		},
		"ioutil": []varSet{
			varSet{
				Name:        "Discard",
				Description: "Discard is an io.Writer on which all Write calls succeed without doing anything. Deprecated: As of Go 1.16, this value is simply [io.Discard]. ",
				TypeName:    "Writer",
				TypePkgName: "io",
			},
		},
		"testcert": []varSet{
			varSet{
				Name:        "LocalhostCert",
				Description: "LocalhostCert is a PEM-encoded TLS cert with SAN IPs \"127.0.0.1\" and \"[::1]\", expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 2048 --host 127.0.0.1,::1,example.com,*.example.com --ca --start-date \"Jan 1 00:00:00 1970\" --duration=1000000h ",
				TypeName:    "[]byte",
				TypePkgName: "",
			},
			varSet{
				Name:        "LocalhostKey",
				Description: "LocalhostKey is the private key for LocalhostCert. ",
				TypeName:    "[]byte",
				TypePkgName: "",
			},
		},
		"testdeps": []varSet{
			varSet{
				Name:        "Cover",
				Description: "Cover indicates whether coverage is enabled. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "CoverMarkProfileEmittedFunc",
				Description: "These variables below are set at runtime (via code in testmain) to point to the equivalent functions in package internal/coverage/cfile; doing things this way allows us to have tests import internal/coverage/cfile only when -cover is in effect (as opposed to importing for all tests). ",
				TypeName:    "func(val bool)",
				TypePkgName: "",
			},
			varSet{
				Name:        "CoverMode",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "CoverProcessTestDirFunc",
				Description: "These variables below are set at runtime (via code in testmain) to point to the equivalent functions in package internal/coverage/cfile; doing things this way allows us to have tests import internal/coverage/cfile only when -cover is in effect (as opposed to importing for all tests). ",
				TypeName:    "func(dir string, cfile string, cm string, cpkg string, w io.Writer, selpkgs []string) error",
				TypePkgName: "",
			},
			varSet{
				Name:        "CoverSelectedPackages",
				Description: "",
				TypeName:    "[]string",
				TypePkgName: "",
			},
			varSet{
				Name:        "CoverSnapshotFunc",
				Description: "These variables below are set at runtime (via code in testmain) to point to the equivalent functions in package internal/coverage/cfile; doing things this way allows us to have tests import internal/coverage/cfile only when -cover is in effect (as opposed to importing for all tests). ",
				TypeName:    "func() float64",
				TypePkgName: "",
			},
			varSet{
				Name:        "Covered",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "ImportPath",
				Description: "ImportPath is the import path of the testing binary, set by the generated main function. ",
				TypeName:    "string",
				TypePkgName: "",
			},
		},
		"filepath": []varSet{
			varSet{
				Name:        "ErrBadPattern",
				Description: "ErrBadPattern indicates a pattern was malformed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "SkipAll",
				Description: "SkipAll is used as a return value from [WalkFunc] to indicate that all remaining files and directories are to be skipped. It is not returned as an error by any function. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "SkipDir",
				Description: "SkipDir is used as a return value from [WalkFunc] to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"rand": []varSet{
			varSet{
				Name:        "Reader",
				Description: "Reader is a global, shared instance of a cryptographically secure random number generator. It is safe for concurrent use. - On Linux, FreeBSD, Dragonfly, and Solaris, Reader uses getrandom(2). - On legacy Linux (< 3.17), Reader opens /dev/urandom on first use. - On macOS, iOS, and OpenBSD Reader, uses arc4random_buf(3). - On NetBSD, Reader uses the kern.arandom sysctl. - On Windows, Reader uses the ProcessPrng API. - On js/wasm, Reader uses the Web Crypto API. - On wasip1/wasm, Reader uses random_get. In FIPS 140-3 mode, the output passes through an SP 800-90A Rev. 1 Deterministric Random Bit Generator (DRBG). ",
				TypeName:    "Reader",
				TypePkgName: "io",
			},
		},
		"base64": []varSet{
			varSet{
				Name:        "RawStdEncoding",
				Description: "RawStdEncoding is the standard raw, unpadded base64 encoding, as defined in RFC 4648 section 3.2. This is the same as [StdEncoding] but omits padding characters. ",
				TypeName:    "Encoding",
				TypePkgName: "base64",
			},
			varSet{
				Name:        "RawURLEncoding",
				Description: "RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. This is the same as [URLEncoding] but omits padding characters. ",
				TypeName:    "Encoding",
				TypePkgName: "base64",
			},
			varSet{
				Name:        "StdEncoding",
				Description: "StdEncoding is the standard base64 encoding, as defined in RFC 4648. ",
				TypeName:    "Encoding",
				TypePkgName: "base64",
			},
			varSet{
				Name:        "URLEncoding",
				Description: "URLEncoding is the alternate base64 encoding defined in RFC 4648. It is typically used in URLs and file names. ",
				TypeName:    "Encoding",
				TypePkgName: "base64",
			},
		},
		"ssh": []varSet{
			varSet{
				Name:        "ClientKeys",
				Description: "",
				TypeName:    "Direction",
				TypePkgName: "ssh",
			},
			varSet{
				Name:        "ServerKeys",
				Description: "",
				TypeName:    "Direction",
				TypePkgName: "ssh",
			},
		},
		"hpke": []varSet{
			varSet{
				Name:        "SupportedAEADs",
				Description: "",
				TypeName:    "map[uint16]struct{keySize int; nonceSize int; aead func([]byte) (crypto/cipher.AEAD, error)}",
				TypePkgName: "",
			},
			varSet{
				Name:        "SupportedKDFs",
				Description: "",
				TypeName:    "map[uint16]func() *crypto/internal/hpke.hkdfKDF",
				TypePkgName: "",
			},
			varSet{
				Name:        "SupportedKEMs",
				Description: "",
				TypeName:    "map[uint16]struct{curve crypto/ecdh.Curve; hash crypto.Hash; nSecret uint16}",
				TypePkgName: "",
			},
		},
		"profile": []varSet{
			varSet{
				Name:        "ErrNoData",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"net": []varSet{
			varSet{
				Name:        "DefaultResolver",
				Description: "DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver. ",
				TypeName:    "Resolver",
				TypePkgName: "net",
			},
			varSet{
				Name:        "ErrClosed",
				Description: "ErrClosed is the error returned by an I/O call on a network connection that has already been closed, or that is closed by another goroutine before the I/O is completed. This may be wrapped in another error, and should normally be tested using errors.Is(err, net.ErrClosed). ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrWriteToConnected",
				Description: "Various errors contained in OpError. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "IPv4allrouter",
				Description: "Well-known IPv4 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv4allsys",
				Description: "Well-known IPv4 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv4bcast",
				Description: "Well-known IPv4 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv4zero",
				Description: "Well-known IPv4 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6interfacelocalallnodes",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6linklocalallnodes",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6linklocalallrouters",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6loopback",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6unspecified",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
			varSet{
				Name:        "IPv6zero",
				Description: "Well-known IPv6 addresses ",
				TypeName:    "IP",
				TypePkgName: "net",
			},
		},
		"dwarf": []varSet{
			varSet{
				Name:        "ErrUnknownPC",
				Description: "ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is not covered by any entry in the line table. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"mime": []varSet{
			varSet{
				Name:        "ErrInvalidMediaParameter",
				Description: "ErrInvalidMediaParameter is returned by [ParseMediaType] if the media type value was found but there was an error parsing the optional parameters ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"build": []varSet{
			varSet{
				Name:        "Default",
				Description: "Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables if set, or else the compiled code's GOARCH, GOOS, and GOROOT. ",
				TypeName:    "Context",
				TypePkgName: "build",
			},
			varSet{
				Name:        "ToolDir",
				Description: "ToolDir is the directory containing build tools. ",
				TypeName:    "string",
				TypePkgName: "",
			},
		},
		"image": []varSet{
			varSet{
				Name:        "Black",
				Description: "Black is an opaque black uniform image. ",
				TypeName:    "Uniform",
				TypePkgName: "image",
			},
			varSet{
				Name:        "ErrFormat",
				Description: "ErrFormat indicates that decoding encountered an unknown format. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "Transparent",
				Description: "Transparent is a fully transparent uniform image. ",
				TypeName:    "Uniform",
				TypePkgName: "image",
			},
			varSet{
				Name:        "White",
				Description: "White is an opaque white uniform image. ",
				TypeName:    "Uniform",
				TypePkgName: "image",
			},
			varSet{
				Name:        "ZP",
				Description: "ZP is the zero [Point]. Deprecated: Use a literal [image.Point] instead. ",
				TypeName:    "Point",
				TypePkgName: "image",
			},
			varSet{
				Name:        "ZR",
				Description: "ZR is the zero [Rectangle]. Deprecated: Use a literal [image.Rectangle] instead. ",
				TypeName:    "Rectangle",
				TypePkgName: "image",
			},
		},
		"trace": []varSet{
			varSet{
				Name:        "NoStack",
				Description: "NoStack is a sentinel value that can be compared against any Stack value, indicating a lack of a stack trace. ",
				TypeName:    "Stack",
				TypePkgName: "trace",
			},
		},
		"cpu": []varSet{
			varSet{
				Name:        "ARM",
				Description: "The booleans in ARM contain the correspondingly named cpu feature bit. The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasVFPv4 bool; HasIDIVA bool; HasV7Atomics bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64",
				Description: "The booleans in ARM64 contain the correspondingly named cpu feature bit. The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasAES bool; HasPMULL bool; HasSHA1 bool; HasSHA2 bool; HasSHA512 bool; HasSHA3 bool; HasCRC32 bool; HasATOMICS bool; HasCPUID bool; HasDIT bool; IsNeoverse bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "CacheLineSize",
				Description: "CacheLineSize is the CPU's assumed cache line size. There is currently no runtime detection of the real cache line size so we use the constant per GOARCH CacheLinePadSize as an approximation. ",
				TypeName:    "uintptr",
				TypePkgName: "",
			},
			varSet{
				Name:        "DebugOptions",
				Description: "DebugOptions is set to true by the runtime if the OS supports reading GODEBUG early in runtime startup. This should not be changed after it is initialized. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "Loong64",
				Description: "The booleans in Loong64 contain the correspondingly named cpu feature bit. The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasLSX bool; HasLASX bool; HasCRC32 bool; HasLAMCAS bool; HasLAM_BH bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "MIPS64X",
				Description: "",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasMSA bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "PPC64",
				Description: "For ppc64(le), it is safe to check only for ISA level starting on ISA v3.00, since there are no optional categories. There are some exceptions that also require kernel support to work (darn, scv), so there are feature bits for those as well. The minimum processor requirement is POWER8 (ISA 2.07). The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasDARN bool; HasSCV bool; IsPOWER8 bool; IsPOWER9 bool; IsPOWER10 bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "RISCV64",
				Description: "RISCV64 contains the supported CPU features and performance characteristics for riscv64 platforms. The booleans in RISCV64, with the exception of HasFastMisaligned, indicate the presence of RISC-V extensions. The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasFastMisaligned bool; HasV bool; HasZbb bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390X",
				Description: "",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasZARCH bool; HasSTFLE bool; HasLDISP bool; HasEIMM bool; HasDFP bool; HasETF3EH bool; HasMSA bool; HasAES bool; HasAESCBC bool; HasAESCTR bool; HasAESGCM bool; HasGHASH bool; HasSHA1 bool; HasSHA256 bool; HasSHA512 bool; HasSHA3 bool; HasVX bool; HasVXE bool; HasKDSA bool; HasECDSA bool; HasEDDSA bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86",
				Description: "The booleans in X86 contain the correspondingly named cpuid feature bit. HasAVX and HasAVX2 are only set if the OS does support XMM and YMM registers in addition to the cpuid feature bit being set. The struct is padded to avoid false sharing. ",
				TypeName:    "struct{_ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasAVX512F bool; HasAVX512BW bool; HasAVX512VL bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFSRM bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSHA bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; _ internal/cpu.CacheLinePad}",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64HasAES",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64HasPMULL",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64HasSHA2",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64HasSHA3",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "ARM64HasSHA512",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "LOONG64HasLASX",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "LOONG64HasLSX",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasAES",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasAESCBC",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasAESCTR",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasAESGCM",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasECDSA",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasGHASH",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasSHA256",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasSHA3",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "S390XHasSHA512",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasADX",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasAES",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasAVX",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasAVX2",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasBMI2",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasPCLMULQDQ",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasSHA",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasSSE41",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "X86HasSSSE3",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"unicode": []varSet{
			varSet{
				Name:        "ASCII_Hex_Digit",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Adlam",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ahom",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Anatolian_Hieroglyphs",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Arabic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Armenian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Avestan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "AzeriCase",
				Description: "",
				TypeName:    "SpecialCase",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Balinese",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bamum",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bassa_Vah",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Batak",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bengali",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bhaiksuki",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bidi_Control",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Bopomofo",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Brahmi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Braille",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Buginese",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Buhid",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "C",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Canadian_Aboriginal",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Carian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "CaseRanges",
				Description: "CaseRanges is the table describing case mappings for all letters with non-self mappings. ",
				TypeName:    "[]unicode.CaseRange",
				TypePkgName: "",
			},
			varSet{
				Name:        "Categories",
				Description: "Categories is the set of Unicode category tables. ",
				TypeName:    "map[string]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "CategoryAliases",
				Description: "CategoryAliases maps category aliases to standard category names. ",
				TypeName:    "map[string]string",
				TypePkgName: "",
			},
			varSet{
				Name:        "Caucasian_Albanian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cc",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cf",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Chakma",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cham",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cherokee",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Chorasmian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cn",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Co",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Common",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Coptic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cs",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cuneiform",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cypriot",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cypro_Minoan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Cyrillic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Dash",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Deprecated",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Deseret",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Devanagari",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Diacritic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Digit",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Dives_Akuru",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Dogra",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Duployan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Egyptian_Hieroglyphs",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Elbasan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Elymaic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ethiopic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Extender",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "FoldCategory",
				Description: "FoldCategory maps a category name to a table of code points outside the category that are equivalent under simple case folding to code points inside the category. If there is no entry for a category name, there are no such points. ",
				TypeName:    "map[string]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "FoldScript",
				Description: "FoldScript maps a script name to a table of code points outside the script that are equivalent under simple case folding to code points inside the script. If there is no entry for a script name, there are no such points. ",
				TypeName:    "map[string]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "Georgian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Glagolitic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Gothic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Grantha",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "GraphicRanges",
				Description: "GraphicRanges defines the set of graphic characters according to Unicode. ",
				TypeName:    "[]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "Greek",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Gujarati",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Gunjala_Gondi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Gurmukhi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Han",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hangul",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hanifi_Rohingya",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hanunoo",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hatran",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hebrew",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hex_Digit",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hiragana",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Hyphen",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "IDS_Binary_Operator",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "IDS_Trinary_Operator",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ideographic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Imperial_Aramaic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Inherited",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Inscriptional_Pahlavi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Inscriptional_Parthian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Javanese",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Join_Control",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Kaithi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Kannada",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Katakana",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Kawi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Kayah_Li",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Kharoshthi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Khitan_Small_Script",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Khmer",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Khojki",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Khudawadi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "L",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "LC",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lao",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Latin",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lepcha",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Letter",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Limbu",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Linear_A",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Linear_B",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lisu",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ll",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lm",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lo",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Logical_Order_Exception",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lower",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lt",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lu",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lycian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Lydian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "M",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mahajani",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Makasar",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Malayalam",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mandaic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Manichaean",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Marchen",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mark",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Masaram_Gondi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mc",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Me",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Medefaidrin",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Meetei_Mayek",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mende_Kikakui",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Meroitic_Cursive",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Meroitic_Hieroglyphs",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Miao",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mn",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Modi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mongolian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Mro",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Multani",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Myanmar",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "N",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nabataean",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nag_Mundari",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nandinagari",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nd",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "New_Tai_Lue",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Newa",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nko",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nl",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "No",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Noncharacter_Code_Point",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Number",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nushu",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Nyiakeng_Puachue_Hmong",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ogham",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ol_Chiki",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Hungarian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Italic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_North_Arabian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Permic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Persian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Sogdian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_South_Arabian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Turkic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Old_Uyghur",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Oriya",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Osage",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Osmanya",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Alphabetic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Default_Ignorable_Code_Point",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Grapheme_Extend",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_ID_Continue",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_ID_Start",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Lowercase",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Math",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Other_Uppercase",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "P",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pahawh_Hmong",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Palmyrene",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pattern_Syntax",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pattern_White_Space",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pau_Cin_Hau",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pc",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pd",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pe",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pf",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Phags_Pa",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Phoenician",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Pi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Po",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Prepended_Concatenation_Mark",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "PrintRanges",
				Description: "PrintRanges defines the set of printable characters according to Go. ASCII space, U+0020, is handled separately. ",
				TypeName:    "[]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "Properties",
				Description: "Properties is the set of Unicode property tables. ",
				TypeName:    "map[string]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "Ps",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Psalter_Pahlavi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Punct",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Quotation_Mark",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Radical",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Regional_Indicator",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Rejang",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Runic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "S",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "STerm",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Samaritan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Saurashtra",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sc",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Scripts",
				Description: "Scripts is the set of Unicode script tables. ",
				TypeName:    "map[string]*unicode.RangeTable",
				TypePkgName: "",
			},
			varSet{
				Name:        "Sentence_Terminal",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sharada",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Shavian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Siddham",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "SignWriting",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sinhala",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sk",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sm",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "So",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Soft_Dotted",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sogdian",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sora_Sompeng",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Soyombo",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Space",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Sundanese",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Syloti_Nagri",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Symbol",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Syriac",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tagalog",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tagbanwa",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tai_Le",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tai_Tham",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tai_Viet",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Takri",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tamil",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tangsa",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tangut",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Telugu",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Terminal_Punctuation",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Thaana",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Thai",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tibetan",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tifinagh",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Tirhuta",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Title",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Toto",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "TurkishCase",
				Description: "",
				TypeName:    "SpecialCase",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Ugaritic",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Unified_Ideograph",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Upper",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Vai",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Variation_Selector",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Vithkuqi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Wancho",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Warang_Citi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "White_Space",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Yezidi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Yi",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Z",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Zanabazar_Square",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Zl",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Zp",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
			varSet{
				Name:        "Zs",
				Description: "These variables have type *RangeTable. ",
				TypeName:    "RangeTable",
				TypePkgName: "unicode",
			},
		},
		"bufio": []varSet{
			varSet{
				Name:        "ErrAdvanceTooFar",
				Description: "Errors returned by Scanner. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrBadReadCount",
				Description: "Errors returned by Scanner. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrBufferFull",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrFinalToken",
				Description: "ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the scanning should stop with no error. If the token being delivered with this error is not nil, the token is the last token. The value is useful to stop processing early or when it is necessary to deliver a final empty token (which is different from a nil token). One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInvalidUnreadByte",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInvalidUnreadRune",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNegativeAdvance",
				Description: "Errors returned by Scanner. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNegativeCount",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrTooLong",
				Description: "Errors returned by Scanner. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"fips140": []varSet{
			varSet{
				Name:        "Enabled",
				Description: "",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"dsa": []varSet{
			varSet{
				Name:        "ErrInvalidPublicKey",
				Description: "ErrInvalidPublicKey results when a public key is not usable by this code. FIPS is quite strict about the format of DSA keys, but other code may be less so. Thus, when using keys which may have been generated by other code, this error must be handled. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"base32": []varSet{
			varSet{
				Name:        "HexEncoding",
				Description: "HexEncoding is the âExtended Hex Alphabetâ defined in RFC 4648. It is typically used in DNS. ",
				TypeName:    "Encoding",
				TypePkgName: "base32",
			},
			varSet{
				Name:        "StdEncoding",
				Description: "StdEncoding is the standard base32 encoding, as defined in RFC 4648. ",
				TypeName:    "Encoding",
				TypePkgName: "base32",
			},
		},
		"xml": []varSet{
			varSet{
				Name:        "HTMLAutoClose",
				Description: "HTMLAutoClose is the set of HTML elements that should be considered to close automatically. See the [Decoder.Strict] and [Decoder.Entity] fields' documentation. ",
				TypeName:    "[]string",
				TypePkgName: "",
			},
			varSet{
				Name:        "HTMLEntity",
				Description: "HTMLEntity is an entity map containing translations for the standard HTML entity characters. See the [Decoder.Strict] and [Decoder.Entity] fields' documentation. ",
				TypeName:    "map[string]string",
				TypePkgName: "",
			},
		},
		"palette": []varSet{
			varSet{
				Name:        "Plan9",
				Description: "Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4Ã4Ã4 subdivision, with 4 shades in each subcube. Compared to the [WebSafe], the idea is to reduce the color resolution by dicing the color cube into fewer cells, and to use the extra space to increase the intensity resolution. This results in 16 gray shades (4 gray subcubes with 4 samples in each), 13 shades of each primary and secondary color (3 subcubes with 4 samples plus black) and a reasonable selection of colors covering the rest of the color cube. The advantage is better representation of continuous tones. This palette was used in the Plan 9 Operating System, described at https://9p.io/magic/man2html/6/color ",
				TypeName:    "[]image/color.Color",
				TypePkgName: "",
			},
			varSet{
				Name:        "WebSafe",
				Description: "WebSafe is a 216-color palette that was popularized by early versions of Netscape Navigator. It is also known as the Netscape Color Cube. See https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors for details. ",
				TypeName:    "[]image/color.Color",
				TypePkgName: "",
			},
		},
		"elf": []varSet{
			varSet{
				Name:        "ErrNoSymbols",
				Description: "ErrNoSymbols is returned by [File.Symbols] and [File.DynamicSymbols] if there is no such section in the File. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"draw": []varSet{
			varSet{
				Name:        "FloydSteinberg",
				Description: "FloydSteinberg is a [Drawer] that is the [Src] [Op] with Floyd-Steinberg error diffusion. ",
				TypeName:    "Drawer",
				TypePkgName: "draw",
			},
		},
		"asmgen": []varSet{
			varSet{
				Name:        "Arch386",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchAMD64",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchARM",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchARM64",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchLoong64",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchMIPS",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchMIPS64x",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchPPC64x",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchRISCV64",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
			varSet{
				Name:        "ArchS390X",
				Description: "",
				TypeName:    "Arch",
				TypePkgName: "asmgen",
			},
		},
		"strconv": []varSet{
			varSet{
				Name:        "ErrRange",
				Description: "ErrRange indicates that a value is out of range for the target type. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrSyntax",
				Description: "ErrSyntax indicates that a value does not have the right syntax for the target type. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"context": []varSet{
			varSet{
				Name:        "Canceled",
				Description: "Canceled is the error returned by [Context.Err] when the context is canceled for some reason other than its deadline passing. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "DeadlineExceeded",
				Description: "DeadlineExceeded is the error returned by [Context.Err] when the context is canceled due to its deadline passing. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"fips140only": []varSet{
			varSet{
				Name:        "Enabled",
				Description: "Enabled reports whether FIPS 140-only mode is enabled, in which non-approved cryptography returns an error or panics. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
		},
		"testenv": []varSet{
			varSet{
				Name:        "NoSpecialBuildTypes",
				Description: "NoSpecialBuildTypes indicates a standard, no cgo go build. ",
				TypeName:    "SpecialBuildTypes",
				TypePkgName: "testenv",
			},
			varSet{
				Name:        "Sigquit",
				Description: "Sigquit is the signal to send to kill a hanging subprocess. Send SIGQUIT to get a stack trace. ",
				TypeName:    "Signal",
				TypePkgName: "syscall",
			},
		},
		"buildcfg": []varSet{
			varSet{
				Name:        "Error",
				Description: "Error is one of the errors found (if any) in the build configuration. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "Experiment",
				Description: "Experiment contains the toolchain experiments enabled for the current build. (This is not necessarily the set of experiments the compiler itself was built with.) Experiment.baseline specifies the experiment flags that are enabled by default in the current toolchain. This is, in effect, the \"control\" configuration and any variation from this is an experiment. ",
				TypeName:    "ExperimentFlags",
				TypePkgName: "buildcfg",
			},
			varSet{
				Name:        "FramePointerEnabled",
				Description: "FramePointerEnabled enables the use of platform conventions for saving frame pointers. This used to be an experiment, but now it's always enabled on platforms that support it. Note: must agree with runtime.framepointer_enabled. ",
				TypeName:    "bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "GO386",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOAMD64",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOARCH",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOARM",
				Description: "",
				TypeName:    "GoarmFeatures",
				TypePkgName: "buildcfg",
			},
			varSet{
				Name:        "GOARM64",
				Description: "",
				TypeName:    "Goarm64Features",
				TypePkgName: "buildcfg",
			},
			varSet{
				Name:        "GOFIPS140",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOMIPS",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOMIPS64",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOOS",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOPPC64",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "GORISCV64",
				Description: "",
				TypeName:    "int",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOROOT",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "GOWASM",
				Description: "",
				TypeName:    "gowasmFeatures",
				TypePkgName: "buildcfg",
			},
			varSet{
				Name:        "GO_LDSO",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
			varSet{
				Name:        "ToolTags",
				Description: "",
				TypeName:    "[]string",
				TypePkgName: "",
			},
			varSet{
				Name:        "Version",
				Description: "",
				TypeName:    "string",
				TypePkgName: "",
			},
		},
		"types": []varSet{
			varSet{
				Name:        "Typ",
				Description: "Typ contains the predeclared *Basic types indexed by their corresponding BasicKind. The *Basic type for Typ[Byte] will have the name \"uint8\". Use Universe.Lookup(\"byte\").Type() to obtain the specific alias basic type named \"byte\" (and analogous for \"rune\"). ",
				TypeName:    "[]*go/types.Basic",
				TypePkgName: "",
			},
			varSet{
				Name:        "Universe",
				Description: "The Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes. ",
				TypeName:    "Scope",
				TypePkgName: "types",
			},
			varSet{
				Name:        "Unsafe",
				Description: "The Unsafe package is the package returned by an importer for the import path \"unsafe\". ",
				TypeName:    "Package",
				TypePkgName: "types",
			},
		},
		"errors": []varSet{
			varSet{
				Name:        "ErrUnsupported",
				Description: "ErrUnsupported indicates that a requested operation cannot be performed, because it is unsupported. For example, a call to [os.Link] when using a file system that does not support hard links. Functions and methods should not return this error but should instead return an error including appropriate context that satisfies errors.Is(err, errors.ErrUnsupported) either by directly wrapping ErrUnsupported or by implementing an [Is] method. Functions and methods should document the cases in which an error wrapping this will be returned. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"poll": []varSet{
			varSet{
				Name:        "AcceptFunc",
				Description: "AcceptFunc is used to hook the accept call. ",
				TypeName:    "func(int) (int, syscall.Sockaddr, error)",
				TypePkgName: "",
			},
			varSet{
				Name:        "CloseFunc",
				Description: "CloseFunc is used to hook the close call. ",
				TypeName:    "func(int) error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrDeadlineExceeded",
				Description: "ErrDeadlineExceeded is returned for an expired deadline. This is exported by the os package as os.ErrDeadlineExceeded. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrFileClosing",
				Description: "ErrFileClosing is returned when a file descriptor is used after it has been closed. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNetClosing",
				Description: "ErrNetClosing is returned when a network descriptor is used after it has been closed. ",
				TypeName:    "errNetClosing",
				TypePkgName: "poll",
			},
			varSet{
				Name:        "ErrNoDeadline",
				Description: "ErrNoDeadline is returned when a request is made to set a deadline on a file type that does not use the poller. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotPollable",
				Description: "ErrNotPollable is returned when the file or socket is not suitable for event notification. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "TestHookDidSendFile",
				Description: "",
				TypeName:    "func(dstFD *internal/poll.FD, src uintptr, written int64, err error, handled bool)",
				TypePkgName: "",
			},
			varSet{
				Name:        "TestHookDidWritev",
				Description: "TestHookDidWritev is a hook for testing writev. ",
				TypeName:    "func(wrote int)",
				TypePkgName: "",
			},
		},
		"binary": []varSet{
			varSet{
				Name:        "BigEndian",
				Description: "BigEndian is the big-endian implementation of [ByteOrder] and [AppendByteOrder]. ",
				TypeName:    "bigEndian",
				TypePkgName: "binary",
			},
			varSet{
				Name:        "LittleEndian",
				Description: "LittleEndian is the little-endian implementation of [ByteOrder] and [AppendByteOrder]. ",
				TypeName:    "littleEndian",
				TypePkgName: "binary",
			},
			varSet{
				Name:        "NativeEndian",
				Description: "NativeEndian is the native-endian implementation of [ByteOrder] and [AppendByteOrder]. ",
				TypeName:    "nativeEndian",
				TypePkgName: "binary",
			},
		},
		"color": []varSet{
			varSet{
				Name:        "Alpha16Model",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "AlphaModel",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "Black",
				Description: "Standard colors. ",
				TypeName:    "Gray16",
				TypePkgName: "color",
			},
			varSet{
				Name:        "CMYKModel",
				Description: "CMYKModel is the [Model] for CMYK colors. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "Gray16Model",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "GrayModel",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "NRGBA64Model",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "NRGBAModel",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "NYCbCrAModel",
				Description: "NYCbCrAModel is the [Model] for non-alpha-premultiplied Y'CbCr-with-alpha colors. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "Opaque",
				Description: "Standard colors. ",
				TypeName:    "Alpha16",
				TypePkgName: "color",
			},
			varSet{
				Name:        "RGBA64Model",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "RGBAModel",
				Description: "Models for the standard color types. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
			varSet{
				Name:        "Transparent",
				Description: "Standard colors. ",
				TypeName:    "Alpha16",
				TypePkgName: "color",
			},
			varSet{
				Name:        "White",
				Description: "Standard colors. ",
				TypeName:    "Gray16",
				TypePkgName: "color",
			},
			varSet{
				Name:        "YCbCrModel",
				Description: "YCbCrModel is the [Model] for Y'CbCr colors. ",
				TypeName:    "Model",
				TypePkgName: "color",
			},
		},
		"rtcov": []varSet{
			varSet{
				Name:        "Meta",
				Description: "Meta is the top-level container for bits of state related to code coverage meta-data in the runtime. ",
				TypeName:    "struct{List []internal/coverage/rtcov.CovMetaBlob; PkgMap map[int]int; hardCodedListNeedsUpdating bool}",
				TypePkgName: "",
			},
		},
		"flag": []varSet{
			varSet{
				Name:        "CommandLine",
				Description: "CommandLine is the default set of command-line flags, parsed from [os.Args]. The top-level functions such as [BoolVar], [Arg], and so on are wrappers for the methods of CommandLine. ",
				TypeName:    "FlagSet",
				TypePkgName: "flag",
			},
			varSet{
				Name:        "ErrHelp",
				Description: "ErrHelp is the error returned if the -help or -h flag is invoked but no such flag is defined. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "Usage",
				Description: "Usage prints a usage message documenting all defined command-line flags to [CommandLine]'s output, which by default is [os.Stderr]. It is called when an error occurs while parsing flags. The function is a variable that may be changed to point to a custom function. By default it prints a simple header and calls [PrintDefaults]; for details about the format of the output and how to control it, see the documentation for [PrintDefaults]. Custom usage functions may choose to exit the program; by default exiting happens anyway as the command line's error handling strategy is set to [ExitOnError]. ",
				TypeName:    "func()",
				TypePkgName: "",
			},
		},
		"syslist": []varSet{
			varSet{
				Name:        "KnownArch",
				Description: "KnownArch is the list of past, present, and future known GOARCH values. Do not remove from this list, as it is used for filename matching. ",
				TypeName:    "map[string]bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "KnownOS",
				Description: "KnownOS is the list of past, present, and future known GOOS values. Do not remove from this list, as it is used for filename matching. If you add an entry to this list, look at UnixOS, below. ",
				TypeName:    "map[string]bool",
				TypePkgName: "",
			},
			varSet{
				Name:        "UnixOS",
				Description: "UnixOS is the set of GOOS values matched by the \"unix\" build tag. This is not used for filename matching. This list also appears in cmd/dist/build.go. ",
				TypeName:    "map[string]bool",
				TypePkgName: "",
			},
		},
		"coverage": []varSet{
			varSet{
				Name:        "CovCounterMagic",
				Description: "CovCounterMagic holds the magic string for a coverage counter-data file. ",
				TypeName:    "[4]byte",
				TypePkgName: "",
			},
			varSet{
				Name:        "CovMetaMagic",
				Description: "CovMetaMagic holds the magic string for a meta-data file. ",
				TypeName:    "[4]byte",
				TypePkgName: "",
			},
		},
		"zlib": []varSet{
			varSet{
				Name:        "ErrChecksum",
				Description: "ErrChecksum is returned when reading ZLIB data that has an invalid checksum. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrDictionary",
				Description: "ErrDictionary is returned when reading ZLIB data that has an invalid dictionary. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrHeader",
				Description: "ErrHeader is returned when reading ZLIB data that has an invalid header. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"godebugs": []varSet{
			varSet{
				Name:        "All",
				Description: "All is the table of known settings, sorted by Name. Note: After adding entries to this table, run 'go generate runtime/metrics' to update the runtime/metrics doc comment. (Otherwise the runtime/metrics test will fail.) Note: After adding entries to this table, update the list in doc/godebug.md as well. (Otherwise the test in this package will fail.) ",
				TypeName:    "[]internal/godebugs.Info",
				TypePkgName: "",
			},
		},
		"asn1": []varSet{
			varSet{
				Name:        "NullBytes",
				Description: "NullBytes contains bytes representing the DER-encoded ASN.1 NULL type. ",
				TypeName:    "[]byte",
				TypePkgName: "",
			},
			varSet{
				Name:        "NullRawValue",
				Description: "NullRawValue is a [RawValue] with its Tag set to the ASN.1 NULL type tag (5). ",
				TypeName:    "RawValue",
				TypePkgName: "asn1",
			},
		},
		"tracev1": []varSet{
			varSet{
				Name:        "ErrTimeOrder",
				Description: "ErrTimeOrder is returned by Parse when the trace contains time stamps that do not respect actual event ordering. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "EventDescriptions",
				Description: "",
				TypeName:    "[256]struct{Name string; minVersion internal/trace/version.Version; Stack bool; Args []string; SArgs []string}",
				TypePkgName: "",
			},
		},
		"slog": []varSet{
			varSet{
				Name:        "DiscardHandler",
				Description: "DiscardHandler discards all log output. DiscardHandler.Enabled returns false for all Levels. ",
				TypeName:    "Handler",
				TypePkgName: "slog",
			},
		},
		"mail": []varSet{
			varSet{
				Name:        "ErrHeaderNotPresent",
				Description: "",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"driver": []varSet{
			varSet{
				Name:        "Bool",
				Description: "Bool is a [ValueConverter] that converts input values to bool. The conversion rules are: - booleans are returned unchanged - for integer types, 1 is true 0 is false, other integers are an error - for strings and []byte, same rules as [strconv.ParseBool] - all other types are an error ",
				TypeName:    "boolType",
				TypePkgName: "driver",
			},
			varSet{
				Name:        "DefaultParameterConverter",
				Description: "DefaultParameterConverter is the default implementation of [ValueConverter] that's used when a [Stmt] doesn't implement [ColumnConverter]. DefaultParameterConverter returns its argument directly if IsValue(arg). Otherwise, if the argument implements [Valuer], its Value method is used to return a [Value]. As a fallback, the provided argument's underlying type is used to convert it to a [Value]: underlying integer types are converted to int64, floats to float64, bool, string, and []byte to themselves. If the argument is a nil pointer, defaultConverter.ConvertValue returns a nil [Value]. If the argument is a non-nil pointer, it is dereferenced and defaultConverter.ConvertValue is called recursively. Other types are an error. ",
				TypeName:    "defaultConverter",
				TypePkgName: "driver",
			},
			varSet{
				Name:        "ErrBadConn",
				Description: "ErrBadConn should be returned by a driver to signal to the [database/sql] package that a driver.[Conn] is in a bad state (such as the server having earlier closed the connection) and the [database/sql] package should retry on a new connection. To prevent duplicate operations, ErrBadConn should NOT be returned if there's a possibility that the database server might have performed the operation. Even if the server sends back an error, you shouldn't return ErrBadConn. Errors will be checked using [errors.Is]. An error may wrap ErrBadConn or implement the Is(error) bool method. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrRemoveArgument",
				Description: "ErrRemoveArgument may be returned from [NamedValueChecker] to instruct the [database/sql] package to not pass the argument to the driver query interface. Return when accepting query specific options or structures that aren't SQL query arguments. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrSkip",
				Description: "ErrSkip may be returned by some optional interfaces' methods to indicate at runtime that the fast path is unavailable and the sql package should continue as if the optional interface was not implemented. ErrSkip is only supported where explicitly documented. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "Int32",
				Description: "Int32 is a [ValueConverter] that converts input values to int64, respecting the limits of an int32 value. ",
				TypeName:    "int32Type",
				TypePkgName: "driver",
			},
			varSet{
				Name:        "ResultNoRows",
				Description: "ResultNoRows is a pre-defined [Result] for drivers to return when a DDL command (such as a CREATE TABLE) succeeds. It returns an error for both LastInsertId and [RowsAffected]. ",
				TypeName:    "noRows",
				TypePkgName: "driver",
			},
		},
		"sql": []varSet{
			varSet{
				Name:        "ErrConnDone",
				Description: "ErrConnDone is returned by any operation that is performed on a connection that has already been returned to the connection pool. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNoRows",
				Description: "ErrNoRows is returned by [Row.Scan] when [DB.QueryRow] doesn't return a row. In such a case, QueryRow returns a placeholder [*Row] value that defers this error until a Scan. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrTxDone",
				Description: "ErrTxDone is returned by any operation that is performed on a transaction that has already been committed or rolled back. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"bytealg": []varSet{
			varSet{
				Name:        "MaxLen",
				Description: "MaxLen is the maximum length of the string to be searched for (argument b) in Index. If MaxLen is not 0, make sure MaxLen >= 4. ",
				TypeName:    "int",
				TypePkgName: "",
			},
		},
		"gc": []varSet{
			varSet{
				Name:        "SizeClassToDivMagic",
				Description: "",
				TypeName:    "[68]uint32",
				TypePkgName: "",
			},
			varSet{
				Name:        "SizeClassToNPages",
				Description: "",
				TypeName:    "[68]uint8",
				TypePkgName: "",
			},
			varSet{
				Name:        "SizeClassToSize",
				Description: "",
				TypeName:    "[68]uint16",
				TypePkgName: "",
			},
			varSet{
				Name:        "SizeToSizeClass128",
				Description: "",
				TypeName:    "[249]uint8",
				TypePkgName: "",
			},
			varSet{
				Name:        "SizeToSizeClass8",
				Description: "",
				TypeName:    "[129]uint8",
				TypePkgName: "",
			},
		},
		"os": []varSet{
			varSet{
				Name:        "Args",
				Description: "Args hold the command-line arguments, starting with the program name. ",
				TypeName:    "[]string",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrClosed",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrDeadlineExceeded",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrExist",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrInvalid",
				Description: "ErrInvalid indicates an invalid argument. Methods on File will return this error when the receiver is nil. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNoDeadline",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrNotExist",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrPermission",
				Description: "Portable analogs of some common system call errors. Errors returned from this package may be tested against these errors with [errors.Is]. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "ErrProcessDone",
				Description: "ErrProcessDone indicates a [Process] has finished. ",
				TypeName:    "error",
				TypePkgName: "",
			},
			varSet{
				Name:        "Interrupt",
				Description: "The only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal. ",
				TypeName:    "Signal",
				TypePkgName: "os",
			},
			varSet{
				Name:        "Stderr",
				Description: "Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. ",
				TypeName:    "File",
				TypePkgName: "os",
			},
			varSet{
				Name:        "Stdin",
				Description: "Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. ",
				TypeName:    "File",
				TypePkgName: "os",
			},
			varSet{
				Name:        "Stdout",
				Description: "Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. ",
				TypeName:    "File",
				TypePkgName: "os",
			},
		},
		"doc": []varSet{
			varSet{
				Name:        "IllegalPrefixes",
				Description: "IllegalPrefixes is a list of lower-case prefixes that identify a comment as not being a doc comment. This helps to avoid misinterpreting the common mistake of a copyright notice immediately before a package statement as being a doc comment. ",
				TypeName:    "[]string",
				TypePkgName: "",
			},
		},
		"iotest": []varSet{
			varSet{
				Name:        "ErrTimeout",
				Description: "ErrTimeout is a fake timeout error. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"bytes": []varSet{
			varSet{
				Name:        "ErrTooLarge",
				Description: "ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
		"plan9obj": []varSet{
			varSet{
				Name:        "ErrNoSymbols",
				Description: "ErrNoSymbols is returned by [File.Symbols] if there is no such section in the File. ",
				TypeName:    "error",
				TypePkgName: "",
			},
		},
	},
	Consts: map[types.PkgName][]constSet{
		"token": []constSet{
			constSet{
				Name:        "ADD",
				Description: "Operators and delimiters ",
			},
			constSet{
				Name:        "ADD_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "AND",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "AND_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "AND_NOT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "AND_NOT_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "ARROW",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "BREAK",
				Description: "Keywords ",
			},
			constSet{
				Name:        "CASE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "CHAN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "CHAR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "COLON",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "COMMA",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "COMMENT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "CONST",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "CONTINUE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "DEC",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "DEFAULT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "DEFER",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "DEFINE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "ELLIPSIS",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "ELSE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "EOF",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "EQL",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "FALLTHROUGH",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "FLOAT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "FOR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "FUNC",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "GEQ",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "GO",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "GOTO",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "GTR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "HighestPrec",
				Description: "A set of constants for precedence-based expression parsing. Non-operators have lowest precedence, followed by operators starting with precedence 1 up to unary operators. The highest precedence serves as \"catch-all\" precedence for selector, indexing, and other operator and delimiter tokens. ",
			},
			constSet{
				Name:        "IDENT",
				Description: "Identifiers and basic type literals (these tokens stand for classes of literals) ",
			},
			constSet{
				Name:        "IF",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "ILLEGAL",
				Description: "Special tokens ",
			},
			constSet{
				Name:        "IMAG",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "IMPORT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "INC",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "INT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "INTERFACE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LAND",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LBRACE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LBRACK",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LEQ",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LOR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LPAREN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LSS",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "LowestPrec",
				Description: "A set of constants for precedence-based expression parsing. Non-operators have lowest precedence, followed by operators starting with precedence 1 up to unary operators. The highest precedence serves as \"catch-all\" precedence for selector, indexing, and other operator and delimiter tokens. ",
			},
			constSet{
				Name:        "MAP",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "MUL",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "MUL_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "NEQ",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "NOT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "NoPos",
				Description: "The zero value for [Pos] is NoPos; there is no file and line information associated with it, and NoPos.IsValid() is false. NoPos is always smaller than any other [Pos] value. The corresponding [Position] value for NoPos is the zero value for [Position]. ",
			},
			constSet{
				Name:        "OR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "OR_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "PACKAGE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "PERIOD",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "QUO",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "QUO_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "RANGE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "RBRACE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "RBRACK",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "REM",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "REM_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "RETURN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "RPAREN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SELECT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SEMICOLON",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SHL",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SHL_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SHR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SHR_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "STRING",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "STRUCT",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SUB",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SUB_ASSIGN",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "SWITCH",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "TILDE",
				Description: "additional tokens, handled in an ad-hoc manner ",
			},
			constSet{
				Name:        "TYPE",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "UnaryPrec",
				Description: "A set of constants for precedence-based expression parsing. Non-operators have lowest precedence, followed by operators starting with precedence 1 up to unary operators. The highest precedence serves as \"catch-all\" precedence for selector, indexing, and other operator and delimiter tokens. ",
			},
			constSet{
				Name:        "VAR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "XOR",
				Description: "The list of tokens. ",
			},
			constSet{
				Name:        "XOR_ASSIGN",
				Description: "The list of tokens. ",
			},
		},
		"png": []constSet{
			constSet{
				Name:        "BestCompression",
				Description: "",
			},
			constSet{
				Name:        "BestSpeed",
				Description: "",
			},
			constSet{
				Name:        "DefaultCompression",
				Description: "",
			},
			constSet{
				Name:        "NoCompression",
				Description: "",
			},
		},
		"trace": []constSet{
			constSet{
				Name:        "BackgroundTask",
				Description: "BackgroundTask is the global task that events are attached to if there was no other task in the context at the point the event was emitted. ",
			},
			constSet{
				Name:        "EventBad",
				Description: "",
			},
			constSet{
				Name:        "EventExperimental",
				Description: "EventExperimental is an experimental event that is unvalidated and exposed in a raw form. Users are expected to understand the format and perform their own validation. These events may always be safely ignored. ",
			},
			constSet{
				Name:        "EventLabel",
				Description: "EventLabel attaches a label to a resource. ",
			},
			constSet{
				Name:        "EventLog",
				Description: "EventLog represents a runtime/trace.Log call. ",
			},
			constSet{
				Name:        "EventMetric",
				Description: "EventMetric is an event that represents the value of a metric at a particular point in time. ",
			},
			constSet{
				Name:        "EventRangeActive",
				Description: "",
			},
			constSet{
				Name:        "EventRangeBegin",
				Description: "EventRangeBegin and EventRangeEnd are a pair of generic events representing a special range of time. Ranges are named and scoped to some resource (identified via ResourceKind). A range that has begun but has not ended is considered active. EvRangeBegin and EvRangeEnd will share the same name, and an End will always follow a Begin on the same instance of the resource. The associated resource ID can be obtained from the Event. ResourceNone indicates the range is globally scoped. That is, any goroutine/proc/thread can start or stop, but only one such range may be active at any given time. EventRangeActive is like EventRangeBegin, but indicates that the range was already active. In this case, the resource referenced may not be in the current context. ",
			},
			constSet{
				Name:        "EventRangeEnd",
				Description: "",
			},
			constSet{
				Name:        "EventRegionBegin",
				Description: "EventRegionBegin and EventRegionEnd are a pair of events represent a runtime/trace.Region. ",
			},
			constSet{
				Name:        "EventRegionEnd",
				Description: "",
			},
			constSet{
				Name:        "EventStackSample",
				Description: "EventStackSample represents an execution sample, indicating what a thread/proc/goroutine was doing at a particular point in time via its backtrace. Note: Samples should be considered a close approximation of what a thread/proc/goroutine was executing at a given point in time. These events may slightly contradict the situation StateTransitions describe, so they should only be treated as a best-effort annotation. ",
			},
			constSet{
				Name:        "EventStateTransition",
				Description: "EventStateTransition represents a state change for some resource. ",
			},
			constSet{
				Name:        "EventSync",
				Description: "EventKindSync is an event that indicates a global synchronization point in the trace. At the point of a sync event, the trace reader can be certain that all resources (e.g. threads, goroutines) that have existed until that point have been enumerated. ",
			},
			constSet{
				Name:        "EventTaskBegin",
				Description: "EvTaskBegin and EvTaskEnd are a pair of events representing a runtime/trace.Task. ",
			},
			constSet{
				Name:        "EventTaskEnd",
				Description: "",
			},
			constSet{
				Name:        "GoNotExist",
				Description: "",
			},
			constSet{
				Name:        "GoRunnable",
				Description: "",
			},
			constSet{
				Name:        "GoRunning",
				Description: "",
			},
			constSet{
				Name:        "GoSyscall",
				Description: "",
			},
			constSet{
				Name:        "GoUndetermined",
				Description: "",
			},
			constSet{
				Name:        "GoWaiting",
				Description: "",
			},
			constSet{
				Name:        "NoGoroutine",
				Description: "NoGoroutine indicates that the relevant events don't correspond to any goroutine in particular. ",
			},
			constSet{
				Name:        "NoProc",
				Description: "NoProc indicates that the relevant events don't correspond to any P in particular. ",
			},
			constSet{
				Name:        "NoTask",
				Description: "NoTask indicates the lack of a task. ",
			},
			constSet{
				Name:        "NoThread",
				Description: "NoThread indicates that the relevant events don't correspond to any thread in particular. ",
			},
			constSet{
				Name:        "ProcIdle",
				Description: "",
			},
			constSet{
				Name:        "ProcNotExist",
				Description: "",
			},
			constSet{
				Name:        "ProcRunning",
				Description: "",
			},
			constSet{
				Name:        "ProcUndetermined",
				Description: "",
			},
			constSet{
				Name:        "ResourceGoroutine",
				Description: "",
			},
			constSet{
				Name:        "ResourceNone",
				Description: "",
			},
			constSet{
				Name:        "ResourceProc",
				Description: "",
			},
			constSet{
				Name:        "ResourceThread",
				Description: "",
			},
			constSet{
				Name:        "UtilAssist",
				Description: "UtilAssist means utilization should account for mark assists. ",
			},
			constSet{
				Name:        "UtilBackground",
				Description: "UtilBackground means utilization should account for background mark workers. ",
			},
			constSet{
				Name:        "UtilPerProc",
				Description: "UtilPerProc means each P should be given a separate utilization function. Otherwise, there is a single function and each P is given a fraction of the utilization. ",
			},
			constSet{
				Name:        "UtilSTW",
				Description: "UtilSTW means utilization should account for STW events. This includes non-GC STW events, which are typically user-requested. ",
			},
			constSet{
				Name:        "UtilSweep",
				Description: "UtilSweep means utilization should account for sweeping. ",
			},
			constSet{
				Name:        "ValueBad",
				Description: "",
			},
			constSet{
				Name:        "ValueString",
				Description: "",
			},
			constSet{
				Name:        "ValueUint64",
				Description: "",
			},
		},
		"asan": []constSet{
			constSet{
				Name:        "Enabled",
				Description: "",
			},
		},
		"bits": []constSet{
			constSet{
				Name:        "UintSize",
				Description: "UintSize is the size of a uint in bits. ",
			},
		},
		"sha512": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "BlockSize is the block size, in bytes, of the SHA-512/224, SHA-512/256, SHA-384 and SHA-512 hash functions. ",
			},
			constSet{
				Name:        "Size",
				Description: "Size is the size, in bytes, of a SHA-512 checksum. ",
			},
			constSet{
				Name:        "Size224",
				Description: "Size224 is the size, in bytes, of a SHA-512/224 checksum. ",
			},
			constSet{
				Name:        "Size256",
				Description: "Size256 is the size, in bytes, of a SHA-512/256 checksum. ",
			},
			constSet{
				Name:        "Size384",
				Description: "Size384 is the size, in bytes, of a SHA-384 checksum. ",
			},
		},
		"macOS": []constSet{
			constSet{
				Name:        "ErrSecCertificateExpired",
				Description: "various macOS error codes that can be returned from SecTrustEvaluateWithError that we can map to Go cert verification error types. ",
			},
			constSet{
				Name:        "ErrSecHostNameMismatch",
				Description: "",
			},
			constSet{
				Name:        "ErrSecNotTrusted",
				Description: "",
			},
		},
		"tls": []constSet{
			constSet{
				Name:        "CurveP256",
				Description: "",
			},
			constSet{
				Name:        "CurveP384",
				Description: "",
			},
			constSet{
				Name:        "CurveP521",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithP256AndSHA256",
				Description: "ECDSA algorithms. Only constrained to a specific curve in TLS 1.3. ",
			},
			constSet{
				Name:        "ECDSAWithP384AndSHA384",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithP521AndSHA512",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithSHA1",
				Description: "",
			},
			constSet{
				Name:        "Ed25519",
				Description: "EdDSA algorithms. ",
			},
			constSet{
				Name:        "NoClientCert",
				Description: "NoClientCert indicates that no client certificate should be requested during the handshake, and if any certificates are sent they will not be verified. ",
			},
			constSet{
				Name:        "PKCS1WithSHA1",
				Description: "Legacy signature and hash algorithms for TLS 1.2. ",
			},
			constSet{
				Name:        "PKCS1WithSHA256",
				Description: "RSASSA-PKCS1-v1_5 algorithms. ",
			},
			constSet{
				Name:        "PKCS1WithSHA384",
				Description: "",
			},
			constSet{
				Name:        "PKCS1WithSHA512",
				Description: "",
			},
			constSet{
				Name:        "PSSWithSHA256",
				Description: "RSASSA-PSS algorithms with public key OID rsaEncryption. ",
			},
			constSet{
				Name:        "PSSWithSHA384",
				Description: "",
			},
			constSet{
				Name:        "PSSWithSHA512",
				Description: "",
			},
			constSet{
				Name:        "QUICEncryptionLevelApplication",
				Description: "",
			},
			constSet{
				Name:        "QUICEncryptionLevelEarly",
				Description: "",
			},
			constSet{
				Name:        "QUICEncryptionLevelHandshake",
				Description: "",
			},
			constSet{
				Name:        "QUICEncryptionLevelInitial",
				Description: "",
			},
			constSet{
				Name:        "QUICHandshakeDone",
				Description: "QUICHandshakeDone indicates that the TLS handshake has completed. ",
			},
			constSet{
				Name:        "QUICNoEvent",
				Description: "QUICNoEvent indicates that there are no events available. ",
			},
			constSet{
				Name:        "QUICRejectedEarlyData",
				Description: "QUICRejectedEarlyData indicates that the server rejected 0-RTT data even if we offered it. It's returned before QUICEncryptionLevelApplication keys are returned. This event only occurs on client connections. ",
			},
			constSet{
				Name:        "QUICResumeSession",
				Description: "QUICResumeSession indicates that a client is attempting to resume a previous session. [QUICEvent.SessionState] is set. For client connections, this event occurs when the session ticket is selected. For server connections, this event occurs when receiving the client's session ticket. The application may set [QUICEvent.SessionState.EarlyData] to false before the next call to [QUICConn.NextEvent] to decline 0-RTT even if the session supports it. ",
			},
			constSet{
				Name:        "QUICSetReadSecret",
				Description: "QUICSetReadSecret and QUICSetWriteSecret provide the read and write secrets for a given encryption level. QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set. Secrets for the Initial encryption level are derived from the initial destination connection ID, and are not provided by the QUICConn. ",
			},
			constSet{
				Name:        "QUICSetWriteSecret",
				Description: "",
			},
			constSet{
				Name:        "QUICStoreSession",
				Description: "QUICStoreSession indicates that the server has provided state permitting the client to resume the session. [QUICEvent.SessionState] is set. The application should use [QUICConn.StoreSession] session to store the [SessionState]. The application may modify the [SessionState] before storing it. This event only occurs on client connections. ",
			},
			constSet{
				Name:        "QUICTransportParameters",
				Description: "QUICTransportParameters provides the peer's QUIC transport parameters. QUICEvent.Data is set. ",
			},
			constSet{
				Name:        "QUICTransportParametersRequired",
				Description: "QUICTransportParametersRequired indicates that the caller must provide QUIC transport parameters to send to the peer. The caller should set the transport parameters with QUICConn.SetTransportParameters and call QUICConn.NextEvent again. If transport parameters are set before calling QUICConn.Start, the connection will never generate a QUICTransportParametersRequired event. ",
			},
			constSet{
				Name:        "QUICWriteData",
				Description: "QUICWriteData provides data to send to the peer in CRYPTO frames. QUICEvent.Data is set. ",
			},
			constSet{
				Name:        "RenegotiateFreelyAsClient",
				Description: "RenegotiateFreelyAsClient allows a remote server to repeatedly request renegotiation. ",
			},
			constSet{
				Name:        "RenegotiateNever",
				Description: "RenegotiateNever disables renegotiation. ",
			},
			constSet{
				Name:        "RenegotiateOnceAsClient",
				Description: "RenegotiateOnceAsClient allows a remote server to request renegotiation once per connection. ",
			},
			constSet{
				Name:        "RequestClientCert",
				Description: "RequestClientCert indicates that a client certificate should be requested during the handshake, but does not require that the client send any certificates. ",
			},
			constSet{
				Name:        "RequireAndVerifyClientCert",
				Description: "RequireAndVerifyClientCert indicates that a client certificate should be requested during the handshake, and that at least one valid certificate is required to be sent by the client. ",
			},
			constSet{
				Name:        "RequireAnyClientCert",
				Description: "RequireAnyClientCert indicates that a client certificate should be requested during the handshake, and that at least one certificate is required to be sent by the client, but that certificate is not required to be valid. ",
			},
			constSet{
				Name:        "TLS_AES_128_GCM_SHA256",
				Description: "TLS 1.3 cipher suites. ",
			},
			constSet{
				Name:        "TLS_AES_256_GCM_SHA384",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_CHACHA20_POLY1305_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
				Description: "Legacy names for the corresponding cipher suites with the correct _SHA256 suffix, retained for backward compatibility. ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_FALLBACK_SCSV",
				Description: "TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator that the client is doing version fallback. See RFC 7507. ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_AES_128_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_AES_128_CBC_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_AES_128_GCM_SHA256",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_AES_256_CBC_SHA",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_AES_256_GCM_SHA384",
				Description: "A list of cipher suite IDs that are, or have been, implemented by this package. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml ",
			},
			constSet{
				Name:        "TLS_RSA_WITH_RC4_128_SHA",
				Description: "TLS 1.0 - 1.2 cipher suites. ",
			},
			constSet{
				Name:        "VerifyClientCertIfGiven",
				Description: "VerifyClientCertIfGiven indicates that a client certificate should be requested during the handshake, but does not require that the client sends a certificate. If the client does send a certificate it is required to be valid. ",
			},
			constSet{
				Name:        "VersionSSL30",
				Description: "Deprecated: SSLv3 is cryptographically broken, and is no longer supported by this package. See golang.org/issue/32716. ",
			},
			constSet{
				Name:        "VersionTLS10",
				Description: "",
			},
			constSet{
				Name:        "VersionTLS11",
				Description: "",
			},
			constSet{
				Name:        "VersionTLS12",
				Description: "",
			},
			constSet{
				Name:        "VersionTLS13",
				Description: "",
			},
			constSet{
				Name:        "X25519",
				Description: "",
			},
			constSet{
				Name:        "X25519MLKEM768",
				Description: "",
			},
		},
		"xml": []constSet{
			constSet{
				Name:        "Header",
				Description: "Header is a generic XML header suitable for use with the output of [Marshal]. This is not automatically added to any output of this package, it is provided as a convenience. ",
			},
		},
		"time": []constSet{
			constSet{
				Name:        "ANSIC",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "April",
				Description: "",
			},
			constSet{
				Name:        "August",
				Description: "",
			},
			constSet{
				Name:        "DateOnly",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "DateTime",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "December",
				Description: "",
			},
			constSet{
				Name:        "February",
				Description: "",
			},
			constSet{
				Name:        "Friday",
				Description: "",
			},
			constSet{
				Name:        "January",
				Description: "",
			},
			constSet{
				Name:        "July",
				Description: "",
			},
			constSet{
				Name:        "June",
				Description: "",
			},
			constSet{
				Name:        "Kitchen",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "Layout",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "March",
				Description: "",
			},
			constSet{
				Name:        "May",
				Description: "",
			},
			constSet{
				Name:        "Microsecond",
				Description: "Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. To count the number of units in a [Duration], divide: second := time.Second fmt.Print(int64(second/time.Millisecond)) // prints 1000 To convert an integer number of units to a Duration, multiply: seconds := 10 fmt.Print(time.Duration(seconds)*time.Second) // prints 10s ",
			},
			constSet{
				Name:        "Millisecond",
				Description: "Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. To count the number of units in a [Duration], divide: second := time.Second fmt.Print(int64(second/time.Millisecond)) // prints 1000 To convert an integer number of units to a Duration, multiply: seconds := 10 fmt.Print(time.Duration(seconds)*time.Second) // prints 10s ",
			},
			constSet{
				Name:        "Monday",
				Description: "",
			},
			constSet{
				Name:        "November",
				Description: "",
			},
			constSet{
				Name:        "October",
				Description: "",
			},
			constSet{
				Name:        "RFC1123",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC1123Z",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC3339",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC3339Nano",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC822",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC822Z",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RFC850",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "RubyDate",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "Saturday",
				Description: "",
			},
			constSet{
				Name:        "September",
				Description: "",
			},
			constSet{
				Name:        "Stamp",
				Description: "Handy time stamps. ",
			},
			constSet{
				Name:        "StampMicro",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "StampMilli",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "StampNano",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "Sunday",
				Description: "",
			},
			constSet{
				Name:        "Thursday",
				Description: "",
			},
			constSet{
				Name:        "TimeOnly",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "Tuesday",
				Description: "",
			},
			constSet{
				Name:        "UnixDate",
				Description: "These are predefined layouts for use in [Time.Format] and [time.Parse]. The reference time used in these layouts is the specific time stamp: 01/02 03:04:05PM '06 -0700 (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named [Layout], listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: Mon Jan 2 15:04:05 MST 2006 It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general [RFC1123Z] should be used instead of [RFC1123] for servers that insist on that format, and [RFC3339] should be preferred for new protocols. [RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The [RFC3339Nano] format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like [ANSIC], [StampMicro] or [Kitchen] for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Numeric time zone offsets format as follows: \"-0700\" Â±hhmm \"-07:00\" Â±hh:mm \"-07\" Â±hh \"-070000\" Â±hhmmss \"-07:00:00\" Â±hh:mm:ss Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or Â±hhmm \"Z07:00\" Z or Â±hh:mm \"Z07\" Z or Â±hh \"Z070000\" Z or Â±hhmmss \"Z07:00:00\" Z or Â±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. ",
			},
			constSet{
				Name:        "Wednesday",
				Description: "",
			},
		},
		"zlib": []constSet{
			constSet{
				Name:        "BestCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/zlib] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "BestSpeed",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/zlib] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "DefaultCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/zlib] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "HuffmanOnly",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/zlib] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "NoCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/zlib] does not also have to import [compress/flate]. ",
			},
		},
		"cfg": []constSet{
			constSet{
				Name:        "KnownEnv",
				Description: "KnownEnv is a list of environment variables that affect the operation of the Go command. ",
			},
		},
		"sha256": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "The blocksize of SHA256 and SHA224 in bytes. ",
			},
			constSet{
				Name:        "Size",
				Description: "The size of a SHA256 checksum in bytes. ",
			},
			constSet{
				Name:        "Size224",
				Description: "The size of a SHA224 checksum in bytes. ",
			},
		},
		"goversion": []constSet{
			constSet{
				Name:        "Version",
				Description: "Version is the Go 1.x version which is currently in development and will eventually get released. It should be updated at the start of each development cycle to be the version of the next Go 1.x release. See go.dev/issue/40705. ",
			},
		},
		"template": []constSet{
			constSet{
				Name:        "ErrAmbigContext",
				Description: "ErrAmbigContext: \"... appears in an ambiguous context within a URL\" Example: <a href=\" {{if .C}} /path/ {{else}} /search?q= {{end}} {{.X}} \"> Discussion: {{.X}} is in an ambiguous URL context since, depending on {{.C}}, it may be either a URL suffix or a query parameter. Moving {{.X}} into the condition removes the ambiguity: <a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\"> ",
			},
			constSet{
				Name:        "ErrBadHTML",
				Description: "ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\", \"... in unquoted attr\", \"... in attribute name\" Example: <a href = /search?q=foo> <href=foo> <form na<e=...> <option selected< Discussion: This is often due to a typo in an HTML element, but some runes are banned in tag names, attribute names, and unquoted attribute values because they can tickle parser ambiguities. Quoting all attributes is the best policy. ",
			},
			constSet{
				Name:        "ErrBranchEnd",
				Description: "ErrBranchEnd: \"{{if}} branches end in different contexts\" Examples: {{if .C}}<a href=\"{{end}}{{.X}} <script {{with .T}}type=\"{{.}}\"{{end}}> Discussion: Package html/template statically examines each path through an {{if}}, {{range}}, or {{with}} to escape any following pipelines. The first example is ambiguous since {{.X}} might be an HTML text node, or a URL prefix in an HTML attribute. The context of {{.X}} is used to figure out how to escape it, but that context depends on the run-time value of {{.C}} which is not statically known. The second example is ambiguous as the script type attribute can change the type of escaping needed for the script contents. The problem is usually something like missing quotes or angle brackets, or can be avoided by refactoring to put the two contexts into different branches of an if, range or with. If the problem is in a {{range}} over a collection that should never be empty, adding a dummy {{else}} can help. ",
			},
			constSet{
				Name:        "ErrEndContext",
				Description: "ErrEndContext: \"... ends in a non-text context: ...\" Examples: <div <div title=\"no close quote> <script>f() Discussion: Executed templates should produce a DocumentFragment of HTML. Templates that end without closing tags will trigger this error. Templates that should not be used in an HTML context or that produce incomplete Fragments should not be executed directly. {{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}} {{define \"helper\"}} document.write(' <div title=\" ') {{end}} \"helper\" does not produce a valid document fragment, so should not be Executed directly. ",
			},
			constSet{
				Name:        "ErrJSTemplate",
				Description: "ErrJSTemplate: \"... appears in a JS template literal\" Example: <script>var tmpl = `{{.Interp}}`</script> Discussion: Package html/template does not support actions inside of JS template literals. Deprecated: ErrJSTemplate is no longer returned when an action is present in a JS template literal. Actions inside of JS template literals are now escaped as expected. ",
			},
			constSet{
				Name:        "ErrNoSuchTemplate",
				Description: "ErrNoSuchTemplate: \"no such template ...\" Examples: {{define \"main\"}}<div {{template \"attrs\"}}>{{end}} {{define \"attrs\"}}href=\"{{.URL}}\"{{end}} Discussion: Package html/template looks through template calls to compute the context. Here the {{.URL}} in \"attrs\" must be treated as a URL when called from \"main\", but you will get this error if \"attrs\" is not defined when \"main\" is parsed. ",
			},
			constSet{
				Name:        "ErrOutputContext",
				Description: "ErrOutputContext: \"cannot compute output context for template ...\" Examples: {{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}} Discussion: A recursive template does not end in the same context in which it starts, and a reliable output context cannot be computed. Look for typos in the named template. If the template should not be called in the named start context, look for calls to that template in unexpected contexts. Maybe refactor recursive templates to not be recursive. ",
			},
			constSet{
				Name:        "ErrPartialCharset",
				Description: "ErrPartialCharset: \"unfinished JS regexp charset in ...\" Example: <script>var pattern = /foo[{{.Chars}}]/</script> Discussion: Package html/template does not support interpolation into regular expression literal character sets. ",
			},
			constSet{
				Name:        "ErrPartialEscape",
				Description: "ErrPartialEscape: \"unfinished escape sequence in ...\" Example: <script>alert(\"\\{{.X}}\")</script> Discussion: Package html/template does not support actions following a backslash. This is usually an error and there are better solutions; for example <script>alert(\"{{.X}}\")</script> should work, and if {{.X}} is a partial escape sequence such as \"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`) ",
			},
			constSet{
				Name:        "ErrPredefinedEscaper",
				Description: "ErrPredefinedEscaper: \"predefined escaper ... disallowed in template\" Example: <div class={{. | html}}>Hello<div> Discussion: Package html/template already contextually escapes all pipelines to produce HTML output safe against code injection. Manually escaping pipeline output using the predefined escapers \"html\" or \"urlquery\" is unnecessary, and may affect the correctness or safety of the escaped pipeline output in Go 1.8 and earlier. In most cases, such as the given example, this error can be resolved by simply removing the predefined escaper from the pipeline and letting the contextual autoescaper handle the escaping of the pipeline. In other instances, where the predefined escaper occurs in the middle of a pipeline where subsequent commands expect escaped input, e.g. {{.X | html | makeALink}} where makeALink does return `<a href=\"`+input+`\">link</a>` consider refactoring the surrounding template to make use of the contextual autoescaper, i.e. <a href=\"{{.X}}\">link</a> To ease migration to Go 1.9 and beyond, \"html\" and \"urlquery\" will continue to be allowed as the last command in a pipeline. However, if the pipeline occurs in an unquoted attribute value context, \"html\" is disallowed. Avoid using \"html\" and \"urlquery\" entirely in new templates. ",
			},
			constSet{
				Name:        "ErrRangeLoopReentry",
				Description: "ErrRangeLoopReentry: \"on range loop re-entry: ...\" Example: <script>var x = [{{range .}}'{{.}},{{end}}]</script> Discussion: If an iteration through a range would cause it to end in a different context than an earlier pass, there is no single context. In the example, there is missing a quote, so it is not clear whether {{.}} is meant to be inside a JS string or in a JS value context. The second iteration would produce something like <script>var x = ['firstValue,'secondValue]</script> ",
			},
			constSet{
				Name:        "ErrSlashAmbig",
				Description: "ErrSlashAmbig: '/' could start a division or regexp. Example: <script> {{if .C}}var x = 1{{end}} /-{{.N}}/i.test(x) ? doThis : doThat(); </script> Discussion: The example above could produce `var x = 1/-2/i.test(s)...` in which the first '/' is a mathematical division operator or it could produce `/-2/i.test(s)` in which the first '/' starts a regexp literal. Look for missing semicolons inside branches, and maybe add parentheses to make it clear which interpretation you intend. ",
			},
			constSet{
				Name:        "OK",
				Description: "OK indicates the lack of an error. ",
			},
		},
		"image": []constSet{
			constSet{
				Name:        "YCbCrSubsampleRatio410",
				Description: "",
			},
			constSet{
				Name:        "YCbCrSubsampleRatio411",
				Description: "",
			},
			constSet{
				Name:        "YCbCrSubsampleRatio420",
				Description: "",
			},
			constSet{
				Name:        "YCbCrSubsampleRatio422",
				Description: "",
			},
			constSet{
				Name:        "YCbCrSubsampleRatio440",
				Description: "",
			},
			constSet{
				Name:        "YCbCrSubsampleRatio444",
				Description: "",
			},
		},
		"tracev1": []constSet{
			constSet{
				Name:        "EvBatch",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvCPUSample",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvCount",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvFrequency",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvFutileWakeup",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCDone",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCMarkAssistDone",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCMarkAssistStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCSweepDone",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGCSweepStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlock",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockCond",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockGC",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockNet",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockRecv",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockSelect",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockSend",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoBlockSync",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoCreate",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoEnd",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoInSyscall",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoPreempt",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSched",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSleep",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoStartLabel",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoStartLocal",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoStop",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSysBlock",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSysCall",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSysExit",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoSysExitLocal",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoUnblock",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoUnblockLocal",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGoWaiting",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvGomaxprocs",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvHeapAlloc",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvHeapGoal",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvNone",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvProcStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvProcStop",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvSTWDone",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvSTWStart",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvStack",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvString",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvTimerGoroutine",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvUserLog",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvUserRegion",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvUserTaskCreate",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "EvUserTaskEnd",
				Description: "Event types in the trace. Verbatim copy from src/runtime/trace.go with the \"trace\" prefix removed. ",
			},
			constSet{
				Name:        "FakeP",
				Description: "Special P identifiers: ",
			},
			constSet{
				Name:        "GCP",
				Description: "",
			},
			constSet{
				Name:        "NetpollP",
				Description: "",
			},
			constSet{
				Name:        "NumSTWReasons",
				Description: "",
			},
			constSet{
				Name:        "ProfileP",
				Description: "",
			},
			constSet{
				Name:        "STWAllGoroutinesStackTrace",
				Description: "",
			},
			constSet{
				Name:        "STWAllThreadsSyscall",
				Description: "",
			},
			constSet{
				Name:        "STWCountPagesInUse",
				Description: "",
			},
			constSet{
				Name:        "STWGCMarkTermination",
				Description: "",
			},
			constSet{
				Name:        "STWGCSweepTermination",
				Description: "",
			},
			constSet{
				Name:        "STWGOMAXPROCS",
				Description: "",
			},
			constSet{
				Name:        "STWGoroutineProfile",
				Description: "",
			},
			constSet{
				Name:        "STWGoroutineProfileCleanup",
				Description: "",
			},
			constSet{
				Name:        "STWPageCachePagesLeaked",
				Description: "",
			},
			constSet{
				Name:        "STWReadMemStats",
				Description: "",
			},
			constSet{
				Name:        "STWReadMemStatsSlow",
				Description: "",
			},
			constSet{
				Name:        "STWReadMetricsSlow",
				Description: "",
			},
			constSet{
				Name:        "STWResetDebugLog",
				Description: "",
			},
			constSet{
				Name:        "STWStartTrace",
				Description: "",
			},
			constSet{
				Name:        "STWStopTrace",
				Description: "",
			},
			constSet{
				Name:        "STWUnknown",
				Description: "",
			},
			constSet{
				Name:        "STWWriteHeapDump",
				Description: "",
			},
			constSet{
				Name:        "SyscallP",
				Description: "",
			},
			constSet{
				Name:        "TimerP",
				Description: "",
			},
		},
		"utf8": []constSet{
			constSet{
				Name:        "MaxRune",
				Description: "Numbers fundamental to the encoding. ",
			},
			constSet{
				Name:        "RuneError",
				Description: "Numbers fundamental to the encoding. ",
			},
			constSet{
				Name:        "RuneSelf",
				Description: "Numbers fundamental to the encoding. ",
			},
			constSet{
				Name:        "UTFMax",
				Description: "Numbers fundamental to the encoding. ",
			},
		},
		"syscall": []constSet{
			constSet{
				Name:        "AF_APPLETALK",
				Description: "",
			},
			constSet{
				Name:        "AF_CCITT",
				Description: "",
			},
			constSet{
				Name:        "AF_CHAOS",
				Description: "",
			},
			constSet{
				Name:        "AF_CNT",
				Description: "",
			},
			constSet{
				Name:        "AF_COIP",
				Description: "",
			},
			constSet{
				Name:        "AF_DATAKIT",
				Description: "",
			},
			constSet{
				Name:        "AF_DECnet",
				Description: "",
			},
			constSet{
				Name:        "AF_DLI",
				Description: "",
			},
			constSet{
				Name:        "AF_E164",
				Description: "",
			},
			constSet{
				Name:        "AF_ECMA",
				Description: "",
			},
			constSet{
				Name:        "AF_HYLINK",
				Description: "",
			},
			constSet{
				Name:        "AF_IEEE80211",
				Description: "",
			},
			constSet{
				Name:        "AF_IMPLINK",
				Description: "",
			},
			constSet{
				Name:        "AF_INET",
				Description: "",
			},
			constSet{
				Name:        "AF_INET6",
				Description: "",
			},
			constSet{
				Name:        "AF_IPX",
				Description: "",
			},
			constSet{
				Name:        "AF_ISDN",
				Description: "",
			},
			constSet{
				Name:        "AF_ISO",
				Description: "",
			},
			constSet{
				Name:        "AF_LAT",
				Description: "",
			},
			constSet{
				Name:        "AF_LINK",
				Description: "",
			},
			constSet{
				Name:        "AF_LOCAL",
				Description: "",
			},
			constSet{
				Name:        "AF_MAX",
				Description: "",
			},
			constSet{
				Name:        "AF_NATM",
				Description: "",
			},
			constSet{
				Name:        "AF_NDRV",
				Description: "",
			},
			constSet{
				Name:        "AF_NETBIOS",
				Description: "",
			},
			constSet{
				Name:        "AF_NS",
				Description: "",
			},
			constSet{
				Name:        "AF_OSI",
				Description: "",
			},
			constSet{
				Name:        "AF_PPP",
				Description: "",
			},
			constSet{
				Name:        "AF_PUP",
				Description: "",
			},
			constSet{
				Name:        "AF_RESERVED_36",
				Description: "",
			},
			constSet{
				Name:        "AF_ROUTE",
				Description: "",
			},
			constSet{
				Name:        "AF_SIP",
				Description: "",
			},
			constSet{
				Name:        "AF_SNA",
				Description: "",
			},
			constSet{
				Name:        "AF_SYSTEM",
				Description: "",
			},
			constSet{
				Name:        "AF_UNIX",
				Description: "",
			},
			constSet{
				Name:        "AF_UNSPEC",
				Description: "",
			},
			constSet{
				Name:        "AF_UTUN",
				Description: "",
			},
			constSet{
				Name:        "B0",
				Description: "",
			},
			constSet{
				Name:        "B110",
				Description: "",
			},
			constSet{
				Name:        "B115200",
				Description: "",
			},
			constSet{
				Name:        "B1200",
				Description: "",
			},
			constSet{
				Name:        "B134",
				Description: "",
			},
			constSet{
				Name:        "B14400",
				Description: "",
			},
			constSet{
				Name:        "B150",
				Description: "",
			},
			constSet{
				Name:        "B1800",
				Description: "",
			},
			constSet{
				Name:        "B19200",
				Description: "",
			},
			constSet{
				Name:        "B200",
				Description: "",
			},
			constSet{
				Name:        "B230400",
				Description: "",
			},
			constSet{
				Name:        "B2400",
				Description: "",
			},
			constSet{
				Name:        "B28800",
				Description: "",
			},
			constSet{
				Name:        "B300",
				Description: "",
			},
			constSet{
				Name:        "B38400",
				Description: "",
			},
			constSet{
				Name:        "B4800",
				Description: "",
			},
			constSet{
				Name:        "B50",
				Description: "",
			},
			constSet{
				Name:        "B57600",
				Description: "",
			},
			constSet{
				Name:        "B600",
				Description: "",
			},
			constSet{
				Name:        "B7200",
				Description: "",
			},
			constSet{
				Name:        "B75",
				Description: "",
			},
			constSet{
				Name:        "B76800",
				Description: "",
			},
			constSet{
				Name:        "B9600",
				Description: "",
			},
			constSet{
				Name:        "BIOCFLUSH",
				Description: "",
			},
			constSet{
				Name:        "BIOCGBLEN",
				Description: "",
			},
			constSet{
				Name:        "BIOCGDLT",
				Description: "",
			},
			constSet{
				Name:        "BIOCGDLTLIST",
				Description: "",
			},
			constSet{
				Name:        "BIOCGETIF",
				Description: "",
			},
			constSet{
				Name:        "BIOCGHDRCMPLT",
				Description: "",
			},
			constSet{
				Name:        "BIOCGRSIG",
				Description: "",
			},
			constSet{
				Name:        "BIOCGRTIMEOUT",
				Description: "",
			},
			constSet{
				Name:        "BIOCGSEESENT",
				Description: "",
			},
			constSet{
				Name:        "BIOCGSTATS",
				Description: "",
			},
			constSet{
				Name:        "BIOCIMMEDIATE",
				Description: "",
			},
			constSet{
				Name:        "BIOCPROMISC",
				Description: "",
			},
			constSet{
				Name:        "BIOCSBLEN",
				Description: "",
			},
			constSet{
				Name:        "BIOCSDLT",
				Description: "",
			},
			constSet{
				Name:        "BIOCSETF",
				Description: "",
			},
			constSet{
				Name:        "BIOCSETIF",
				Description: "",
			},
			constSet{
				Name:        "BIOCSHDRCMPLT",
				Description: "",
			},
			constSet{
				Name:        "BIOCSRSIG",
				Description: "",
			},
			constSet{
				Name:        "BIOCSRTIMEOUT",
				Description: "",
			},
			constSet{
				Name:        "BIOCSSEESENT",
				Description: "",
			},
			constSet{
				Name:        "BIOCVERSION",
				Description: "",
			},
			constSet{
				Name:        "BPF_A",
				Description: "",
			},
			constSet{
				Name:        "BPF_ABS",
				Description: "",
			},
			constSet{
				Name:        "BPF_ADD",
				Description: "",
			},
			constSet{
				Name:        "BPF_ALIGNMENT",
				Description: "",
			},
			constSet{
				Name:        "BPF_ALU",
				Description: "",
			},
			constSet{
				Name:        "BPF_AND",
				Description: "",
			},
			constSet{
				Name:        "BPF_B",
				Description: "",
			},
			constSet{
				Name:        "BPF_DIV",
				Description: "",
			},
			constSet{
				Name:        "BPF_H",
				Description: "",
			},
			constSet{
				Name:        "BPF_IMM",
				Description: "",
			},
			constSet{
				Name:        "BPF_IND",
				Description: "",
			},
			constSet{
				Name:        "BPF_JA",
				Description: "",
			},
			constSet{
				Name:        "BPF_JEQ",
				Description: "",
			},
			constSet{
				Name:        "BPF_JGE",
				Description: "",
			},
			constSet{
				Name:        "BPF_JGT",
				Description: "",
			},
			constSet{
				Name:        "BPF_JMP",
				Description: "",
			},
			constSet{
				Name:        "BPF_JSET",
				Description: "",
			},
			constSet{
				Name:        "BPF_K",
				Description: "",
			},
			constSet{
				Name:        "BPF_LD",
				Description: "",
			},
			constSet{
				Name:        "BPF_LDX",
				Description: "",
			},
			constSet{
				Name:        "BPF_LEN",
				Description: "",
			},
			constSet{
				Name:        "BPF_LSH",
				Description: "",
			},
			constSet{
				Name:        "BPF_MAJOR_VERSION",
				Description: "",
			},
			constSet{
				Name:        "BPF_MAXBUFSIZE",
				Description: "",
			},
			constSet{
				Name:        "BPF_MAXINSNS",
				Description: "",
			},
			constSet{
				Name:        "BPF_MEM",
				Description: "",
			},
			constSet{
				Name:        "BPF_MEMWORDS",
				Description: "",
			},
			constSet{
				Name:        "BPF_MINBUFSIZE",
				Description: "",
			},
			constSet{
				Name:        "BPF_MINOR_VERSION",
				Description: "",
			},
			constSet{
				Name:        "BPF_MISC",
				Description: "",
			},
			constSet{
				Name:        "BPF_MSH",
				Description: "",
			},
			constSet{
				Name:        "BPF_MUL",
				Description: "",
			},
			constSet{
				Name:        "BPF_NEG",
				Description: "",
			},
			constSet{
				Name:        "BPF_OR",
				Description: "",
			},
			constSet{
				Name:        "BPF_RELEASE",
				Description: "",
			},
			constSet{
				Name:        "BPF_RET",
				Description: "",
			},
			constSet{
				Name:        "BPF_RSH",
				Description: "",
			},
			constSet{
				Name:        "BPF_ST",
				Description: "",
			},
			constSet{
				Name:        "BPF_STX",
				Description: "",
			},
			constSet{
				Name:        "BPF_SUB",
				Description: "",
			},
			constSet{
				Name:        "BPF_TAX",
				Description: "",
			},
			constSet{
				Name:        "BPF_TXA",
				Description: "",
			},
			constSet{
				Name:        "BPF_W",
				Description: "",
			},
			constSet{
				Name:        "BPF_X",
				Description: "",
			},
			constSet{
				Name:        "BRKINT",
				Description: "",
			},
			constSet{
				Name:        "CFLUSH",
				Description: "",
			},
			constSet{
				Name:        "CLOCAL",
				Description: "",
			},
			constSet{
				Name:        "CREAD",
				Description: "",
			},
			constSet{
				Name:        "CS5",
				Description: "",
			},
			constSet{
				Name:        "CS6",
				Description: "",
			},
			constSet{
				Name:        "CS7",
				Description: "",
			},
			constSet{
				Name:        "CS8",
				Description: "",
			},
			constSet{
				Name:        "CSIZE",
				Description: "",
			},
			constSet{
				Name:        "CSTART",
				Description: "",
			},
			constSet{
				Name:        "CSTATUS",
				Description: "",
			},
			constSet{
				Name:        "CSTOP",
				Description: "",
			},
			constSet{
				Name:        "CSTOPB",
				Description: "",
			},
			constSet{
				Name:        "CSUSP",
				Description: "",
			},
			constSet{
				Name:        "CTL_MAXNAME",
				Description: "",
			},
			constSet{
				Name:        "CTL_NET",
				Description: "",
			},
			constSet{
				Name:        "DLT_APPLE_IP_OVER_IEEE1394",
				Description: "",
			},
			constSet{
				Name:        "DLT_ARCNET",
				Description: "",
			},
			constSet{
				Name:        "DLT_ATM_CLIP",
				Description: "",
			},
			constSet{
				Name:        "DLT_ATM_RFC1483",
				Description: "",
			},
			constSet{
				Name:        "DLT_AX25",
				Description: "",
			},
			constSet{
				Name:        "DLT_CHAOS",
				Description: "",
			},
			constSet{
				Name:        "DLT_CHDLC",
				Description: "",
			},
			constSet{
				Name:        "DLT_C_HDLC",
				Description: "",
			},
			constSet{
				Name:        "DLT_EN10MB",
				Description: "",
			},
			constSet{
				Name:        "DLT_EN3MB",
				Description: "",
			},
			constSet{
				Name:        "DLT_FDDI",
				Description: "",
			},
			constSet{
				Name:        "DLT_IEEE802",
				Description: "",
			},
			constSet{
				Name:        "DLT_IEEE802_11",
				Description: "",
			},
			constSet{
				Name:        "DLT_IEEE802_11_RADIO",
				Description: "",
			},
			constSet{
				Name:        "DLT_IEEE802_11_RADIO_AVS",
				Description: "",
			},
			constSet{
				Name:        "DLT_LINUX_SLL",
				Description: "",
			},
			constSet{
				Name:        "DLT_LOOP",
				Description: "",
			},
			constSet{
				Name:        "DLT_NULL",
				Description: "",
			},
			constSet{
				Name:        "DLT_PFLOG",
				Description: "",
			},
			constSet{
				Name:        "DLT_PFSYNC",
				Description: "",
			},
			constSet{
				Name:        "DLT_PPP",
				Description: "",
			},
			constSet{
				Name:        "DLT_PPP_BSDOS",
				Description: "",
			},
			constSet{
				Name:        "DLT_PPP_SERIAL",
				Description: "",
			},
			constSet{
				Name:        "DLT_PRONET",
				Description: "",
			},
			constSet{
				Name:        "DLT_RAW",
				Description: "",
			},
			constSet{
				Name:        "DLT_SLIP",
				Description: "",
			},
			constSet{
				Name:        "DLT_SLIP_BSDOS",
				Description: "",
			},
			constSet{
				Name:        "DT_BLK",
				Description: "",
			},
			constSet{
				Name:        "DT_CHR",
				Description: "",
			},
			constSet{
				Name:        "DT_DIR",
				Description: "",
			},
			constSet{
				Name:        "DT_FIFO",
				Description: "",
			},
			constSet{
				Name:        "DT_LNK",
				Description: "",
			},
			constSet{
				Name:        "DT_REG",
				Description: "",
			},
			constSet{
				Name:        "DT_SOCK",
				Description: "",
			},
			constSet{
				Name:        "DT_UNKNOWN",
				Description: "",
			},
			constSet{
				Name:        "DT_WHT",
				Description: "",
			},
			constSet{
				Name:        "E2BIG",
				Description: "Errors ",
			},
			constSet{
				Name:        "EACCES",
				Description: "Errors ",
			},
			constSet{
				Name:        "EADDRINUSE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EADDRNOTAVAIL",
				Description: "Errors ",
			},
			constSet{
				Name:        "EAFNOSUPPORT",
				Description: "Errors ",
			},
			constSet{
				Name:        "EAGAIN",
				Description: "Errors ",
			},
			constSet{
				Name:        "EALREADY",
				Description: "Errors ",
			},
			constSet{
				Name:        "EAUTH",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADARCH",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADEXEC",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADF",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADMACHO",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADMSG",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBADRPC",
				Description: "Errors ",
			},
			constSet{
				Name:        "EBUSY",
				Description: "Errors ",
			},
			constSet{
				Name:        "ECANCELED",
				Description: "Errors ",
			},
			constSet{
				Name:        "ECHILD",
				Description: "Errors ",
			},
			constSet{
				Name:        "ECHO",
				Description: "",
			},
			constSet{
				Name:        "ECHOCTL",
				Description: "",
			},
			constSet{
				Name:        "ECHOE",
				Description: "",
			},
			constSet{
				Name:        "ECHOK",
				Description: "",
			},
			constSet{
				Name:        "ECHOKE",
				Description: "",
			},
			constSet{
				Name:        "ECHONL",
				Description: "",
			},
			constSet{
				Name:        "ECHOPRT",
				Description: "",
			},
			constSet{
				Name:        "ECONNABORTED",
				Description: "Errors ",
			},
			constSet{
				Name:        "ECONNREFUSED",
				Description: "Errors ",
			},
			constSet{
				Name:        "ECONNRESET",
				Description: "Errors ",
			},
			constSet{
				Name:        "EDEADLK",
				Description: "Errors ",
			},
			constSet{
				Name:        "EDESTADDRREQ",
				Description: "Errors ",
			},
			constSet{
				Name:        "EDEVERR",
				Description: "Errors ",
			},
			constSet{
				Name:        "EDOM",
				Description: "Errors ",
			},
			constSet{
				Name:        "EDQUOT",
				Description: "Errors ",
			},
			constSet{
				Name:        "EEXIST",
				Description: "Errors ",
			},
			constSet{
				Name:        "EFAULT",
				Description: "Errors ",
			},
			constSet{
				Name:        "EFBIG",
				Description: "Errors ",
			},
			constSet{
				Name:        "EFTYPE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EHOSTDOWN",
				Description: "Errors ",
			},
			constSet{
				Name:        "EHOSTUNREACH",
				Description: "Errors ",
			},
			constSet{
				Name:        "EIDRM",
				Description: "Errors ",
			},
			constSet{
				Name:        "EILSEQ",
				Description: "Errors ",
			},
			constSet{
				Name:        "EINPROGRESS",
				Description: "Errors ",
			},
			constSet{
				Name:        "EINTR",
				Description: "Errors ",
			},
			constSet{
				Name:        "EINVAL",
				Description: "Errors ",
			},
			constSet{
				Name:        "EIO",
				Description: "Errors ",
			},
			constSet{
				Name:        "EISCONN",
				Description: "Errors ",
			},
			constSet{
				Name:        "EISDIR",
				Description: "Errors ",
			},
			constSet{
				Name:        "ELAST",
				Description: "Errors ",
			},
			constSet{
				Name:        "ELOOP",
				Description: "Errors ",
			},
			constSet{
				Name:        "EMFILE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EMLINK",
				Description: "Errors ",
			},
			constSet{
				Name:        "EMSGSIZE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EMULTIHOP",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENAMETOOLONG",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENEEDAUTH",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENETDOWN",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENETRESET",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENETUNREACH",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENFILE",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOATTR",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOBUFS",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENODATA",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENODEV",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOENT",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOEXEC",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOLCK",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOLINK",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOMEM",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOMSG",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOPOLICY",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOPROTOOPT",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOSPC",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOSR",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOSTR",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOSYS",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTBLK",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTCONN",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTDIR",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTEMPTY",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTRECOVERABLE",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTSOCK",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTSUP",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENOTTY",
				Description: "Errors ",
			},
			constSet{
				Name:        "ENXIO",
				Description: "Errors ",
			},
			constSet{
				Name:        "EOPNOTSUPP",
				Description: "Errors ",
			},
			constSet{
				Name:        "EOVERFLOW",
				Description: "Errors ",
			},
			constSet{
				Name:        "EOWNERDEAD",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPERM",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPFNOSUPPORT",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPIPE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROCLIM",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROCUNAVAIL",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROGMISMATCH",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROGUNAVAIL",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROTO",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROTONOSUPPORT",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPROTOTYPE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EPWROFF",
				Description: "Errors ",
			},
			constSet{
				Name:        "EQFULL",
				Description: "Errors ",
			},
			constSet{
				Name:        "ERANGE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EREMOTE",
				Description: "Errors ",
			},
			constSet{
				Name:        "EROFS",
				Description: "Errors ",
			},
			constSet{
				Name:        "ERPCMISMATCH",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESHLIBVERS",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESHUTDOWN",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESOCKTNOSUPPORT",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESPIPE",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESRCH",
				Description: "Errors ",
			},
			constSet{
				Name:        "ESTALE",
				Description: "Errors ",
			},
			constSet{
				Name:        "ETIME",
				Description: "Errors ",
			},
			constSet{
				Name:        "ETIMEDOUT",
				Description: "Errors ",
			},
			constSet{
				Name:        "ETOOMANYREFS",
				Description: "Errors ",
			},
			constSet{
				Name:        "ETXTBSY",
				Description: "Errors ",
			},
			constSet{
				Name:        "EUSERS",
				Description: "Errors ",
			},
			constSet{
				Name:        "EVFILT_AIO",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_FS",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_MACHPORT",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_PROC",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_READ",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_SIGNAL",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_SYSCOUNT",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_THREADMARKER",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_TIMER",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_USER",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_VM",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_VNODE",
				Description: "",
			},
			constSet{
				Name:        "EVFILT_WRITE",
				Description: "",
			},
			constSet{
				Name:        "EV_ADD",
				Description: "",
			},
			constSet{
				Name:        "EV_CLEAR",
				Description: "",
			},
			constSet{
				Name:        "EV_DELETE",
				Description: "",
			},
			constSet{
				Name:        "EV_DISABLE",
				Description: "",
			},
			constSet{
				Name:        "EV_DISPATCH",
				Description: "",
			},
			constSet{
				Name:        "EV_ENABLE",
				Description: "",
			},
			constSet{
				Name:        "EV_EOF",
				Description: "",
			},
			constSet{
				Name:        "EV_ERROR",
				Description: "",
			},
			constSet{
				Name:        "EV_FLAG0",
				Description: "",
			},
			constSet{
				Name:        "EV_FLAG1",
				Description: "",
			},
			constSet{
				Name:        "EV_ONESHOT",
				Description: "",
			},
			constSet{
				Name:        "EV_OOBAND",
				Description: "",
			},
			constSet{
				Name:        "EV_POLL",
				Description: "",
			},
			constSet{
				Name:        "EV_RECEIPT",
				Description: "",
			},
			constSet{
				Name:        "EV_SYSFLAGS",
				Description: "",
			},
			constSet{
				Name:        "EWOULDBLOCK",
				Description: "Errors ",
			},
			constSet{
				Name:        "EXDEV",
				Description: "Errors ",
			},
			constSet{
				Name:        "EXTA",
				Description: "",
			},
			constSet{
				Name:        "EXTB",
				Description: "",
			},
			constSet{
				Name:        "EXTPROC",
				Description: "",
			},
			constSet{
				Name:        "FD_CLOEXEC",
				Description: "",
			},
			constSet{
				Name:        "FD_SETSIZE",
				Description: "",
			},
			constSet{
				Name:        "FLUSHO",
				Description: "",
			},
			constSet{
				Name:        "F_ADDFILESIGS",
				Description: "",
			},
			constSet{
				Name:        "F_ADDSIGS",
				Description: "",
			},
			constSet{
				Name:        "F_ALLOCATEALL",
				Description: "",
			},
			constSet{
				Name:        "F_ALLOCATECONTIG",
				Description: "",
			},
			constSet{
				Name:        "F_CHKCLEAN",
				Description: "",
			},
			constSet{
				Name:        "F_DUPFD",
				Description: "",
			},
			constSet{
				Name:        "F_DUPFD_CLOEXEC",
				Description: "",
			},
			constSet{
				Name:        "F_FINDSIGS",
				Description: "",
			},
			constSet{
				Name:        "F_FLUSH_DATA",
				Description: "",
			},
			constSet{
				Name:        "F_FREEZE_FS",
				Description: "",
			},
			constSet{
				Name:        "F_FULLFSYNC",
				Description: "",
			},
			constSet{
				Name:        "F_GETCODEDIR",
				Description: "",
			},
			constSet{
				Name:        "F_GETFD",
				Description: "",
			},
			constSet{
				Name:        "F_GETFL",
				Description: "",
			},
			constSet{
				Name:        "F_GETLK",
				Description: "",
			},
			constSet{
				Name:        "F_GETLKPID",
				Description: "",
			},
			constSet{
				Name:        "F_GETNOSIGPIPE",
				Description: "",
			},
			constSet{
				Name:        "F_GETOWN",
				Description: "",
			},
			constSet{
				Name:        "F_GETPATH",
				Description: "",
			},
			constSet{
				Name:        "F_GETPATH_MTMINFO",
				Description: "",
			},
			constSet{
				Name:        "F_GETPROTECTIONCLASS",
				Description: "",
			},
			constSet{
				Name:        "F_GETPROTECTIONLEVEL",
				Description: "",
			},
			constSet{
				Name:        "F_GLOBAL_NOCACHE",
				Description: "",
			},
			constSet{
				Name:        "F_LOG2PHYS",
				Description: "",
			},
			constSet{
				Name:        "F_LOG2PHYS_EXT",
				Description: "",
			},
			constSet{
				Name:        "F_NOCACHE",
				Description: "",
			},
			constSet{
				Name:        "F_NODIRECT",
				Description: "",
			},
			constSet{
				Name:        "F_OK",
				Description: "",
			},
			constSet{
				Name:        "F_PATHPKG_CHECK",
				Description: "",
			},
			constSet{
				Name:        "F_PEOFPOSMODE",
				Description: "",
			},
			constSet{
				Name:        "F_PREALLOCATE",
				Description: "",
			},
			constSet{
				Name:        "F_RDADVISE",
				Description: "",
			},
			constSet{
				Name:        "F_RDAHEAD",
				Description: "",
			},
			constSet{
				Name:        "F_RDLCK",
				Description: "",
			},
			constSet{
				Name:        "F_SETBACKINGSTORE",
				Description: "",
			},
			constSet{
				Name:        "F_SETFD",
				Description: "",
			},
			constSet{
				Name:        "F_SETFL",
				Description: "",
			},
			constSet{
				Name:        "F_SETLK",
				Description: "",
			},
			constSet{
				Name:        "F_SETLKW",
				Description: "",
			},
			constSet{
				Name:        "F_SETLKWTIMEOUT",
				Description: "",
			},
			constSet{
				Name:        "F_SETNOSIGPIPE",
				Description: "",
			},
			constSet{
				Name:        "F_SETOWN",
				Description: "",
			},
			constSet{
				Name:        "F_SETPROTECTIONCLASS",
				Description: "",
			},
			constSet{
				Name:        "F_SETSIZE",
				Description: "",
			},
			constSet{
				Name:        "F_SINGLE_WRITER",
				Description: "",
			},
			constSet{
				Name:        "F_THAW_FS",
				Description: "",
			},
			constSet{
				Name:        "F_TRANSCODEKEY",
				Description: "",
			},
			constSet{
				Name:        "F_UNLCK",
				Description: "",
			},
			constSet{
				Name:        "F_VOLPOSMODE",
				Description: "",
			},
			constSet{
				Name:        "F_WRLCK",
				Description: "",
			},
			constSet{
				Name:        "HUPCL",
				Description: "",
			},
			constSet{
				Name:        "ICANON",
				Description: "",
			},
			constSet{
				Name:        "ICMP6_FILTER",
				Description: "",
			},
			constSet{
				Name:        "ICRNL",
				Description: "",
			},
			constSet{
				Name:        "IEXTEN",
				Description: "",
			},
			constSet{
				Name:        "IFF_ALLMULTI",
				Description: "",
			},
			constSet{
				Name:        "IFF_ALTPHYS",
				Description: "",
			},
			constSet{
				Name:        "IFF_BROADCAST",
				Description: "",
			},
			constSet{
				Name:        "IFF_DEBUG",
				Description: "",
			},
			constSet{
				Name:        "IFF_LINK0",
				Description: "",
			},
			constSet{
				Name:        "IFF_LINK1",
				Description: "",
			},
			constSet{
				Name:        "IFF_LINK2",
				Description: "",
			},
			constSet{
				Name:        "IFF_LOOPBACK",
				Description: "",
			},
			constSet{
				Name:        "IFF_MULTICAST",
				Description: "",
			},
			constSet{
				Name:        "IFF_NOARP",
				Description: "",
			},
			constSet{
				Name:        "IFF_NOTRAILERS",
				Description: "",
			},
			constSet{
				Name:        "IFF_OACTIVE",
				Description: "",
			},
			constSet{
				Name:        "IFF_POINTOPOINT",
				Description: "",
			},
			constSet{
				Name:        "IFF_PROMISC",
				Description: "",
			},
			constSet{
				Name:        "IFF_RUNNING",
				Description: "",
			},
			constSet{
				Name:        "IFF_SIMPLEX",
				Description: "",
			},
			constSet{
				Name:        "IFF_UP",
				Description: "",
			},
			constSet{
				Name:        "IFNAMSIZ",
				Description: "",
			},
			constSet{
				Name:        "IFT_1822",
				Description: "",
			},
			constSet{
				Name:        "IFT_AAL5",
				Description: "",
			},
			constSet{
				Name:        "IFT_ARCNET",
				Description: "",
			},
			constSet{
				Name:        "IFT_ARCNETPLUS",
				Description: "",
			},
			constSet{
				Name:        "IFT_ATM",
				Description: "",
			},
			constSet{
				Name:        "IFT_BRIDGE",
				Description: "",
			},
			constSet{
				Name:        "IFT_CARP",
				Description: "",
			},
			constSet{
				Name:        "IFT_CELLULAR",
				Description: "",
			},
			constSet{
				Name:        "IFT_CEPT",
				Description: "",
			},
			constSet{
				Name:        "IFT_DS3",
				Description: "",
			},
			constSet{
				Name:        "IFT_ENC",
				Description: "",
			},
			constSet{
				Name:        "IFT_EON",
				Description: "",
			},
			constSet{
				Name:        "IFT_ETHER",
				Description: "",
			},
			constSet{
				Name:        "IFT_FAITH",
				Description: "",
			},
			constSet{
				Name:        "IFT_FDDI",
				Description: "",
			},
			constSet{
				Name:        "IFT_FRELAY",
				Description: "",
			},
			constSet{
				Name:        "IFT_FRELAYDCE",
				Description: "",
			},
			constSet{
				Name:        "IFT_GIF",
				Description: "",
			},
			constSet{
				Name:        "IFT_HDH1822",
				Description: "",
			},
			constSet{
				Name:        "IFT_HIPPI",
				Description: "",
			},
			constSet{
				Name:        "IFT_HSSI",
				Description: "",
			},
			constSet{
				Name:        "IFT_HY",
				Description: "",
			},
			constSet{
				Name:        "IFT_IEEE1394",
				Description: "",
			},
			constSet{
				Name:        "IFT_IEEE8023ADLAG",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISDNBASIC",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISDNPRIMARY",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISO88022LLC",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISO88023",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISO88024",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISO88025",
				Description: "",
			},
			constSet{
				Name:        "IFT_ISO88026",
				Description: "",
			},
			constSet{
				Name:        "IFT_L2VLAN",
				Description: "",
			},
			constSet{
				Name:        "IFT_LAPB",
				Description: "",
			},
			constSet{
				Name:        "IFT_LOCALTALK",
				Description: "",
			},
			constSet{
				Name:        "IFT_LOOP",
				Description: "",
			},
			constSet{
				Name:        "IFT_MIOX25",
				Description: "",
			},
			constSet{
				Name:        "IFT_MODEM",
				Description: "",
			},
			constSet{
				Name:        "IFT_NSIP",
				Description: "",
			},
			constSet{
				Name:        "IFT_OTHER",
				Description: "",
			},
			constSet{
				Name:        "IFT_P10",
				Description: "",
			},
			constSet{
				Name:        "IFT_P80",
				Description: "",
			},
			constSet{
				Name:        "IFT_PARA",
				Description: "",
			},
			constSet{
				Name:        "IFT_PDP",
				Description: "",
			},
			constSet{
				Name:        "IFT_PFLOG",
				Description: "",
			},
			constSet{
				Name:        "IFT_PFSYNC",
				Description: "",
			},
			constSet{
				Name:        "IFT_PPP",
				Description: "",
			},
			constSet{
				Name:        "IFT_PROPMUX",
				Description: "",
			},
			constSet{
				Name:        "IFT_PROPVIRTUAL",
				Description: "",
			},
			constSet{
				Name:        "IFT_PTPSERIAL",
				Description: "",
			},
			constSet{
				Name:        "IFT_RS232",
				Description: "",
			},
			constSet{
				Name:        "IFT_SDLC",
				Description: "",
			},
			constSet{
				Name:        "IFT_SIP",
				Description: "",
			},
			constSet{
				Name:        "IFT_SLIP",
				Description: "",
			},
			constSet{
				Name:        "IFT_SMDSDXI",
				Description: "",
			},
			constSet{
				Name:        "IFT_SMDSICIP",
				Description: "",
			},
			constSet{
				Name:        "IFT_SONET",
				Description: "",
			},
			constSet{
				Name:        "IFT_SONETPATH",
				Description: "",
			},
			constSet{
				Name:        "IFT_SONETVT",
				Description: "",
			},
			constSet{
				Name:        "IFT_STARLAN",
				Description: "",
			},
			constSet{
				Name:        "IFT_STF",
				Description: "",
			},
			constSet{
				Name:        "IFT_T1",
				Description: "",
			},
			constSet{
				Name:        "IFT_ULTRA",
				Description: "",
			},
			constSet{
				Name:        "IFT_V35",
				Description: "",
			},
			constSet{
				Name:        "IFT_X25",
				Description: "",
			},
			constSet{
				Name:        "IFT_X25DDN",
				Description: "",
			},
			constSet{
				Name:        "IFT_X25PLE",
				Description: "",
			},
			constSet{
				Name:        "IFT_XETHER",
				Description: "",
			},
			constSet{
				Name:        "IGNBRK",
				Description: "",
			},
			constSet{
				Name:        "IGNCR",
				Description: "",
			},
			constSet{
				Name:        "IGNPAR",
				Description: "",
			},
			constSet{
				Name:        "IMAXBEL",
				Description: "",
			},
			constSet{
				Name:        "INLCR",
				Description: "",
			},
			constSet{
				Name:        "INPCK",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSA_HOST",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSA_MAX",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSA_NET",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSA_NSHIFT",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSB_HOST",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSB_MAX",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSB_NET",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSB_NSHIFT",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSC_HOST",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSC_NET",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSC_NSHIFT",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSD_HOST",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSD_NET",
				Description: "",
			},
			constSet{
				Name:        "IN_CLASSD_NSHIFT",
				Description: "",
			},
			constSet{
				Name:        "IN_LINKLOCALNETNUM",
				Description: "",
			},
			constSet{
				Name:        "IN_LOOPBACKNET",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_3PC",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ADFS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_AH",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_AHIP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_APES",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ARGUS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_AX25",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_BHA",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_BLT",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_BRSATMON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_CFTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_CHAOS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_CMTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_CPHB",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_CPNX",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_DDP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_DGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_DIVERT",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_DONE",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_DSTOPTS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_EGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_EMCON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ENCAP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_EON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ESP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ETHERIP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_FRAGMENT",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_GGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_GMTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_GRE",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_HELLO",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_HMP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_HOPOPTS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ICMP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ICMPV6",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IDP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IDPR",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IDRP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IGMP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IGRP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IL",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_INLSP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_INP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPCOMP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPCV",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPEIP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPIP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPPC",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPV4",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IPV6",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_IRTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_KRYPTOLAN",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_LARP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_LEAF1",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_LEAF2",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MAX",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MAXID",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MEAS",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MHRP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MICP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_MUX",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ND",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_NHRP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_NONE",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_NSP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_NVPII",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_OSPFIGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PGM",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PIGP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PIM",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PRM",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PUP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_PVP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_RAW",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_RCCMON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_RDP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ROUTING",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_RSVP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_RVD",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SATEXPAK",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SATMON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SCCSP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SCTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SDRP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SEP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SRPC",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_ST",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SVMTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_SWIPE",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TCF",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TCP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TPXX",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TRUNK1",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TRUNK2",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_TTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_UDP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_VINES",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_VISA",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_VMTP",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_WBEXPAK",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_WBMON",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_WSN",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_XNET",
				Description: "",
			},
			constSet{
				Name:        "IPPROTO_XTP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292DSTOPTS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292HOPLIMIT",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292HOPOPTS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292NEXTHOP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292PKTINFO",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292PKTOPTIONS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_2292RTHDR",
				Description: "",
			},
			constSet{
				Name:        "IPV6_BINDV6ONLY",
				Description: "",
			},
			constSet{
				Name:        "IPV6_BOUND_IF",
				Description: "",
			},
			constSet{
				Name:        "IPV6_CHECKSUM",
				Description: "",
			},
			constSet{
				Name:        "IPV6_DEFAULT_MULTICAST_HOPS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_DEFAULT_MULTICAST_LOOP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_DEFHLIM",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FAITH",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FLOWINFO_MASK",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FLOWLABEL_MASK",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FRAGTTL",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FW_ADD",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FW_DEL",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FW_FLUSH",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FW_GET",
				Description: "",
			},
			constSet{
				Name:        "IPV6_FW_ZERO",
				Description: "",
			},
			constSet{
				Name:        "IPV6_HLIMDEC",
				Description: "",
			},
			constSet{
				Name:        "IPV6_IPSEC_POLICY",
				Description: "",
			},
			constSet{
				Name:        "IPV6_JOIN_GROUP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_LEAVE_GROUP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAXHLIM",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAXOPTHDR",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAXPACKET",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAX_GROUP_SRC_FILTER",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAX_MEMBERSHIPS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MAX_SOCK_SRC_FILTER",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MIN_MEMBERSHIPS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MMTU",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MULTICAST_HOPS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MULTICAST_IF",
				Description: "",
			},
			constSet{
				Name:        "IPV6_MULTICAST_LOOP",
				Description: "",
			},
			constSet{
				Name:        "IPV6_PORTRANGE",
				Description: "",
			},
			constSet{
				Name:        "IPV6_PORTRANGE_DEFAULT",
				Description: "",
			},
			constSet{
				Name:        "IPV6_PORTRANGE_HIGH",
				Description: "",
			},
			constSet{
				Name:        "IPV6_PORTRANGE_LOW",
				Description: "",
			},
			constSet{
				Name:        "IPV6_RECVTCLASS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_RTHDR_LOOSE",
				Description: "",
			},
			constSet{
				Name:        "IPV6_RTHDR_STRICT",
				Description: "",
			},
			constSet{
				Name:        "IPV6_RTHDR_TYPE_0",
				Description: "",
			},
			constSet{
				Name:        "IPV6_SOCKOPT_RESERVED1",
				Description: "",
			},
			constSet{
				Name:        "IPV6_TCLASS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_UNICAST_HOPS",
				Description: "",
			},
			constSet{
				Name:        "IPV6_V6ONLY",
				Description: "",
			},
			constSet{
				Name:        "IPV6_VERSION",
				Description: "",
			},
			constSet{
				Name:        "IPV6_VERSION_MASK",
				Description: "",
			},
			constSet{
				Name:        "IP_ADD_MEMBERSHIP",
				Description: "",
			},
			constSet{
				Name:        "IP_ADD_SOURCE_MEMBERSHIP",
				Description: "",
			},
			constSet{
				Name:        "IP_BLOCK_SOURCE",
				Description: "",
			},
			constSet{
				Name:        "IP_BOUND_IF",
				Description: "",
			},
			constSet{
				Name:        "IP_DEFAULT_MULTICAST_LOOP",
				Description: "",
			},
			constSet{
				Name:        "IP_DEFAULT_MULTICAST_TTL",
				Description: "",
			},
			constSet{
				Name:        "IP_DF",
				Description: "",
			},
			constSet{
				Name:        "IP_DROP_MEMBERSHIP",
				Description: "",
			},
			constSet{
				Name:        "IP_DROP_SOURCE_MEMBERSHIP",
				Description: "",
			},
			constSet{
				Name:        "IP_DUMMYNET_CONFIGURE",
				Description: "",
			},
			constSet{
				Name:        "IP_DUMMYNET_DEL",
				Description: "",
			},
			constSet{
				Name:        "IP_DUMMYNET_FLUSH",
				Description: "",
			},
			constSet{
				Name:        "IP_DUMMYNET_GET",
				Description: "",
			},
			constSet{
				Name:        "IP_FAITH",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_ADD",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_DEL",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_FLUSH",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_GET",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_RESETLOG",
				Description: "",
			},
			constSet{
				Name:        "IP_FW_ZERO",
				Description: "",
			},
			constSet{
				Name:        "IP_HDRINCL",
				Description: "",
			},
			constSet{
				Name:        "IP_IPSEC_POLICY",
				Description: "",
			},
			constSet{
				Name:        "IP_MAXPACKET",
				Description: "",
			},
			constSet{
				Name:        "IP_MAX_GROUP_SRC_FILTER",
				Description: "",
			},
			constSet{
				Name:        "IP_MAX_MEMBERSHIPS",
				Description: "",
			},
			constSet{
				Name:        "IP_MAX_SOCK_MUTE_FILTER",
				Description: "",
			},
			constSet{
				Name:        "IP_MAX_SOCK_SRC_FILTER",
				Description: "",
			},
			constSet{
				Name:        "IP_MF",
				Description: "",
			},
			constSet{
				Name:        "IP_MIN_MEMBERSHIPS",
				Description: "",
			},
			constSet{
				Name:        "IP_MSFILTER",
				Description: "",
			},
			constSet{
				Name:        "IP_MSS",
				Description: "",
			},
			constSet{
				Name:        "IP_MULTICAST_IF",
				Description: "",
			},
			constSet{
				Name:        "IP_MULTICAST_IFINDEX",
				Description: "",
			},
			constSet{
				Name:        "IP_MULTICAST_LOOP",
				Description: "",
			},
			constSet{
				Name:        "IP_MULTICAST_TTL",
				Description: "",
			},
			constSet{
				Name:        "IP_MULTICAST_VIF",
				Description: "",
			},
			constSet{
				Name:        "IP_NAT__XXX",
				Description: "",
			},
			constSet{
				Name:        "IP_OFFMASK",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_ADD",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_DEL",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_FLUSH",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_GET",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_RESETLOG",
				Description: "",
			},
			constSet{
				Name:        "IP_OLD_FW_ZERO",
				Description: "",
			},
			constSet{
				Name:        "IP_OPTIONS",
				Description: "",
			},
			constSet{
				Name:        "IP_PKTINFO",
				Description: "",
			},
			constSet{
				Name:        "IP_PORTRANGE",
				Description: "",
			},
			constSet{
				Name:        "IP_PORTRANGE_DEFAULT",
				Description: "",
			},
			constSet{
				Name:        "IP_PORTRANGE_HIGH",
				Description: "",
			},
			constSet{
				Name:        "IP_PORTRANGE_LOW",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVDSTADDR",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVIF",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVOPTS",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVPKTINFO",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVRETOPTS",
				Description: "",
			},
			constSet{
				Name:        "IP_RECVTTL",
				Description: "",
			},
			constSet{
				Name:        "IP_RETOPTS",
				Description: "",
			},
			constSet{
				Name:        "IP_RF",
				Description: "",
			},
			constSet{
				Name:        "IP_RSVP_OFF",
				Description: "",
			},
			constSet{
				Name:        "IP_RSVP_ON",
				Description: "",
			},
			constSet{
				Name:        "IP_RSVP_VIF_OFF",
				Description: "",
			},
			constSet{
				Name:        "IP_RSVP_VIF_ON",
				Description: "",
			},
			constSet{
				Name:        "IP_STRIPHDR",
				Description: "",
			},
			constSet{
				Name:        "IP_TOS",
				Description: "",
			},
			constSet{
				Name:        "IP_TRAFFIC_MGT_BACKGROUND",
				Description: "",
			},
			constSet{
				Name:        "IP_TTL",
				Description: "",
			},
			constSet{
				Name:        "IP_UNBLOCK_SOURCE",
				Description: "",
			},
			constSet{
				Name:        "ISIG",
				Description: "",
			},
			constSet{
				Name:        "ISTRIP",
				Description: "",
			},
			constSet{
				Name:        "IUTF8",
				Description: "",
			},
			constSet{
				Name:        "IXANY",
				Description: "",
			},
			constSet{
				Name:        "IXOFF",
				Description: "",
			},
			constSet{
				Name:        "IXON",
				Description: "",
			},
			constSet{
				Name:        "ImplementsGetwd",
				Description: "",
			},
			constSet{
				Name:        "LOCK_EX",
				Description: "",
			},
			constSet{
				Name:        "LOCK_NB",
				Description: "",
			},
			constSet{
				Name:        "LOCK_SH",
				Description: "",
			},
			constSet{
				Name:        "LOCK_UN",
				Description: "",
			},
			constSet{
				Name:        "MADV_CAN_REUSE",
				Description: "",
			},
			constSet{
				Name:        "MADV_DONTNEED",
				Description: "",
			},
			constSet{
				Name:        "MADV_FREE",
				Description: "",
			},
			constSet{
				Name:        "MADV_FREE_REUSABLE",
				Description: "",
			},
			constSet{
				Name:        "MADV_FREE_REUSE",
				Description: "",
			},
			constSet{
				Name:        "MADV_NORMAL",
				Description: "",
			},
			constSet{
				Name:        "MADV_RANDOM",
				Description: "",
			},
			constSet{
				Name:        "MADV_SEQUENTIAL",
				Description: "",
			},
			constSet{
				Name:        "MADV_WILLNEED",
				Description: "",
			},
			constSet{
				Name:        "MADV_ZERO_WIRED_PAGES",
				Description: "",
			},
			constSet{
				Name:        "MAP_ANON",
				Description: "",
			},
			constSet{
				Name:        "MAP_COPY",
				Description: "",
			},
			constSet{
				Name:        "MAP_FILE",
				Description: "",
			},
			constSet{
				Name:        "MAP_FIXED",
				Description: "",
			},
			constSet{
				Name:        "MAP_HASSEMAPHORE",
				Description: "",
			},
			constSet{
				Name:        "MAP_JIT",
				Description: "",
			},
			constSet{
				Name:        "MAP_NOCACHE",
				Description: "",
			},
			constSet{
				Name:        "MAP_NOEXTEND",
				Description: "",
			},
			constSet{
				Name:        "MAP_NORESERVE",
				Description: "",
			},
			constSet{
				Name:        "MAP_PRIVATE",
				Description: "",
			},
			constSet{
				Name:        "MAP_RENAME",
				Description: "",
			},
			constSet{
				Name:        "MAP_RESERVED0080",
				Description: "",
			},
			constSet{
				Name:        "MAP_SHARED",
				Description: "",
			},
			constSet{
				Name:        "MCL_CURRENT",
				Description: "",
			},
			constSet{
				Name:        "MCL_FUTURE",
				Description: "",
			},
			constSet{
				Name:        "MSG_CTRUNC",
				Description: "",
			},
			constSet{
				Name:        "MSG_DONTROUTE",
				Description: "",
			},
			constSet{
				Name:        "MSG_DONTWAIT",
				Description: "",
			},
			constSet{
				Name:        "MSG_EOF",
				Description: "",
			},
			constSet{
				Name:        "MSG_EOR",
				Description: "",
			},
			constSet{
				Name:        "MSG_FLUSH",
				Description: "",
			},
			constSet{
				Name:        "MSG_HAVEMORE",
				Description: "",
			},
			constSet{
				Name:        "MSG_HOLD",
				Description: "",
			},
			constSet{
				Name:        "MSG_NEEDSA",
				Description: "",
			},
			constSet{
				Name:        "MSG_OOB",
				Description: "",
			},
			constSet{
				Name:        "MSG_PEEK",
				Description: "",
			},
			constSet{
				Name:        "MSG_RCVMORE",
				Description: "",
			},
			constSet{
				Name:        "MSG_SEND",
				Description: "",
			},
			constSet{
				Name:        "MSG_TRUNC",
				Description: "",
			},
			constSet{
				Name:        "MSG_WAITALL",
				Description: "",
			},
			constSet{
				Name:        "MSG_WAITSTREAM",
				Description: "",
			},
			constSet{
				Name:        "MS_ASYNC",
				Description: "",
			},
			constSet{
				Name:        "MS_DEACTIVATE",
				Description: "",
			},
			constSet{
				Name:        "MS_INVALIDATE",
				Description: "",
			},
			constSet{
				Name:        "MS_KILLPAGES",
				Description: "",
			},
			constSet{
				Name:        "MS_SYNC",
				Description: "",
			},
			constSet{
				Name:        "NAME_MAX",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_DUMP",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_DUMP2",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_FLAGS",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_IFLIST",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_IFLIST2",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_MAXID",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_STAT",
				Description: "",
			},
			constSet{
				Name:        "NET_RT_TRASH",
				Description: "",
			},
			constSet{
				Name:        "NOFLSH",
				Description: "",
			},
			constSet{
				Name:        "NOTE_ABSOLUTE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_ATTRIB",
				Description: "",
			},
			constSet{
				Name:        "NOTE_BACKGROUND",
				Description: "",
			},
			constSet{
				Name:        "NOTE_CHILD",
				Description: "",
			},
			constSet{
				Name:        "NOTE_CRITICAL",
				Description: "",
			},
			constSet{
				Name:        "NOTE_DELETE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXEC",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXITSTATUS",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_CSERROR",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_DECRYPTFAIL",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_DETAIL",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_DETAIL_MASK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_MEMORY",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXIT_REPARENTED",
				Description: "",
			},
			constSet{
				Name:        "NOTE_EXTEND",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFAND",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFCOPY",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFCTRLMASK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFLAGSMASK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFNOP",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FFOR",
				Description: "",
			},
			constSet{
				Name:        "NOTE_FORK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_LEEWAY",
				Description: "",
			},
			constSet{
				Name:        "NOTE_LINK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_LOWAT",
				Description: "",
			},
			constSet{
				Name:        "NOTE_NONE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_NSECONDS",
				Description: "",
			},
			constSet{
				Name:        "NOTE_PCTRLMASK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_PDATAMASK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_REAP",
				Description: "",
			},
			constSet{
				Name:        "NOTE_RENAME",
				Description: "",
			},
			constSet{
				Name:        "NOTE_REVOKE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_SECONDS",
				Description: "",
			},
			constSet{
				Name:        "NOTE_SIGNAL",
				Description: "",
			},
			constSet{
				Name:        "NOTE_TRACK",
				Description: "",
			},
			constSet{
				Name:        "NOTE_TRACKERR",
				Description: "",
			},
			constSet{
				Name:        "NOTE_TRIGGER",
				Description: "",
			},
			constSet{
				Name:        "NOTE_USECONDS",
				Description: "",
			},
			constSet{
				Name:        "NOTE_VM_ERROR",
				Description: "",
			},
			constSet{
				Name:        "NOTE_VM_PRESSURE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_VM_PRESSURE_SUDDEN_TERMINATE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_VM_PRESSURE_TERMINATE",
				Description: "",
			},
			constSet{
				Name:        "NOTE_WRITE",
				Description: "",
			},
			constSet{
				Name:        "OCRNL",
				Description: "",
			},
			constSet{
				Name:        "OFDEL",
				Description: "",
			},
			constSet{
				Name:        "OFILL",
				Description: "",
			},
			constSet{
				Name:        "ONLCR",
				Description: "",
			},
			constSet{
				Name:        "ONLRET",
				Description: "",
			},
			constSet{
				Name:        "ONOCR",
				Description: "",
			},
			constSet{
				Name:        "ONOEOT",
				Description: "",
			},
			constSet{
				Name:        "OPOST",
				Description: "",
			},
			constSet{
				Name:        "O_ACCMODE",
				Description: "",
			},
			constSet{
				Name:        "O_ALERT",
				Description: "",
			},
			constSet{
				Name:        "O_APPEND",
				Description: "",
			},
			constSet{
				Name:        "O_ASYNC",
				Description: "",
			},
			constSet{
				Name:        "O_CLOEXEC",
				Description: "",
			},
			constSet{
				Name:        "O_CREAT",
				Description: "",
			},
			constSet{
				Name:        "O_DIRECTORY",
				Description: "",
			},
			constSet{
				Name:        "O_DP_GETRAWENCRYPTED",
				Description: "",
			},
			constSet{
				Name:        "O_DSYNC",
				Description: "",
			},
			constSet{
				Name:        "O_EVTONLY",
				Description: "",
			},
			constSet{
				Name:        "O_EXCL",
				Description: "",
			},
			constSet{
				Name:        "O_EXLOCK",
				Description: "",
			},
			constSet{
				Name:        "O_FSYNC",
				Description: "",
			},
			constSet{
				Name:        "O_NDELAY",
				Description: "",
			},
			constSet{
				Name:        "O_NOCTTY",
				Description: "",
			},
			constSet{
				Name:        "O_NOFOLLOW",
				Description: "",
			},
			constSet{
				Name:        "O_NONBLOCK",
				Description: "",
			},
			constSet{
				Name:        "O_POPUP",
				Description: "",
			},
			constSet{
				Name:        "O_RDONLY",
				Description: "",
			},
			constSet{
				Name:        "O_RDWR",
				Description: "",
			},
			constSet{
				Name:        "O_SHLOCK",
				Description: "",
			},
			constSet{
				Name:        "O_SYMLINK",
				Description: "",
			},
			constSet{
				Name:        "O_SYNC",
				Description: "",
			},
			constSet{
				Name:        "O_TRUNC",
				Description: "",
			},
			constSet{
				Name:        "O_WRONLY",
				Description: "",
			},
			constSet{
				Name:        "PARENB",
				Description: "",
			},
			constSet{
				Name:        "PARMRK",
				Description: "",
			},
			constSet{
				Name:        "PARODD",
				Description: "",
			},
			constSet{
				Name:        "PENDIN",
				Description: "",
			},
			constSet{
				Name:        "PRIO_PGRP",
				Description: "",
			},
			constSet{
				Name:        "PRIO_PROCESS",
				Description: "",
			},
			constSet{
				Name:        "PRIO_USER",
				Description: "",
			},
			constSet{
				Name:        "PROT_EXEC",
				Description: "",
			},
			constSet{
				Name:        "PROT_NONE",
				Description: "",
			},
			constSet{
				Name:        "PROT_READ",
				Description: "",
			},
			constSet{
				Name:        "PROT_WRITE",
				Description: "",
			},
			constSet{
				Name:        "PTRACE_CONT",
				Description: "",
			},
			constSet{
				Name:        "PTRACE_KILL",
				Description: "",
			},
			constSet{
				Name:        "PTRACE_TRACEME",
				Description: "",
			},
			constSet{
				Name:        "PT_ATTACH",
				Description: "",
			},
			constSet{
				Name:        "PT_ATTACHEXC",
				Description: "",
			},
			constSet{
				Name:        "PT_CONTINUE",
				Description: "",
			},
			constSet{
				Name:        "PT_DENY_ATTACH",
				Description: "",
			},
			constSet{
				Name:        "PT_DETACH",
				Description: "",
			},
			constSet{
				Name:        "PT_FIRSTMACH",
				Description: "",
			},
			constSet{
				Name:        "PT_FORCEQUOTA",
				Description: "",
			},
			constSet{
				Name:        "PT_KILL",
				Description: "",
			},
			constSet{
				Name:        "PT_READ_D",
				Description: "",
			},
			constSet{
				Name:        "PT_READ_I",
				Description: "",
			},
			constSet{
				Name:        "PT_READ_U",
				Description: "",
			},
			constSet{
				Name:        "PT_SIGEXC",
				Description: "",
			},
			constSet{
				Name:        "PT_STEP",
				Description: "",
			},
			constSet{
				Name:        "PT_THUPDATE",
				Description: "",
			},
			constSet{
				Name:        "PT_TRACE_ME",
				Description: "",
			},
			constSet{
				Name:        "PT_WRITE_D",
				Description: "",
			},
			constSet{
				Name:        "PT_WRITE_I",
				Description: "",
			},
			constSet{
				Name:        "PT_WRITE_U",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_AS",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_CORE",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_CPU",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_CPU_USAGE_MONITOR",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_DATA",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_FSIZE",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_NOFILE",
				Description: "",
			},
			constSet{
				Name:        "RLIMIT_STACK",
				Description: "",
			},
			constSet{
				Name:        "RLIM_INFINITY",
				Description: "",
			},
			constSet{
				Name:        "RTAX_AUTHOR",
				Description: "",
			},
			constSet{
				Name:        "RTAX_BRD",
				Description: "",
			},
			constSet{
				Name:        "RTAX_DST",
				Description: "",
			},
			constSet{
				Name:        "RTAX_GATEWAY",
				Description: "",
			},
			constSet{
				Name:        "RTAX_GENMASK",
				Description: "",
			},
			constSet{
				Name:        "RTAX_IFA",
				Description: "",
			},
			constSet{
				Name:        "RTAX_IFP",
				Description: "",
			},
			constSet{
				Name:        "RTAX_MAX",
				Description: "",
			},
			constSet{
				Name:        "RTAX_NETMASK",
				Description: "",
			},
			constSet{
				Name:        "RTA_AUTHOR",
				Description: "",
			},
			constSet{
				Name:        "RTA_BRD",
				Description: "",
			},
			constSet{
				Name:        "RTA_DST",
				Description: "",
			},
			constSet{
				Name:        "RTA_GATEWAY",
				Description: "",
			},
			constSet{
				Name:        "RTA_GENMASK",
				Description: "",
			},
			constSet{
				Name:        "RTA_IFA",
				Description: "",
			},
			constSet{
				Name:        "RTA_IFP",
				Description: "",
			},
			constSet{
				Name:        "RTA_NETMASK",
				Description: "",
			},
			constSet{
				Name:        "RTF_BLACKHOLE",
				Description: "",
			},
			constSet{
				Name:        "RTF_BROADCAST",
				Description: "",
			},
			constSet{
				Name:        "RTF_CLONING",
				Description: "",
			},
			constSet{
				Name:        "RTF_CONDEMNED",
				Description: "",
			},
			constSet{
				Name:        "RTF_DELCLONE",
				Description: "",
			},
			constSet{
				Name:        "RTF_DONE",
				Description: "",
			},
			constSet{
				Name:        "RTF_DYNAMIC",
				Description: "",
			},
			constSet{
				Name:        "RTF_GATEWAY",
				Description: "",
			},
			constSet{
				Name:        "RTF_HOST",
				Description: "",
			},
			constSet{
				Name:        "RTF_IFREF",
				Description: "",
			},
			constSet{
				Name:        "RTF_IFSCOPE",
				Description: "",
			},
			constSet{
				Name:        "RTF_LLINFO",
				Description: "",
			},
			constSet{
				Name:        "RTF_LOCAL",
				Description: "",
			},
			constSet{
				Name:        "RTF_MODIFIED",
				Description: "",
			},
			constSet{
				Name:        "RTF_MULTICAST",
				Description: "",
			},
			constSet{
				Name:        "RTF_PINNED",
				Description: "",
			},
			constSet{
				Name:        "RTF_PRCLONING",
				Description: "",
			},
			constSet{
				Name:        "RTF_PROTO1",
				Description: "",
			},
			constSet{
				Name:        "RTF_PROTO2",
				Description: "",
			},
			constSet{
				Name:        "RTF_PROTO3",
				Description: "",
			},
			constSet{
				Name:        "RTF_PROXY",
				Description: "",
			},
			constSet{
				Name:        "RTF_REJECT",
				Description: "",
			},
			constSet{
				Name:        "RTF_ROUTER",
				Description: "",
			},
			constSet{
				Name:        "RTF_STATIC",
				Description: "",
			},
			constSet{
				Name:        "RTF_UP",
				Description: "",
			},
			constSet{
				Name:        "RTF_WASCLONED",
				Description: "",
			},
			constSet{
				Name:        "RTF_XRESOLVE",
				Description: "",
			},
			constSet{
				Name:        "RTM_ADD",
				Description: "",
			},
			constSet{
				Name:        "RTM_CHANGE",
				Description: "",
			},
			constSet{
				Name:        "RTM_DELADDR",
				Description: "",
			},
			constSet{
				Name:        "RTM_DELETE",
				Description: "",
			},
			constSet{
				Name:        "RTM_DELMADDR",
				Description: "",
			},
			constSet{
				Name:        "RTM_GET",
				Description: "",
			},
			constSet{
				Name:        "RTM_GET2",
				Description: "",
			},
			constSet{
				Name:        "RTM_IFINFO",
				Description: "",
			},
			constSet{
				Name:        "RTM_IFINFO2",
				Description: "",
			},
			constSet{
				Name:        "RTM_LOCK",
				Description: "",
			},
			constSet{
				Name:        "RTM_LOSING",
				Description: "",
			},
			constSet{
				Name:        "RTM_MISS",
				Description: "",
			},
			constSet{
				Name:        "RTM_NEWADDR",
				Description: "",
			},
			constSet{
				Name:        "RTM_NEWMADDR",
				Description: "",
			},
			constSet{
				Name:        "RTM_NEWMADDR2",
				Description: "",
			},
			constSet{
				Name:        "RTM_OLDADD",
				Description: "",
			},
			constSet{
				Name:        "RTM_OLDDEL",
				Description: "",
			},
			constSet{
				Name:        "RTM_REDIRECT",
				Description: "",
			},
			constSet{
				Name:        "RTM_RESOLVE",
				Description: "",
			},
			constSet{
				Name:        "RTM_RTTUNIT",
				Description: "",
			},
			constSet{
				Name:        "RTM_VERSION",
				Description: "",
			},
			constSet{
				Name:        "RTV_EXPIRE",
				Description: "",
			},
			constSet{
				Name:        "RTV_HOPCOUNT",
				Description: "",
			},
			constSet{
				Name:        "RTV_MTU",
				Description: "",
			},
			constSet{
				Name:        "RTV_RPIPE",
				Description: "",
			},
			constSet{
				Name:        "RTV_RTT",
				Description: "",
			},
			constSet{
				Name:        "RTV_RTTVAR",
				Description: "",
			},
			constSet{
				Name:        "RTV_SPIPE",
				Description: "",
			},
			constSet{
				Name:        "RTV_SSTHRESH",
				Description: "",
			},
			constSet{
				Name:        "RUSAGE_CHILDREN",
				Description: "",
			},
			constSet{
				Name:        "RUSAGE_SELF",
				Description: "",
			},
			constSet{
				Name:        "SCM_CREDS",
				Description: "",
			},
			constSet{
				Name:        "SCM_RIGHTS",
				Description: "",
			},
			constSet{
				Name:        "SCM_TIMESTAMP",
				Description: "",
			},
			constSet{
				Name:        "SCM_TIMESTAMP_MONOTONIC",
				Description: "",
			},
			constSet{
				Name:        "SHUT_RD",
				Description: "",
			},
			constSet{
				Name:        "SHUT_RDWR",
				Description: "",
			},
			constSet{
				Name:        "SHUT_WR",
				Description: "",
			},
			constSet{
				Name:        "SIGABRT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGALRM",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGBUS",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGCHLD",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGCONT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGEMT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGFPE",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGHUP",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGILL",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGINFO",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGINT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGIO",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGIOT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGKILL",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGPIPE",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGPROF",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGQUIT",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGSEGV",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGSTOP",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGSYS",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGTERM",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGTRAP",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGTSTP",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGTTIN",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGTTOU",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGURG",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGUSR1",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGUSR2",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGVTALRM",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGWINCH",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGXCPU",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIGXFSZ",
				Description: "Signals ",
			},
			constSet{
				Name:        "SIOCADDMULTI",
				Description: "",
			},
			constSet{
				Name:        "SIOCAIFADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCARPIPLL",
				Description: "",
			},
			constSet{
				Name:        "SIOCATMARK",
				Description: "",
			},
			constSet{
				Name:        "SIOCAUTOADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCAUTONETMASK",
				Description: "",
			},
			constSet{
				Name:        "SIOCDELMULTI",
				Description: "",
			},
			constSet{
				Name:        "SIOCDIFADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCDIFPHYADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGDRVSPEC",
				Description: "",
			},
			constSet{
				Name:        "SIOCGETVLAN",
				Description: "",
			},
			constSet{
				Name:        "SIOCGHIWAT",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFALTMTU",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFASYNCMAP",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFBOND",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFBRDADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFCAP",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFCONF",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFDEVMTU",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFDSTADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFGENERIC",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFKPI",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFMAC",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFMEDIA",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFMETRIC",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFMTU",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFNETMASK",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFPDSTADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFPHYS",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFPSRCADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFSTATUS",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFVLAN",
				Description: "",
			},
			constSet{
				Name:        "SIOCGIFWAKEFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SIOCGLOWAT",
				Description: "",
			},
			constSet{
				Name:        "SIOCGPGRP",
				Description: "",
			},
			constSet{
				Name:        "SIOCIFCREATE",
				Description: "",
			},
			constSet{
				Name:        "SIOCIFCREATE2",
				Description: "",
			},
			constSet{
				Name:        "SIOCIFDESTROY",
				Description: "",
			},
			constSet{
				Name:        "SIOCIFGCLONERS",
				Description: "",
			},
			constSet{
				Name:        "SIOCRSLVMULTI",
				Description: "",
			},
			constSet{
				Name:        "SIOCSDRVSPEC",
				Description: "",
			},
			constSet{
				Name:        "SIOCSETVLAN",
				Description: "",
			},
			constSet{
				Name:        "SIOCSHIWAT",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFALTMTU",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFASYNCMAP",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFBOND",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFBRDADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFCAP",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFDSTADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFGENERIC",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFKPI",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFLLADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFMAC",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFMEDIA",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFMETRIC",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFMTU",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFNETMASK",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFPHYADDR",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFPHYS",
				Description: "",
			},
			constSet{
				Name:        "SIOCSIFVLAN",
				Description: "",
			},
			constSet{
				Name:        "SIOCSLOWAT",
				Description: "",
			},
			constSet{
				Name:        "SIOCSPGRP",
				Description: "",
			},
			constSet{
				Name:        "SOCK_DGRAM",
				Description: "",
			},
			constSet{
				Name:        "SOCK_MAXADDRLEN",
				Description: "",
			},
			constSet{
				Name:        "SOCK_RAW",
				Description: "",
			},
			constSet{
				Name:        "SOCK_RDM",
				Description: "",
			},
			constSet{
				Name:        "SOCK_SEQPACKET",
				Description: "",
			},
			constSet{
				Name:        "SOCK_STREAM",
				Description: "",
			},
			constSet{
				Name:        "SOL_SOCKET",
				Description: "",
			},
			constSet{
				Name:        "SOMAXCONN",
				Description: "",
			},
			constSet{
				Name:        "SO_ACCEPTCONN",
				Description: "",
			},
			constSet{
				Name:        "SO_BROADCAST",
				Description: "",
			},
			constSet{
				Name:        "SO_DEBUG",
				Description: "",
			},
			constSet{
				Name:        "SO_DONTROUTE",
				Description: "",
			},
			constSet{
				Name:        "SO_DONTTRUNC",
				Description: "",
			},
			constSet{
				Name:        "SO_ERROR",
				Description: "",
			},
			constSet{
				Name:        "SO_KEEPALIVE",
				Description: "",
			},
			constSet{
				Name:        "SO_LABEL",
				Description: "",
			},
			constSet{
				Name:        "SO_LINGER",
				Description: "",
			},
			constSet{
				Name:        "SO_LINGER_SEC",
				Description: "",
			},
			constSet{
				Name:        "SO_NKE",
				Description: "",
			},
			constSet{
				Name:        "SO_NOADDRERR",
				Description: "",
			},
			constSet{
				Name:        "SO_NOSIGPIPE",
				Description: "",
			},
			constSet{
				Name:        "SO_NOTIFYCONFLICT",
				Description: "",
			},
			constSet{
				Name:        "SO_NP_EXTENSIONS",
				Description: "",
			},
			constSet{
				Name:        "SO_NREAD",
				Description: "",
			},
			constSet{
				Name:        "SO_NUMRCVPKT",
				Description: "",
			},
			constSet{
				Name:        "SO_NWRITE",
				Description: "",
			},
			constSet{
				Name:        "SO_OOBINLINE",
				Description: "",
			},
			constSet{
				Name:        "SO_PEERLABEL",
				Description: "",
			},
			constSet{
				Name:        "SO_RANDOMPORT",
				Description: "",
			},
			constSet{
				Name:        "SO_RCVBUF",
				Description: "",
			},
			constSet{
				Name:        "SO_RCVLOWAT",
				Description: "",
			},
			constSet{
				Name:        "SO_RCVTIMEO",
				Description: "",
			},
			constSet{
				Name:        "SO_REUSEADDR",
				Description: "",
			},
			constSet{
				Name:        "SO_REUSEPORT",
				Description: "",
			},
			constSet{
				Name:        "SO_REUSESHAREUID",
				Description: "",
			},
			constSet{
				Name:        "SO_SNDBUF",
				Description: "",
			},
			constSet{
				Name:        "SO_SNDLOWAT",
				Description: "",
			},
			constSet{
				Name:        "SO_SNDTIMEO",
				Description: "",
			},
			constSet{
				Name:        "SO_TIMESTAMP",
				Description: "",
			},
			constSet{
				Name:        "SO_TIMESTAMP_MONOTONIC",
				Description: "",
			},
			constSet{
				Name:        "SO_TYPE",
				Description: "",
			},
			constSet{
				Name:        "SO_UPCALLCLOSEWAIT",
				Description: "",
			},
			constSet{
				Name:        "SO_USELOOPBACK",
				Description: "",
			},
			constSet{
				Name:        "SO_WANTMORE",
				Description: "",
			},
			constSet{
				Name:        "SO_WANTOOBFLAG",
				Description: "",
			},
			constSet{
				Name:        "SYS_ACCEPT",
				Description: "",
			},
			constSet{
				Name:        "SYS_ACCEPT_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_ACCESS",
				Description: "",
			},
			constSet{
				Name:        "SYS_ACCESS_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_ACCT",
				Description: "",
			},
			constSet{
				Name:        "SYS_ADJTIME",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_CANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_ERROR",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_FSYNC",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_READ",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_RETURN",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_SUSPEND",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_SUSPEND_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_AIO_WRITE",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATGETMSG",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATPGETREQ",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATPGETRSP",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATPSNDREQ",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATPSNDRSP",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATPUTMSG",
				Description: "",
			},
			constSet{
				Name:        "SYS_ATSOCKET",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDITCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDITON",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDIT_SESSION_JOIN",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDIT_SESSION_PORT",
				Description: "",
			},
			constSet{
				Name:        "SYS_AUDIT_SESSION_SELF",
				Description: "",
			},
			constSet{
				Name:        "SYS_BIND",
				Description: "",
			},
			constSet{
				Name:        "SYS_BSDTHREAD_CREATE",
				Description: "",
			},
			constSet{
				Name:        "SYS_BSDTHREAD_REGISTER",
				Description: "",
			},
			constSet{
				Name:        "SYS_BSDTHREAD_TERMINATE",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHMOD",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHMOD_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHOWN",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHROOT",
				Description: "",
			},
			constSet{
				Name:        "SYS_CHUD",
				Description: "",
			},
			constSet{
				Name:        "SYS_CLOSE",
				Description: "",
			},
			constSet{
				Name:        "SYS_CLOSE_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_CONNECT",
				Description: "",
			},
			constSet{
				Name:        "SYS_CONNECT_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_COPYFILE",
				Description: "",
			},
			constSet{
				Name:        "SYS_CSOPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_CSOPS_AUDITTOKEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_DELETE",
				Description: "",
			},
			constSet{
				Name:        "SYS_DUP",
				Description: "",
			},
			constSet{
				Name:        "SYS_DUP2",
				Description: "",
			},
			constSet{
				Name:        "SYS_EXCHANGEDATA",
				Description: "",
			},
			constSet{
				Name:        "SYS_EXECVE",
				Description: "",
			},
			constSet{
				Name:        "SYS_EXIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCHDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCHFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCHMOD",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCHMOD_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCHOWN",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCNTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_FCNTL_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_FDATASYNC",
				Description: "",
			},
			constSet{
				Name:        "SYS_FFSCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_FGETATTRLIST",
				Description: "",
			},
			constSet{
				Name:        "SYS_FGETXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_FHOPEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_FILEPORT_MAKEFD",
				Description: "",
			},
			constSet{
				Name:        "SYS_FILEPORT_MAKEPORT",
				Description: "",
			},
			constSet{
				Name:        "SYS_FLISTXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_FLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_FORK",
				Description: "",
			},
			constSet{
				Name:        "SYS_FPATHCONF",
				Description: "",
			},
			constSet{
				Name:        "SYS_FREMOVEXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSETATTRLIST",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSETXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSGETPATH",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTAT",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTAT64",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTAT64_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTATFS",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTATFS64",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSTAT_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSYNC",
				Description: "",
			},
			constSet{
				Name:        "SYS_FSYNC_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_FTRUNCATE",
				Description: "",
			},
			constSet{
				Name:        "SYS_FUTIMES",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETATTRLIST",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETAUDIT_ADDR",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETAUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETDIRENTRIES",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETDIRENTRIES64",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETDIRENTRIESATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETDTABLESIZE",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETEGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETEUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETFH",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETFSSTAT",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETFSSTAT64",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETHOSTUUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETITIMER",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETLCID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETLOGIN",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPEERNAME",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPGRP",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPPID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETPRIORITY",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETRLIMIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETRUSAGE",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETSGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETSID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETSOCKNAME",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETSOCKOPT",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETTID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETTIMEOFDAY",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETWGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_GETXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_IDENTITYSVC",
				Description: "",
			},
			constSet{
				Name:        "SYS_INITGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_IOCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_IOPOLICYSYS",
				Description: "",
			},
			constSet{
				Name:        "SYS_ISSETUGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_KAS_INFO",
				Description: "",
			},
			constSet{
				Name:        "SYS_KDEBUG_TRACE",
				Description: "",
			},
			constSet{
				Name:        "SYS_KEVENT",
				Description: "",
			},
			constSet{
				Name:        "SYS_KEVENT64",
				Description: "",
			},
			constSet{
				Name:        "SYS_KILL",
				Description: "",
			},
			constSet{
				Name:        "SYS_KQUEUE",
				Description: "",
			},
			constSet{
				Name:        "SYS_LCHOWN",
				Description: "",
			},
			constSet{
				Name:        "SYS_LEDGER",
				Description: "",
			},
			constSet{
				Name:        "SYS_LINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_LIO_LISTIO",
				Description: "",
			},
			constSet{
				Name:        "SYS_LISTEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_LISTXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_LSEEK",
				Description: "",
			},
			constSet{
				Name:        "SYS_LSTAT",
				Description: "",
			},
			constSet{
				Name:        "SYS_LSTAT64",
				Description: "",
			},
			constSet{
				Name:        "SYS_LSTAT64_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_LSTAT_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_MADVISE",
				Description: "",
			},
			constSet{
				Name:        "SYS_MAXSYSCALL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MINCORE",
				Description: "",
			},
			constSet{
				Name:        "SYS_MINHERIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_MKDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS_MKDIR_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_MKFIFO",
				Description: "",
			},
			constSet{
				Name:        "SYS_MKFIFO_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_MKNOD",
				Description: "",
			},
			constSet{
				Name:        "SYS_MLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_MLOCKALL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MMAP",
				Description: "",
			},
			constSet{
				Name:        "SYS_MODWATCH",
				Description: "",
			},
			constSet{
				Name:        "SYS_MOUNT",
				Description: "",
			},
			constSet{
				Name:        "SYS_MPROTECT",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGGET",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGRCV",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGRCV_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGSND",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGSND_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSGSYS",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSYNC",
				Description: "",
			},
			constSet{
				Name:        "SYS_MSYNC_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MUNLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_MUNLOCKALL",
				Description: "",
			},
			constSet{
				Name:        "SYS_MUNMAP",
				Description: "",
			},
			constSet{
				Name:        "SYS_NFSCLNT",
				Description: "",
			},
			constSet{
				Name:        "SYS_NFSSVC",
				Description: "",
			},
			constSet{
				Name:        "SYS_OPEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_OPEN_DPROTECTED_NP",
				Description: "",
			},
			constSet{
				Name:        "SYS_OPEN_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_OPEN_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_PATHCONF",
				Description: "",
			},
			constSet{
				Name:        "SYS_PID_HIBERNATE",
				Description: "",
			},
			constSet{
				Name:        "SYS_PID_RESUME",
				Description: "",
			},
			constSet{
				Name:        "SYS_PID_SHUTDOWN_SOCKETS",
				Description: "",
			},
			constSet{
				Name:        "SYS_PID_SUSPEND",
				Description: "",
			},
			constSet{
				Name:        "SYS_PIPE",
				Description: "",
			},
			constSet{
				Name:        "SYS_POLL",
				Description: "",
			},
			constSet{
				Name:        "SYS_POLL_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_POSIX_SPAWN",
				Description: "",
			},
			constSet{
				Name:        "SYS_PREAD",
				Description: "",
			},
			constSet{
				Name:        "SYS_PREAD_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_PROCESS_POLICY",
				Description: "",
			},
			constSet{
				Name:        "SYS_PROC_INFO",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_CVBROAD",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_CVCLRPREPOST",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_CVSIGNAL",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_CVWAIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_MUTEXDROP",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_MUTEXWAIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_DOWNGRADE",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_LONGRDLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_RDLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_UNLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_UNLOCK2",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_UPGRADE",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_WRLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_PSYNCH_RW_YIELDWRLOCK",
				Description: "",
			},
			constSet{
				Name:        "SYS_PTRACE",
				Description: "",
			},
			constSet{
				Name:        "SYS_PWRITE",
				Description: "",
			},
			constSet{
				Name:        "SYS_PWRITE_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_QUOTACTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_READ",
				Description: "",
			},
			constSet{
				Name:        "SYS_READLINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_READV",
				Description: "",
			},
			constSet{
				Name:        "SYS_READV_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_READ_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_REBOOT",
				Description: "",
			},
			constSet{
				Name:        "SYS_RECVFROM",
				Description: "",
			},
			constSet{
				Name:        "SYS_RECVFROM_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_RECVMSG",
				Description: "",
			},
			constSet{
				Name:        "SYS_RECVMSG_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_REMOVEXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_RENAME",
				Description: "",
			},
			constSet{
				Name:        "SYS_REVOKE",
				Description: "",
			},
			constSet{
				Name:        "SYS_RMDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEARCHFS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SELECT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SELECT_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEMCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEMGET",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEMOP",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEMSYS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_CLOSE",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_DESTROY",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_GETVALUE",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_INIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_OPEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_POST",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_TRYWAIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_UNLINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_WAIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SEM_WAIT_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SENDFILE",
				Description: "",
			},
			constSet{
				Name:        "SYS_SENDMSG",
				Description: "",
			},
			constSet{
				Name:        "SYS_SENDMSG_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SENDTO",
				Description: "",
			},
			constSet{
				Name:        "SYS_SENDTO_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETATTRLIST",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETAUDIT_ADDR",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETAUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETEGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETEUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETITIMER",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETLCID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETLOGIN",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETPGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETPRIORITY",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETPRIVEXEC",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETREGID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETREUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETRLIMIT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETSGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETSID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETSOCKOPT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETTID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETTID_WITH_PID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETTIMEOFDAY",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETUID",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETWGROUPS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SETXATTR",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHARED_REGION_CHECK_NP",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHARED_REGION_MAP_AND_SLIDE_NP",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHMAT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHMCTL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHMDT",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHMGET",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHMSYS",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHM_OPEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHM_UNLINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_SHUTDOWN",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGACTION",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGALTSTACK",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGPENDING",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGPROCMASK",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGRETURN",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGSUSPEND",
				Description: "",
			},
			constSet{
				Name:        "SYS_SIGSUSPEND_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_SOCKET",
				Description: "",
			},
			constSet{
				Name:        "SYS_SOCKETPAIR",
				Description: "",
			},
			constSet{
				Name:        "SYS_STACK_SNAPSHOT",
				Description: "",
			},
			constSet{
				Name:        "SYS_STAT",
				Description: "",
			},
			constSet{
				Name:        "SYS_STAT64",
				Description: "",
			},
			constSet{
				Name:        "SYS_STAT64_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_STATFS",
				Description: "",
			},
			constSet{
				Name:        "SYS_STATFS64",
				Description: "",
			},
			constSet{
				Name:        "SYS_STAT_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_SWAPON",
				Description: "",
			},
			constSet{
				Name:        "SYS_SYMLINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_SYNC",
				Description: "",
			},
			constSet{
				Name:        "SYS_SYSCALL",
				Description: "",
			},
			constSet{
				Name:        "SYS_THREAD_SELFID",
				Description: "",
			},
			constSet{
				Name:        "SYS_TRUNCATE",
				Description: "",
			},
			constSet{
				Name:        "SYS_UMASK",
				Description: "",
			},
			constSet{
				Name:        "SYS_UMASK_EXTENDED",
				Description: "",
			},
			constSet{
				Name:        "SYS_UNDELETE",
				Description: "",
			},
			constSet{
				Name:        "SYS_UNLINK",
				Description: "",
			},
			constSet{
				Name:        "SYS_UNMOUNT",
				Description: "",
			},
			constSet{
				Name:        "SYS_UTIMES",
				Description: "",
			},
			constSet{
				Name:        "SYS_VFORK",
				Description: "",
			},
			constSet{
				Name:        "SYS_VM_PRESSURE_MONITOR",
				Description: "",
			},
			constSet{
				Name:        "SYS_WAIT4",
				Description: "",
			},
			constSet{
				Name:        "SYS_WAIT4_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_WAITEVENT",
				Description: "",
			},
			constSet{
				Name:        "SYS_WAITID",
				Description: "",
			},
			constSet{
				Name:        "SYS_WAITID_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_WATCHEVENT",
				Description: "",
			},
			constSet{
				Name:        "SYS_WORKQ_KERNRETURN",
				Description: "",
			},
			constSet{
				Name:        "SYS_WORKQ_OPEN",
				Description: "",
			},
			constSet{
				Name:        "SYS_WRITE",
				Description: "",
			},
			constSet{
				Name:        "SYS_WRITEV",
				Description: "",
			},
			constSet{
				Name:        "SYS_WRITEV_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS_WRITE_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS___DISABLE_THREADSIGNAL",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_EXECVE",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GETFSSTAT",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_FD",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_FILE",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_LCID",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_LCTX",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_LINK",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_MOUNT",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_PID",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_GET_PROC",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_MOUNT",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SET_FD",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SET_FILE",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SET_LCTX",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SET_LINK",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SET_PROC",
				Description: "",
			},
			constSet{
				Name:        "SYS___MAC_SYSCALL",
				Description: "",
			},
			constSet{
				Name:        "SYS___OLD_SEMWAIT_SIGNAL",
				Description: "",
			},
			constSet{
				Name:        "SYS___OLD_SEMWAIT_SIGNAL_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_CANCELED",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_CHDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_FCHDIR",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_KILL",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_MARKCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS___PTHREAD_SIGMASK",
				Description: "",
			},
			constSet{
				Name:        "SYS___SEMWAIT_SIGNAL",
				Description: "",
			},
			constSet{
				Name:        "SYS___SEMWAIT_SIGNAL_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS___SIGWAIT",
				Description: "",
			},
			constSet{
				Name:        "SYS___SIGWAIT_NOCANCEL",
				Description: "",
			},
			constSet{
				Name:        "SYS___SYSCTL",
				Description: "",
			},
			constSet{
				Name:        "S_IEXEC",
				Description: "",
			},
			constSet{
				Name:        "S_IFBLK",
				Description: "",
			},
			constSet{
				Name:        "S_IFCHR",
				Description: "",
			},
			constSet{
				Name:        "S_IFDIR",
				Description: "",
			},
			constSet{
				Name:        "S_IFIFO",
				Description: "",
			},
			constSet{
				Name:        "S_IFLNK",
				Description: "",
			},
			constSet{
				Name:        "S_IFMT",
				Description: "",
			},
			constSet{
				Name:        "S_IFREG",
				Description: "",
			},
			constSet{
				Name:        "S_IFSOCK",
				Description: "",
			},
			constSet{
				Name:        "S_IFWHT",
				Description: "",
			},
			constSet{
				Name:        "S_IREAD",
				Description: "",
			},
			constSet{
				Name:        "S_IRGRP",
				Description: "",
			},
			constSet{
				Name:        "S_IROTH",
				Description: "",
			},
			constSet{
				Name:        "S_IRUSR",
				Description: "",
			},
			constSet{
				Name:        "S_IRWXG",
				Description: "",
			},
			constSet{
				Name:        "S_IRWXO",
				Description: "",
			},
			constSet{
				Name:        "S_IRWXU",
				Description: "",
			},
			constSet{
				Name:        "S_ISGID",
				Description: "",
			},
			constSet{
				Name:        "S_ISTXT",
				Description: "",
			},
			constSet{
				Name:        "S_ISUID",
				Description: "",
			},
			constSet{
				Name:        "S_ISVTX",
				Description: "",
			},
			constSet{
				Name:        "S_IWGRP",
				Description: "",
			},
			constSet{
				Name:        "S_IWOTH",
				Description: "",
			},
			constSet{
				Name:        "S_IWRITE",
				Description: "",
			},
			constSet{
				Name:        "S_IWUSR",
				Description: "",
			},
			constSet{
				Name:        "S_IXGRP",
				Description: "",
			},
			constSet{
				Name:        "S_IXOTH",
				Description: "",
			},
			constSet{
				Name:        "S_IXUSR",
				Description: "",
			},
			constSet{
				Name:        "SizeofBpfHdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofBpfInsn",
				Description: "",
			},
			constSet{
				Name:        "SizeofBpfProgram",
				Description: "",
			},
			constSet{
				Name:        "SizeofBpfStat",
				Description: "",
			},
			constSet{
				Name:        "SizeofBpfVersion",
				Description: "",
			},
			constSet{
				Name:        "SizeofCmsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofICMPv6Filter",
				Description: "",
			},
			constSet{
				Name:        "SizeofIPMreq",
				Description: "",
			},
			constSet{
				Name:        "SizeofIPv6MTUInfo",
				Description: "",
			},
			constSet{
				Name:        "SizeofIPv6Mreq",
				Description: "",
			},
			constSet{
				Name:        "SizeofIfData",
				Description: "",
			},
			constSet{
				Name:        "SizeofIfMsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofIfaMsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofIfmaMsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofIfmaMsghdr2",
				Description: "",
			},
			constSet{
				Name:        "SizeofInet4Pktinfo",
				Description: "",
			},
			constSet{
				Name:        "SizeofInet6Pktinfo",
				Description: "",
			},
			constSet{
				Name:        "SizeofLinger",
				Description: "",
			},
			constSet{
				Name:        "SizeofMsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofRtMetrics",
				Description: "",
			},
			constSet{
				Name:        "SizeofRtMsghdr",
				Description: "",
			},
			constSet{
				Name:        "SizeofSockaddrAny",
				Description: "",
			},
			constSet{
				Name:        "SizeofSockaddrDatalink",
				Description: "",
			},
			constSet{
				Name:        "SizeofSockaddrInet4",
				Description: "",
			},
			constSet{
				Name:        "SizeofSockaddrInet6",
				Description: "",
			},
			constSet{
				Name:        "SizeofSockaddrUnix",
				Description: "",
			},
			constSet{
				Name:        "TCIFLUSH",
				Description: "",
			},
			constSet{
				Name:        "TCIOFLUSH",
				Description: "",
			},
			constSet{
				Name:        "TCOFLUSH",
				Description: "",
			},
			constSet{
				Name:        "TCP_CONNECTIONTIMEOUT",
				Description: "",
			},
			constSet{
				Name:        "TCP_ENABLE_ECN",
				Description: "",
			},
			constSet{
				Name:        "TCP_KEEPALIVE",
				Description: "",
			},
			constSet{
				Name:        "TCP_KEEPCNT",
				Description: "",
			},
			constSet{
				Name:        "TCP_KEEPINTVL",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAXHLEN",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAXOLEN",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAXSEG",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAXWIN",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAX_SACK",
				Description: "",
			},
			constSet{
				Name:        "TCP_MAX_WINSHIFT",
				Description: "",
			},
			constSet{
				Name:        "TCP_MINMSS",
				Description: "",
			},
			constSet{
				Name:        "TCP_MSS",
				Description: "",
			},
			constSet{
				Name:        "TCP_NODELAY",
				Description: "",
			},
			constSet{
				Name:        "TCP_NOOPT",
				Description: "",
			},
			constSet{
				Name:        "TCP_NOPUSH",
				Description: "",
			},
			constSet{
				Name:        "TCP_NOTSENT_LOWAT",
				Description: "",
			},
			constSet{
				Name:        "TCP_RXT_CONNDROPTIME",
				Description: "",
			},
			constSet{
				Name:        "TCP_RXT_FINDROP",
				Description: "",
			},
			constSet{
				Name:        "TCP_SENDMOREACKS",
				Description: "",
			},
			constSet{
				Name:        "TCSAFLUSH",
				Description: "",
			},
			constSet{
				Name:        "TIOCCBRK",
				Description: "",
			},
			constSet{
				Name:        "TIOCCDTR",
				Description: "",
			},
			constSet{
				Name:        "TIOCCONS",
				Description: "",
			},
			constSet{
				Name:        "TIOCDCDTIMESTAMP",
				Description: "",
			},
			constSet{
				Name:        "TIOCDRAIN",
				Description: "",
			},
			constSet{
				Name:        "TIOCDSIMICROCODE",
				Description: "",
			},
			constSet{
				Name:        "TIOCEXCL",
				Description: "",
			},
			constSet{
				Name:        "TIOCEXT",
				Description: "",
			},
			constSet{
				Name:        "TIOCFLUSH",
				Description: "",
			},
			constSet{
				Name:        "TIOCGDRAINWAIT",
				Description: "",
			},
			constSet{
				Name:        "TIOCGETA",
				Description: "",
			},
			constSet{
				Name:        "TIOCGETD",
				Description: "",
			},
			constSet{
				Name:        "TIOCGPGRP",
				Description: "",
			},
			constSet{
				Name:        "TIOCGWINSZ",
				Description: "",
			},
			constSet{
				Name:        "TIOCIXOFF",
				Description: "",
			},
			constSet{
				Name:        "TIOCIXON",
				Description: "",
			},
			constSet{
				Name:        "TIOCMBIC",
				Description: "",
			},
			constSet{
				Name:        "TIOCMBIS",
				Description: "",
			},
			constSet{
				Name:        "TIOCMGDTRWAIT",
				Description: "",
			},
			constSet{
				Name:        "TIOCMGET",
				Description: "",
			},
			constSet{
				Name:        "TIOCMODG",
				Description: "",
			},
			constSet{
				Name:        "TIOCMODS",
				Description: "",
			},
			constSet{
				Name:        "TIOCMSDTRWAIT",
				Description: "",
			},
			constSet{
				Name:        "TIOCMSET",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_CAR",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_CD",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_CTS",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_DSR",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_DTR",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_LE",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_RI",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_RNG",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_RTS",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_SR",
				Description: "",
			},
			constSet{
				Name:        "TIOCM_ST",
				Description: "",
			},
			constSet{
				Name:        "TIOCNOTTY",
				Description: "",
			},
			constSet{
				Name:        "TIOCNXCL",
				Description: "",
			},
			constSet{
				Name:        "TIOCOUTQ",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_DATA",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_DOSTOP",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_FLUSHREAD",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_FLUSHWRITE",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_IOCTL",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_NOSTOP",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_START",
				Description: "",
			},
			constSet{
				Name:        "TIOCPKT_STOP",
				Description: "",
			},
			constSet{
				Name:        "TIOCPTYGNAME",
				Description: "",
			},
			constSet{
				Name:        "TIOCPTYGRANT",
				Description: "",
			},
			constSet{
				Name:        "TIOCPTYUNLK",
				Description: "",
			},
			constSet{
				Name:        "TIOCREMOTE",
				Description: "",
			},
			constSet{
				Name:        "TIOCSBRK",
				Description: "",
			},
			constSet{
				Name:        "TIOCSCONS",
				Description: "",
			},
			constSet{
				Name:        "TIOCSCTTY",
				Description: "",
			},
			constSet{
				Name:        "TIOCSDRAINWAIT",
				Description: "",
			},
			constSet{
				Name:        "TIOCSDTR",
				Description: "",
			},
			constSet{
				Name:        "TIOCSETA",
				Description: "",
			},
			constSet{
				Name:        "TIOCSETAF",
				Description: "",
			},
			constSet{
				Name:        "TIOCSETAW",
				Description: "",
			},
			constSet{
				Name:        "TIOCSETD",
				Description: "",
			},
			constSet{
				Name:        "TIOCSIG",
				Description: "",
			},
			constSet{
				Name:        "TIOCSPGRP",
				Description: "",
			},
			constSet{
				Name:        "TIOCSTART",
				Description: "",
			},
			constSet{
				Name:        "TIOCSTAT",
				Description: "",
			},
			constSet{
				Name:        "TIOCSTI",
				Description: "",
			},
			constSet{
				Name:        "TIOCSTOP",
				Description: "",
			},
			constSet{
				Name:        "TIOCSWINSZ",
				Description: "",
			},
			constSet{
				Name:        "TIOCTIMESTAMP",
				Description: "",
			},
			constSet{
				Name:        "TIOCUCNTL",
				Description: "",
			},
			constSet{
				Name:        "TOSTOP",
				Description: "",
			},
			constSet{
				Name:        "VDISCARD",
				Description: "",
			},
			constSet{
				Name:        "VDSUSP",
				Description: "",
			},
			constSet{
				Name:        "VEOF",
				Description: "",
			},
			constSet{
				Name:        "VEOL",
				Description: "",
			},
			constSet{
				Name:        "VEOL2",
				Description: "",
			},
			constSet{
				Name:        "VERASE",
				Description: "",
			},
			constSet{
				Name:        "VINTR",
				Description: "",
			},
			constSet{
				Name:        "VKILL",
				Description: "",
			},
			constSet{
				Name:        "VLNEXT",
				Description: "",
			},
			constSet{
				Name:        "VMIN",
				Description: "",
			},
			constSet{
				Name:        "VQUIT",
				Description: "",
			},
			constSet{
				Name:        "VREPRINT",
				Description: "",
			},
			constSet{
				Name:        "VSTART",
				Description: "",
			},
			constSet{
				Name:        "VSTATUS",
				Description: "",
			},
			constSet{
				Name:        "VSTOP",
				Description: "",
			},
			constSet{
				Name:        "VSUSP",
				Description: "",
			},
			constSet{
				Name:        "VT0",
				Description: "",
			},
			constSet{
				Name:        "VT1",
				Description: "",
			},
			constSet{
				Name:        "VTDLY",
				Description: "",
			},
			constSet{
				Name:        "VTIME",
				Description: "",
			},
			constSet{
				Name:        "VWERASE",
				Description: "",
			},
			constSet{
				Name:        "WCONTINUED",
				Description: "",
			},
			constSet{
				Name:        "WCOREFLAG",
				Description: "",
			},
			constSet{
				Name:        "WEXITED",
				Description: "",
			},
			constSet{
				Name:        "WNOHANG",
				Description: "",
			},
			constSet{
				Name:        "WNOWAIT",
				Description: "",
			},
			constSet{
				Name:        "WORDSIZE",
				Description: "",
			},
			constSet{
				Name:        "WSTOPPED",
				Description: "",
			},
			constSet{
				Name:        "WUNTRACED",
				Description: "",
			},
		},
		"unix": []constSet{
			constSet{
				Name:        "AI_ALL",
				Description: "",
			},
			constSet{
				Name:        "AI_CANONNAME",
				Description: "",
			},
			constSet{
				Name:        "AI_MASK",
				Description: "",
			},
			constSet{
				Name:        "AI_V4MAPPED",
				Description: "",
			},
			constSet{
				Name:        "AT_EACCESS",
				Description: "",
			},
			constSet{
				Name:        "AT_FDCWD",
				Description: "",
			},
			constSet{
				Name:        "AT_REMOVEDIR",
				Description: "",
			},
			constSet{
				Name:        "AT_SYMLINK_NOFOLLOW",
				Description: "",
			},
			constSet{
				Name:        "EAI_ADDRFAMILY",
				Description: "",
			},
			constSet{
				Name:        "EAI_AGAIN",
				Description: "",
			},
			constSet{
				Name:        "EAI_NODATA",
				Description: "",
			},
			constSet{
				Name:        "EAI_NONAME",
				Description: "",
			},
			constSet{
				Name:        "EAI_OVERFLOW",
				Description: "",
			},
			constSet{
				Name:        "EAI_SERVICE",
				Description: "",
			},
			constSet{
				Name:        "EAI_SYSTEM",
				Description: "",
			},
			constSet{
				Name:        "NI_NAMEREQD",
				Description: "",
			},
			constSet{
				Name:        "NoFollowErrno",
				Description: "NoFollowErrno is the error returned from open/openat called with O_NOFOLLOW flag, when the trailing component (basename) of the path is a symbolic link. ",
			},
			constSet{
				Name:        "R_OK",
				Description: "",
			},
			constSet{
				Name:        "SC_GETGR_R_SIZE_MAX",
				Description: "",
			},
			constSet{
				Name:        "SC_GETPW_R_SIZE_MAX",
				Description: "",
			},
			constSet{
				Name:        "UTIME_OMIT",
				Description: "",
			},
			constSet{
				Name:        "W_OK",
				Description: "",
			},
			constSet{
				Name:        "X_OK",
				Description: "",
			},
		},
		"crc32": []constSet{
			constSet{
				Name:        "Castagnoli",
				Description: "Castagnoli's polynomial, used in iSCSI. Has better error detection characteristics than IEEE. https://dx.doi.org/10.1109/26.231911 ",
			},
			constSet{
				Name:        "IEEE",
				Description: "IEEE is by far and away the most common CRC-32 polynomial. Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ... ",
			},
			constSet{
				Name:        "Koopman",
				Description: "Koopman's polynomial. Also has better error detection characteristics than IEEE. https://dx.doi.org/10.1109/DSN.2002.1028931 ",
			},
			constSet{
				Name:        "Size",
				Description: "The size of a CRC-32 checksum in bytes. ",
			},
		},
		"lzw": []constSet{
			constSet{
				Name:        "LSB",
				Description: "LSB means Least Significant Bits first, as used in the GIF file format. ",
			},
			constSet{
				Name:        "MSB",
				Description: "MSB means Most Significant Bits first, as used in the TIFF and PDF file formats. ",
			},
		},
		"net": []constSet{
			constSet{
				Name:        "FlagBroadcast",
				Description: "",
			},
			constSet{
				Name:        "FlagLoopback",
				Description: "",
			},
			constSet{
				Name:        "FlagMulticast",
				Description: "",
			},
			constSet{
				Name:        "FlagPointToPoint",
				Description: "",
			},
			constSet{
				Name:        "FlagRunning",
				Description: "",
			},
			constSet{
				Name:        "FlagUp",
				Description: "",
			},
			constSet{
				Name:        "IPv4len",
				Description: "IP address lengths (bytes). ",
			},
			constSet{
				Name:        "IPv6len",
				Description: "IP address lengths (bytes). ",
			},
		},
		"dwarf": []constSet{
			constSet{
				Name:        "AttrAbstractOrigin",
				Description: "",
			},
			constSet{
				Name:        "AttrAccessibility",
				Description: "",
			},
			constSet{
				Name:        "AttrAddrBase",
				Description: "",
			},
			constSet{
				Name:        "AttrAddrClass",
				Description: "",
			},
			constSet{
				Name:        "AttrAlignment",
				Description: "",
			},
			constSet{
				Name:        "AttrAllocated",
				Description: "The following are new in DWARF 3. ",
			},
			constSet{
				Name:        "AttrArtificial",
				Description: "",
			},
			constSet{
				Name:        "AttrAssociated",
				Description: "",
			},
			constSet{
				Name:        "AttrBaseTypes",
				Description: "",
			},
			constSet{
				Name:        "AttrBinaryScale",
				Description: "",
			},
			constSet{
				Name:        "AttrBitOffset",
				Description: "",
			},
			constSet{
				Name:        "AttrBitSize",
				Description: "",
			},
			constSet{
				Name:        "AttrByteSize",
				Description: "",
			},
			constSet{
				Name:        "AttrCallAllCalls",
				Description: "",
			},
			constSet{
				Name:        "AttrCallAllSourceCalls",
				Description: "",
			},
			constSet{
				Name:        "AttrCallAllTailCalls",
				Description: "",
			},
			constSet{
				Name:        "AttrCallColumn",
				Description: "",
			},
			constSet{
				Name:        "AttrCallDataLocation",
				Description: "",
			},
			constSet{
				Name:        "AttrCallDataValue",
				Description: "",
			},
			constSet{
				Name:        "AttrCallFile",
				Description: "",
			},
			constSet{
				Name:        "AttrCallLine",
				Description: "",
			},
			constSet{
				Name:        "AttrCallOrigin",
				Description: "",
			},
			constSet{
				Name:        "AttrCallPC",
				Description: "",
			},
			constSet{
				Name:        "AttrCallParameter",
				Description: "",
			},
			constSet{
				Name:        "AttrCallReturnPC",
				Description: "",
			},
			constSet{
				Name:        "AttrCallTailCall",
				Description: "",
			},
			constSet{
				Name:        "AttrCallTarget",
				Description: "",
			},
			constSet{
				Name:        "AttrCallTargetClobbered",
				Description: "",
			},
			constSet{
				Name:        "AttrCallValue",
				Description: "",
			},
			constSet{
				Name:        "AttrCalling",
				Description: "",
			},
			constSet{
				Name:        "AttrCommonRef",
				Description: "",
			},
			constSet{
				Name:        "AttrCompDir",
				Description: "",
			},
			constSet{
				Name:        "AttrConstExpr",
				Description: "",
			},
			constSet{
				Name:        "AttrConstValue",
				Description: "",
			},
			constSet{
				Name:        "AttrContainingType",
				Description: "",
			},
			constSet{
				Name:        "AttrCount",
				Description: "",
			},
			constSet{
				Name:        "AttrDataBitOffset",
				Description: "",
			},
			constSet{
				Name:        "AttrDataLocation",
				Description: "",
			},
			constSet{
				Name:        "AttrDataMemberLoc",
				Description: "",
			},
			constSet{
				Name:        "AttrDecimalScale",
				Description: "",
			},
			constSet{
				Name:        "AttrDecimalSign",
				Description: "",
			},
			constSet{
				Name:        "AttrDeclColumn",
				Description: "",
			},
			constSet{
				Name:        "AttrDeclFile",
				Description: "",
			},
			constSet{
				Name:        "AttrDeclLine",
				Description: "",
			},
			constSet{
				Name:        "AttrDeclaration",
				Description: "",
			},
			constSet{
				Name:        "AttrDefaultValue",
				Description: "",
			},
			constSet{
				Name:        "AttrDefaulted",
				Description: "",
			},
			constSet{
				Name:        "AttrDeleted",
				Description: "",
			},
			constSet{
				Name:        "AttrDescription",
				Description: "",
			},
			constSet{
				Name:        "AttrDigitCount",
				Description: "",
			},
			constSet{
				Name:        "AttrDiscr",
				Description: "",
			},
			constSet{
				Name:        "AttrDiscrList",
				Description: "",
			},
			constSet{
				Name:        "AttrDiscrValue",
				Description: "",
			},
			constSet{
				Name:        "AttrDwoName",
				Description: "",
			},
			constSet{
				Name:        "AttrElemental",
				Description: "",
			},
			constSet{
				Name:        "AttrEncoding",
				Description: "",
			},
			constSet{
				Name:        "AttrEndianity",
				Description: "",
			},
			constSet{
				Name:        "AttrEntrypc",
				Description: "",
			},
			constSet{
				Name:        "AttrEnumClass",
				Description: "",
			},
			constSet{
				Name:        "AttrExplicit",
				Description: "",
			},
			constSet{
				Name:        "AttrExportSymbols",
				Description: "",
			},
			constSet{
				Name:        "AttrExtension",
				Description: "",
			},
			constSet{
				Name:        "AttrExternal",
				Description: "",
			},
			constSet{
				Name:        "AttrFrameBase",
				Description: "",
			},
			constSet{
				Name:        "AttrFriend",
				Description: "",
			},
			constSet{
				Name:        "AttrHighpc",
				Description: "",
			},
			constSet{
				Name:        "AttrIdentifierCase",
				Description: "",
			},
			constSet{
				Name:        "AttrImport",
				Description: "",
			},
			constSet{
				Name:        "AttrInline",
				Description: "",
			},
			constSet{
				Name:        "AttrIsOptional",
				Description: "",
			},
			constSet{
				Name:        "AttrLanguage",
				Description: "",
			},
			constSet{
				Name:        "AttrLinkageName",
				Description: "",
			},
			constSet{
				Name:        "AttrLocation",
				Description: "",
			},
			constSet{
				Name:        "AttrLoclistsBase",
				Description: "",
			},
			constSet{
				Name:        "AttrLowerBound",
				Description: "",
			},
			constSet{
				Name:        "AttrLowpc",
				Description: "",
			},
			constSet{
				Name:        "AttrMacroInfo",
				Description: "",
			},
			constSet{
				Name:        "AttrMacros",
				Description: "",
			},
			constSet{
				Name:        "AttrMainSubprogram",
				Description: "",
			},
			constSet{
				Name:        "AttrMutable",
				Description: "",
			},
			constSet{
				Name:        "AttrName",
				Description: "",
			},
			constSet{
				Name:        "AttrNamelistItem",
				Description: "",
			},
			constSet{
				Name:        "AttrNoreturn",
				Description: "",
			},
			constSet{
				Name:        "AttrObjectPointer",
				Description: "",
			},
			constSet{
				Name:        "AttrOrdering",
				Description: "",
			},
			constSet{
				Name:        "AttrPictureString",
				Description: "",
			},
			constSet{
				Name:        "AttrPriority",
				Description: "",
			},
			constSet{
				Name:        "AttrProducer",
				Description: "",
			},
			constSet{
				Name:        "AttrPrototyped",
				Description: "",
			},
			constSet{
				Name:        "AttrPure",
				Description: "",
			},
			constSet{
				Name:        "AttrRanges",
				Description: "",
			},
			constSet{
				Name:        "AttrRank",
				Description: "",
			},
			constSet{
				Name:        "AttrRecursive",
				Description: "",
			},
			constSet{
				Name:        "AttrReference",
				Description: "",
			},
			constSet{
				Name:        "AttrReturnAddr",
				Description: "",
			},
			constSet{
				Name:        "AttrRnglistsBase",
				Description: "",
			},
			constSet{
				Name:        "AttrRvalueReference",
				Description: "",
			},
			constSet{
				Name:        "AttrSegment",
				Description: "",
			},
			constSet{
				Name:        "AttrSibling",
				Description: "",
			},
			constSet{
				Name:        "AttrSignature",
				Description: "The following are new in DWARF 4. ",
			},
			constSet{
				Name:        "AttrSmall",
				Description: "",
			},
			constSet{
				Name:        "AttrSpecification",
				Description: "",
			},
			constSet{
				Name:        "AttrStartScope",
				Description: "",
			},
			constSet{
				Name:        "AttrStaticLink",
				Description: "",
			},
			constSet{
				Name:        "AttrStmtList",
				Description: "",
			},
			constSet{
				Name:        "AttrStrOffsetsBase",
				Description: "",
			},
			constSet{
				Name:        "AttrStride",
				Description: "",
			},
			constSet{
				Name:        "AttrStrideSize",
				Description: "",
			},
			constSet{
				Name:        "AttrStringLength",
				Description: "",
			},
			constSet{
				Name:        "AttrStringLengthBitSize",
				Description: "The following are new in DWARF 5. ",
			},
			constSet{
				Name:        "AttrStringLengthByteSize",
				Description: "",
			},
			constSet{
				Name:        "AttrThreadsScaled",
				Description: "",
			},
			constSet{
				Name:        "AttrTrampoline",
				Description: "",
			},
			constSet{
				Name:        "AttrType",
				Description: "",
			},
			constSet{
				Name:        "AttrUpperBound",
				Description: "",
			},
			constSet{
				Name:        "AttrUseLocation",
				Description: "",
			},
			constSet{
				Name:        "AttrUseUTF8",
				Description: "",
			},
			constSet{
				Name:        "AttrVarParam",
				Description: "",
			},
			constSet{
				Name:        "AttrVirtuality",
				Description: "",
			},
			constSet{
				Name:        "AttrVisibility",
				Description: "",
			},
			constSet{
				Name:        "AttrVtableElemLoc",
				Description: "",
			},
			constSet{
				Name:        "ClassAddrPtr",
				Description: "ClassAddrPtr represents values that are an int64 offset into the \"addr\" section. ",
			},
			constSet{
				Name:        "ClassAddress",
				Description: "ClassAddress represents values of type uint64 that are addresses on the target machine. ",
			},
			constSet{
				Name:        "ClassBlock",
				Description: "ClassBlock represents values of type []byte whose interpretation depends on the attribute. ",
			},
			constSet{
				Name:        "ClassConstant",
				Description: "ClassConstant represents values of type int64 that are constants. The interpretation of this constant depends on the attribute. ",
			},
			constSet{
				Name:        "ClassExprLoc",
				Description: "ClassExprLoc represents values of type []byte that contain an encoded DWARF expression or location description. ",
			},
			constSet{
				Name:        "ClassFlag",
				Description: "ClassFlag represents values of type bool. ",
			},
			constSet{
				Name:        "ClassLinePtr",
				Description: "ClassLinePtr represents values that are an int64 offset into the \"line\" section. ",
			},
			constSet{
				Name:        "ClassLocList",
				Description: "ClassLocList represents values that are an int64 offset into the \"loclists\" section. ",
			},
			constSet{
				Name:        "ClassLocListPtr",
				Description: "ClassLocListPtr represents values that are an int64 offset into the \"loclist\" section. ",
			},
			constSet{
				Name:        "ClassMacPtr",
				Description: "ClassMacPtr represents values that are an int64 offset into the \"mac\" section. ",
			},
			constSet{
				Name:        "ClassRangeListPtr",
				Description: "ClassRangeListPtr represents values that are an int64 offset into the \"rangelist\" section. ",
			},
			constSet{
				Name:        "ClassReference",
				Description: "ClassReference represents values that are an Offset offset of an Entry in the info section (for use with Reader.Seek). The DWARF specification combines ClassReference and ClassReferenceSig into class \"reference\". ",
			},
			constSet{
				Name:        "ClassReferenceAlt",
				Description: "ClassReferenceAlt represents values of type int64 that are an offset into the DWARF \"info\" section of an alternate object file. ",
			},
			constSet{
				Name:        "ClassReferenceSig",
				Description: "ClassReferenceSig represents values that are a uint64 type signature referencing a type Entry. ",
			},
			constSet{
				Name:        "ClassRngList",
				Description: "ClassRngList represents values that are a uint64 offset from the base of the \"rnglists\" section. ",
			},
			constSet{
				Name:        "ClassRngListsPtr",
				Description: "ClassRngListsPtr represents values that are an int64 offset into the \"rnglists\" section. These are used as the base for ClassRngList values. ",
			},
			constSet{
				Name:        "ClassStrOffsetsPtr",
				Description: "ClassStrOffsetsPtr represents values that are an int64 offset into the \"str_offsets\" section. ",
			},
			constSet{
				Name:        "ClassString",
				Description: "ClassString represents values that are strings. If the compilation unit specifies the AttrUseUTF8 flag (strongly recommended), the string value will be encoded in UTF-8. Otherwise, the encoding is unspecified. ",
			},
			constSet{
				Name:        "ClassStringAlt",
				Description: "ClassStringAlt represents values of type int64 that are an offset into the DWARF string section of an alternate object file. ",
			},
			constSet{
				Name:        "ClassUnknown",
				Description: "ClassUnknown represents values of unknown DWARF class. ",
			},
			constSet{
				Name:        "TagAccessDeclaration",
				Description: "",
			},
			constSet{
				Name:        "TagArrayType",
				Description: "",
			},
			constSet{
				Name:        "TagAtomicType",
				Description: "",
			},
			constSet{
				Name:        "TagBaseType",
				Description: "",
			},
			constSet{
				Name:        "TagCallSite",
				Description: "",
			},
			constSet{
				Name:        "TagCallSiteParameter",
				Description: "",
			},
			constSet{
				Name:        "TagCatchDwarfBlock",
				Description: "",
			},
			constSet{
				Name:        "TagClassType",
				Description: "",
			},
			constSet{
				Name:        "TagCoarrayType",
				Description: "The following are new in DWARF 5. ",
			},
			constSet{
				Name:        "TagCommonDwarfBlock",
				Description: "",
			},
			constSet{
				Name:        "TagCommonInclusion",
				Description: "",
			},
			constSet{
				Name:        "TagCompileUnit",
				Description: "",
			},
			constSet{
				Name:        "TagCondition",
				Description: "",
			},
			constSet{
				Name:        "TagConstType",
				Description: "",
			},
			constSet{
				Name:        "TagConstant",
				Description: "",
			},
			constSet{
				Name:        "TagDwarfProcedure",
				Description: "The following are new in DWARF 3. ",
			},
			constSet{
				Name:        "TagDynamicType",
				Description: "",
			},
			constSet{
				Name:        "TagEntryPoint",
				Description: "",
			},
			constSet{
				Name:        "TagEnumerationType",
				Description: "",
			},
			constSet{
				Name:        "TagEnumerator",
				Description: "",
			},
			constSet{
				Name:        "TagFileType",
				Description: "",
			},
			constSet{
				Name:        "TagFormalParameter",
				Description: "",
			},
			constSet{
				Name:        "TagFriend",
				Description: "",
			},
			constSet{
				Name:        "TagGenericSubrange",
				Description: "",
			},
			constSet{
				Name:        "TagImmutableType",
				Description: "",
			},
			constSet{
				Name:        "TagImportedDeclaration",
				Description: "",
			},
			constSet{
				Name:        "TagImportedModule",
				Description: "",
			},
			constSet{
				Name:        "TagImportedUnit",
				Description: "",
			},
			constSet{
				Name:        "TagInheritance",
				Description: "",
			},
			constSet{
				Name:        "TagInlinedSubroutine",
				Description: "",
			},
			constSet{
				Name:        "TagInterfaceType",
				Description: "",
			},
			constSet{
				Name:        "TagLabel",
				Description: "",
			},
			constSet{
				Name:        "TagLexDwarfBlock",
				Description: "",
			},
			constSet{
				Name:        "TagMember",
				Description: "",
			},
			constSet{
				Name:        "TagModule",
				Description: "",
			},
			constSet{
				Name:        "TagMutableType",
				Description: "",
			},
			constSet{
				Name:        "TagNamelist",
				Description: "",
			},
			constSet{
				Name:        "TagNamelistItem",
				Description: "",
			},
			constSet{
				Name:        "TagNamespace",
				Description: "",
			},
			constSet{
				Name:        "TagPackedType",
				Description: "",
			},
			constSet{
				Name:        "TagPartialUnit",
				Description: "",
			},
			constSet{
				Name:        "TagPointerType",
				Description: "",
			},
			constSet{
				Name:        "TagPtrToMemberType",
				Description: "",
			},
			constSet{
				Name:        "TagReferenceType",
				Description: "",
			},
			constSet{
				Name:        "TagRestrictType",
				Description: "",
			},
			constSet{
				Name:        "TagRvalueReferenceType",
				Description: "",
			},
			constSet{
				Name:        "TagSetType",
				Description: "",
			},
			constSet{
				Name:        "TagSharedType",
				Description: "",
			},
			constSet{
				Name:        "TagSkeletonUnit",
				Description: "",
			},
			constSet{
				Name:        "TagStringType",
				Description: "",
			},
			constSet{
				Name:        "TagStructType",
				Description: "",
			},
			constSet{
				Name:        "TagSubprogram",
				Description: "",
			},
			constSet{
				Name:        "TagSubrangeType",
				Description: "",
			},
			constSet{
				Name:        "TagSubroutineType",
				Description: "",
			},
			constSet{
				Name:        "TagTemplateAlias",
				Description: "",
			},
			constSet{
				Name:        "TagTemplateTypeParameter",
				Description: "",
			},
			constSet{
				Name:        "TagTemplateValueParameter",
				Description: "",
			},
			constSet{
				Name:        "TagThrownType",
				Description: "",
			},
			constSet{
				Name:        "TagTryDwarfBlock",
				Description: "",
			},
			constSet{
				Name:        "TagTypeUnit",
				Description: "The following are new in DWARF 4. ",
			},
			constSet{
				Name:        "TagTypedef",
				Description: "",
			},
			constSet{
				Name:        "TagUnionType",
				Description: "",
			},
			constSet{
				Name:        "TagUnspecifiedParameters",
				Description: "",
			},
			constSet{
				Name:        "TagUnspecifiedType",
				Description: "",
			},
			constSet{
				Name:        "TagVariable",
				Description: "",
			},
			constSet{
				Name:        "TagVariant",
				Description: "",
			},
			constSet{
				Name:        "TagVariantPart",
				Description: "",
			},
			constSet{
				Name:        "TagVolatileType",
				Description: "",
			},
			constSet{
				Name:        "TagWithStmt",
				Description: "",
			},
		},
		"base32": []constSet{
			constSet{
				Name:        "NoPadding",
				Description: "",
			},
			constSet{
				Name:        "StdPadding",
				Description: "",
			},
		},
		"io": []constSet{
			constSet{
				Name:        "SeekCurrent",
				Description: "Seek whence values. ",
			},
			constSet{
				Name:        "SeekEnd",
				Description: "Seek whence values. ",
			},
			constSet{
				Name:        "SeekStart",
				Description: "Seek whence values. ",
			},
		},
		"x509": []constSet{
			constSet{
				Name:        "CANotAuthorizedForExtKeyUsage",
				Description: "CANotAuthorizedForExtKeyUsage results when an intermediate or root certificate does not permit a requested extended key usage. ",
			},
			constSet{
				Name:        "CANotAuthorizedForThisName",
				Description: "CANotAuthorizedForThisName results when an intermediate or root certificate has a name constraint which doesn't permit a DNS or other name (including IP address) in the leaf certificate. ",
			},
			constSet{
				Name:        "DSA",
				Description: "",
			},
			constSet{
				Name:        "DSAWithSHA1",
				Description: "",
			},
			constSet{
				Name:        "DSAWithSHA256",
				Description: "",
			},
			constSet{
				Name:        "ECDSA",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithSHA1",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithSHA256",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithSHA384",
				Description: "",
			},
			constSet{
				Name:        "ECDSAWithSHA512",
				Description: "",
			},
			constSet{
				Name:        "Ed25519",
				Description: "",
			},
			constSet{
				Name:        "Expired",
				Description: "Expired results when a certificate has expired, based on the time given in the VerifyOptions. ",
			},
			constSet{
				Name:        "ExtKeyUsageAny",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageClientAuth",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageCodeSigning",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageEmailProtection",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageIPSECEndSystem",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageIPSECTunnel",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageIPSECUser",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageMicrosoftCommercialCodeSigning",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageMicrosoftKernelCodeSigning",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageMicrosoftServerGatedCrypto",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageNetscapeServerGatedCrypto",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageOCSPSigning",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageServerAuth",
				Description: "",
			},
			constSet{
				Name:        "ExtKeyUsageTimeStamping",
				Description: "",
			},
			constSet{
				Name:        "IncompatibleUsage",
				Description: "IncompatibleUsage results when the certificate's key usage indicates that it may only be used for a different purpose. ",
			},
			constSet{
				Name:        "KeyUsageCRLSign",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageCertSign",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageContentCommitment",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageDataEncipherment",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageDecipherOnly",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageDigitalSignature",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageEncipherOnly",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageKeyAgreement",
				Description: "",
			},
			constSet{
				Name:        "KeyUsageKeyEncipherment",
				Description: "",
			},
			constSet{
				Name:        "MD2WithRSA",
				Description: "",
			},
			constSet{
				Name:        "MD5WithRSA",
				Description: "",
			},
			constSet{
				Name:        "NameConstraintsWithoutSANs",
				Description: "NameConstraintsWithoutSANs is a legacy error and is no longer returned. ",
			},
			constSet{
				Name:        "NameMismatch",
				Description: "NameMismatch results when the subject name of a parent certificate does not match the issuer name in the child. ",
			},
			constSet{
				Name:        "NoValidChains",
				Description: "NoValidChains results when there are no valid chains to return. ",
			},
			constSet{
				Name:        "NotAuthorizedToSign",
				Description: "NotAuthorizedToSign results when a certificate is signed by another which isn't marked as a CA certificate. ",
			},
			constSet{
				Name:        "PEMCipher3DES",
				Description: "Possible values for the EncryptPEMBlock encryption algorithm. ",
			},
			constSet{
				Name:        "PEMCipherAES128",
				Description: "Possible values for the EncryptPEMBlock encryption algorithm. ",
			},
			constSet{
				Name:        "PEMCipherAES192",
				Description: "Possible values for the EncryptPEMBlock encryption algorithm. ",
			},
			constSet{
				Name:        "PEMCipherAES256",
				Description: "Possible values for the EncryptPEMBlock encryption algorithm. ",
			},
			constSet{
				Name:        "PEMCipherDES",
				Description: "Possible values for the EncryptPEMBlock encryption algorithm. ",
			},
			constSet{
				Name:        "PureEd25519",
				Description: "",
			},
			constSet{
				Name:        "RSA",
				Description: "",
			},
			constSet{
				Name:        "SHA1WithRSA",
				Description: "",
			},
			constSet{
				Name:        "SHA256WithRSA",
				Description: "",
			},
			constSet{
				Name:        "SHA256WithRSAPSS",
				Description: "",
			},
			constSet{
				Name:        "SHA384WithRSA",
				Description: "",
			},
			constSet{
				Name:        "SHA384WithRSAPSS",
				Description: "",
			},
			constSet{
				Name:        "SHA512WithRSA",
				Description: "",
			},
			constSet{
				Name:        "SHA512WithRSAPSS",
				Description: "",
			},
			constSet{
				Name:        "TooManyConstraints",
				Description: "TooManyConstraints results when the number of comparison operations needed to check a certificate exceeds the limit set by VerifyOptions.MaxConstraintComparisions. This limit exists to prevent pathological certificates can consuming excessive amounts of CPU time to verify. ",
			},
			constSet{
				Name:        "TooManyIntermediates",
				Description: "TooManyIntermediates results when a path length constraint is violated. ",
			},
			constSet{
				Name:        "UnconstrainedName",
				Description: "UnconstrainedName results when a CA certificate contains permitted name constraints, but leaf certificate contains a name of an unsupported or unconstrained type. ",
			},
			constSet{
				Name:        "UnknownPublicKeyAlgorithm",
				Description: "",
			},
			constSet{
				Name:        "UnknownSignatureAlgorithm",
				Description: "",
			},
		},
		"ast": []constSet{
			constSet{
				Name:        "Bad",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "Con",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "FilterFuncDuplicates",
				Description: "If set, duplicate function declarations are excluded. ",
			},
			constSet{
				Name:        "FilterImportDuplicates",
				Description: "If set, duplicate import declarations are excluded. ",
			},
			constSet{
				Name:        "FilterUnassociatedComments",
				Description: "If set, comments that are not associated with a specific AST node (as Doc or Comment) are excluded. ",
			},
			constSet{
				Name:        "Fun",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "Lbl",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "Pkg",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "RECV",
				Description: "",
			},
			constSet{
				Name:        "SEND",
				Description: "",
			},
			constSet{
				Name:        "Typ",
				Description: "The list of possible [Object] kinds. ",
			},
			constSet{
				Name:        "Var",
				Description: "The list of possible [Object] kinds. ",
			},
		},
		"types": []constSet{
			constSet{
				Name:        "Bool",
				Description: "predeclared types ",
			},
			constSet{
				Name:        "Byte",
				Description: "aliases ",
			},
			constSet{
				Name:        "Complex128",
				Description: "",
			},
			constSet{
				Name:        "Complex64",
				Description: "",
			},
			constSet{
				Name:        "FieldVal",
				Description: "",
			},
			constSet{
				Name:        "FieldVar",
				Description: "",
			},
			constSet{
				Name:        "Float32",
				Description: "",
			},
			constSet{
				Name:        "Float64",
				Description: "",
			},
			constSet{
				Name:        "Int",
				Description: "",
			},
			constSet{
				Name:        "Int16",
				Description: "",
			},
			constSet{
				Name:        "Int32",
				Description: "",
			},
			constSet{
				Name:        "Int64",
				Description: "",
			},
			constSet{
				Name:        "Int8",
				Description: "",
			},
			constSet{
				Name:        "Invalid",
				Description: "",
			},
			constSet{
				Name:        "IsBoolean",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsComplex",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsConstType",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsFloat",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsInteger",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsNumeric",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsOrdered",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsString",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsUnsigned",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "IsUntyped",
				Description: "Properties of basic types. ",
			},
			constSet{
				Name:        "LocalVar",
				Description: "",
			},
			constSet{
				Name:        "MethodExpr",
				Description: "",
			},
			constSet{
				Name:        "MethodVal",
				Description: "",
			},
			constSet{
				Name:        "PackageVar",
				Description: "",
			},
			constSet{
				Name:        "ParamVar",
				Description: "",
			},
			constSet{
				Name:        "RecvOnly",
				Description: "The direction of a channel is indicated by one of these constants. ",
			},
			constSet{
				Name:        "RecvVar",
				Description: "",
			},
			constSet{
				Name:        "ResultVar",
				Description: "",
			},
			constSet{
				Name:        "Rune",
				Description: "",
			},
			constSet{
				Name:        "SendOnly",
				Description: "The direction of a channel is indicated by one of these constants. ",
			},
			constSet{
				Name:        "SendRecv",
				Description: "The direction of a channel is indicated by one of these constants. ",
			},
			constSet{
				Name:        "Uint",
				Description: "",
			},
			constSet{
				Name:        "Uint16",
				Description: "",
			},
			constSet{
				Name:        "Uint32",
				Description: "",
			},
			constSet{
				Name:        "Uint64",
				Description: "",
			},
			constSet{
				Name:        "Uint8",
				Description: "",
			},
			constSet{
				Name:        "Uintptr",
				Description: "",
			},
			constSet{
				Name:        "UnsafePointer",
				Description: "",
			},
			constSet{
				Name:        "UntypedBool",
				Description: "types for untyped values ",
			},
			constSet{
				Name:        "UntypedComplex",
				Description: "",
			},
			constSet{
				Name:        "UntypedFloat",
				Description: "",
			},
			constSet{
				Name:        "UntypedInt",
				Description: "",
			},
			constSet{
				Name:        "UntypedNil",
				Description: "",
			},
			constSet{
				Name:        "UntypedRune",
				Description: "",
			},
			constSet{
				Name:        "UntypedString",
				Description: "",
			},
		},
		"format": []constSet{
			constSet{
				Name:        "ProcsSection",
				Description: "",
			},
			constSet{
				Name:        "StatsSection",
				Description: "",
			},
			constSet{
				Name:        "TasksSection",
				Description: "",
			},
		},
		"sys": []constSet{
			constSet{
				Name:        "DefaultPhysPageSize",
				Description: "DefaultPhysPageSize is the default physical page size. ",
			},
			constSet{
				Name:        "Int64Align",
				Description: "Int64Align is the required alignment for a 64-bit integer (4 on 32-bit systems, 8 on 64-bit). ",
			},
			constSet{
				Name:        "MinFrameSize",
				Description: "MinFrameSize is the size of the system-reserved words at the bottom of a frame (just above the architectural stack pointer). It is zero on x86 and PtrSize on most non-x86 (LR-based) systems. On PowerPC it is larger, to cover three more reserved words: the compiler word, the link editor word, and the TOC save word. ",
			},
			constSet{
				Name:        "PCQuantum",
				Description: "PCQuantum is the minimal unit for a program counter (1 on x86, 4 on most other systems). The various PC tables record PC deltas pre-divided by PCQuantum. ",
			},
			constSet{
				Name:        "StackAlign",
				Description: "StackAlign is the required alignment of the SP register. The stack must be at least word aligned, but some architectures require more. ",
			},
			constSet{
				Name:        "StackGuardMultiplier",
				Description: "AIX and OpenBSD require a larger stack for syscalls. The race build also needs more stack. See issue 54291. This arithmetic must match that in cmd/internal/objabi/stack.go:stackGuardMultiplier. ",
			},
		},
		"bytes": []constSet{
			constSet{
				Name:        "MinRead",
				Description: "MinRead is the minimum slice size passed to a [Buffer.Read] call by [Buffer.ReadFrom]. As long as the [Buffer] has at least MinRead bytes beyond what is required to hold the contents of r, [Buffer.ReadFrom] will not grow the underlying buffer. ",
			},
		},
		"hpke": []constSet{
			constSet{
				Name:        "AEAD_AES_128_GCM",
				Description: "",
			},
			constSet{
				Name:        "AEAD_AES_256_GCM",
				Description: "",
			},
			constSet{
				Name:        "AEAD_ChaCha20Poly1305",
				Description: "",
			},
			constSet{
				Name:        "DHKEM_X25519_HKDF_SHA256",
				Description: "",
			},
			constSet{
				Name:        "KDF_HKDF_SHA256",
				Description: "",
			},
		},
		"md5": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "The blocksize of MD5 in bytes. ",
			},
			constSet{
				Name:        "Size",
				Description: "The size of an MD5 checksum in bytes. ",
			},
		},
		"sql": []constSet{
			constSet{
				Name:        "LevelDefault",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelLinearizable",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelReadCommitted",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelReadUncommitted",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelRepeatableRead",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelSerializable",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelSnapshot",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
			constSet{
				Name:        "LevelWriteCommitted",
				Description: "Various isolation levels that drivers may support in [DB.BeginTx]. If a driver does not support a given isolation level an error may be returned. See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels. ",
			},
		},
		"parser": []constSet{
			constSet{
				Name:        "AllErrors",
				Description: "",
			},
			constSet{
				Name:        "DeclarationErrors",
				Description: "",
			},
			constSet{
				Name:        "ImportsOnly",
				Description: "",
			},
			constSet{
				Name:        "PackageClauseOnly",
				Description: "",
			},
			constSet{
				Name:        "ParseComments",
				Description: "",
			},
			constSet{
				Name:        "SkipObjectResolution",
				Description: "",
			},
			constSet{
				Name:        "SpuriousErrors",
				Description: "",
			},
			constSet{
				Name:        "Trace",
				Description: "",
			},
		},
		"printer": []constSet{
			constSet{
				Name:        "RawFormat",
				Description: "",
			},
			constSet{
				Name:        "SourcePos",
				Description: "",
			},
			constSet{
				Name:        "TabIndent",
				Description: "",
			},
			constSet{
				Name:        "UseSpaces",
				Description: "",
			},
		},
		"version": []constSet{
			constSet{
				Name:        "Current",
				Description: "",
			},
			constSet{
				Name:        "Go111",
				Description: "",
			},
			constSet{
				Name:        "Go119",
				Description: "",
			},
			constSet{
				Name:        "Go121",
				Description: "",
			},
			constSet{
				Name:        "Go122",
				Description: "",
			},
			constSet{
				Name:        "Go123",
				Description: "",
			},
			constSet{
				Name:        "Go125",
				Description: "",
			},
		},
		"gc": []constSet{
			constSet{
				Name:        "LargeSizeDiv",
				Description: "",
			},
			constSet{
				Name:        "MallocHeaderSize",
				Description: "A malloc header is functionally a single type pointer, but we need to use 8 here to ensure 8-byte alignment of allocations on 32-bit platforms. It's wasteful, but a lot of code relies on 8-byte alignment for 8-byte atomics. ",
			},
			constSet{
				Name:        "MaxObjsPerSpan",
				Description: "",
			},
			constSet{
				Name:        "MaxSmallSize",
				Description: "",
			},
			constSet{
				Name:        "MinHeapAlign",
				Description: "",
			},
			constSet{
				Name:        "MinSizeForMallocHeader",
				Description: "The minimum object size that has a malloc header, exclusive. The size of this value controls overheads from the malloc header. The minimum size is bound by writeHeapBitsSmall, which assumes that the pointer bitmap for objects of a size smaller than this doesn't cross more than one pointer-word boundary. This sets an upper-bound on this value at the number of bits in a uintptr, multiplied by the pointer size in bytes. We choose a value here that has a natural cutover point in terms of memory overheads. This value just happens to be the maximum possible value this can be. A span with heap bits in it will have 128 bytes of heap bits on 64-bit platforms, and 256 bytes of heap bits on 32-bit platforms. The first size class where malloc headers match this overhead for 64-bit platforms is 512 bytes (8 KiB / 512 bytes * 8 bytes-per-header = 128 bytes of overhead). On 32-bit platforms, this same point is the 256 byte size class (8 KiB / 256 bytes * 8 bytes-per-header = 256 bytes of overhead). Guaranteed to be exactly at a size class boundary. The reason this value is an exclusive minimum is subtle. Suppose we're allocating a 504-byte object and its rounded up to 512 bytes for the size class. If minSizeForMallocHeader is 512 and an inclusive minimum, then a comparison against minSizeForMallocHeader by the two values would produce different results. In other words, the comparison would not be invariant to size-class rounding. Eschewing this property means a more complex check or possibly storing additional state to determine whether a span has malloc headers. ",
			},
			constSet{
				Name:        "NumSizeClasses",
				Description: "",
			},
			constSet{
				Name:        "PageShift",
				Description: "",
			},
			constSet{
				Name:        "PageSize",
				Description: "PageSize is the increment in which spans are managed. ",
			},
			constSet{
				Name:        "SmallSizeDiv",
				Description: "",
			},
			constSet{
				Name:        "SmallSizeMax",
				Description: "",
			},
		},
		"aes": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "BlockSize is the AES block size in bytes. ",
			},
			constSet{
				Name:        "BlockSize",
				Description: "The AES block size in bytes. ",
			},
		},
		"tabwriter": []constSet{
			constSet{
				Name:        "AlignRight",
				Description: "Force right-alignment of cell content. Default is left-alignment. ",
			},
			constSet{
				Name:        "Debug",
				Description: "Print a vertical bar ('|') between columns (after formatting). Discarded columns appear as zero-width columns (\"||\"). ",
			},
			constSet{
				Name:        "DiscardEmptyColumns",
				Description: "Handle empty columns as if they were not present in the input in the first place. ",
			},
			constSet{
				Name:        "Escape",
				Description: "To escape a text segment, bracket it with Escape characters. For instance, the tab in this string \"Ignore this tab: \\xff\\t\\xff\" does not terminate a cell and constitutes a single character of width one for formatting purposes. The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence. ",
			},
			constSet{
				Name:        "FilterHTML",
				Description: "Ignore html tags and treat entities (starting with '&' and ending in ';') as single characters (width = 1). ",
			},
			constSet{
				Name:        "StripEscape",
				Description: "Strip Escape characters bracketing escaped text segments instead of passing them through unchanged with the text. ",
			},
			constSet{
				Name:        "TabIndent",
				Description: "Always use tabs for indentation columns (i.e., padding of leading empty cells on the left) independent of padchar. ",
			},
		},
		"pkgbits": []constSet{
			constSet{
				Name:        "AliasTypeParamNames",
				Description: "ObjAlias has a list of TypeParamNames. ",
			},
			constSet{
				Name:        "DerivedFuncInstance",
				Description: "Deprecated: DerivedFuncInstance was a bool indicating whether an object was a function instance. ",
			},
			constSet{
				Name:        "DerivedInfoNeeded",
				Description: "Deprecated: DerivedInfoNeeded was a bool indicating whether a type was a derived type. ",
			},
			constSet{
				Name:        "Flags",
				Description: "Flags in a uint32 in the header of a bitstream that is used to indicate whether optional features are enabled. ",
			},
			constSet{
				Name:        "HasInit",
				Description: "Deprecated: HasInit was a bool indicating whether a package has any init functions. ",
			},
			constSet{
				Name:        "ObjAlias",
				Description: "",
			},
			constSet{
				Name:        "ObjConst",
				Description: "",
			},
			constSet{
				Name:        "ObjFunc",
				Description: "",
			},
			constSet{
				Name:        "ObjStub",
				Description: "",
			},
			constSet{
				Name:        "ObjType",
				Description: "",
			},
			constSet{
				Name:        "ObjVar",
				Description: "",
			},
			constSet{
				Name:        "PrivateRootIdx",
				Description: "Reserved indices within the [SectionMeta] section. ",
			},
			constSet{
				Name:        "PublicRootIdx",
				Description: "Reserved indices within the [SectionMeta] section. ",
			},
			constSet{
				Name:        "SectionBody",
				Description: "",
			},
			constSet{
				Name:        "SectionMeta",
				Description: "",
			},
			constSet{
				Name:        "SectionName",
				Description: "",
			},
			constSet{
				Name:        "SectionObj",
				Description: "",
			},
			constSet{
				Name:        "SectionObjDict",
				Description: "",
			},
			constSet{
				Name:        "SectionObjExt",
				Description: "",
			},
			constSet{
				Name:        "SectionPkg",
				Description: "",
			},
			constSet{
				Name:        "SectionPosBase",
				Description: "",
			},
			constSet{
				Name:        "SectionString",
				Description: "",
			},
			constSet{
				Name:        "SectionType",
				Description: "",
			},
			constSet{
				Name:        "SyncAddLocal",
				Description: "",
			},
			constSet{
				Name:        "SyncAssign",
				Description: "",
			},
			constSet{
				Name:        "SyncBlockStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncBool",
				Description: "",
			},
			constSet{
				Name:        "SyncCaseClause",
				Description: "",
			},
			constSet{
				Name:        "SyncCloseAnotherScope",
				Description: "",
			},
			constSet{
				Name:        "SyncCloseScope",
				Description: "",
			},
			constSet{
				Name:        "SyncCodeObj",
				Description: "",
			},
			constSet{
				Name:        "SyncCommClause",
				Description: "",
			},
			constSet{
				Name:        "SyncCompLit",
				Description: "",
			},
			constSet{
				Name:        "SyncConvRTTI",
				Description: "",
			},
			constSet{
				Name:        "SyncDecl",
				Description: "",
			},
			constSet{
				Name:        "SyncDeclName",
				Description: "",
			},
			constSet{
				Name:        "SyncDeclNames",
				Description: "",
			},
			constSet{
				Name:        "SyncDecls",
				Description: "",
			},
			constSet{
				Name:        "SyncEOF",
				Description: "Low-level coding markers. ",
			},
			constSet{
				Name:        "SyncExpr",
				Description: "",
			},
			constSet{
				Name:        "SyncExprList",
				Description: "",
			},
			constSet{
				Name:        "SyncExprType",
				Description: "",
			},
			constSet{
				Name:        "SyncExprs",
				Description: "",
			},
			constSet{
				Name:        "SyncForStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncFuncBody",
				Description: "",
			},
			constSet{
				Name:        "SyncFuncExt",
				Description: "",
			},
			constSet{
				Name:        "SyncFuncLit",
				Description: "",
			},
			constSet{
				Name:        "SyncIfStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncInt64",
				Description: "",
			},
			constSet{
				Name:        "SyncLabel",
				Description: "",
			},
			constSet{
				Name:        "SyncLabeledStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncLinkname",
				Description: "",
			},
			constSet{
				Name:        "SyncLocalIdent",
				Description: "",
			},
			constSet{
				Name:        "SyncMethod",
				Description: "",
			},
			constSet{
				Name:        "SyncMultiExpr",
				Description: "",
			},
			constSet{
				Name:        "SyncObject",
				Description: "",
			},
			constSet{
				Name:        "SyncObject1",
				Description: "",
			},
			constSet{
				Name:        "SyncOp",
				Description: "",
			},
			constSet{
				Name:        "SyncOpenScope",
				Description: "",
			},
			constSet{
				Name:        "SyncOptLabel",
				Description: "",
			},
			constSet{
				Name:        "SyncParam",
				Description: "",
			},
			constSet{
				Name:        "SyncParams",
				Description: "",
			},
			constSet{
				Name:        "SyncPkg",
				Description: "",
			},
			constSet{
				Name:        "SyncPkgDef",
				Description: "",
			},
			constSet{
				Name:        "SyncPos",
				Description: "",
			},
			constSet{
				Name:        "SyncPosBase",
				Description: "",
			},
			constSet{
				Name:        "SyncPragma",
				Description: "",
			},
			constSet{
				Name:        "SyncPrivate",
				Description: "Private markers (only known to cmd/compile). ",
			},
			constSet{
				Name:        "SyncPublic",
				Description: "Higher-level object and type markers. ",
			},
			constSet{
				Name:        "SyncRType",
				Description: "",
			},
			constSet{
				Name:        "SyncRangeStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncReloc",
				Description: "",
			},
			constSet{
				Name:        "SyncRelocs",
				Description: "",
			},
			constSet{
				Name:        "SyncSelectStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncSelector",
				Description: "",
			},
			constSet{
				Name:        "SyncSignature",
				Description: "",
			},
			constSet{
				Name:        "SyncStmt1",
				Description: "",
			},
			constSet{
				Name:        "SyncStmts",
				Description: "",
			},
			constSet{
				Name:        "SyncStmtsEnd",
				Description: "",
			},
			constSet{
				Name:        "SyncString",
				Description: "",
			},
			constSet{
				Name:        "SyncSwitchStmt",
				Description: "",
			},
			constSet{
				Name:        "SyncSym",
				Description: "",
			},
			constSet{
				Name:        "SyncType",
				Description: "",
			},
			constSet{
				Name:        "SyncTypeExt",
				Description: "",
			},
			constSet{
				Name:        "SyncTypeIdx",
				Description: "",
			},
			constSet{
				Name:        "SyncTypeParamNames",
				Description: "",
			},
			constSet{
				Name:        "SyncUint64",
				Description: "",
			},
			constSet{
				Name:        "SyncUseObjLocal",
				Description: "",
			},
			constSet{
				Name:        "SyncUseReloc",
				Description: "",
			},
			constSet{
				Name:        "SyncVal",
				Description: "",
			},
			constSet{
				Name:        "SyncValue",
				Description: "",
			},
			constSet{
				Name:        "SyncVarExt",
				Description: "",
			},
			constSet{
				Name:        "TypeArray",
				Description: "",
			},
			constSet{
				Name:        "TypeBasic",
				Description: "",
			},
			constSet{
				Name:        "TypeChan",
				Description: "",
			},
			constSet{
				Name:        "TypeInterface",
				Description: "",
			},
			constSet{
				Name:        "TypeMap",
				Description: "",
			},
			constSet{
				Name:        "TypeNamed",
				Description: "",
			},
			constSet{
				Name:        "TypePointer",
				Description: "",
			},
			constSet{
				Name:        "TypeSignature",
				Description: "",
			},
			constSet{
				Name:        "TypeSlice",
				Description: "",
			},
			constSet{
				Name:        "TypeStruct",
				Description: "",
			},
			constSet{
				Name:        "TypeTypeParam",
				Description: "",
			},
			constSet{
				Name:        "TypeUnion",
				Description: "",
			},
			constSet{
				Name:        "V0",
				Description: "V0: initial prototype. All data that is not assigned a Field is in version V0 and has not been deprecated. ",
			},
			constSet{
				Name:        "V1",
				Description: "V1: adds the Flags uint32 word ",
			},
			constSet{
				Name:        "V2",
				Description: "V2: removes unused legacy fields and supports type parameters for aliases. - remove the legacy \"has init\" bool from the public root - remove obj's \"derived func instance\" bool - add a TypeParamNames field to ObjAlias - remove derived info \"needed\" bool ",
			},
			constSet{
				Name:        "ValBigFloat",
				Description: "",
			},
			constSet{
				Name:        "ValBigInt",
				Description: "",
			},
			constSet{
				Name:        "ValBigRat",
				Description: "",
			},
			constSet{
				Name:        "ValBool",
				Description: "",
			},
			constSet{
				Name:        "ValInt64",
				Description: "",
			},
			constSet{
				Name:        "ValString",
				Description: "",
			},
		},
		"gif": []constSet{
			constSet{
				Name:        "DisposalBackground",
				Description: "Disposal Methods. ",
			},
			constSet{
				Name:        "DisposalNone",
				Description: "Disposal Methods. ",
			},
			constSet{
				Name:        "DisposalPrevious",
				Description: "Disposal Methods. ",
			},
		},
		"traceviewer": []constSet{
			constSet{
				Name:        "CommonStyle",
				Description: "",
			},
			constSet{
				Name:        "FakeP",
				Description: "Special P identifiers: ",
			},
			constSet{
				Name:        "GCP",
				Description: "",
			},
			constSet{
				Name:        "GDead",
				Description: "",
			},
			constSet{
				Name:        "GRunnable",
				Description: "",
			},
			constSet{
				Name:        "GRunning",
				Description: "",
			},
			constSet{
				Name:        "GWaiting",
				Description: "",
			},
			constSet{
				Name:        "GWaitingGC",
				Description: "",
			},
			constSet{
				Name:        "ModeGoroutineOriented",
				Description: "",
			},
			constSet{
				Name:        "ModeTaskOriented",
				Description: "",
			},
			constSet{
				Name:        "ModeThreadOriented",
				Description: "",
			},
			constSet{
				Name:        "NetpollP",
				Description: "",
			},
			constSet{
				Name:        "ProfileP",
				Description: "",
			},
			constSet{
				Name:        "SyscallP",
				Description: "",
			},
			constSet{
				Name:        "ThreadStateInSyscall",
				Description: "",
			},
			constSet{
				Name:        "ThreadStateInSyscallRuntime",
				Description: "",
			},
			constSet{
				Name:        "ThreadStateRunning",
				Description: "",
			},
			constSet{
				Name:        "TimerP",
				Description: "",
			},
			constSet{
				Name:        "ViewProc",
				Description: "",
			},
			constSet{
				Name:        "ViewThread",
				Description: "",
			},
		},
		"httptest": []constSet{
			constSet{
				Name:        "DefaultRemoteAddr",
				Description: "DefaultRemoteAddr is the default remote address to return in RemoteAddr if an explicit DefaultRemoteAddr isn't set on [ResponseRecorder]. ",
			},
		},
		"socktest": []constSet{
			constSet{
				Name:        "FilterAccept",
				Description: "",
			},
			constSet{
				Name:        "FilterClose",
				Description: "",
			},
			constSet{
				Name:        "FilterConnect",
				Description: "",
			},
			constSet{
				Name:        "FilterGetsockoptInt",
				Description: "",
			},
			constSet{
				Name:        "FilterListen",
				Description: "",
			},
			constSet{
				Name:        "FilterSocket",
				Description: "",
			},
		},
		"msan": []constSet{
			constSet{
				Name:        "Enabled",
				Description: "",
			},
		},
		"binary": []constSet{
			constSet{
				Name:        "MaxVarintLen16",
				Description: "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer. ",
			},
			constSet{
				Name:        "MaxVarintLen32",
				Description: "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer. ",
			},
			constSet{
				Name:        "MaxVarintLen64",
				Description: "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer. ",
			},
		},
		"gzip": []constSet{
			constSet{
				Name:        "BestCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/gzip] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "BestSpeed",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/gzip] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "DefaultCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/gzip] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "HuffmanOnly",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/gzip] does not also have to import [compress/flate]. ",
			},
			constSet{
				Name:        "NoCompression",
				Description: "These constants are copied from the [flate] package, so that code that imports [compress/gzip] does not also have to import [compress/flate]. ",
			},
		},
		"flag": []constSet{
			constSet{
				Name:        "ContinueOnError",
				Description: "These constants cause [FlagSet.Parse] to behave as described if the parse fails. ",
			},
			constSet{
				Name:        "ExitOnError",
				Description: "These constants cause [FlagSet.Parse] to behave as described if the parse fails. ",
			},
			constSet{
				Name:        "PanicOnError",
				Description: "These constants cause [FlagSet.Parse] to behave as described if the parse fails. ",
			},
		},
		"rsa": []constSet{
			constSet{
				Name:        "PSSSaltLengthAuto",
				Description: "PSSSaltLengthAuto causes the salt in a PSS signature to be as large as possible when signing, and to be auto-detected when verifying. When signing in FIPS 140-3 mode, the salt length is capped at the length of the hash function used in the signature. ",
			},
			constSet{
				Name:        "PSSSaltLengthEqualsHash",
				Description: "PSSSaltLengthEqualsHash causes the salt length to equal the length of the hash used in the signature. ",
			},
		},
		"errors": []constSet{
			constSet{
				Name:        "AmbiguousSelector",
				Description: "AmbiguousSelector occurs when a selector is ambiguous. Example: type E1 struct { i int } type E2 struct { i int } type T struct { E1; E2 } var x T var _ = x.i ",
			},
			constSet{
				Name:        "BadDecl",
				Description: "BadDecl occurs when a declaration has invalid syntax. ",
			},
			constSet{
				Name:        "BadDotDotDotSyntax",
				Description: "BadDotDotDotSyntax occurs when a \"...\" occurs in a context where it is not valid. Example: var _ = map[int][...]int{0: {}} ",
			},
			constSet{
				Name:        "BadImportPath",
				Description: "BadImportPath occurs when an import path is not valid. ",
			},
			constSet{
				Name:        "BadOffsetofSyntax",
				Description: "BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument that is not a selector expression. Example: import \"unsafe\" var x int var _ = unsafe.Offsetof(x) ",
			},
			constSet{
				Name:        "BadRecv",
				Description: "BadRecv occurs when a method declaration does not have exactly one receiver parameter. Example: func () _() {} ",
			},
			constSet{
				Name:        "BadTypeKeyword",
				Description: "BadTypeKeyword occurs when a .(type) expression is used anywhere other than a type switch. Example: type I interface { m() } var t I var _ = t.(type) ",
			},
			constSet{
				Name:        "BlankIfaceMethod",
				Description: "BlankIfaceMethod occurs when a method name is '_'. Per the spec: \"The name of each explicitly specified method must be unique and not blank.\" Example: type T interface { _(int) } ",
			},
			constSet{
				Name:        "BlankPkgName",
				Description: "BlankPkgName occurs when a package name is the blank identifier \"_\". Per the spec: \"The PackageName must not be the blank identifier.\" Example: package _ ",
			},
			constSet{
				Name:        "BrokenImport",
				Description: "BrokenImport occurs when importing a package fails. Example: import \"amissingpackage\" ",
			},
			constSet{
				Name:        "CannotInferTypeArgs",
				Description: "CannotInferTypeArgs occurs when type or function type argument inference fails to infer all type arguments. Example: func f[T any]() {} func _() { f() } ",
			},
			constSet{
				Name:        "DivByZero",
				Description: "DivByZero occurs when a division operation is provable at compile time to be a division by zero. Example: const divisor = 0 var x int = 1/divisor ",
			},
			constSet{
				Name:        "DuplicateCase",
				Description: "DuplicateCase occurs when a type or expression switch has duplicate cases. Example: func printInt(i int) { switch i { case 1: println(\"one\") case 1: println(\"One\") } } ",
			},
			constSet{
				Name:        "DuplicateDecl",
				Description: "DuplicateDecl occurs when an identifier is declared multiple times. Example: var x = 1 var x = 2 ",
			},
			constSet{
				Name:        "DuplicateDefault",
				Description: "DuplicateDefault occurs when a type or expression switch has multiple default clauses. Example: func printInt(i int) { switch i { case 1: println(\"one\") default: println(\"One\") default: println(\"1\") } } ",
			},
			constSet{
				Name:        "DuplicateFieldAndMethod",
				Description: "DuplicateFieldAndMethod occurs when an identifier appears as both a field and method name. Example: type T struct { m int } func (T) m() {} ",
			},
			constSet{
				Name:        "DuplicateLabel",
				Description: "DuplicateLabel occurs when a label is declared more than once. Example: func f() int { L: L: return 1 } ",
			},
			constSet{
				Name:        "DuplicateLitField",
				Description: "DuplicateLitField occurs when a struct literal contains duplicated fields. Example: var _ = struct{i int}{i: 1, i: 2} ",
			},
			constSet{
				Name:        "DuplicateLitKey",
				Description: "DuplicateLitKey occurs when an index is duplicated in a slice, array, or map literal. Example: var _ = []int{0:1, 0:2} Example: var _ = map[string]int{\"a\": 1, \"a\": 2} ",
			},
			constSet{
				Name:        "DuplicateMethod",
				Description: "DuplicateMethod occurs when two methods on the same receiver type have the same name. Example: type T struct {} func (T) m() {} func (T) m(i int) int { return i } ",
			},
			constSet{
				Name:        "ImportCRenamed",
				Description: "ImportCRenamed occurs when the special import \"C\" is renamed. \"C\" is a pseudo-package, and must not be renamed. Example: import _ \"C\" ",
			},
			constSet{
				Name:        "ImpossibleAssert",
				Description: "ImpossibleAssert occurs for a type assertion x.(T) when the value x of interface cannot have dynamic type T, due to a missing or mismatching method on T. Example: type T int func (t *T) m() int { return int(*t) } type I interface { m() int } var x I var _ = x.(T) ",
			},
			constSet{
				Name:        "IncomparableMapKey",
				Description: "IncomparableMapKey occurs when a map key type does not support the == and != operators. Per the spec: \"The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice.\" Example: var x map[T]int type T []int ",
			},
			constSet{
				Name:        "IncompatibleAssign",
				Description: "IncompatibleAssign occurs when the type of the right-hand side expression in an assignment cannot be assigned to the type of the variable being assigned. Example: var x []int var _ int = x ",
			},
			constSet{
				Name:        "InvalidAppend",
				Description: "InvalidAppend occurs when append is called with a first argument that is not a slice. Example: var _ = append(1, 2) ",
			},
			constSet{
				Name:        "InvalidArrayLen",
				Description: "InvalidArrayLen occurs when an array length is not a constant value. Example: var n = 3 var _ = [n]int{} ",
			},
			constSet{
				Name:        "InvalidAssert",
				Description: "InvalidAssert occurs when a type assertion is applied to a value that is not of interface type. Example: var x = 1 var _ = x.(float64) ",
			},
			constSet{
				Name:        "InvalidBlank",
				Description: "InvalidBlank occurs when a blank identifier is used as a value or type. Per the spec: \"The blank identifier may appear as an operand only on the left-hand side of an assignment.\" Example: var x = _ ",
			},
			constSet{
				Name:        "InvalidCall",
				Description: "InvalidCall occurs when an expression is called that is not of function type. Example: var x = \"x\" var y = x() ",
			},
			constSet{
				Name:        "InvalidCap",
				Description: "InvalidCap occurs when an argument to the cap built-in function is not of supported type. See https://golang.org/ref/spec#Length_and_capacity for information on which underlying types are supported as arguments to cap and len. Example: var s = 2 var x = cap(s) ",
			},
			constSet{
				Name:        "InvalidChanAssign",
				Description: "InvalidChanAssign occurs when a chan assignment is invalid. Per the spec, a value x is assignable to a channel type T if: \"x is a bidirectional channel value, T is a channel type, x's type V and T have identical element types, and at least one of V or T is not a defined type.\" Example: type T1 chan int type T2 chan int var x T1 // Invalid assignment because both types are named var _ T2 = x ",
			},
			constSet{
				Name:        "InvalidClear",
				Description: "InvalidClear occurs when clear is called with an argument that is not of map or slice type. Example: func _(x int) { clear(x) } ",
			},
			constSet{
				Name:        "InvalidClose",
				Description: "InvalidClose occurs when close(...) is called with an argument that is not of channel type, or that is a receive-only channel. Example: func f() { var x int close(x) } ",
			},
			constSet{
				Name:        "InvalidComplex",
				Description: "InvalidComplex occurs when the complex built-in function is called with arguments with incompatible types. Example: var _ = complex(float32(1), float64(2)) ",
			},
			constSet{
				Name:        "InvalidCond",
				Description: "InvalidCond occurs when an if condition is not a boolean expression. Example: func checkReturn(i int) { if i { panic(\"non-zero return\") } } ",
			},
			constSet{
				Name:        "InvalidConstInit",
				Description: "InvalidConstInit occurs when a const declaration has a non-constant initializer. Example: var x int const _ = x ",
			},
			constSet{
				Name:        "InvalidConstType",
				Description: "InvalidConstType occurs when the underlying type in a const declaration is not a valid constant type. Example: const c *int = 4 ",
			},
			constSet{
				Name:        "InvalidConstVal",
				Description: "InvalidConstVal occurs when a const value cannot be converted to its target type. TODO(findleyr): this error code and example are not very clear. Consider removing it. Example: const _ = 1 << \"hello\" ",
			},
			constSet{
				Name:        "InvalidConversion",
				Description: "InvalidConversion occurs when the argument type cannot be converted to the target. See https://golang.org/ref/spec#Conversions for the rules of convertibility. Example: var x float64 var _ = string(x) ",
			},
			constSet{
				Name:        "InvalidCopy",
				Description: "InvalidCopy occurs when the arguments are not of slice type or do not have compatible type. See https://golang.org/ref/spec#Appending_and_copying_slices for more information on the type requirements for the copy built-in. Example: func f() { var x []int y := []int64{1,2,3} copy(x, y) } ",
			},
			constSet{
				Name:        "InvalidDeclCycle",
				Description: "InvalidDeclCycle occurs when a declaration cycle is not valid. Example: type S struct { S } ",
			},
			constSet{
				Name:        "InvalidDefer",
				Description: "InvalidDefer occurs when a deferred expression is not a function call, for example if the expression is a type conversion. Example: func f(i int) int { defer int32(i) return i } ",
			},
			constSet{
				Name:        "InvalidDelete",
				Description: "InvalidDelete occurs when the delete built-in function is called with a first argument that is not a map. Example: func f() { m := \"hello\" delete(m, \"e\") } ",
			},
			constSet{
				Name:        "InvalidDotDotDot",
				Description: "InvalidDotDotDot occurs when a \"...\" is used in a non-variadic built-in function. Example: var s = []int{1, 2, 3} var l = len(s...) ",
			},
			constSet{
				Name:        "InvalidExprSwitch",
				Description: "InvalidExprSwitch occurs when a switch expression is not comparable. Example: func _() { var a struct{ _ func() } switch a /* ERROR cannot switch on a */ { } } ",
			},
			constSet{
				Name:        "InvalidGo",
				Description: "InvalidGo occurs when a go expression is not a function call, for example if the expression is a type conversion. Example: func f(i int) int { go int32(i) return i } ",
			},
			constSet{
				Name:        "InvalidIfaceAssign",
				Description: "InvalidIfaceAssign occurs when a value of type T is used as an interface, but T does not implement a method of the expected interface. Example: type I interface { f() } type T int var x I = T(1) ",
			},
			constSet{
				Name:        "InvalidImag",
				Description: "InvalidImag occurs when the imag built-in function is called with an argument that does not have complex type. Example: var _ = imag(int(1)) ",
			},
			constSet{
				Name:        "InvalidIndex",
				Description: "InvalidIndex occurs when an index argument is not of integer type, negative, or out-of-bounds. Example: var s = [...]int{1,2,3} var x = s[5] Example: var s = []int{1,2,3} var _ = s[-1] Example: var s = []int{1,2,3} var i string var _ = s[i] ",
			},
			constSet{
				Name:        "InvalidIndirection",
				Description: "InvalidIndirection occurs when a non-pointer value is indirected via the '*' operator. Example: var x int var y = *x ",
			},
			constSet{
				Name:        "InvalidInitCycle",
				Description: "InvalidInitCycle occurs when an invalid cycle is detected within the initialization graph. Example: var x int = f() func f() int { return x } ",
			},
			constSet{
				Name:        "InvalidInitDecl",
				Description: "InvalidInitDecl occurs when init is declared as anything other than a function. Example: var init = 1 Example: func init() int { return 1 } ",
			},
			constSet{
				Name:        "InvalidInitSig",
				Description: "InvalidInitSig occurs when an init function declares parameters or results. Deprecated: no longer emitted by the type checker. _InvalidInitDecl is used instead. ",
			},
			constSet{
				Name:        "InvalidInstanceCycle",
				Description: "InvalidInstanceCycle occurs when an invalid cycle is detected within the instantiation graph. Example: func f[T any]() { f[*T]() } ",
			},
			constSet{
				Name:        "InvalidIota",
				Description: "InvalidIota occurs when the predeclared identifier iota is used outside of a constant declaration. Example: var x = iota ",
			},
			constSet{
				Name:        "InvalidIterVar",
				Description: "InvalidIterVar occurs when two iteration variables are used while ranging over a channel. Example: func f(c chan int) { for k, v := range c { println(k, v) } } ",
			},
			constSet{
				Name:        "InvalidLen",
				Description: "InvalidLen occurs when an argument to the len built-in function is not of supported type. See https://golang.org/ref/spec#Length_and_capacity for information on which underlying types are supported as arguments to cap and len. Example: var s = 2 var x = len(s) ",
			},
			constSet{
				Name:        "InvalidLit",
				Description: "InvalidLit occurs when a composite literal expression does not match its type. Example: type P *struct{ x int } var _ = P {} ",
			},
			constSet{
				Name:        "InvalidLitField",
				Description: "InvalidLitField occurs when a field name is not a valid identifier. Example: var _ = struct{i int}{1: 1} ",
			},
			constSet{
				Name:        "InvalidLitIndex",
				Description: "InvalidLitIndex occurs when the key in a key-value element of a slice or array literal is not an integer constant. Example: var i = 0 var x = []string{i: \"world\"} ",
			},
			constSet{
				Name:        "InvalidMainDecl",
				Description: "InvalidMainDecl occurs when main is declared as anything other than a function, in a main package. ",
			},
			constSet{
				Name:        "InvalidMake",
				Description: "InvalidMake occurs when make is called with an unsupported type argument. See https://golang.org/ref/spec#Making_slices_maps_and_channels for information on the types that may be created using make. Example: var x = make(int) ",
			},
			constSet{
				Name:        "InvalidMethodExpr",
				Description: "InvalidMethodExpr occurs when a pointer method is called but the argument is not addressable. Example: type T struct {} func (*T) m() int { return 1 } var _ = T.m(T{}) ",
			},
			constSet{
				Name:        "InvalidMethodTypeParams",
				Description: "InvalidMethodTypeParams occurs when methods have type parameters. It cannot be encountered with an AST parsed using go/parser. ",
			},
			constSet{
				Name:        "InvalidMinMaxOperand",
				Description: "InvalidMinMaxOperand occurs if min or max is called with an operand that cannot be ordered because it does not support the < operator. Example: const _ = min(true) Example: var s, t []byte var _ = max(s, t) ",
			},
			constSet{
				Name:        "InvalidOffsetof",
				Description: "InvalidOffsetof occurs when unsafe.Offsetof is called with a method selector, rather than a field selector, or when the field is embedded via a pointer. Per the spec: \"If f is an embedded field, it must be reachable without pointer indirections through fields of the struct. \" Example: import \"unsafe\" type T struct { f int } type S struct { *T } var s S var _ = unsafe.Offsetof(s.f) Example: import \"unsafe\" type S struct{} func (S) m() {} var s S var _ = unsafe.Offsetof(s.m) ",
			},
			constSet{
				Name:        "InvalidPkgUse",
				Description: "InvalidPkgUse occurs when a package identifier is used outside of a selector expression. Example: import \"fmt\" var _ = fmt ",
			},
			constSet{
				Name:        "InvalidPostDecl",
				Description: "InvalidPostDecl occurs when there is a declaration in a for-loop post statement. Example: func f() { for i := 0; i < 10; j := 0 {} } ",
			},
			constSet{
				Name:        "InvalidPtrEmbed",
				Description: "InvalidPtrEmbed occurs when an embedded field is of the pointer form *T, and T itself is itself a pointer, an unsafe.Pointer, or an interface. Per the spec: \"An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type.\" Example: type T *int type S struct { *T } ",
			},
			constSet{
				Name:        "InvalidRangeExpr",
				Description: "InvalidRangeExpr occurs when the type of a range expression is not a valid type for use with a range loop. Example: func f(f float64) { for j := range f { println(j) } } ",
			},
			constSet{
				Name:        "InvalidReal",
				Description: "InvalidReal occurs when the real built-in function is called with an argument that does not have complex type. Example: var _ = real(int(1)) ",
			},
			constSet{
				Name:        "InvalidReceive",
				Description: "InvalidReceive occurs when there is a channel receive from a value that is either not a channel, or is a send-only channel. Example: func f() { var x = 1 <-x } ",
			},
			constSet{
				Name:        "InvalidRecv",
				Description: "InvalidRecv occurs when a receiver type expression is not of the form T or *T, or T is a pointer type. Example: type T struct {} func (**T) m() {} ",
			},
			constSet{
				Name:        "InvalidSelectCase",
				Description: "InvalidSelectCase occurs when a select case is not a channel send or receive. Example: func checkChan(c <-chan int) bool { select { case c: return true default: return false } } ",
			},
			constSet{
				Name:        "InvalidSend",
				Description: "InvalidSend occurs when there is a channel send to a value that is not a channel, or is a receive-only channel. Example: func f() { var x = 1 x <- \"hello!\" } ",
			},
			constSet{
				Name:        "InvalidShiftCount",
				Description: "InvalidShiftCount occurs when the right-hand side of a shift operation is either non-integer, negative, or too large. Example: var ( x string y int = 1 << x ) ",
			},
			constSet{
				Name:        "InvalidShiftOperand",
				Description: "InvalidShiftOperand occurs when the shifted operand is not an integer. Example: var s = \"hello\" var x = s << 2 ",
			},
			constSet{
				Name:        "InvalidSliceExpr",
				Description: "InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is applied to a string. Example: var s = \"hello\" var x = s[1:2:3] ",
			},
			constSet{
				Name:        "InvalidStructLit",
				Description: "InvalidStructLit occurs when a positional struct literal has an incorrect number of values. Example: var _ = struct{i, j int}{1,2,3} ",
			},
			constSet{
				Name:        "InvalidSyntaxTree",
				Description: "InvalidSyntaxTree occurs if an invalid syntax tree is provided to the type checker. It should never happen. ",
			},
			constSet{
				Name:        "InvalidTypeArg",
				Description: "InvalidTypeArg occurs when a type argument does not satisfy its corresponding type parameter constraints. Example: type T[P ~int] struct{} var _ T[string] ",
			},
			constSet{
				Name:        "InvalidTypeCycle",
				Description: "InvalidTypeCycle occurs when a cycle in type definitions results in a type that is not well-defined. Example: import \"unsafe\" type T [unsafe.Sizeof(T{})]int ",
			},
			constSet{
				Name:        "InvalidTypeSwitch",
				Description: "InvalidTypeSwitch occurs when .(type) is used on an expression that is not of interface type. Example: func f(i int) { switch x := i.(type) {} } ",
			},
			constSet{
				Name:        "InvalidUnion",
				Description: "InvalidUnion occurs when an embedded union or approximation element is not valid. Example: type _ interface { ~int | interface{ m() } } ",
			},
			constSet{
				Name:        "InvalidUnsafeAdd",
				Description: "InvalidUnsafeAdd occurs when unsafe.Add is called with a length argument that is not of integer type. It also occurs if it is used in a package compiled for a language version before go1.17. Example: import \"unsafe\" var p unsafe.Pointer var _ = unsafe.Add(p, float64(1)) ",
			},
			constSet{
				Name:        "InvalidUnsafeSlice",
				Description: "InvalidUnsafeSlice occurs when unsafe.Slice is called with a pointer argument that is not of pointer type or a length argument that is not of integer type, negative, or out of bounds. It also occurs if it is used in a package compiled for a language version before go1.17. Example: import \"unsafe\" var x int var _ = unsafe.Slice(x, 1) Example: import \"unsafe\" var x int var _ = unsafe.Slice(&x, float64(1)) Example: import \"unsafe\" var x int var _ = unsafe.Slice(&x, -1) Example: import \"unsafe\" var x int var _ = unsafe.Slice(&x, uint64(1) << 63) ",
			},
			constSet{
				Name:        "InvalidUnsafeSliceData",
				Description: "InvalidUnsafeSliceData occurs when unsafe.SliceData is called with an argument that is not of slice type. It also occurs if it is used in a package compiled for a language version before go1.20. Example: import \"unsafe\" var x int var _ = unsafe.SliceData(x) ",
			},
			constSet{
				Name:        "InvalidUnsafeString",
				Description: "InvalidUnsafeString occurs when unsafe.String is called with a length argument that is not of integer type, negative, or out of bounds. It also occurs if it is used in a package compiled for a language version before go1.20. Example: import \"unsafe\" var b [10]byte var _ = unsafe.String(&b[0], -1) ",
			},
			constSet{
				Name:        "InvalidUntypedConversion",
				Description: "InvalidUntypedConversion occurs when there is no valid implicit conversion from an untyped value satisfying the type constraints of the context in which it is used. Example: var _ = 1 + []int{} ",
			},
			constSet{
				Name:        "JumpIntoBlock",
				Description: "JumpIntoBlock occurs when a forward jump goes to a label inside a nested block. Example: func f(x int) { goto L if x > 0 { L: print(\"inside block\") } } ",
			},
			constSet{
				Name:        "JumpOverDecl",
				Description: "JumpOverDecl occurs when a label jumps over a variable declaration. Example: func f() int { goto L x := 2 L: x++ return x } ",
			},
			constSet{
				Name:        "MismatchedPkgName",
				Description: "MismatchedPkgName occurs when a file's package name doesn't match the package name already established by other files. ",
			},
			constSet{
				Name:        "MismatchedTypes",
				Description: "MismatchedTypes occurs when operand types are incompatible in a binary operation. Example: var a = \"hello\" var b = 1 var c = a - b ",
			},
			constSet{
				Name:        "MisplacedBreak",
				Description: "MisplacedBreak occurs when a break statement is not within a for, switch, or select statement of the innermost function definition. Example: func f() { break } ",
			},
			constSet{
				Name:        "MisplacedConstraintIface",
				Description: "MisplacedConstraintIface occurs when a constraint-type interface is used outside of constraint position. Example: type I interface { ~int } var _ I ",
			},
			constSet{
				Name:        "MisplacedContinue",
				Description: "MisplacedContinue occurs when a continue statement is not within a for loop of the innermost function definition. Example: func sumeven(n int) int { proceed := func() { continue } sum := 0 for i := 1; i <= n; i++ { if i % 2 != 0 { proceed() } sum += i } return sum } ",
			},
			constSet{
				Name:        "MisplacedFallthrough",
				Description: "MisplacedFallthrough occurs when a fallthrough statement is not within an expression switch. Example: func typename(i interface{}) string { switch i.(type) { case int64: fallthrough case int: return \"int\" } return \"unsupported\" } ",
			},
			constSet{
				Name:        "MisplacedLabel",
				Description: "MisplacedLabel occurs when a break or continue label is not on a for, switch, or select statement. Example: func f() { L: a := []int{1,2,3} for _, e := range a { if e > 10 { break L } println(a) } } ",
			},
			constSet{
				Name:        "MisplacedTypeParam",
				Description: "MisplacedTypeParam occurs when a type parameter is used in a place where it is not permitted. Example: type T[P any] P Example: type T[P any] struct{ *P } ",
			},
			constSet{
				Name:        "MissingFieldOrMethod",
				Description: "MissingFieldOrMethod occurs when a selector references a field or method that does not exist. Example: type T struct {} var x = T{}.f ",
			},
			constSet{
				Name:        "MissingInitBody",
				Description: "MissingInitBody occurs when an init function is missing its body. Example: func init() ",
			},
			constSet{
				Name:        "MissingLitField",
				Description: "MissingLitField occurs when a struct literal refers to a field that does not exist on the struct type. Example: var _ = struct{i int}{j: 2} ",
			},
			constSet{
				Name:        "MissingLitKey",
				Description: "MissingLitKey occurs when a map literal is missing a key expression. Example: var _ = map[string]int{1} ",
			},
			constSet{
				Name:        "MissingReturn",
				Description: "MissingReturn occurs when a function with results is missing a return statement. Example: func f() int {} ",
			},
			constSet{
				Name:        "MixedStructLit",
				Description: "MixedStructLit occurs when a struct literal contains a mix of positional and named elements. Example: var _ = struct{i, j int}{i: 1, 2} ",
			},
			constSet{
				Name:        "MultiValAssignOp",
				Description: "MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does not have single-valued left-hand or right-hand side. Per the spec: \"In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression\" Example: func f() int { x, y := 1, 2 x, y += 1 return x + y } ",
			},
			constSet{
				Name:        "NoNewVar",
				Description: "NoNewVar occurs when a short variable declaration (':=') does not declare new variables. Example: func f() { x := 1 x := 2 } ",
			},
			constSet{
				Name:        "NonIndexableOperand",
				Description: "NonIndexableOperand occurs when an index operation is applied to a value that cannot be indexed. Example: var x = 1 var y = x[1] ",
			},
			constSet{
				Name:        "NonNumericIncDec",
				Description: "NonNumericIncDec occurs when an increment or decrement operator is applied to a non-numeric value. Example: func f() { var c = \"c\" c++ } ",
			},
			constSet{
				Name:        "NonSliceableOperand",
				Description: "NonSliceableOperand occurs when a slice operation is applied to a value whose type is not sliceable, or is unaddressable. Example: var x = [...]int{1, 2, 3}[:1] Example: var x = 1 var y = 1[:1] ",
			},
			constSet{
				Name:        "NonVariadicDotDotDot",
				Description: "NonVariadicDotDotDot occurs when a \"...\" is used on the final argument to a non-variadic function. Example: func printArgs(s []string) { for _, a := range s { println(a) } } func f() { s := []string{\"a\", \"b\", \"c\"} printArgs(s...) } ",
			},
			constSet{
				Name:        "NotAGenericType",
				Description: "NotAGenericType occurs when a non-generic type is used where a generic type is expected: in type or function instantiation. Example: type T int var _ T[int] ",
			},
			constSet{
				Name:        "NotAType",
				Description: "NotAType occurs when the identifier used as the underlying type in a type declaration or the right-hand side of a type alias does not denote a type. Example: var S = 2 type T S ",
			},
			constSet{
				Name:        "NotAnExpr",
				Description: "NotAnExpr occurs when a type expression is used where a value expression is expected. Example: type T struct {} func f() { T } ",
			},
			constSet{
				Name:        "NumericOverflow",
				Description: "NumericOverflow occurs when a numeric constant overflows its target type. Example: var x int8 = 1000 ",
			},
			constSet{
				Name:        "OutOfScopeResult",
				Description: "OutOfScopeResult occurs when the name of a value implicitly returned by an empty return statement is shadowed in a nested scope. Example: func factor(n int) (i int) { for i := 2; i < n; i++ { if n%i == 0 { return } } return 0 } ",
			},
			constSet{
				Name:        "OversizeArrayLit",
				Description: "OversizeArrayLit occurs when an array literal exceeds its length. Example: var _ = [2]int{1,2,3} ",
			},
			constSet{
				Name:        "RepeatedDecl",
				Description: "RepeatedDecl occurs when an identifier occurs more than once on the left hand side of a short variable declaration. Example: func _() { x, y, y := 1, 2, 3 } ",
			},
			constSet{
				Name:        "SwappedMakeArgs",
				Description: "SwappedMakeArgs occurs when make is called with three arguments, and its length argument is larger than its capacity argument. Example: var x = make([]int, 3, 2) ",
			},
			constSet{
				Name:        "SwappedSliceIndices",
				Description: "SwappedSliceIndices occurs when constant indices in a slice expression are decreasing in value. Example: var _ = []int{1,2,3}[2:1] ",
			},
			constSet{
				Name:        "Test",
				Description: "Test is reserved for errors that only apply while in self-test mode. ",
			},
			constSet{
				Name:        "TooManyValues",
				Description: "TooManyValues occurs when a function returns too many values for the expression context in which it is used. Example: func ReturnTwo() (int, int) { return 1, 2 } var x = ReturnTwo() ",
			},
			constSet{
				Name:        "TooNew",
				Description: "TooNew indicates that, through build tags or a go.mod file, a source file requires a version of Go that is newer than the logic of the type checker. As a consequence, the type checker may produce spurious errors or fail to report real errors. The solution is to rebuild the application with a newer Go release. ",
			},
			constSet{
				Name:        "TruncatedFloat",
				Description: "TruncatedFloat occurs when a float constant is truncated to an integer value. Example: var _ int = 98.6 ",
			},
			constSet{
				Name:        "TypeTooLarge",
				Description: "TypeTooLarge occurs if unsafe.Sizeof or unsafe.Offsetof is called with an expression whose type is too large. Example: import \"unsafe\" type E [1 << 31 - 1]int var a [1 << 31]E var _ = unsafe.Sizeof(a) Example: import \"unsafe\" type E [1 << 31 - 1]int var s struct { _ [1 << 31]E x int } var _ = unsafe.Offsetof(s.x) ",
			},
			constSet{
				Name:        "UnaddressableFieldAssign",
				Description: "UnaddressableFieldAssign occurs when trying to assign to a struct field in a map value. Example: func f() { m := make(map[string]struct{i int}) m[\"foo\"].i = 42 } ",
			},
			constSet{
				Name:        "UnaddressableOperand",
				Description: "UnaddressableOperand occurs when the & operator is applied to an unaddressable expression. Example: var x = &1 ",
			},
			constSet{
				Name:        "UnassignableOperand",
				Description: "UnassignableOperand occurs when the left-hand side of an assignment is not assignable. Example: func f() { const c = 1 c = 2 } ",
			},
			constSet{
				Name:        "UncalledBuiltin",
				Description: "UncalledBuiltin occurs when a built-in function is used as a function-valued expression, instead of being called. Per the spec: \"The built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.\" Example: var _ = copy ",
			},
			constSet{
				Name:        "UndeclaredImportedName",
				Description: "UndeclaredImportedName occurs when a package-qualified identifier is undeclared by the imported package. Example: import \"go/types\" var _ = types.NotAnActualIdentifier ",
			},
			constSet{
				Name:        "UndeclaredLabel",
				Description: "UndeclaredLabel occurs when an undeclared label is jumped to. Example: func f() { goto L } ",
			},
			constSet{
				Name:        "UndeclaredName",
				Description: "UndeclaredName occurs when an identifier is not declared in the current scope. Example: var x T ",
			},
			constSet{
				Name:        "UndefinedOp",
				Description: "UndefinedOp occurs when an operator is not defined for the type(s) used in an operation. Example: var c = \"a\" - \"b\" ",
			},
			constSet{
				Name:        "UnexportedLitField",
				Description: "UnexportedLitField occurs when a positional struct literal implicitly assigns an unexported field of an imported type. ",
			},
			constSet{
				Name:        "UnexportedName",
				Description: "UnexportedName occurs when a selector refers to an unexported identifier of an imported package. Example: import \"reflect\" type _ reflect.flag ",
			},
			constSet{
				Name:        "UnsupportedFeature",
				Description: "UnsupportedFeature occurs when a language feature is used that is not supported at this Go version. ",
			},
			constSet{
				Name:        "UntypedLit",
				Description: "UntypedLit occurs when a composite literal omits a required type identifier. Example: type outer struct{ inner struct { i int } } var _ = outer{inner: {1}} ",
			},
			constSet{
				Name:        "UntypedNilUse",
				Description: "UntypedNilUse occurs when the predeclared (untyped) value nil is used to initialize a variable declared without an explicit type. Example: var x = nil ",
			},
			constSet{
				Name:        "UnusedExpr",
				Description: "UnusedExpr occurs when a side-effect free expression is used as a statement. Such a statement has no effect. Example: func f(i int) { i*i } ",
			},
			constSet{
				Name:        "UnusedImport",
				Description: "UnusedImport occurs when an import is unused. Example: import \"fmt\" func main() {} ",
			},
			constSet{
				Name:        "UnusedLabel",
				Description: "UnusedLabel occurs when a label is declared and not used. Example: func f() { L: } ",
			},
			constSet{
				Name:        "UnusedResults",
				Description: "UnusedResults occurs when a restricted expression-only built-in function is suspended via go or defer. Such a suspension discards the results of these side-effect free built-in functions, and therefore is ineffectual. Example: func f(a []int) int { defer len(a) return i } ",
			},
			constSet{
				Name:        "UnusedVar",
				Description: "UnusedVar occurs when a variable is declared but unused. Example: func f() { x := 1 } ",
			},
			constSet{
				Name:        "WrongArgCount",
				Description: "WrongArgCount occurs when too few or too many arguments are passed by a function call. Example: func f(i int) {} var x = f() ",
			},
			constSet{
				Name:        "WrongAssignCount",
				Description: "WrongAssignCount occurs when the number of values on the right-hand side of an assignment or initialization expression does not match the number of variables on the left-hand side. Example: var x = 1, 2 ",
			},
			constSet{
				Name:        "WrongResultCount",
				Description: "WrongResultCount occurs when a return statement returns an incorrect number of values. Example: func ReturnOne() int { return 1, 2 } ",
			},
			constSet{
				Name:        "WrongTypeArgCount",
				Description: "WrongTypeArgCount occurs when a type or function is instantiated with an incorrect number of type arguments, including when a generic type or function is used without instantiation. Errors involving failed type inference are assigned other error codes. Example: type T[p any] int var _ T[int, string] Example: func f[T any]() {} var x = f ",
			},
		},
		"cmerge": []constSet{
			constSet{
				Name:        "ModeMergeRelaxed",
				Description: "",
			},
			constSet{
				Name:        "ModeMergeStrict",
				Description: "",
			},
		},
		"slog": []constSet{
			constSet{
				Name:        "KindAny",
				Description: "",
			},
			constSet{
				Name:        "KindBool",
				Description: "",
			},
			constSet{
				Name:        "KindDuration",
				Description: "",
			},
			constSet{
				Name:        "KindFloat64",
				Description: "",
			},
			constSet{
				Name:        "KindGroup",
				Description: "",
			},
			constSet{
				Name:        "KindInt64",
				Description: "",
			},
			constSet{
				Name:        "KindLogValuer",
				Description: "",
			},
			constSet{
				Name:        "KindString",
				Description: "",
			},
			constSet{
				Name:        "KindTime",
				Description: "",
			},
			constSet{
				Name:        "KindUint64",
				Description: "",
			},
			constSet{
				Name:        "LevelDebug",
				Description: "Names for common levels. Level numbers are inherently arbitrary, but we picked them to satisfy three constraints. Any system can map them to another numbering scheme if it wishes. First, we wanted the default level to be Info, Since Levels are ints, Info is the default value for int, zero. Second, we wanted to make it easy to use levels to specify logger verbosity. Since a larger level means a more severe event, a logger that accepts events with smaller (or more negative) level means a more verbose logger. Logger verbosity is thus the negation of event severity, and the default verbosity of 0 accepts all events at least as severe as INFO. Third, we wanted some room between levels to accommodate schemes with named levels between ours. For example, Google Cloud Logging defines a Notice level between Info and Warn. Since there are only a few of these intermediate levels, the gap between the numbers need not be large. Our gap of 4 matches OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog Level range. OpenTelemetry also has the names TRACE and FATAL, which slog does not. But those OpenTelemetry levels can still be represented as slog Levels by using the appropriate integers. ",
			},
			constSet{
				Name:        "LevelError",
				Description: "Names for common levels. Level numbers are inherently arbitrary, but we picked them to satisfy three constraints. Any system can map them to another numbering scheme if it wishes. First, we wanted the default level to be Info, Since Levels are ints, Info is the default value for int, zero. Second, we wanted to make it easy to use levels to specify logger verbosity. Since a larger level means a more severe event, a logger that accepts events with smaller (or more negative) level means a more verbose logger. Logger verbosity is thus the negation of event severity, and the default verbosity of 0 accepts all events at least as severe as INFO. Third, we wanted some room between levels to accommodate schemes with named levels between ours. For example, Google Cloud Logging defines a Notice level between Info and Warn. Since there are only a few of these intermediate levels, the gap between the numbers need not be large. Our gap of 4 matches OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog Level range. OpenTelemetry also has the names TRACE and FATAL, which slog does not. But those OpenTelemetry levels can still be represented as slog Levels by using the appropriate integers. ",
			},
			constSet{
				Name:        "LevelInfo",
				Description: "Names for common levels. Level numbers are inherently arbitrary, but we picked them to satisfy three constraints. Any system can map them to another numbering scheme if it wishes. First, we wanted the default level to be Info, Since Levels are ints, Info is the default value for int, zero. Second, we wanted to make it easy to use levels to specify logger verbosity. Since a larger level means a more severe event, a logger that accepts events with smaller (or more negative) level means a more verbose logger. Logger verbosity is thus the negation of event severity, and the default verbosity of 0 accepts all events at least as severe as INFO. Third, we wanted some room between levels to accommodate schemes with named levels between ours. For example, Google Cloud Logging defines a Notice level between Info and Warn. Since there are only a few of these intermediate levels, the gap between the numbers need not be large. Our gap of 4 matches OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog Level range. OpenTelemetry also has the names TRACE and FATAL, which slog does not. But those OpenTelemetry levels can still be represented as slog Levels by using the appropriate integers. ",
			},
			constSet{
				Name:        "LevelKey",
				Description: "LevelKey is the key used by the built-in handlers for the level of the log call. The associated value is a [Level]. ",
			},
			constSet{
				Name:        "LevelWarn",
				Description: "Names for common levels. Level numbers are inherently arbitrary, but we picked them to satisfy three constraints. Any system can map them to another numbering scheme if it wishes. First, we wanted the default level to be Info, Since Levels are ints, Info is the default value for int, zero. Second, we wanted to make it easy to use levels to specify logger verbosity. Since a larger level means a more severe event, a logger that accepts events with smaller (or more negative) level means a more verbose logger. Logger verbosity is thus the negation of event severity, and the default verbosity of 0 accepts all events at least as severe as INFO. Third, we wanted some room between levels to accommodate schemes with named levels between ours. For example, Google Cloud Logging defines a Notice level between Info and Warn. Since there are only a few of these intermediate levels, the gap between the numbers need not be large. Our gap of 4 matches OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog Level range. OpenTelemetry also has the names TRACE and FATAL, which slog does not. But those OpenTelemetry levels can still be represented as slog Levels by using the appropriate integers. ",
			},
			constSet{
				Name:        "MessageKey",
				Description: "MessageKey is the key used by the built-in handlers for the message of the log call. The associated value is a string. ",
			},
			constSet{
				Name:        "SourceKey",
				Description: "SourceKey is the key used by the built-in handlers for the source file and line of the log call. The associated value is a *[Source]. ",
			},
			constSet{
				Name:        "TimeKey",
				Description: "TimeKey is the key used by the built-in handlers for the time when the log method is called. The associated Value is a [time.Time]. ",
			},
		},
		"goexperiment": []constSet{
			constSet{
				Name:        "AliasTypeParams",
				Description: "",
			},
			constSet{
				Name:        "AliasTypeParamsInt",
				Description: "",
			},
			constSet{
				Name:        "Arenas",
				Description: "",
			},
			constSet{
				Name:        "ArenasInt",
				Description: "",
			},
			constSet{
				Name:        "BoringCrypto",
				Description: "",
			},
			constSet{
				Name:        "BoringCryptoInt",
				Description: "",
			},
			constSet{
				Name:        "CacheProg",
				Description: "",
			},
			constSet{
				Name:        "CacheProgInt",
				Description: "",
			},
			constSet{
				Name:        "CgoCheck2",
				Description: "",
			},
			constSet{
				Name:        "CgoCheck2Int",
				Description: "",
			},
			constSet{
				Name:        "Dwarf5",
				Description: "",
			},
			constSet{
				Name:        "Dwarf5Int",
				Description: "",
			},
			constSet{
				Name:        "FieldTrack",
				Description: "",
			},
			constSet{
				Name:        "FieldTrackInt",
				Description: "",
			},
			constSet{
				Name:        "GreenTeaGC",
				Description: "",
			},
			constSet{
				Name:        "GreenTeaGCInt",
				Description: "",
			},
			constSet{
				Name:        "HeapMinimum512KiB",
				Description: "",
			},
			constSet{
				Name:        "HeapMinimum512KiBInt",
				Description: "",
			},
			constSet{
				Name:        "JSONv2",
				Description: "",
			},
			constSet{
				Name:        "JSONv2Int",
				Description: "",
			},
			constSet{
				Name:        "LoopVar",
				Description: "",
			},
			constSet{
				Name:        "LoopVarInt",
				Description: "",
			},
			constSet{
				Name:        "NewInliner",
				Description: "",
			},
			constSet{
				Name:        "NewInlinerInt",
				Description: "",
			},
			constSet{
				Name:        "PreemptibleLoops",
				Description: "",
			},
			constSet{
				Name:        "PreemptibleLoopsInt",
				Description: "",
			},
			constSet{
				Name:        "RangeFunc",
				Description: "",
			},
			constSet{
				Name:        "RangeFuncInt",
				Description: "",
			},
			constSet{
				Name:        "RegabiArgs",
				Description: "",
			},
			constSet{
				Name:        "RegabiArgsInt",
				Description: "",
			},
			constSet{
				Name:        "RegabiWrappers",
				Description: "",
			},
			constSet{
				Name:        "RegabiWrappersInt",
				Description: "",
			},
			constSet{
				Name:        "StaticLockRanking",
				Description: "",
			},
			constSet{
				Name:        "StaticLockRankingInt",
				Description: "",
			},
			constSet{
				Name:        "SwissMap",
				Description: "",
			},
			constSet{
				Name:        "SwissMapInt",
				Description: "",
			},
			constSet{
				Name:        "SyncHashTrieMap",
				Description: "",
			},
			constSet{
				Name:        "SyncHashTrieMapInt",
				Description: "",
			},
			constSet{
				Name:        "Synctest",
				Description: "",
			},
			constSet{
				Name:        "SynctestInt",
				Description: "",
			},
		},
		"fs": []constSet{
			constSet{
				Name:        "ModeAppend",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeCharDevice",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeDevice",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeDir",
				Description: "The single letters are the abbreviations used by the String method's formatting. ",
			},
			constSet{
				Name:        "ModeExclusive",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeIrregular",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeNamedPipe",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModePerm",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSetgid",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSetuid",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSocket",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSticky",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSymlink",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeTemporary",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeType",
				Description: "Mask for the type bits. For regular files, none will be set. ",
			},
		},
		"flate": []constSet{
			constSet{
				Name:        "BestCompression",
				Description: "",
			},
			constSet{
				Name:        "BestSpeed",
				Description: "",
			},
			constSet{
				Name:        "DefaultCompression",
				Description: "",
			},
			constSet{
				Name:        "HuffmanOnly",
				Description: "HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman entropy encoding. This mode is useful in compressing data that has already been compressed with an LZ style algorithm (e.g. Snappy or LZ4) that lacks an entropy encoder. Compression gains are achieved when certain bytes in the input stream occur more frequently than others. Note that HuffmanOnly produces a compressed output that is RFC 1951 compliant. That is, any valid DEFLATE decompressor will continue to be able to decompress this output. ",
			},
			constSet{
				Name:        "NoCompression",
				Description: "",
			},
		},
		"sha1": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "The blocksize of SHA-1 in bytes. ",
			},
			constSet{
				Name:        "Size",
				Description: "The size of a SHA-1 checksum in bytes. ",
			},
		},
		"elf": []constSet{
			constSet{
				Name:        "ARM_MAGIC_TRAMP_NUMBER",
				Description: "Magic number for the elf trampoline, chosen wisely to be an immediate value. ",
			},
			constSet{
				Name:        "COMPRESS_HIOS",
				Description: "",
			},
			constSet{
				Name:        "COMPRESS_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "COMPRESS_LOOS",
				Description: "",
			},
			constSet{
				Name:        "COMPRESS_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "COMPRESS_ZLIB",
				Description: "",
			},
			constSet{
				Name:        "COMPRESS_ZSTD",
				Description: "",
			},
			constSet{
				Name:        "DF_1_CONFALT",
				Description: "Identifies this object as a configuration alternative object generated by crle. Triggers the runtime linker to search for a configuration file $ORIGIN/ld.config.app-name. ",
			},
			constSet{
				Name:        "DF_1_DIRECT",
				Description: "Indicates that the object should use direct binding information. ",
			},
			constSet{
				Name:        "DF_1_DISPRELDNE",
				Description: "Indicates that this object has displacement relocations applied. ",
			},
			constSet{
				Name:        "DF_1_DISPRELPND",
				Description: "Indicates that this object has displacement relocations pending. ",
			},
			constSet{
				Name:        "DF_1_EDITED",
				Description: "Indicates that this object has been edited or has been modified since the objects original construction by the link-editor. ",
			},
			constSet{
				Name:        "DF_1_ENDFILTEE",
				Description: "Meaningful only for filtees. Terminates a filters search for any further filtees. ",
			},
			constSet{
				Name:        "DF_1_GLOBAL",
				Description: "Unused. ",
			},
			constSet{
				Name:        "DF_1_GLOBAUDIT",
				Description: "Indicates that the executable requires global auditing. ",
			},
			constSet{
				Name:        "DF_1_GROUP",
				Description: "Indicates that the object is a member of a group. ",
			},
			constSet{
				Name:        "DF_1_IGNMULDEF",
				Description: "Reserved for internal use by the kernel runtime-linker. ",
			},
			constSet{
				Name:        "DF_1_INITFIRST",
				Description: "Indicates that this object's initialization section be run before any other objects loaded. ",
			},
			constSet{
				Name:        "DF_1_INTERPOSE",
				Description: "Indicates that the objects symbol table is to interpose before all symbols except the primary load object, which is typically the executable. ",
			},
			constSet{
				Name:        "DF_1_KMOD",
				Description: "Indicates that the object is a kernel module. ",
			},
			constSet{
				Name:        "DF_1_LOADFLTR",
				Description: "Meaningful only for filters. Indicates that all associated filtees be processed immediately. ",
			},
			constSet{
				Name:        "DF_1_NOCOMMON",
				Description: "Unused. ",
			},
			constSet{
				Name:        "DF_1_NODEFLIB",
				Description: "Indicates that the search for dependencies of this object ignores any default library search paths. ",
			},
			constSet{
				Name:        "DF_1_NODELETE",
				Description: "Indicates that the object cannot be deleted from a process. ",
			},
			constSet{
				Name:        "DF_1_NODIRECT",
				Description: "Indicates that this object contains symbols that cannot be directly bound to. ",
			},
			constSet{
				Name:        "DF_1_NODUMP",
				Description: "Indicates that this object is not dumped by dldump. Candidates are objects with no relocations that might get included when generating alternative objects using. ",
			},
			constSet{
				Name:        "DF_1_NOHDR",
				Description: "Reserved for internal use by the kernel runtime-linker. ",
			},
			constSet{
				Name:        "DF_1_NOKSYMS",
				Description: "Reserved for internal use by the kernel runtime-linker. ",
			},
			constSet{
				Name:        "DF_1_NOOPEN",
				Description: "Indicates that the object cannot be added to a running process with dlopen. ",
			},
			constSet{
				Name:        "DF_1_NORELOC",
				Description: "Reserved for internal use by the kernel runtime-linker. ",
			},
			constSet{
				Name:        "DF_1_NOW",
				Description: "Indicates that all relocations for this object must be processed before returning control to the program. ",
			},
			constSet{
				Name:        "DF_1_ORIGIN",
				Description: "Indicates the object requires $ORIGIN processing. ",
			},
			constSet{
				Name:        "DF_1_PIE",
				Description: "Indicates that the object is a position-independent executable. ",
			},
			constSet{
				Name:        "DF_1_SINGLETON",
				Description: "Indicates that the object defines, or makes reference to singleton symbols. ",
			},
			constSet{
				Name:        "DF_1_STUB",
				Description: "Indicates that the object is a stub. ",
			},
			constSet{
				Name:        "DF_1_SYMINTPOSE",
				Description: "Indicates that the object contains individual symbols that should interpose before all symbols except the primary load object, which is typically the executable. ",
			},
			constSet{
				Name:        "DF_1_TRANS",
				Description: "Unused. ",
			},
			constSet{
				Name:        "DF_1_WEAKFILTER",
				Description: "Indicates that the object is a weak standard filter. ",
			},
			constSet{
				Name:        "DF_BIND_NOW",
				Description: "",
			},
			constSet{
				Name:        "DF_ORIGIN",
				Description: "",
			},
			constSet{
				Name:        "DF_STATIC_TLS",
				Description: "",
			},
			constSet{
				Name:        "DF_SYMBOLIC",
				Description: "",
			},
			constSet{
				Name:        "DF_TEXTREL",
				Description: "",
			},
			constSet{
				Name:        "DT_ADDRRNGHI",
				Description: "",
			},
			constSet{
				Name:        "DT_ADDRRNGLO",
				Description: "",
			},
			constSet{
				Name:        "DT_AUDIT",
				Description: "",
			},
			constSet{
				Name:        "DT_AUXILIARY",
				Description: "",
			},
			constSet{
				Name:        "DT_BIND_NOW",
				Description: "",
			},
			constSet{
				Name:        "DT_CHECKSUM",
				Description: "",
			},
			constSet{
				Name:        "DT_CONFIG",
				Description: "",
			},
			constSet{
				Name:        "DT_DEBUG",
				Description: "",
			},
			constSet{
				Name:        "DT_DEPAUDIT",
				Description: "",
			},
			constSet{
				Name:        "DT_ENCODING",
				Description: "",
			},
			constSet{
				Name:        "DT_FEATURE",
				Description: "",
			},
			constSet{
				Name:        "DT_FILTER",
				Description: "",
			},
			constSet{
				Name:        "DT_FINI",
				Description: "",
			},
			constSet{
				Name:        "DT_FINI_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "DT_FINI_ARRAYSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_FLAGS",
				Description: "",
			},
			constSet{
				Name:        "DT_FLAGS_1",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_CONFLICT",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_CONFLICTSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_HASH",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_LIBLIST",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_LIBLISTSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_GNU_PRELINKED",
				Description: "",
			},
			constSet{
				Name:        "DT_HASH",
				Description: "",
			},
			constSet{
				Name:        "DT_HIOS",
				Description: "",
			},
			constSet{
				Name:        "DT_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "DT_INIT",
				Description: "",
			},
			constSet{
				Name:        "DT_INIT_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "DT_INIT_ARRAYSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_JMPREL",
				Description: "",
			},
			constSet{
				Name:        "DT_LOOS",
				Description: "",
			},
			constSet{
				Name:        "DT_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_AUX_DYNAMIC",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_BASE_ADDRESS",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_COMPACT_SIZE",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_CONFLICT",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_CONFLICTNO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_CXX_FLAGS",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_CLASS",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_CLASSSYM",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_CLASSSYM_NO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_CLASS_NO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_INSTANCE",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_INSTANCE_NO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_RELOC",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_RELOC_NO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_SYM",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DELTA_SYM_NO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_DYNSTR_ALIGN",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_FLAGS",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_GOTSYM",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_GP_VALUE",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_HIDDEN_GOTIDX",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_HIPAGENO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_ICHECKSUM",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_INTERFACE",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_INTERFACE_SIZE",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_IVERSION",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_LIBLIST",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_LIBLISTNO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_LOCALPAGE_GOTIDX",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_LOCAL_GOTIDX",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_LOCAL_GOTNO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_MSYM",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_OPTIONS",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_PERF_SUFFIX",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_PIXIE_INIT",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_PLTGOT",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_PROTECTED_GOTIDX",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_RLD_MAP",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_RLD_MAP_REL",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_RLD_TEXT_RESOLVE_ADDR",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_RLD_VERSION",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_RWPLT",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_SYMBOL_LIB",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_SYMTABNO",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_TIME_STAMP",
				Description: "",
			},
			constSet{
				Name:        "DT_MIPS_UNREFEXTNO",
				Description: "",
			},
			constSet{
				Name:        "DT_MOVEENT",
				Description: "",
			},
			constSet{
				Name:        "DT_MOVESZ",
				Description: "",
			},
			constSet{
				Name:        "DT_MOVETAB",
				Description: "",
			},
			constSet{
				Name:        "DT_NEEDED",
				Description: "",
			},
			constSet{
				Name:        "DT_NULL",
				Description: "",
			},
			constSet{
				Name:        "DT_PLTGOT",
				Description: "",
			},
			constSet{
				Name:        "DT_PLTPAD",
				Description: "",
			},
			constSet{
				Name:        "DT_PLTPADSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_PLTREL",
				Description: "",
			},
			constSet{
				Name:        "DT_PLTRELSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_POSFLAG_1",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC64_GLINK",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC64_OPD",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC64_OPDSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC64_OPT",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC_GOT",
				Description: "",
			},
			constSet{
				Name:        "DT_PPC_OPT",
				Description: "",
			},
			constSet{
				Name:        "DT_PREINIT_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "DT_PREINIT_ARRAYSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_REL",
				Description: "",
			},
			constSet{
				Name:        "DT_RELA",
				Description: "",
			},
			constSet{
				Name:        "DT_RELACOUNT",
				Description: "",
			},
			constSet{
				Name:        "DT_RELAENT",
				Description: "",
			},
			constSet{
				Name:        "DT_RELASZ",
				Description: "",
			},
			constSet{
				Name:        "DT_RELCOUNT",
				Description: "",
			},
			constSet{
				Name:        "DT_RELENT",
				Description: "",
			},
			constSet{
				Name:        "DT_RELSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_RPATH",
				Description: "",
			},
			constSet{
				Name:        "DT_RUNPATH",
				Description: "",
			},
			constSet{
				Name:        "DT_SONAME",
				Description: "",
			},
			constSet{
				Name:        "DT_SPARC_REGISTER",
				Description: "",
			},
			constSet{
				Name:        "DT_STRSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_STRTAB",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMBOLIC",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMENT",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMINENT",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMINFO",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMINSZ",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMTAB",
				Description: "",
			},
			constSet{
				Name:        "DT_SYMTAB_SHNDX",
				Description: "",
			},
			constSet{
				Name:        "DT_TEXTREL",
				Description: "",
			},
			constSet{
				Name:        "DT_TLSDESC_GOT",
				Description: "",
			},
			constSet{
				Name:        "DT_TLSDESC_PLT",
				Description: "",
			},
			constSet{
				Name:        "DT_USED",
				Description: "",
			},
			constSet{
				Name:        "DT_VALRNGHI",
				Description: "",
			},
			constSet{
				Name:        "DT_VALRNGLO",
				Description: "",
			},
			constSet{
				Name:        "DT_VERDEF",
				Description: "",
			},
			constSet{
				Name:        "DT_VERDEFNUM",
				Description: "",
			},
			constSet{
				Name:        "DT_VERNEED",
				Description: "",
			},
			constSet{
				Name:        "DT_VERNEEDNUM",
				Description: "",
			},
			constSet{
				Name:        "DT_VERSYM",
				Description: "",
			},
			constSet{
				Name:        "EI_ABIVERSION",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_CLASS",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_DATA",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_NIDENT",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_OSABI",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_PAD",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "EI_VERSION",
				Description: "Indexes into the Header.Ident array. ",
			},
			constSet{
				Name:        "ELFCLASS32",
				Description: "",
			},
			constSet{
				Name:        "ELFCLASS64",
				Description: "",
			},
			constSet{
				Name:        "ELFCLASSNONE",
				Description: "",
			},
			constSet{
				Name:        "ELFDATA2LSB",
				Description: "",
			},
			constSet{
				Name:        "ELFDATA2MSB",
				Description: "",
			},
			constSet{
				Name:        "ELFDATANONE",
				Description: "",
			},
			constSet{
				Name:        "ELFMAG",
				Description: "Initial magic number for ELF files. ",
			},
			constSet{
				Name:        "ELFOSABI_86OPEN",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_AIX",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_ARM",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_AROS",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_CLOUDABI",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_FENIXOS",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_FREEBSD",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_HPUX",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_HURD",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_IRIX",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_LINUX",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_MODESTO",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_NETBSD",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_NONE",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_NSK",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_OPENBSD",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_OPENVMS",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_SOLARIS",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_STANDALONE",
				Description: "",
			},
			constSet{
				Name:        "ELFOSABI_TRU64",
				Description: "",
			},
			constSet{
				Name:        "EM_386",
				Description: "",
			},
			constSet{
				Name:        "EM_486",
				Description: " Non-standard or deprecated. ",
			},
			constSet{
				Name:        "EM_56800EX",
				Description: "",
			},
			constSet{
				Name:        "EM_68HC05",
				Description: "",
			},
			constSet{
				Name:        "EM_68HC08",
				Description: "",
			},
			constSet{
				Name:        "EM_68HC11",
				Description: "",
			},
			constSet{
				Name:        "EM_68HC12",
				Description: "",
			},
			constSet{
				Name:        "EM_68HC16",
				Description: "",
			},
			constSet{
				Name:        "EM_68K",
				Description: "",
			},
			constSet{
				Name:        "EM_78KOR",
				Description: "",
			},
			constSet{
				Name:        "EM_8051",
				Description: "",
			},
			constSet{
				Name:        "EM_860",
				Description: "",
			},
			constSet{
				Name:        "EM_88K",
				Description: "",
			},
			constSet{
				Name:        "EM_960",
				Description: "",
			},
			constSet{
				Name:        "EM_AARCH64",
				Description: "",
			},
			constSet{
				Name:        "EM_ALPHA",
				Description: "",
			},
			constSet{
				Name:        "EM_ALPHA_STD",
				Description: "",
			},
			constSet{
				Name:        "EM_ALTERA_NIOS2",
				Description: "",
			},
			constSet{
				Name:        "EM_AMDGPU",
				Description: "",
			},
			constSet{
				Name:        "EM_ARC",
				Description: "",
			},
			constSet{
				Name:        "EM_ARCA",
				Description: "",
			},
			constSet{
				Name:        "EM_ARC_COMPACT",
				Description: "",
			},
			constSet{
				Name:        "EM_ARC_COMPACT2",
				Description: "",
			},
			constSet{
				Name:        "EM_ARM",
				Description: "",
			},
			constSet{
				Name:        "EM_AVR",
				Description: "",
			},
			constSet{
				Name:        "EM_AVR32",
				Description: "",
			},
			constSet{
				Name:        "EM_BA1",
				Description: "",
			},
			constSet{
				Name:        "EM_BA2",
				Description: "",
			},
			constSet{
				Name:        "EM_BLACKFIN",
				Description: "",
			},
			constSet{
				Name:        "EM_BPF",
				Description: "",
			},
			constSet{
				Name:        "EM_C166",
				Description: "",
			},
			constSet{
				Name:        "EM_CDP",
				Description: "",
			},
			constSet{
				Name:        "EM_CE",
				Description: "",
			},
			constSet{
				Name:        "EM_CLOUDSHIELD",
				Description: "",
			},
			constSet{
				Name:        "EM_COGE",
				Description: "",
			},
			constSet{
				Name:        "EM_COLDFIRE",
				Description: "",
			},
			constSet{
				Name:        "EM_COOL",
				Description: "",
			},
			constSet{
				Name:        "EM_COREA_1ST",
				Description: "",
			},
			constSet{
				Name:        "EM_COREA_2ND",
				Description: "",
			},
			constSet{
				Name:        "EM_CR",
				Description: "",
			},
			constSet{
				Name:        "EM_CR16",
				Description: "",
			},
			constSet{
				Name:        "EM_CRAYNV2",
				Description: "",
			},
			constSet{
				Name:        "EM_CRIS",
				Description: "",
			},
			constSet{
				Name:        "EM_CRX",
				Description: "",
			},
			constSet{
				Name:        "EM_CSR_KALIMBA",
				Description: "",
			},
			constSet{
				Name:        "EM_CUDA",
				Description: "",
			},
			constSet{
				Name:        "EM_CYPRESS_M8C",
				Description: "",
			},
			constSet{
				Name:        "EM_D10V",
				Description: "",
			},
			constSet{
				Name:        "EM_D30V",
				Description: "",
			},
			constSet{
				Name:        "EM_DSP24",
				Description: "",
			},
			constSet{
				Name:        "EM_DSPIC30F",
				Description: "",
			},
			constSet{
				Name:        "EM_DXP",
				Description: "",
			},
			constSet{
				Name:        "EM_ECOG1",
				Description: "",
			},
			constSet{
				Name:        "EM_ECOG16",
				Description: "",
			},
			constSet{
				Name:        "EM_ECOG1X",
				Description: "",
			},
			constSet{
				Name:        "EM_ECOG2",
				Description: "",
			},
			constSet{
				Name:        "EM_ETPU",
				Description: "",
			},
			constSet{
				Name:        "EM_EXCESS",
				Description: "",
			},
			constSet{
				Name:        "EM_F2MC16",
				Description: "",
			},
			constSet{
				Name:        "EM_FIREPATH",
				Description: "",
			},
			constSet{
				Name:        "EM_FR20",
				Description: "",
			},
			constSet{
				Name:        "EM_FR30",
				Description: "",
			},
			constSet{
				Name:        "EM_FT32",
				Description: "",
			},
			constSet{
				Name:        "EM_FX66",
				Description: "",
			},
			constSet{
				Name:        "EM_H8S",
				Description: "",
			},
			constSet{
				Name:        "EM_H8_300",
				Description: "",
			},
			constSet{
				Name:        "EM_H8_300H",
				Description: "",
			},
			constSet{
				Name:        "EM_H8_500",
				Description: "",
			},
			constSet{
				Name:        "EM_HUANY",
				Description: "",
			},
			constSet{
				Name:        "EM_IA_64",
				Description: "",
			},
			constSet{
				Name:        "EM_INTEL205",
				Description: "",
			},
			constSet{
				Name:        "EM_INTEL206",
				Description: "",
			},
			constSet{
				Name:        "EM_INTEL207",
				Description: "",
			},
			constSet{
				Name:        "EM_INTEL208",
				Description: "",
			},
			constSet{
				Name:        "EM_INTEL209",
				Description: "",
			},
			constSet{
				Name:        "EM_IP2K",
				Description: "",
			},
			constSet{
				Name:        "EM_JAVELIN",
				Description: "",
			},
			constSet{
				Name:        "EM_K10M",
				Description: "",
			},
			constSet{
				Name:        "EM_KM32",
				Description: "",
			},
			constSet{
				Name:        "EM_KMX16",
				Description: "",
			},
			constSet{
				Name:        "EM_KMX32",
				Description: "",
			},
			constSet{
				Name:        "EM_KMX8",
				Description: "",
			},
			constSet{
				Name:        "EM_KVARC",
				Description: "",
			},
			constSet{
				Name:        "EM_L10M",
				Description: "",
			},
			constSet{
				Name:        "EM_LANAI",
				Description: "",
			},
			constSet{
				Name:        "EM_LATTICEMICO32",
				Description: "",
			},
			constSet{
				Name:        "EM_LOONGARCH",
				Description: "",
			},
			constSet{
				Name:        "EM_M16C",
				Description: "",
			},
			constSet{
				Name:        "EM_M32",
				Description: "",
			},
			constSet{
				Name:        "EM_M32C",
				Description: "",
			},
			constSet{
				Name:        "EM_M32R",
				Description: "",
			},
			constSet{
				Name:        "EM_MANIK",
				Description: "",
			},
			constSet{
				Name:        "EM_MAX",
				Description: "",
			},
			constSet{
				Name:        "EM_MAXQ30",
				Description: "",
			},
			constSet{
				Name:        "EM_MCHP_PIC",
				Description: "",
			},
			constSet{
				Name:        "EM_MCST_ELBRUS",
				Description: "",
			},
			constSet{
				Name:        "EM_ME16",
				Description: "",
			},
			constSet{
				Name:        "EM_METAG",
				Description: "",
			},
			constSet{
				Name:        "EM_MICROBLAZE",
				Description: "",
			},
			constSet{
				Name:        "EM_MIPS",
				Description: "",
			},
			constSet{
				Name:        "EM_MIPS_RS3_LE",
				Description: "",
			},
			constSet{
				Name:        "EM_MIPS_RS4_BE",
				Description: "",
			},
			constSet{
				Name:        "EM_MIPS_X",
				Description: "",
			},
			constSet{
				Name:        "EM_MMA",
				Description: "",
			},
			constSet{
				Name:        "EM_MMDSP_PLUS",
				Description: "",
			},
			constSet{
				Name:        "EM_MMIX",
				Description: "",
			},
			constSet{
				Name:        "EM_MN10200",
				Description: "",
			},
			constSet{
				Name:        "EM_MN10300",
				Description: "",
			},
			constSet{
				Name:        "EM_MOXIE",
				Description: "",
			},
			constSet{
				Name:        "EM_MSP430",
				Description: "",
			},
			constSet{
				Name:        "EM_NCPU",
				Description: "",
			},
			constSet{
				Name:        "EM_NDR1",
				Description: "",
			},
			constSet{
				Name:        "EM_NDS32",
				Description: "",
			},
			constSet{
				Name:        "EM_NONE",
				Description: "",
			},
			constSet{
				Name:        "EM_NORC",
				Description: "",
			},
			constSet{
				Name:        "EM_NS32K",
				Description: "",
			},
			constSet{
				Name:        "EM_OPEN8",
				Description: "",
			},
			constSet{
				Name:        "EM_OPENRISC",
				Description: "",
			},
			constSet{
				Name:        "EM_PARISC",
				Description: "",
			},
			constSet{
				Name:        "EM_PCP",
				Description: "",
			},
			constSet{
				Name:        "EM_PDP10",
				Description: "",
			},
			constSet{
				Name:        "EM_PDP11",
				Description: "",
			},
			constSet{
				Name:        "EM_PDSP",
				Description: "",
			},
			constSet{
				Name:        "EM_PJ",
				Description: "",
			},
			constSet{
				Name:        "EM_PPC",
				Description: "",
			},
			constSet{
				Name:        "EM_PPC64",
				Description: "",
			},
			constSet{
				Name:        "EM_PRISM",
				Description: "",
			},
			constSet{
				Name:        "EM_QDSP6",
				Description: "",
			},
			constSet{
				Name:        "EM_R32C",
				Description: "",
			},
			constSet{
				Name:        "EM_RCE",
				Description: "",
			},
			constSet{
				Name:        "EM_RH32",
				Description: "",
			},
			constSet{
				Name:        "EM_RISCV",
				Description: "",
			},
			constSet{
				Name:        "EM_RL78",
				Description: "",
			},
			constSet{
				Name:        "EM_RS08",
				Description: "",
			},
			constSet{
				Name:        "EM_RX",
				Description: "",
			},
			constSet{
				Name:        "EM_S370",
				Description: "",
			},
			constSet{
				Name:        "EM_S390",
				Description: "",
			},
			constSet{
				Name:        "EM_SCORE7",
				Description: "",
			},
			constSet{
				Name:        "EM_SEP",
				Description: "",
			},
			constSet{
				Name:        "EM_SE_C17",
				Description: "",
			},
			constSet{
				Name:        "EM_SE_C33",
				Description: "",
			},
			constSet{
				Name:        "EM_SH",
				Description: "",
			},
			constSet{
				Name:        "EM_SHARC",
				Description: "",
			},
			constSet{
				Name:        "EM_SLE9X",
				Description: "",
			},
			constSet{
				Name:        "EM_SNP1K",
				Description: "",
			},
			constSet{
				Name:        "EM_SPARC",
				Description: "",
			},
			constSet{
				Name:        "EM_SPARC32PLUS",
				Description: "",
			},
			constSet{
				Name:        "EM_SPARCV9",
				Description: "",
			},
			constSet{
				Name:        "EM_ST100",
				Description: "",
			},
			constSet{
				Name:        "EM_ST19",
				Description: "",
			},
			constSet{
				Name:        "EM_ST200",
				Description: "",
			},
			constSet{
				Name:        "EM_ST7",
				Description: "",
			},
			constSet{
				Name:        "EM_ST9PLUS",
				Description: "",
			},
			constSet{
				Name:        "EM_STARCORE",
				Description: "",
			},
			constSet{
				Name:        "EM_STM8",
				Description: "",
			},
			constSet{
				Name:        "EM_STXP7X",
				Description: "",
			},
			constSet{
				Name:        "EM_SVX",
				Description: "",
			},
			constSet{
				Name:        "EM_TILE64",
				Description: "",
			},
			constSet{
				Name:        "EM_TILEGX",
				Description: "",
			},
			constSet{
				Name:        "EM_TILEPRO",
				Description: "",
			},
			constSet{
				Name:        "EM_TINYJ",
				Description: "",
			},
			constSet{
				Name:        "EM_TI_ARP32",
				Description: "",
			},
			constSet{
				Name:        "EM_TI_C2000",
				Description: "",
			},
			constSet{
				Name:        "EM_TI_C5500",
				Description: "",
			},
			constSet{
				Name:        "EM_TI_C6000",
				Description: "",
			},
			constSet{
				Name:        "EM_TI_PRU",
				Description: "",
			},
			constSet{
				Name:        "EM_TMM_GPP",
				Description: "",
			},
			constSet{
				Name:        "EM_TPC",
				Description: "",
			},
			constSet{
				Name:        "EM_TRICORE",
				Description: "",
			},
			constSet{
				Name:        "EM_TRIMEDIA",
				Description: "",
			},
			constSet{
				Name:        "EM_TSK3000",
				Description: "",
			},
			constSet{
				Name:        "EM_UNICORE",
				Description: "",
			},
			constSet{
				Name:        "EM_V800",
				Description: "",
			},
			constSet{
				Name:        "EM_V850",
				Description: "",
			},
			constSet{
				Name:        "EM_VAX",
				Description: "",
			},
			constSet{
				Name:        "EM_VIDEOCORE",
				Description: "",
			},
			constSet{
				Name:        "EM_VIDEOCORE3",
				Description: "",
			},
			constSet{
				Name:        "EM_VIDEOCORE5",
				Description: "",
			},
			constSet{
				Name:        "EM_VISIUM",
				Description: "",
			},
			constSet{
				Name:        "EM_VPP500",
				Description: "",
			},
			constSet{
				Name:        "EM_X86_64",
				Description: "",
			},
			constSet{
				Name:        "EM_XCORE",
				Description: "",
			},
			constSet{
				Name:        "EM_XGATE",
				Description: "",
			},
			constSet{
				Name:        "EM_XIMO16",
				Description: "",
			},
			constSet{
				Name:        "EM_XTENSA",
				Description: "",
			},
			constSet{
				Name:        "EM_Z80",
				Description: "",
			},
			constSet{
				Name:        "EM_ZSP",
				Description: "",
			},
			constSet{
				Name:        "ET_CORE",
				Description: "",
			},
			constSet{
				Name:        "ET_DYN",
				Description: "",
			},
			constSet{
				Name:        "ET_EXEC",
				Description: "",
			},
			constSet{
				Name:        "ET_HIOS",
				Description: "",
			},
			constSet{
				Name:        "ET_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "ET_LOOS",
				Description: "",
			},
			constSet{
				Name:        "ET_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "ET_NONE",
				Description: "",
			},
			constSet{
				Name:        "ET_REL",
				Description: "",
			},
			constSet{
				Name:        "EV_CURRENT",
				Description: "",
			},
			constSet{
				Name:        "EV_NONE",
				Description: "",
			},
			constSet{
				Name:        "NT_FPREGSET",
				Description: "",
			},
			constSet{
				Name:        "NT_PRPSINFO",
				Description: "",
			},
			constSet{
				Name:        "NT_PRSTATUS",
				Description: "",
			},
			constSet{
				Name:        "PF_MASKOS",
				Description: "",
			},
			constSet{
				Name:        "PF_MASKPROC",
				Description: "",
			},
			constSet{
				Name:        "PF_R",
				Description: "",
			},
			constSet{
				Name:        "PF_W",
				Description: "",
			},
			constSet{
				Name:        "PF_X",
				Description: "",
			},
			constSet{
				Name:        "PT_AARCH64_ARCHEXT",
				Description: "",
			},
			constSet{
				Name:        "PT_AARCH64_UNWIND",
				Description: "",
			},
			constSet{
				Name:        "PT_ARM_ARCHEXT",
				Description: "",
			},
			constSet{
				Name:        "PT_ARM_EXIDX",
				Description: "",
			},
			constSet{
				Name:        "PT_DYNAMIC",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_EH_FRAME",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_MBIND_HI",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_MBIND_LO",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_PROPERTY",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_RELRO",
				Description: "",
			},
			constSet{
				Name:        "PT_GNU_STACK",
				Description: "",
			},
			constSet{
				Name:        "PT_HIOS",
				Description: "",
			},
			constSet{
				Name:        "PT_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "PT_INTERP",
				Description: "",
			},
			constSet{
				Name:        "PT_LOAD",
				Description: "",
			},
			constSet{
				Name:        "PT_LOOS",
				Description: "",
			},
			constSet{
				Name:        "PT_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "PT_MIPS_ABIFLAGS",
				Description: "",
			},
			constSet{
				Name:        "PT_MIPS_OPTIONS",
				Description: "",
			},
			constSet{
				Name:        "PT_MIPS_REGINFO",
				Description: "",
			},
			constSet{
				Name:        "PT_MIPS_RTPROC",
				Description: "",
			},
			constSet{
				Name:        "PT_NOTE",
				Description: "",
			},
			constSet{
				Name:        "PT_NULL",
				Description: "",
			},
			constSet{
				Name:        "PT_OPENBSD_BOOTDATA",
				Description: "",
			},
			constSet{
				Name:        "PT_OPENBSD_NOBTCFI",
				Description: "",
			},
			constSet{
				Name:        "PT_OPENBSD_RANDOMIZE",
				Description: "",
			},
			constSet{
				Name:        "PT_OPENBSD_WXNEEDED",
				Description: "",
			},
			constSet{
				Name:        "PT_PAX_FLAGS",
				Description: "",
			},
			constSet{
				Name:        "PT_PHDR",
				Description: "",
			},
			constSet{
				Name:        "PT_RISCV_ATTRIBUTES",
				Description: "",
			},
			constSet{
				Name:        "PT_S390_PGSTE",
				Description: "",
			},
			constSet{
				Name:        "PT_SHLIB",
				Description: "",
			},
			constSet{
				Name:        "PT_SUNWSTACK",
				Description: "",
			},
			constSet{
				Name:        "PT_SUNW_EH_FRAME",
				Description: "",
			},
			constSet{
				Name:        "PT_TLS",
				Description: "",
			},
			constSet{
				Name:        "R_386_16",
				Description: "",
			},
			constSet{
				Name:        "R_386_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_32PLT",
				Description: "",
			},
			constSet{
				Name:        "R_386_8",
				Description: "",
			},
			constSet{
				Name:        "R_386_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_386_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_386_GOT32",
				Description: "",
			},
			constSet{
				Name:        "R_386_GOT32X",
				Description: "",
			},
			constSet{
				Name:        "R_386_GOTOFF",
				Description: "",
			},
			constSet{
				Name:        "R_386_GOTPC",
				Description: "",
			},
			constSet{
				Name:        "R_386_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_386_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_386_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_386_PC16",
				Description: "",
			},
			constSet{
				Name:        "R_386_PC32",
				Description: "",
			},
			constSet{
				Name:        "R_386_PC8",
				Description: "",
			},
			constSet{
				Name:        "R_386_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_386_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_386_SIZE32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_DESC",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_DESC_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_DTPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GD",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GD_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GD_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GD_POP",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GD_PUSH",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GOTDESC",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_GOTIE",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_IE",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_IE_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDM",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDM_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDM_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDM_POP",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDM_PUSH",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LDO_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LE",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_LE_32",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_TPOFF",
				Description: "",
			},
			constSet{
				Name:        "R_386_TLS_TPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_390_12",
				Description: "",
			},
			constSet{
				Name:        "R_390_16",
				Description: "",
			},
			constSet{
				Name:        "R_390_20",
				Description: "",
			},
			constSet{
				Name:        "R_390_32",
				Description: "",
			},
			constSet{
				Name:        "R_390_64",
				Description: "",
			},
			constSet{
				Name:        "R_390_8",
				Description: "",
			},
			constSet{
				Name:        "R_390_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_390_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOT12",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOT16",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOT20",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOT32",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOT64",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTENT",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTOFF",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTOFF16",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTOFF64",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPC",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPCDBL",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLT12",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLT16",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLT20",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLT32",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLT64",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLTENT",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLTOFF16",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLTOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_390_GOTPLTOFF64",
				Description: "",
			},
			constSet{
				Name:        "R_390_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_390_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_390_PC16",
				Description: "",
			},
			constSet{
				Name:        "R_390_PC16DBL",
				Description: "",
			},
			constSet{
				Name:        "R_390_PC32",
				Description: "",
			},
			constSet{
				Name:        "R_390_PC32DBL",
				Description: "",
			},
			constSet{
				Name:        "R_390_PC64",
				Description: "",
			},
			constSet{
				Name:        "R_390_PLT16DBL",
				Description: "",
			},
			constSet{
				Name:        "R_390_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_390_PLT32DBL",
				Description: "",
			},
			constSet{
				Name:        "R_390_PLT64",
				Description: "",
			},
			constSet{
				Name:        "R_390_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_DTPMOD",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_DTPOFF",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GD32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GD64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GDCALL",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GOTIE12",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GOTIE20",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GOTIE32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_GOTIE64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_IE32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_IE64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_IEENT",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LDCALL",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LDM32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LDM64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LDO32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LDO64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LE32",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LE64",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_LOAD",
				Description: "",
			},
			constSet{
				Name:        "R_390_TLS_TPOFF",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ABS16",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ABS32",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ABS64",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ADD_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ADR_GOT_PAGE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ADR_PREL_LO21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ADR_PREL_PG_HI21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_ADR_PREL_PG_HI21_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_CALL26",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_CONDBR19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_GOT_LD_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_JUMP26",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_JUMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LD64_GOTOFF_LO15",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LD64_GOTPAGE_LO15",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LD64_GOT_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LDST128_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LDST16_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LDST32_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LDST64_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LDST8_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_LD_PREL_LO19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_SABS_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_SABS_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_SABS_G2",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G1_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G2",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G2_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_MOVW_UABS_G3",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_NULL",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ABS16",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ABS32",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ADD_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ADR_GOT_PAGE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ADR_PREL_LO21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_ADR_PREL_PG_HI21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_CALL26",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_CONDBR19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_GOT_LD_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_JUMP26",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_JUMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LD32_GOT_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LDST128_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LDST16_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LDST32_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LDST64_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LDST8_ABS_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_LD_PREL_LO19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_MOVW_SABS_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_MOVW_UABS_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_MOVW_UABS_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_MOVW_UABS_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_PREL16",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_PREL32",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_ADD_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_ADR_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_ADR_PREL21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_LD32_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSDESC_LD_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSGD_ADD_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSGD_ADR_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_ADD_TPREL_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLSLE_MOVW_TPREL_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLS_DTPMOD",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLS_DTPREL",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TLS_TPREL",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_P32_TSTBR14",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_PREL16",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_PREL32",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_PREL64",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_ADD",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_ADD_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_ADR_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_ADR_PREL21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_LD64_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_LDR",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_LD_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_OFF_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSDESC_OFF_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSGD_ADD_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSGD_ADR_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSGD_ADR_PREL21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSGD_MOVW_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSGD_MOVW_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSIE_LD_GOTTPREL_PREL19",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSIE_MOVW_GOTTPREL_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLD_ADR_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLD_ADR_PREL21",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLD_LDST128_DTPREL_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_ADD_TPREL_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_ADD_TPREL_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_ADD_TPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_LDST128_TPREL_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_MOVW_TPREL_G0",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_MOVW_TPREL_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_MOVW_TPREL_G1",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_MOVW_TPREL_G1_NC",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLSLE_MOVW_TPREL_G2",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLS_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLS_DTPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TLS_TPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_AARCH64_TSTBR14",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_BRADDR",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GPDISP",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GPRELHIGH",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GPRELLOW",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_GPVALUE",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_HINT",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_IMMED_BR_HI32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_IMMED_GP_16",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_IMMED_GP_HI32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_IMMED_LO32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_IMMED_SCN_HI32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_LITERAL",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_LITUSE",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_OP_PRSHIFT",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_OP_PSUB",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_OP_PUSH",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_OP_STORE",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_REFLONG",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_REFQUAD",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_SREL16",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_SREL32",
				Description: "",
			},
			constSet{
				Name:        "R_ALPHA_SREL64",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ABS12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ABS16",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ABS32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ABS32_NOI",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ABS8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PCREL_15_8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PCREL_23_15",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PCREL_7_0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PC_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PC_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PC_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PC_G1_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_PC_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SBREL_19_12_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SBREL_27_20_CK",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SB_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SB_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SB_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SB_G1_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ALU_SB_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_AMP_VCALL9",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_BASE_ABS",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GNU_VTENTRY",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GNU_VTINHERIT",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOT32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOTOFF",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOTOFF12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOTPC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOTRELAX",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOT_ABS",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOT_BREL12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_GOT_PREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_JUMP24",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_JUMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_PC_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_PC_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_PC_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_SB_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_SB_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDC_SB_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_PC_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_PC_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_PC_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_SB_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_SB_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDRS_SB_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_PC_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_PC_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_SBREL_11_10_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_SB_G0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_SB_G1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_LDR_SB_G2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_ME_TOO",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVT_ABS",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVT_BREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVT_PREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVW_ABS_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVW_BREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVW_BREL_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_MOVW_PREL_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PC13",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PC24",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PLT32_ABS",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PREL31",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_10",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_11",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_13",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_14",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_15",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_3",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_4",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_5",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_6",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_7",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_PRIVATE_9",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RABS32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RBASE",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_REL32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_REL32_NOI",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RPC24",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RREL32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RSBREL32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_RXPC25",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_SBREL31",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_SBREL32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_SWI24",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TARGET1",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TARGET2",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ABS5",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ALU_ABS_G0_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ALU_ABS_G1_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ALU_ABS_G2_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ALU_ABS_G3",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_ALU_PREL_11_0",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_GOT_BREL12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_JUMP11",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_JUMP19",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_JUMP24",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_JUMP6",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_JUMP8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVT_ABS",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVT_BREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVT_PREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVW_ABS_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVW_BREL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVW_BREL_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_MOVW_PREL_NC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_PC12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_PC22",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_PC8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_RPC22",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_SWI8",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_TLS_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_TLS_DESCSEQ16",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_TLS_DESCSEQ32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_THM_XPC22",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_DESCSEQ",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_DTPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_GD32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_GOTDESC",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_IE12GP",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_IE32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_LDM32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_LDO12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_LDO32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_LE12",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_LE32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_TLS_TPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_V4BX",
				Description: "",
			},
			constSet{
				Name:        "R_ARM_XPC25",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_32_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_64",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_64_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ABS64_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ABS64_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ABS_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ABS_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD16",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD24",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD6",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD64",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD8",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ADD_ULEB128",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_ALIGN",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_B16",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_B21",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_B26",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_CFA",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_DELETE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GNU_VTENTRY",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GNU_VTINHERIT",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT64_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT64_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT64_PC_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT64_PC_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT_PC_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_GOT_PC_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_JUMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_MARK_LA",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_MARK_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_PCALA64_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_PCALA64_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_PCALA_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_PCALA_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_PCREL20_S2",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_RELAX",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_ADD",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_AND",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_ASSERT",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_IF_ELSE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_NOT",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_0_10_10_16_S2",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_0_5_10_16_S2",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_10_12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_10_16",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_10_16_S2",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_10_5",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_S_5_20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_U",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_POP_32_U_10_12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_ABSOLUTE",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_DUP",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_GPREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_PLT_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_TLS_GD",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_TLS_GOT",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_PUSH_TLS_TPREL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_SL",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_SR",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SOP_SUB",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB16",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB24",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB6",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB64",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB8",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_SUB_ULEB128",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_DTPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_DTPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_GD_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_GD_PC_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE64_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE64_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE64_PC_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE64_PC_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE_PC_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_IE_PC_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LD_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LD_PC_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LE64_HI12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LE64_LO20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LE_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_LE_LO12",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_TPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_LARCH_TLS_TPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_26",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_64",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_ADD_IMMEDIATE",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_CALL16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_CALL_HI16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_CALL_LO16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_DELETE",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT_DISP",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT_HI16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT_LO16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT_OFST",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GOT_PAGE",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_GPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_HI16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_HIGHER",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_HIGHEST",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_INSERT_A",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_INSERT_B",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_JALR",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_LITERAL",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_LO16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_PC16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_PC32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_PJUMP",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_REL16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_REL32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_RELGOT",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_SCN_DISP",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_SHIFT5",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_SHIFT6",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_SUB",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPREL_HI16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_DTPREL_LO16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_GD",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_GOTTPREL",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_LDM",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_TPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_TPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_TPREL_HI16",
				Description: "",
			},
			constSet{
				Name:        "R_MIPS_TLS_TPREL_LO16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR14",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR14_BRNTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR14_BRTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGH",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHER",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHER34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHERA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHERA34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHEST",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHEST34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHESTA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_HIGHESTA34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR24",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ADDR64_LOCAL",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_D28",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_D34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_D34_HA30",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_D34_HI30",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_D34_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGH",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGHA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGHER",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGHERA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGHEST",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_HIGHESTA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_DTPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_ENTRY",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GNU_VTENTRY",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GNU_VTINHERIT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_DTPREL16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_DTPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_DTPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_DTPREL16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_DTPREL_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSGD16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSGD16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSGD16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSGD16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSGD_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSLD16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSLD16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSLD16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSLD16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TLSLD_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TPREL16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TPREL16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_GOT_TPREL_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_JMP_IREL",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PCREL28",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PCREL_OPT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTCALL",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTCALL_NOTOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTGOT_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTREL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTREL64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTSEQ",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLTSEQ_NOTOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT_PCREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_PLT_PCREL34_NOTOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL14",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL14_BRNTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL14_BRTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16DX_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGH",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHER",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHER34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHERA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHERA34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHEST",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHEST34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHESTA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_HIGHESTA34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL24",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL24_NOTOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL24_P9NOTOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL30",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_REL64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_SECTOFF_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TLS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TLSGD",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TLSLD",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOC16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TOCSAVE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGH",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGHA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGHER",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGHERA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGHEST",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_HIGHESTA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL16_LO_DS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL34",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_TPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_UADDR16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_UADDR32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC64_UADDR64",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR14",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR14_BRNTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR14_BRTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR24",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_ADDR32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPREL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_DTPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_BIT_FLD",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_MRKREF",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_NADDR16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_NADDR16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_NADDR16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_NADDR16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_NADDR32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_RELSDA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_RELSEC16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_RELST_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_RELST_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_RELST_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_SDA21",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_SDA2I16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_SDA2REL",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_EMB_SDAI16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSGD16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSGD16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSGD16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSGD16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSLD16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSLD16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSLD16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TLSLD16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_GOT_TPREL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_LOCAL24PC",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLT16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLT16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLT16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLTREL24",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_PLTREL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_REL14",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_REL14_BRNTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_REL14_BRTAKEN",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_REL24",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_REL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_SDAREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_SECTOFF",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_SECTOFF_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_SECTOFF_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_SECTOFF_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TLS",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TPREL16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TPREL16_HA",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TPREL16_HI",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TPREL16_LO",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_TPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_UADDR16",
				Description: "",
			},
			constSet{
				Name:        "R_PPC_UADDR32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_32_PCREL",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_ADD16",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_ADD32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_ADD64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_ADD8",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_ALIGN",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_BRANCH",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_CALL_PLT",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_GNU_VTENTRY",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_GNU_VTINHERIT",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_GOT_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_GPREL_I",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_GPREL_S",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_JAL",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_JUMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_LO12_I",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_LO12_S",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_PCREL_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_PCREL_LO12_I",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_PCREL_LO12_S",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_RELAX",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_RVC_BRANCH",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_RVC_JUMP",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_RVC_LUI",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SET16",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SET32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SET6",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SET8",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SUB16",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SUB32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SUB6",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SUB64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_SUB8",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_DTPMOD32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_DTPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_DTPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_GD_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_GOT_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_TPREL32",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TLS_TPREL64",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_ADD",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_HI20",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_I",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_LO12_I",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_LO12_S",
				Description: "",
			},
			constSet{
				Name:        "R_RISCV_TPREL_S",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_11",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_13",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_16",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_32",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_5",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_6",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_64",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_7",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_8",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_DISP16",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_DISP32",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_DISP64",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_DISP8",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_GLOB_JMP",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_GOT10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_GOT13",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_GOT22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_H44",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_HH22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_HI22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_HIPLT22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_HIX22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_HM10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_L44",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_LM22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_LO10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_LOPLT10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_LOX10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_M44",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_OLO10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PC10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PC22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PCPLT10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PCPLT22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PCPLT32",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PC_HH22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PC_HM10",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PC_LM22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_PLT64",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_REGISTER",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_UA16",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_UA32",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_UA64",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_WDISP16",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_WDISP19",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_WDISP22",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_WDISP30",
				Description: "",
			},
			constSet{
				Name:        "R_SPARC_WPLT30",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_16",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_32S",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_8",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_COPY",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_DTPMOD64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_DTPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_DTPOFF64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GLOB_DAT",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOT32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOT64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTOFF64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPC32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPC32_TLSDESC",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPC64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPCREL",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPCREL64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPCRELX",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTPLT64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_GOTTPOFF",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_IRELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_JMP_SLOT",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_NONE",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PC16",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PC32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PC32_BND",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PC64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PC8",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PLT32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PLT32_BND",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_PLTOFF64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_RELATIVE",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_RELATIVE64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_REX_GOTPCRELX",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_SIZE32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_SIZE64",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TLSDESC",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TLSDESC_CALL",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TLSGD",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TLSLD",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TPOFF32",
				Description: "",
			},
			constSet{
				Name:        "R_X86_64_TPOFF64",
				Description: "",
			},
			constSet{
				Name:        "SHF_ALLOC",
				Description: "",
			},
			constSet{
				Name:        "SHF_COMPRESSED",
				Description: "",
			},
			constSet{
				Name:        "SHF_EXECINSTR",
				Description: "",
			},
			constSet{
				Name:        "SHF_GROUP",
				Description: "",
			},
			constSet{
				Name:        "SHF_INFO_LINK",
				Description: "",
			},
			constSet{
				Name:        "SHF_LINK_ORDER",
				Description: "",
			},
			constSet{
				Name:        "SHF_MASKOS",
				Description: "",
			},
			constSet{
				Name:        "SHF_MASKPROC",
				Description: "",
			},
			constSet{
				Name:        "SHF_MERGE",
				Description: "",
			},
			constSet{
				Name:        "SHF_OS_NONCONFORMING",
				Description: "",
			},
			constSet{
				Name:        "SHF_STRINGS",
				Description: "",
			},
			constSet{
				Name:        "SHF_TLS",
				Description: "",
			},
			constSet{
				Name:        "SHF_WRITE",
				Description: "",
			},
			constSet{
				Name:        "SHN_ABS",
				Description: "",
			},
			constSet{
				Name:        "SHN_COMMON",
				Description: "",
			},
			constSet{
				Name:        "SHN_HIOS",
				Description: "",
			},
			constSet{
				Name:        "SHN_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "SHN_HIRESERVE",
				Description: "",
			},
			constSet{
				Name:        "SHN_LOOS",
				Description: "",
			},
			constSet{
				Name:        "SHN_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "SHN_LORESERVE",
				Description: "",
			},
			constSet{
				Name:        "SHN_UNDEF",
				Description: "",
			},
			constSet{
				Name:        "SHN_XINDEX",
				Description: "",
			},
			constSet{
				Name:        "SHT_DYNAMIC",
				Description: "",
			},
			constSet{
				Name:        "SHT_DYNSYM",
				Description: "",
			},
			constSet{
				Name:        "SHT_FINI_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_ATTRIBUTES",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_HASH",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_LIBLIST",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_VERDEF",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_VERNEED",
				Description: "",
			},
			constSet{
				Name:        "SHT_GNU_VERSYM",
				Description: "",
			},
			constSet{
				Name:        "SHT_GROUP",
				Description: "",
			},
			constSet{
				Name:        "SHT_HASH",
				Description: "",
			},
			constSet{
				Name:        "SHT_HIOS",
				Description: "",
			},
			constSet{
				Name:        "SHT_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "SHT_HIUSER",
				Description: "",
			},
			constSet{
				Name:        "SHT_INIT_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "SHT_LOOS",
				Description: "",
			},
			constSet{
				Name:        "SHT_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "SHT_LOUSER",
				Description: "",
			},
			constSet{
				Name:        "SHT_MIPS_ABIFLAGS",
				Description: "",
			},
			constSet{
				Name:        "SHT_NOBITS",
				Description: "",
			},
			constSet{
				Name:        "SHT_NOTE",
				Description: "",
			},
			constSet{
				Name:        "SHT_NULL",
				Description: "",
			},
			constSet{
				Name:        "SHT_PREINIT_ARRAY",
				Description: "",
			},
			constSet{
				Name:        "SHT_PROGBITS",
				Description: "",
			},
			constSet{
				Name:        "SHT_REL",
				Description: "",
			},
			constSet{
				Name:        "SHT_RELA",
				Description: "",
			},
			constSet{
				Name:        "SHT_RISCV_ATTRIBUTES",
				Description: "",
			},
			constSet{
				Name:        "SHT_SHLIB",
				Description: "",
			},
			constSet{
				Name:        "SHT_STRTAB",
				Description: "",
			},
			constSet{
				Name:        "SHT_SYMTAB",
				Description: "",
			},
			constSet{
				Name:        "SHT_SYMTAB_SHNDX",
				Description: "",
			},
			constSet{
				Name:        "STB_GLOBAL",
				Description: "",
			},
			constSet{
				Name:        "STB_HIOS",
				Description: "",
			},
			constSet{
				Name:        "STB_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "STB_LOCAL",
				Description: "",
			},
			constSet{
				Name:        "STB_LOOS",
				Description: "",
			},
			constSet{
				Name:        "STB_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "STB_WEAK",
				Description: "",
			},
			constSet{
				Name:        "STT_COMMON",
				Description: "",
			},
			constSet{
				Name:        "STT_FILE",
				Description: "",
			},
			constSet{
				Name:        "STT_FUNC",
				Description: "",
			},
			constSet{
				Name:        "STT_GNU_IFUNC",
				Description: "",
			},
			constSet{
				Name:        "STT_HIOS",
				Description: "",
			},
			constSet{
				Name:        "STT_HIPROC",
				Description: "",
			},
			constSet{
				Name:        "STT_LOOS",
				Description: "",
			},
			constSet{
				Name:        "STT_LOPROC",
				Description: "",
			},
			constSet{
				Name:        "STT_NOTYPE",
				Description: "",
			},
			constSet{
				Name:        "STT_OBJECT",
				Description: "",
			},
			constSet{
				Name:        "STT_RELC",
				Description: " Non-standard symbol types. ",
			},
			constSet{
				Name:        "STT_SECTION",
				Description: "",
			},
			constSet{
				Name:        "STT_SRELC",
				Description: "",
			},
			constSet{
				Name:        "STT_TLS",
				Description: "",
			},
			constSet{
				Name:        "STV_DEFAULT",
				Description: "",
			},
			constSet{
				Name:        "STV_HIDDEN",
				Description: "",
			},
			constSet{
				Name:        "STV_INTERNAL",
				Description: "",
			},
			constSet{
				Name:        "STV_PROTECTED",
				Description: "",
			},
			constSet{
				Name:        "Sym32Size",
				Description: "",
			},
			constSet{
				Name:        "Sym64Size",
				Description: "",
			},
			constSet{
				Name:        "VER_FLG_BASE",
				Description: "",
			},
			constSet{
				Name:        "VER_FLG_INFO",
				Description: "",
			},
			constSet{
				Name:        "VER_FLG_WEAK",
				Description: "",
			},
		},
		"plan9obj": []constSet{
			constSet{
				Name:        "Magic386",
				Description: "",
			},
			constSet{
				Name:        "Magic64",
				Description: "",
			},
			constSet{
				Name:        "MagicAMD64",
				Description: "",
			},
			constSet{
				Name:        "MagicARM",
				Description: "",
			},
		},
		"mime": []constSet{
			constSet{
				Name:        "BEncoding",
				Description: "BEncoding represents Base64 encoding scheme as defined by RFC 2045. ",
			},
			constSet{
				Name:        "QEncoding",
				Description: "QEncoding represents the Q-encoding scheme as defined by RFC 2047. ",
			},
		},
		"parse": []constSet{
			constSet{
				Name:        "NodeAction",
				Description: "",
			},
			constSet{
				Name:        "NodeBool",
				Description: "",
			},
			constSet{
				Name:        "NodeBreak",
				Description: "",
			},
			constSet{
				Name:        "NodeChain",
				Description: "",
			},
			constSet{
				Name:        "NodeCommand",
				Description: "",
			},
			constSet{
				Name:        "NodeComment",
				Description: "",
			},
			constSet{
				Name:        "NodeContinue",
				Description: "",
			},
			constSet{
				Name:        "NodeDot",
				Description: "",
			},
			constSet{
				Name:        "NodeField",
				Description: "",
			},
			constSet{
				Name:        "NodeIdentifier",
				Description: "",
			},
			constSet{
				Name:        "NodeIf",
				Description: "",
			},
			constSet{
				Name:        "NodeList",
				Description: "",
			},
			constSet{
				Name:        "NodeNil",
				Description: "",
			},
			constSet{
				Name:        "NodeNumber",
				Description: "",
			},
			constSet{
				Name:        "NodePipe",
				Description: "",
			},
			constSet{
				Name:        "NodeRange",
				Description: "",
			},
			constSet{
				Name:        "NodeString",
				Description: "",
			},
			constSet{
				Name:        "NodeTemplate",
				Description: "",
			},
			constSet{
				Name:        "NodeText",
				Description: "",
			},
			constSet{
				Name:        "NodeVariable",
				Description: "",
			},
			constSet{
				Name:        "NodeWith",
				Description: "",
			},
			constSet{
				Name:        "ParseComments",
				Description: "",
			},
			constSet{
				Name:        "SkipFuncCheck",
				Description: "",
			},
		},
		"bytealg": []constSet{
			constSet{
				Name:        "MaxBruteForce",
				Description: "Empirical data shows that using Index can get better performance when len(s) <= 16. ",
			},
			constSet{
				Name:        "PrimeRK",
				Description: "PrimeRK is the prime base used in Rabin-Karp algorithm. ",
			},
		},
		"filepath": []constSet{
			constSet{
				Name:        "ListSeparator",
				Description: "",
			},
			constSet{
				Name:        "Separator",
				Description: "",
			},
		},
		"xcoff": []constSet{
			constSet{
				Name:        "AIAFMAG",
				Description: "",
			},
			constSet{
				Name:        "AIAMAG",
				Description: "",
			},
			constSet{
				Name:        "AIAMAGBIG",
				Description: "",
			},
			constSet{
				Name:        "AR_HSZ_BIG",
				Description: "",
			},
			constSet{
				Name:        "C_BCOMM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_BINCL",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_BLOCK",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_BSTAT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_DECL",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_DWARF",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_ECOML",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_ECOMM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_EINCL",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_ENTRY",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_ESTAT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_EXT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_FCN",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_FILE",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_FUN",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_GSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_GTLS",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_HIDEXT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_LSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_NULL",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_PSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_RPSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_RSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_STAT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_STSYM",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_STTLS",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "C_WEAKEXT",
				Description: "Storage Class. ",
			},
			constSet{
				Name:        "FILHSZ_32",
				Description: "",
			},
			constSet{
				Name:        "FILHSZ_64",
				Description: "",
			},
			constSet{
				Name:        "FL_HSZ_BIG",
				Description: "Sizeof ",
			},
			constSet{
				Name:        "F_DSA",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_DYNLOAD",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_EXEC",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_FDPR_OPTI",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_FDPR_PROF",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_LNNO",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_LOADONLY",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_RELFLG",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_SHROBJ",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "F_VARPG",
				Description: "Flags that describe the type of the object file. ",
			},
			constSet{
				Name:        "LDHDRSZ_32",
				Description: "",
			},
			constSet{
				Name:        "LDHDRSZ_64",
				Description: "",
			},
			constSet{
				Name:        "N_ABS",
				Description: "",
			},
			constSet{
				Name:        "N_DEBUG",
				Description: "Nscnum ",
			},
			constSet{
				Name:        "N_UNDEF",
				Description: "",
			},
			constSet{
				Name:        "R_BA",
				Description: "",
			},
			constSet{
				Name:        "R_BR",
				Description: "",
			},
			constSet{
				Name:        "R_GL",
				Description: "",
			},
			constSet{
				Name:        "R_NEG",
				Description: "",
			},
			constSet{
				Name:        "R_POS",
				Description: "",
			},
			constSet{
				Name:        "R_RBA",
				Description: "",
			},
			constSet{
				Name:        "R_RBR",
				Description: "",
			},
			constSet{
				Name:        "R_REF",
				Description: "",
			},
			constSet{
				Name:        "R_REL",
				Description: "",
			},
			constSet{
				Name:        "R_RL",
				Description: "",
			},
			constSet{
				Name:        "R_RLA",
				Description: "",
			},
			constSet{
				Name:        "R_TCL",
				Description: "",
			},
			constSet{
				Name:        "R_TLS",
				Description: "",
			},
			constSet{
				Name:        "R_TLSM",
				Description: "",
			},
			constSet{
				Name:        "R_TLSML",
				Description: "",
			},
			constSet{
				Name:        "R_TLS_IE",
				Description: "",
			},
			constSet{
				Name:        "R_TLS_LD",
				Description: "",
			},
			constSet{
				Name:        "R_TLS_LE",
				Description: "",
			},
			constSet{
				Name:        "R_TOC",
				Description: "",
			},
			constSet{
				Name:        "R_TOCL",
				Description: "",
			},
			constSet{
				Name:        "R_TOCU",
				Description: "",
			},
			constSet{
				Name:        "R_TRL",
				Description: "",
			},
			constSet{
				Name:        "R_TRLA",
				Description: "",
			},
			constSet{
				Name:        "SAIAMAG",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWABREV",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWARNGE",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWFRAME",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWINFO",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWLINE",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWLOC",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWMAC",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWPBNMS",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWPBTYP",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWRNGES",
				Description: "",
			},
			constSet{
				Name:        "SSUBTYP_DWSTR",
				Description: "",
			},
			constSet{
				Name:        "STYP_BSS",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_DATA",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_DEBUG",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_DWARF",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_EXCEPT",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_INFO",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_LOADER",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_OVRFLO",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_TBSS",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_TDATA",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_TEXT",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "STYP_TYPCHK",
				Description: "Flags defining the section type. ",
			},
			constSet{
				Name:        "SYMESZ",
				Description: "",
			},
			constSet{
				Name:        "SYM_TYPE_FUNC",
				Description: "",
			},
			constSet{
				Name:        "SYM_V_EXPORTED",
				Description: "",
			},
			constSet{
				Name:        "SYM_V_HIDDEN",
				Description: "",
			},
			constSet{
				Name:        "SYM_V_INTERNAL",
				Description: "Ntype ",
			},
			constSet{
				Name:        "SYM_V_PROTECTED",
				Description: "",
			},
			constSet{
				Name:        "U64_TOCMAGIC",
				Description: "",
			},
			constSet{
				Name:        "U802TOCMAGIC",
				Description: "",
			},
			constSet{
				Name:        "XFT_CD",
				Description: "Defines for File auxiliary definitions: x_ftype field of x_file ",
			},
			constSet{
				Name:        "XFT_CT",
				Description: "Defines for File auxiliary definitions: x_ftype field of x_file ",
			},
			constSet{
				Name:        "XFT_CV",
				Description: "Defines for File auxiliary definitions: x_ftype field of x_file ",
			},
			constSet{
				Name:        "XFT_FN",
				Description: "Defines for File auxiliary definitions: x_ftype field of x_file ",
			},
			constSet{
				Name:        "XMC_BS",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_DB",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_DS",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_GL",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_PR",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_RO",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_RW",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_SV",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_SV3264",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_SV64",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_TC",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_TC0",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_TD",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_TE",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_TL",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_UA",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_UC",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_UL",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XMC_XO",
				Description: "Storage-mapping class. ",
			},
			constSet{
				Name:        "XTY_CM",
				Description: "Symbol type field. ",
			},
			constSet{
				Name:        "XTY_ER",
				Description: "Symbol type field. ",
			},
			constSet{
				Name:        "XTY_LD",
				Description: "Symbol type field. ",
			},
			constSet{
				Name:        "XTY_SD",
				Description: "Symbol type field. ",
			},
		},
		"http": []constSet{
			constSet{
				Name:        "DefaultMaxHeaderBytes",
				Description: "DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting [Server.MaxHeaderBytes]. ",
			},
			constSet{
				Name:        "DefaultMaxIdleConnsPerHost",
				Description: "DefaultMaxIdleConnsPerHost is the default value of [Transport]'s MaxIdleConnsPerHost. ",
			},
			constSet{
				Name:        "MethodConnect",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodDelete",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodGet",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodHead",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodOptions",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodPatch",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodPost",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodPut",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "MethodTrace",
				Description: "Common HTTP methods. Unless otherwise noted, these are defined in RFC 7231 section 4.3. ",
			},
			constSet{
				Name:        "SameSiteDefaultMode",
				Description: "",
			},
			constSet{
				Name:        "SameSiteLaxMode",
				Description: "",
			},
			constSet{
				Name:        "SameSiteNoneMode",
				Description: "",
			},
			constSet{
				Name:        "SameSiteStrictMode",
				Description: "",
			},
			constSet{
				Name:        "StateActive",
				Description: "StateActive represents a connection that has read 1 or more bytes of a request. The Server.ConnState hook for StateActive fires before the request has entered a handler and doesn't fire again until the request has been handled. After the request is handled, the state transitions to StateClosed, StateHijacked, or StateIdle. For HTTP/2, StateActive fires on the transition from zero to one active request, and only transitions away once all active requests are complete. That means that ConnState cannot be used to do per-request work; ConnState only notes the overall state of the connection. ",
			},
			constSet{
				Name:        "StateClosed",
				Description: "StateClosed represents a closed connection. This is a terminal state. Hijacked connections do not transition to StateClosed. ",
			},
			constSet{
				Name:        "StateHijacked",
				Description: "StateHijacked represents a hijacked connection. This is a terminal state. It does not transition to StateClosed. ",
			},
			constSet{
				Name:        "StateIdle",
				Description: "StateIdle represents a connection that has finished handling a request and is in the keep-alive state, waiting for a new request. Connections transition from StateIdle to either StateActive or StateClosed. ",
			},
			constSet{
				Name:        "StateNew",
				Description: "StateNew represents a new connection that is expected to send a request immediately. Connections begin at this state and then transition to either StateActive or StateClosed. ",
			},
			constSet{
				Name:        "StatusAccepted",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusAlreadyReported",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusBadGateway",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusBadRequest",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusConflict",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusContinue",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusCreated",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusEarlyHints",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusExpectationFailed",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusFailedDependency",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusForbidden",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusFound",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusGatewayTimeout",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusGone",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusHTTPVersionNotSupported",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusIMUsed",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusInsufficientStorage",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusInternalServerError",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusLengthRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusLocked",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusLoopDetected",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusMethodNotAllowed",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusMisdirectedRequest",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusMovedPermanently",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusMultiStatus",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusMultipleChoices",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNetworkAuthenticationRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNoContent",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNonAuthoritativeInfo",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNotAcceptable",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNotExtended",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNotFound",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNotImplemented",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusNotModified",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusOK",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusPartialContent",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusPaymentRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusPermanentRedirect",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusPreconditionFailed",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusPreconditionRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusProcessing",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusProxyAuthRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusRequestEntityTooLarge",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusRequestHeaderFieldsTooLarge",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusRequestTimeout",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusRequestURITooLong",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusRequestedRangeNotSatisfiable",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusResetContent",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusSeeOther",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusServiceUnavailable",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusSwitchingProtocols",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusTeapot",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusTemporaryRedirect",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusTooEarly",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusTooManyRequests",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUnauthorized",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUnavailableForLegalReasons",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUnprocessableEntity",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUnsupportedMediaType",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUpgradeRequired",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusUseProxy",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "StatusVariantAlsoNegotiates",
				Description: "HTTP status codes as registered with IANA. See: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ",
			},
			constSet{
				Name:        "TimeFormat",
				Description: "TimeFormat is the time format to use when generating times in HTTP headers. It is like [time.RFC1123] but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format. For parsing this time format, see [ParseTime]. ",
			},
			constSet{
				Name:        "TrailerPrefix",
				Description: "TrailerPrefix is a magic prefix for [ResponseWriter.Header] map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers. This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred: https://pkg.go.dev/net/http#ResponseWriter https://pkg.go.dev/net/http#example-ResponseWriter-Trailers ",
			},
		},
		"draw": []constSet{
			constSet{
				Name:        "Over",
				Description: "Over specifies ``(src in mask) over dst''. ",
			},
			constSet{
				Name:        "Src",
				Description: "Src specifies ``src in mask''. ",
			},
		},
		"syslog": []constSet{
			constSet{
				Name:        "LOG_ALERT",
				Description: "",
			},
			constSet{
				Name:        "LOG_AUTH",
				Description: "",
			},
			constSet{
				Name:        "LOG_AUTHPRIV",
				Description: "",
			},
			constSet{
				Name:        "LOG_CRIT",
				Description: "",
			},
			constSet{
				Name:        "LOG_CRON",
				Description: "",
			},
			constSet{
				Name:        "LOG_DAEMON",
				Description: "",
			},
			constSet{
				Name:        "LOG_DEBUG",
				Description: "",
			},
			constSet{
				Name:        "LOG_EMERG",
				Description: "From /usr/include/sys/syslog.h. These are the same on Linux, BSD, and OS X. ",
			},
			constSet{
				Name:        "LOG_ERR",
				Description: "",
			},
			constSet{
				Name:        "LOG_FTP",
				Description: "",
			},
			constSet{
				Name:        "LOG_INFO",
				Description: "",
			},
			constSet{
				Name:        "LOG_KERN",
				Description: "From /usr/include/sys/syslog.h. These are the same up to LOG_FTP on Linux, BSD, and OS X. ",
			},
			constSet{
				Name:        "LOG_LOCAL0",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL1",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL2",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL3",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL4",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL5",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL6",
				Description: "",
			},
			constSet{
				Name:        "LOG_LOCAL7",
				Description: "",
			},
			constSet{
				Name:        "LOG_LPR",
				Description: "",
			},
			constSet{
				Name:        "LOG_MAIL",
				Description: "",
			},
			constSet{
				Name:        "LOG_NEWS",
				Description: "",
			},
			constSet{
				Name:        "LOG_NOTICE",
				Description: "",
			},
			constSet{
				Name:        "LOG_SYSLOG",
				Description: "",
			},
			constSet{
				Name:        "LOG_USER",
				Description: "",
			},
			constSet{
				Name:        "LOG_UUCP",
				Description: "",
			},
			constSet{
				Name:        "LOG_WARNING",
				Description: "",
			},
		},
		"goos": []constSet{
			constSet{
				Name:        "GOOS",
				Description: "",
			},
			constSet{
				Name:        "IsAix",
				Description: "",
			},
			constSet{
				Name:        "IsAndroid",
				Description: "",
			},
			constSet{
				Name:        "IsDarwin",
				Description: "",
			},
			constSet{
				Name:        "IsDragonfly",
				Description: "",
			},
			constSet{
				Name:        "IsFreebsd",
				Description: "",
			},
			constSet{
				Name:        "IsHurd",
				Description: "",
			},
			constSet{
				Name:        "IsIllumos",
				Description: "",
			},
			constSet{
				Name:        "IsIos",
				Description: "",
			},
			constSet{
				Name:        "IsJs",
				Description: "",
			},
			constSet{
				Name:        "IsLinux",
				Description: "",
			},
			constSet{
				Name:        "IsNacl",
				Description: "",
			},
			constSet{
				Name:        "IsNetbsd",
				Description: "",
			},
			constSet{
				Name:        "IsOpenbsd",
				Description: "",
			},
			constSet{
				Name:        "IsPlan9",
				Description: "",
			},
			constSet{
				Name:        "IsSolaris",
				Description: "",
			},
			constSet{
				Name:        "IsUnix",
				Description: "",
			},
			constSet{
				Name:        "IsWasip1",
				Description: "",
			},
			constSet{
				Name:        "IsWindows",
				Description: "",
			},
			constSet{
				Name:        "IsZos",
				Description: "",
			},
		},
		"race": []constSet{
			constSet{
				Name:        "Enabled",
				Description: "",
			},
		},
		"filepathlite": []constSet{
			constSet{
				Name:        "ListSeparator",
				Description: "",
			},
			constSet{
				Name:        "Separator",
				Description: "",
			},
		},
		"os": []constSet{
			constSet{
				Name:        "DevNull",
				Description: "DevNull is the name of the operating system's ânull device.â On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\". ",
			},
			constSet{
				Name:        "ModeAppend",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeCharDevice",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeDevice",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeDir",
				Description: "The single letters are the abbreviations used by the String method's formatting. ",
			},
			constSet{
				Name:        "ModeExclusive",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeIrregular",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeNamedPipe",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModePerm",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSetgid",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSetuid",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSocket",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSticky",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeSymlink",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeTemporary",
				Description: "The defined file mode bits are the most significant bits of the [FileMode]. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. ",
			},
			constSet{
				Name:        "ModeType",
				Description: "Mask for the type bits. For regular files, none will be set. ",
			},
			constSet{
				Name:        "O_APPEND",
				Description: "The remaining values may be or'ed in to control behavior. ",
			},
			constSet{
				Name:        "O_CREATE",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "O_EXCL",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "O_RDONLY",
				Description: "Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified. ",
			},
			constSet{
				Name:        "O_RDWR",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "O_SYNC",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "O_TRUNC",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "O_WRONLY",
				Description: "Flags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. ",
			},
			constSet{
				Name:        "PathListSeparator",
				Description: "",
			},
			constSet{
				Name:        "PathSeparator",
				Description: "",
			},
			constSet{
				Name:        "SEEK_CUR",
				Description: "Seek whence values. Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. ",
			},
			constSet{
				Name:        "SEEK_END",
				Description: "Seek whence values. Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. ",
			},
			constSet{
				Name:        "SEEK_SET",
				Description: "Seek whence values. Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. ",
			},
		},
		"big": []constSet{
			constSet{
				Name:        "Above",
				Description: "Constants describing the [Accuracy] of a [Float]. ",
			},
			constSet{
				Name:        "AwayFromZero",
				Description: "These constants define supported rounding modes. ",
			},
			constSet{
				Name:        "Below",
				Description: "Constants describing the [Accuracy] of a [Float]. ",
			},
			constSet{
				Name:        "Exact",
				Description: "Constants describing the [Accuracy] of a [Float]. ",
			},
			constSet{
				Name:        "MaxBase",
				Description: "MaxBase is the largest number base accepted for string conversions. ",
			},
			constSet{
				Name:        "MaxExp",
				Description: "Exponent and precision limits. ",
			},
			constSet{
				Name:        "MaxPrec",
				Description: "Exponent and precision limits. ",
			},
			constSet{
				Name:        "MinExp",
				Description: "Exponent and precision limits. ",
			},
			constSet{
				Name:        "ToNearestAway",
				Description: "These constants define supported rounding modes. ",
			},
			constSet{
				Name:        "ToNearestEven",
				Description: "These constants define supported rounding modes. ",
			},
			constSet{
				Name:        "ToNegativeInf",
				Description: "These constants define supported rounding modes. ",
			},
			constSet{
				Name:        "ToPositiveInf",
				Description: "These constants define supported rounding modes. ",
			},
			constSet{
				Name:        "ToZero",
				Description: "These constants define supported rounding modes. ",
			},
		},
		"scanner": []constSet{
			constSet{
				Name:        "ScanComments",
				Description: "",
			},
			constSet{
				Name:        "Char",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "Comment",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "EOF",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "Float",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "GoTokens",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "GoWhitespace",
				Description: "GoWhitespace is the default value for the [Scanner]'s Whitespace field. Its value selects Go's white space characters. ",
			},
			constSet{
				Name:        "Ident",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "Int",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "RawString",
				Description: "The result of Scan is one of these tokens or a Unicode character. ",
			},
			constSet{
				Name:        "ScanChars",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanComments",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanFloats",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanIdents",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanInts",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanRawStrings",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "ScanStrings",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
			constSet{
				Name:        "SkipComments",
				Description: "Predefined mode bits to control recognition of tokens. For instance, to configure a [Scanner] such that it only recognizes (Go) identifiers, integers, and skips comments, set the Scanner's Mode field to: ScanIdents | ScanInts | ScanComments | SkipComments With the exceptions of comments, which are skipped if SkipComments is set, unrecognized tokens are not ignored. Instead, the scanner simply returns the respective individual characters (or possibly sub-tokens). For instance, if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as the token sequence '\"' [Ident] '\"'. Use GoTokens to configure the Scanner such that it accepts all Go literal tokens including Go identifiers. Comments will be skipped. ",
			},
		},
		"doc": []constSet{
			constSet{
				Name:        "AllDecls",
				Description: "AllDecls says to extract documentation for all package-level declarations, not just exported ones. ",
			},
			constSet{
				Name:        "AllMethods",
				Description: "AllMethods says to show all embedded methods, not just the ones of invisible (unexported) anonymous fields. ",
			},
			constSet{
				Name:        "PreserveAST",
				Description: "PreserveAST says to leave the AST unmodified. Originally, pieces of the AST such as function bodies were nil-ed out to save memory in godoc, but not all programs want that behavior. ",
			},
		},
		"crc64": []constSet{
			constSet{
				Name:        "ECMA",
				Description: "The ECMA polynomial, defined in ECMA 182. ",
			},
			constSet{
				Name:        "ISO",
				Description: "The ISO polynomial, defined in ISO 3309 and used in HDLC. ",
			},
			constSet{
				Name:        "Size",
				Description: "The size of a CRC-64 checksum in bytes. ",
			},
		},
		"zip": []constSet{
			constSet{
				Name:        "Deflate",
				Description: "Compression methods. ",
			},
			constSet{
				Name:        "Store",
				Description: "Compression methods. ",
			},
		},
		"dsa": []constSet{
			constSet{
				Name:        "L1024N160",
				Description: "",
			},
			constSet{
				Name:        "L2048N224",
				Description: "",
			},
			constSet{
				Name:        "L2048N256",
				Description: "",
			},
			constSet{
				Name:        "L3072N256",
				Description: "",
			},
		},
		"ed25519": []constSet{
			constSet{
				Name:        "PrivateKeySize",
				Description: "PrivateKeySize is the size, in bytes, of private keys as used in this package. ",
			},
			constSet{
				Name:        "PublicKeySize",
				Description: "PublicKeySize is the size, in bytes, of public keys as used in this package. ",
			},
			constSet{
				Name:        "SeedSize",
				Description: "SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032. ",
			},
			constSet{
				Name:        "SignatureSize",
				Description: "SignatureSize is the size, in bytes, of signatures generated and verified by this package. ",
			},
		},
		"base64": []constSet{
			constSet{
				Name:        "NoPadding",
				Description: "",
			},
			constSet{
				Name:        "StdPadding",
				Description: "",
			},
		},
		"mlkem": []constSet{
			constSet{
				Name:        "CiphertextSize1024",
				Description: "ML-KEM-1024 parameters. ",
			},
			constSet{
				Name:        "CiphertextSize768",
				Description: "ML-KEM-768 parameters. ",
			},
			constSet{
				Name:        "EncapsulationKeySize1024",
				Description: "ML-KEM-1024 parameters. ",
			},
			constSet{
				Name:        "EncapsulationKeySize768",
				Description: "ML-KEM-768 parameters. ",
			},
			constSet{
				Name:        "SeedSize",
				Description: "",
			},
			constSet{
				Name:        "SharedKeySize",
				Description: "",
			},
			constSet{
				Name:        "CiphertextSize1024",
				Description: "CiphertextSize1024 is the size of a ciphertext produced by ML-KEM-1024. ",
			},
			constSet{
				Name:        "CiphertextSize768",
				Description: "CiphertextSize768 is the size of a ciphertext produced by ML-KEM-768. ",
			},
			constSet{
				Name:        "EncapsulationKeySize1024",
				Description: "EncapsulationKeySize1024 is the size of an ML-KEM-1024 encapsulation key. ",
			},
			constSet{
				Name:        "EncapsulationKeySize768",
				Description: "EncapsulationKeySize768 is the size of an ML-KEM-768 encapsulation key. ",
			},
			constSet{
				Name:        "SeedSize",
				Description: "SeedSize is the size of a seed used to generate a decapsulation key. ",
			},
			constSet{
				Name:        "SharedKeySize",
				Description: "SharedKeySize is the size of a shared key produced by ML-KEM. ",
			},
		},
		"constant": []constSet{
			constSet{
				Name:        "Bool",
				Description: "non-numeric values ",
			},
			constSet{
				Name:        "Complex",
				Description: "",
			},
			constSet{
				Name:        "Float",
				Description: "",
			},
			constSet{
				Name:        "Int",
				Description: "numeric values ",
			},
			constSet{
				Name:        "Unknown",
				Description: "unknown values ",
			},
		},
		"metrics": []constSet{
			constSet{
				Name:        "KindBad",
				Description: "KindBad indicates that the Value has no type and should not be used. ",
			},
			constSet{
				Name:        "KindFloat64",
				Description: "KindFloat64 indicates that the type of the Value is a float64. ",
			},
			constSet{
				Name:        "KindFloat64Histogram",
				Description: "KindFloat64Histogram indicates that the type of the Value is a *Float64Histogram. ",
			},
			constSet{
				Name:        "KindUint64",
				Description: "KindUint64 indicates that the type of the Value is a uint64. ",
			},
		},
		"abi": []constSet{
			constSet{
				Name:        "ArgsSizeUnknown",
				Description: "ArgsSizeUnknown is set in Func.argsize to mark all functions whose argument size is unknown (C vararg functions, and assembly code without an explicit specification). This value is generated by the compiler, assembler, or linker. ",
			},
			constSet{
				Name:        "Array",
				Description: "",
			},
			constSet{
				Name:        "Bool",
				Description: "",
			},
			constSet{
				Name:        "BothDir",
				Description: "",
			},
			constSet{
				Name:        "Chan",
				Description: "",
			},
			constSet{
				Name:        "Complex128",
				Description: "",
			},
			constSet{
				Name:        "Complex64",
				Description: "",
			},
			constSet{
				Name:        "EffectiveFloatRegSize",
				Description: "",
			},
			constSet{
				Name:        "FUNCDATA_ArgInfo",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_ArgLiveInfo",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_ArgsPointerMaps",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_InlTree",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_LocalsPointerMaps",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_OpenCodedDeferInfo",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_StackObjects",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "FUNCDATA_WrapInfo",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "Float32",
				Description: "",
			},
			constSet{
				Name:        "Float64",
				Description: "",
			},
			constSet{
				Name:        "FloatArgRegs",
				Description: "F0 - F15. ",
			},
			constSet{
				Name:        "Func",
				Description: "",
			},
			constSet{
				Name:        "FuncFlagAsm",
				Description: "FuncFlagAsm indicates that a function was implemented in assembly. ",
			},
			constSet{
				Name:        "FuncFlagSPWrite",
				Description: "FuncFlagSPWrite indicates a function that writes an arbitrary value to SP (any write other than adding or subtracting a constant amount). The traceback routines cannot encode such changes into the pcsp tables, so the function traceback cannot safely unwind past SPWrite functions. Stopping at an SPWrite function is considered to be an incomplete unwinding of the stack. In certain contexts (in particular garbage collector stack scans) that is a fatal error. ",
			},
			constSet{
				Name:        "FuncFlagTopFrame",
				Description: "FuncFlagTopFrame indicates a function that appears at the top of its stack. The traceback routine stop at such a function and consider that a successful, complete traversal of the stack. Examples of TopFrame functions include goexit, which appears at the top of a user goroutine stack, and mstart, which appears at the top of a system goroutine stack. ",
			},
			constSet{
				Name:        "FuncIDNormal",
				Description: "",
			},
			constSet{
				Name:        "FuncIDWrapper",
				Description: "",
			},
			constSet{
				Name:        "FuncID_abort",
				Description: "",
			},
			constSet{
				Name:        "FuncID_asmcgocall",
				Description: "",
			},
			constSet{
				Name:        "FuncID_asyncPreempt",
				Description: "",
			},
			constSet{
				Name:        "FuncID_cgocallback",
				Description: "",
			},
			constSet{
				Name:        "FuncID_corostart",
				Description: "",
			},
			constSet{
				Name:        "FuncID_debugCallV2",
				Description: "",
			},
			constSet{
				Name:        "FuncID_gcBgMarkWorker",
				Description: "",
			},
			constSet{
				Name:        "FuncID_goexit",
				Description: "",
			},
			constSet{
				Name:        "FuncID_gogo",
				Description: "",
			},
			constSet{
				Name:        "FuncID_gopanic",
				Description: "",
			},
			constSet{
				Name:        "FuncID_handleAsyncEvent",
				Description: "",
			},
			constSet{
				Name:        "FuncID_mcall",
				Description: "",
			},
			constSet{
				Name:        "FuncID_morestack",
				Description: "",
			},
			constSet{
				Name:        "FuncID_mstart",
				Description: "",
			},
			constSet{
				Name:        "FuncID_panicwrap",
				Description: "",
			},
			constSet{
				Name:        "FuncID_rt0_go",
				Description: "",
			},
			constSet{
				Name:        "FuncID_runCleanups",
				Description: "",
			},
			constSet{
				Name:        "FuncID_runFinalizers",
				Description: "",
			},
			constSet{
				Name:        "FuncID_runtime_main",
				Description: "",
			},
			constSet{
				Name:        "FuncID_sigpanic",
				Description: "",
			},
			constSet{
				Name:        "FuncID_systemstack",
				Description: "",
			},
			constSet{
				Name:        "FuncID_systemstack_switch",
				Description: "",
			},
			constSet{
				Name:        "FuncTabBucketSize",
				Description: "",
			},
			constSet{
				Name:        "Int",
				Description: "",
			},
			constSet{
				Name:        "Int16",
				Description: "",
			},
			constSet{
				Name:        "Int32",
				Description: "",
			},
			constSet{
				Name:        "Int64",
				Description: "",
			},
			constSet{
				Name:        "Int8",
				Description: "",
			},
			constSet{
				Name:        "IntArgRegs",
				Description: "R0 - R15. ",
			},
			constSet{
				Name:        "Interface",
				Description: "",
			},
			constSet{
				Name:        "Invalid",
				Description: "",
			},
			constSet{
				Name:        "InvalidDir",
				Description: "",
			},
			constSet{
				Name:        "KindDirectIface",
				Description: "TODO (khr, drchase) why aren't these in TFlag? Investigate, fix if possible. ",
			},
			constSet{
				Name:        "KindMask",
				Description: "",
			},
			constSet{
				Name:        "MINFUNC",
				Description: "",
			},
			constSet{
				Name:        "Map",
				Description: "",
			},
			constSet{
				Name:        "MaxPtrmaskBytes",
				Description: "MaxPtrmaskBytes is the maximum length of a GC ptrmask bitmap, which holds 1-bit entries describing where pointers are in a given type. Above this length, the GC information is recorded as a GC program, which can express repetition compactly. In either form, the information is used by the runtime to initialize the heap bitmap, and for large types (like 128 or more words), they are roughly the same speed. GC programs are never much larger and often more compact. (If large arrays are involved, they can be arbitrarily more compact.) The cutoff must be large enough that any allocation large enough to use a GC program is large enough that it does not share heap bitmap bytes with any other objects, allowing the GC program execution to assume an aligned start and not use atomic operations. In the current runtime, this means all malloc size classes larger than the cutoff must be multiples of four words. On 32-bit systems that's 16 bytes, and all size classes >= 16 bytes are 16-byte aligned, so no real constraint. On 64-bit systems, that's 32 bytes, and 32-byte alignment is guaranteed for size classes >= 256 bytes. On a 64-bit system, 256 bytes allocated is 32 pointers, the bits for which fit in 4 bytes. So MaxPtrmaskBytes must be >= 4. We used to use 16 because the GC programs do have some constant overhead to get started, and processing 128 pointers seems to be enough to amortize that overhead well. To make sure that the runtime's chansend can call typeBitsBulkBarrier, we raised the limit to 2048, so that even 32-bit systems are guaranteed to use bitmaps for objects up to 64 kB in size. ",
			},
			constSet{
				Name:        "OldMapBucketCount",
				Description: "Map constants common to several packages runtime/runtime-gdb.py:MapTypePrinter contains its own copy ",
			},
			constSet{
				Name:        "OldMapBucketCountBits",
				Description: "Maximum number of key/elem pairs a bucket can hold. ",
			},
			constSet{
				Name:        "OldMapMaxElemBytes",
				Description: "Map constants common to several packages runtime/runtime-gdb.py:MapTypePrinter contains its own copy ",
			},
			constSet{
				Name:        "OldMapMaxKeyBytes",
				Description: "Maximum key or elem size to keep inline (instead of mallocing per element). Must fit in a uint8. Note: fast map functions cannot handle big elems (bigger than MapMaxElemBytes). ",
			},
			constSet{
				Name:        "PCDATA_ArgLiveIndex",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "PCDATA_InlTreeIndex",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "PCDATA_StackMapIndex",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "PCDATA_UnsafePoint",
				Description: "IDs for PCDATA and FUNCDATA tables in Go binaries. These must agree with ../../../runtime/funcdata.h. ",
			},
			constSet{
				Name:        "Pointer",
				Description: "",
			},
			constSet{
				Name:        "RF_DONE",
				Description: "These constants are shared between the compiler, which uses them for state functions and panic indicators, and the runtime, which turns them into more meaningful strings For best code generation, RF_DONE and RF_READY should be 0 and 1. ",
			},
			constSet{
				Name:        "RF_EXHAUSTED",
				Description: "These constants are shared between the compiler, which uses them for state functions and panic indicators, and the runtime, which turns them into more meaningful strings For best code generation, RF_DONE and RF_READY should be 0 and 1. ",
			},
			constSet{
				Name:        "RF_MISSING_PANIC",
				Description: "These constants are shared between the compiler, which uses them for state functions and panic indicators, and the runtime, which turns them into more meaningful strings For best code generation, RF_DONE and RF_READY should be 0 and 1. ",
			},
			constSet{
				Name:        "RF_PANIC",
				Description: "These constants are shared between the compiler, which uses them for state functions and panic indicators, and the runtime, which turns them into more meaningful strings For best code generation, RF_DONE and RF_READY should be 0 and 1. ",
			},
			constSet{
				Name:        "RF_READY",
				Description: "These constants are shared between the compiler, which uses them for state functions and panic indicators, and the runtime, which turns them into more meaningful strings For best code generation, RF_DONE and RF_READY should be 0 and 1. ",
			},
			constSet{
				Name:        "RecvDir",
				Description: "",
			},
			constSet{
				Name:        "SendDir",
				Description: "",
			},
			constSet{
				Name:        "Slice",
				Description: "",
			},
			constSet{
				Name:        "StackBig",
				Description: "Functions that need frames <= StackBig can assume that neither SP-framesize nor stackGuard-StackSmall will underflow, and thus use a more efficient check. In order to ensure this, StackBig must be <= the size of the unmapped space at zero. ",
			},
			constSet{
				Name:        "StackNosplitBase",
				Description: "StackNosplitBase is the base maximum number of bytes that a chain of NOSPLIT functions can use. This value must be multiplied by the stack guard multiplier, so do not use it directly. See runtime/stack.go:stackNosplit and cmd/internal/objabi/stack.go:StackNosplit. ",
			},
			constSet{
				Name:        "StackSmall",
				Description: "After a stack split check the SP is allowed to be StackSmall bytes below the stack guard. Functions that need frames <= StackSmall can perform the stack check using a single comparison directly between the stack guard and the SP because we ensure that StackSmall bytes of stack space are available beyond the stack guard. ",
			},
			constSet{
				Name:        "String",
				Description: "",
			},
			constSet{
				Name:        "Struct",
				Description: "",
			},
			constSet{
				Name:        "SwissMapCtrlEmpty",
				Description: "Value of control word with all empty slots. ",
			},
			constSet{
				Name:        "SwissMapGroupSlots",
				Description: "Number of slots in a group. ",
			},
			constSet{
				Name:        "SwissMapGroupSlotsBits",
				Description: "Number of bits in the group.slot count. ",
			},
			constSet{
				Name:        "SwissMapHashMightPanic",
				Description: "Flag values ",
			},
			constSet{
				Name:        "SwissMapIndirectElem",
				Description: "Flag values ",
			},
			constSet{
				Name:        "SwissMapIndirectKey",
				Description: "Flag values ",
			},
			constSet{
				Name:        "SwissMapMaxElemBytes",
				Description: "Map constants common to several packages runtime/runtime-gdb.py:MapTypePrinter contains its own copy ",
			},
			constSet{
				Name:        "SwissMapMaxKeyBytes",
				Description: "Maximum key or elem size to keep inline (instead of mallocing per element). Must fit in a uint8. ",
			},
			constSet{
				Name:        "SwissMapNeedKeyUpdate",
				Description: "Flag values ",
			},
			constSet{
				Name:        "TFlagExtraStar",
				Description: "TFlagExtraStar means the name in the str field has an extraneous '*' prefix. This is because for most types T in a program, the type *T also exists and reusing the str data saves binary size. ",
			},
			constSet{
				Name:        "TFlagGCMaskOnDemand",
				Description: "TFlagGCMaskOnDemand means that the GC pointer bitmask will be computed on demand at runtime instead of being precomputed at compile time. If this flag is set, the GCData field effectively has type **byte instead of *byte. The runtime will store a pointer to the GC pointer bitmask in *GCData. ",
			},
			constSet{
				Name:        "TFlagNamed",
				Description: "TFlagNamed means the type has a name. ",
			},
			constSet{
				Name:        "TFlagRegularMemory",
				Description: "TFlagRegularMemory means that equal and hash functions can treat this type as a single region of t.size bytes. ",
			},
			constSet{
				Name:        "TFlagUncommon",
				Description: "TFlagUncommon means that there is a data with a type, UncommonType, just beyond the shared-per-type common data. That is, the data for struct types will store their UncommonType at one offset, the data for interface types will store their UncommonType at a different offset. UncommonType is always accessed via a pointer that is computed using trust-us-we-are-the-implementors pointer arithmetic. For example, if t.Kind() == Struct and t.tflag&TFlagUncommon != 0, then t has UncommonType data and it can be accessed as: type structTypeUncommon struct { structType u UncommonType } u := &(*structTypeUncommon)(unsafe.Pointer(t)).u ",
			},
			constSet{
				Name:        "TraceArgsDotdotdot",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "TraceArgsEndAgg",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "TraceArgsEndSeq",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "TraceArgsLimit",
				Description: "",
			},
			constSet{
				Name:        "TraceArgsMaxDepth",
				Description: "",
			},
			constSet{
				Name:        "TraceArgsMaxLen",
				Description: "maxLen is a (conservative) upper bound of the byte stream length. For each arg/component, it has no more than 2 bytes of data (size, offset), and no more than one {, }, ... at each level (it cannot have both the data and ... unless it is the last one, just be conservative). Plus 1 for _endSeq. ",
			},
			constSet{
				Name:        "TraceArgsOffsetTooLarge",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "TraceArgsSpecial",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "TraceArgsStartAgg",
				Description: "Populate the data. The data is a stream of bytes, which contains the offsets and sizes of the non-aggregate arguments or non-aggregate fields/elements of aggregate-typed arguments, along with special \"operators\". Specifically, - for each non-aggregate arg/field/element, its offset from FP (1 byte) and size (1 byte) - special operators: - 0xff - end of sequence - 0xfe - print { (at the start of an aggregate-typed argument) - 0xfd - print } (at the end of an aggregate-typed argument) - 0xfc - print ... (more args/fields/elements) - 0xfb - print _ (offset too large) ",
			},
			constSet{
				Name:        "Uint",
				Description: "",
			},
			constSet{
				Name:        "Uint16",
				Description: "",
			},
			constSet{
				Name:        "Uint32",
				Description: "",
			},
			constSet{
				Name:        "Uint64",
				Description: "",
			},
			constSet{
				Name:        "Uint8",
				Description: "",
			},
			constSet{
				Name:        "Uintptr",
				Description: "",
			},
			constSet{
				Name:        "UnsafePointRestart1",
				Description: "UnsafePointRestart1(2) apply on a sequence of instructions, within which if an async preemption happens, we should back off the PC to the start of the sequence when resuming. We need two so we can distinguish the start/end of the sequence in case that two sequences are next to each other. ",
			},
			constSet{
				Name:        "UnsafePointRestart2",
				Description: "Special values for the PCDATA_UnsafePoint table. ",
			},
			constSet{
				Name:        "UnsafePointRestartAtEntry",
				Description: "Like UnsafePointRestart1, but back to function entry if async preempted. ",
			},
			constSet{
				Name:        "UnsafePointSafe",
				Description: "Special values for the PCDATA_UnsafePoint table. ",
			},
			constSet{
				Name:        "UnsafePointUnsafe",
				Description: "Special values for the PCDATA_UnsafePoint table. ",
			},
			constSet{
				Name:        "UnsafePointer",
				Description: "",
			},
			constSet{
				Name:        "ZeroValSize",
				Description: "ZeroValSize is the size in bytes of runtime.zeroVal. ",
			},
		},
		"cpu": []constSet{
			constSet{
				Name:        "CacheLinePadSize",
				Description: "CacheLinePadSize is used to prevent false sharing of cache lines. We choose 128 because Apple Silicon, a.k.a. M1, has 128-byte cache line size. It doesn't cost much and is much more future-proof. ",
			},
			constSet{
				Name:        "AMD64",
				Description: "",
			},
			constSet{
				Name:        "ARM64",
				Description: "",
			},
			constSet{
				Name:        "BigEndian",
				Description: "",
			},
			constSet{
				Name:        "PPC64",
				Description: "",
			},
			constSet{
				Name:        "PPC64le",
				Description: "",
			},
		},
		"strconv": []constSet{
			constSet{
				Name:        "IntSize",
				Description: "IntSize is the size in bits of an int or uint value. ",
			},
		},
		"asn1": []constSet{
			constSet{
				Name:        "ClassApplication",
				Description: "ASN.1 class types represent the namespace of the tag. ",
			},
			constSet{
				Name:        "ClassContextSpecific",
				Description: "ASN.1 class types represent the namespace of the tag. ",
			},
			constSet{
				Name:        "ClassPrivate",
				Description: "ASN.1 class types represent the namespace of the tag. ",
			},
			constSet{
				Name:        "ClassUniversal",
				Description: "ASN.1 class types represent the namespace of the tag. ",
			},
			constSet{
				Name:        "TagBMPString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagBitString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagBoolean",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagEnum",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagGeneralString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagGeneralizedTime",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagIA5String",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagInteger",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagNull",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagNumericString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagOID",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagOctetString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagPrintableString",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagSequence",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagSet",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagT61String",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagUTCTime",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
			constSet{
				Name:        "TagUTF8String",
				Description: "ASN.1 tags represent the type of the following object. ",
			},
		},
		"buildcfg": []constSet{
			constSet{
				Name:        "DefaultCGO_ENABLED",
				Description: "",
			},
			constSet{
				Name:        "DefaultGO386",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOAMD64",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOARM",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOARM64",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOEXPERIMENT",
				Description: "DefaultGOEXPERIMENT is the embedded default GOEXPERIMENT string. It is not guaranteed to be canonical. ",
			},
			constSet{
				Name:        "DefaultGOFIPS140",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOMIPS",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOMIPS64",
				Description: "",
			},
			constSet{
				Name:        "DefaultGOPPC64",
				Description: "",
			},
			constSet{
				Name:        "DefaultGORISCV64",
				Description: "",
			},
		},
		"coverage": []constSet{
			constSet{
				Name:        "CounterFilePref",
				Description: "CounterFilePref is the file prefix used when emitting coverage data output files. CounterFileTemplate describes the format of the file name: prefix followed by meta-file hash followed by process ID followed by emit UnixNanoTime. ",
			},
			constSet{
				Name:        "CounterFileRegexp",
				Description: "",
			},
			constSet{
				Name:        "CounterFileTempl",
				Description: "",
			},
			constSet{
				Name:        "CounterFileVersion",
				Description: "CounterFileVersion stores the most recent counter data file version. ",
			},
			constSet{
				Name:        "CovMetaHeaderSize",
				Description: "",
			},
			constSet{
				Name:        "CtrGranularityInvalid",
				Description: "",
			},
			constSet{
				Name:        "CtrGranularityPerBlock",
				Description: "",
			},
			constSet{
				Name:        "CtrGranularityPerFunc",
				Description: "",
			},
			constSet{
				Name:        "CtrModeAtomic",
				Description: "",
			},
			constSet{
				Name:        "CtrModeCount",
				Description: "",
			},
			constSet{
				Name:        "CtrModeInvalid",
				Description: "",
			},
			constSet{
				Name:        "CtrModeRegOnly",
				Description: "",
			},
			constSet{
				Name:        "CtrModeSet",
				Description: "",
			},
			constSet{
				Name:        "CtrModeTestMain",
				Description: "",
			},
			constSet{
				Name:        "CtrRaw",
				Description: "\"Raw\" representation: all values (pkg ID, func ID, num counters, and counters themselves) are stored as uint32's. ",
			},
			constSet{
				Name:        "CtrULeb128",
				Description: "\"ULeb\" representation: all values (pkg ID, func ID, num counters, and counters themselves) are stored with ULEB128 encoding. ",
			},
			constSet{
				Name:        "FirstCtrOffset",
				Description: "",
			},
			constSet{
				Name:        "FuncIdOffset",
				Description: "",
			},
			constSet{
				Name:        "MetaFilePref",
				Description: "MetaFilePref is a prefix used when emitting meta-data files; these files are of the form \"covmeta.<hash>\", where hash is a hash computed from the hashes of all the package meta-data symbols in the program. ",
			},
			constSet{
				Name:        "MetaFileVersion",
				Description: "MetaFileVersion contains the current (most recent) meta-data file version. ",
			},
			constSet{
				Name:        "MetaFilesFileName",
				Description: "Name of file within the \"go test -cover\" temp coverdir directory containing a list of meta-data files for packages being tested in a \"go test -coverpkg=... ...\" run. This constant is shared by the Go command and by the coverage runtime. ",
			},
			constSet{
				Name:        "NotHardCoded",
				Description: "NotHardCoded is a package pseudo-ID indicating that a given package is not part of the runtime and doesn't require a hard-coded ID. ",
			},
			constSet{
				Name:        "NumCtrsOffset",
				Description: "",
			},
			constSet{
				Name:        "PkgIdOffset",
				Description: "",
			},
		},
		"rpc": []constSet{
			constSet{
				Name:        "DefaultDebugPath",
				Description: "",
			},
			constSet{
				Name:        "DefaultRPCPath",
				Description: "Defaults used by HandleHTTP ",
			},
		},
		"math": []constSet{
			constSet{
				Name:        "MaxInt64",
				Description: "",
			},
			constSet{
				Name:        "MaxUint32",
				Description: "",
			},
			constSet{
				Name:        "MaxUint64",
				Description: "",
			},
			constSet{
				Name:        "MaxUintptr",
				Description: "",
			},
			constSet{
				Name:        "E",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "Ln10",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "Ln2",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "Log10E",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "Log2E",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "MaxFloat32",
				Description: "Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type. ",
			},
			constSet{
				Name:        "MaxFloat64",
				Description: "Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type. ",
			},
			constSet{
				Name:        "MaxInt",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxInt16",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxInt32",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxInt64",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxInt8",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxUint",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxUint16",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxUint32",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxUint64",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MaxUint8",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MinInt",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MinInt16",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MinInt32",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MinInt64",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "MinInt8",
				Description: "Integer limit values. ",
			},
			constSet{
				Name:        "Phi",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "Pi",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "SmallestNonzeroFloat32",
				Description: "Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type. ",
			},
			constSet{
				Name:        "SmallestNonzeroFloat64",
				Description: "Floating-point limit values. Max is the largest finite value representable by the type. SmallestNonzero is the smallest positive, non-zero value representable by the type. ",
			},
			constSet{
				Name:        "Sqrt2",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "SqrtE",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "SqrtPhi",
				Description: "Mathematical constants. ",
			},
			constSet{
				Name:        "SqrtPi",
				Description: "Mathematical constants. ",
			},
		},
		"reflect": []constSet{
			constSet{
				Name:        "Array",
				Description: "",
			},
			constSet{
				Name:        "Bool",
				Description: "",
			},
			constSet{
				Name:        "BothDir",
				Description: "",
			},
			constSet{
				Name:        "Chan",
				Description: "",
			},
			constSet{
				Name:        "Complex128",
				Description: "",
			},
			constSet{
				Name:        "Complex64",
				Description: "",
			},
			constSet{
				Name:        "Float32",
				Description: "",
			},
			constSet{
				Name:        "Float64",
				Description: "",
			},
			constSet{
				Name:        "Func",
				Description: "",
			},
			constSet{
				Name:        "Int",
				Description: "",
			},
			constSet{
				Name:        "Int16",
				Description: "",
			},
			constSet{
				Name:        "Int32",
				Description: "",
			},
			constSet{
				Name:        "Int64",
				Description: "",
			},
			constSet{
				Name:        "Int8",
				Description: "",
			},
			constSet{
				Name:        "Interface",
				Description: "",
			},
			constSet{
				Name:        "Invalid",
				Description: "",
			},
			constSet{
				Name:        "Map",
				Description: "",
			},
			constSet{
				Name:        "Pointer",
				Description: "",
			},
			constSet{
				Name:        "Ptr",
				Description: "Ptr is the old name for the [Pointer] kind. ",
			},
			constSet{
				Name:        "RecvDir",
				Description: "",
			},
			constSet{
				Name:        "SelectDefault",
				Description: "",
			},
			constSet{
				Name:        "SelectRecv",
				Description: "",
			},
			constSet{
				Name:        "SelectSend",
				Description: "",
			},
			constSet{
				Name:        "SendDir",
				Description: "",
			},
			constSet{
				Name:        "Slice",
				Description: "",
			},
			constSet{
				Name:        "String",
				Description: "",
			},
			constSet{
				Name:        "Struct",
				Description: "",
			},
			constSet{
				Name:        "Uint",
				Description: "",
			},
			constSet{
				Name:        "Uint16",
				Description: "",
			},
			constSet{
				Name:        "Uint32",
				Description: "",
			},
			constSet{
				Name:        "Uint64",
				Description: "",
			},
			constSet{
				Name:        "Uint8",
				Description: "",
			},
			constSet{
				Name:        "Uintptr",
				Description: "",
			},
			constSet{
				Name:        "UnsafePointer",
				Description: "",
			},
		},
		"tar": []constSet{
			constSet{
				Name:        "FormatGNU",
				Description: "FormatGNU represents the GNU header format. The GNU header format is older than the USTAR and PAX standards and is not compatible with them. The GNU format supports arbitrary file sizes, filenames of arbitrary encoding and length, sparse files, and other features. It is recommended that PAX be chosen over GNU unless the target application can only parse GNU formatted archives. Reference: https://www.gnu.org/software/tar/manual/html_node/Standard.html ",
			},
			constSet{
				Name:        "FormatPAX",
				Description: "FormatPAX represents the PAX header format defined in POSIX.1-2001. PAX extends USTAR by writing a special file with Typeflag TypeXHeader preceding the original header. This file contains a set of key-value records, which are used to overcome USTAR's shortcomings, in addition to providing the ability to have sub-second resolution for timestamps. Some newer formats add their own extensions to PAX by defining their own keys and assigning certain semantic meaning to the associated values. For example, sparse file support in PAX is implemented using keys defined by the GNU manual (e.g., \"GNU.sparse.map\"). Reference: http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html ",
			},
			constSet{
				Name:        "FormatUSTAR",
				Description: "FormatUSTAR represents the USTAR header format defined in POSIX.1-1988. While this format is compatible with most tar readers, the format has several limitations making it unsuitable for some usages. Most notably, it cannot support sparse files, files larger than 8GiB, filenames larger than 256 characters, and non-ASCII filenames. Reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06 ",
			},
			constSet{
				Name:        "FormatUnknown",
				Description: "FormatUnknown indicates that the format is unknown. ",
			},
			constSet{
				Name:        "TypeBlock",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeChar",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeCont",
				Description: "Type '7' is reserved. ",
			},
			constSet{
				Name:        "TypeDir",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeFifo",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeGNULongLink",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeGNULongName",
				Description: "Types 'L' and 'K' are used by the GNU format for a meta file used to store the path or link name for the next file. This package transparently handles these types. ",
			},
			constSet{
				Name:        "TypeGNUSparse",
				Description: "Type 'S' indicates a sparse file in the GNU format. ",
			},
			constSet{
				Name:        "TypeLink",
				Description: "Type '1' to '6' are header-only flags and may not have a data body. ",
			},
			constSet{
				Name:        "TypeReg",
				Description: "Type '0' indicates a regular file. ",
			},
			constSet{
				Name:        "TypeRegA",
				Description: "Deprecated: Use TypeReg instead. ",
			},
			constSet{
				Name:        "TypeSymlink",
				Description: "Type flags for Header.Typeflag. ",
			},
			constSet{
				Name:        "TypeXGlobalHeader",
				Description: "Type 'g' is used by the PAX format to store key-value records that are relevant to all subsequent files. This package only supports parsing and composing such headers, but does not currently support persisting the global state across files. ",
			},
			constSet{
				Name:        "TypeXHeader",
				Description: "Type 'x' is used by the PAX format to store key-value records that are only relevant to the next file. This package transparently handles these types. ",
			},
		},
		"drbg": []constSet{
			constSet{
				Name:        "SeedSize",
				Description: "",
			},
		},
		"macho": []constSet{
			constSet{
				Name:        "ARM64_RELOC_ADDEND",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_BRANCH26",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_GOT_LOAD_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_GOT_LOAD_PAGEOFF12",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_PAGEOFF12",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_POINTER_TO_GOT",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_SUBTRACTOR",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_TLVP_LOAD_PAGE21",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_TLVP_LOAD_PAGEOFF12",
				Description: "",
			},
			constSet{
				Name:        "ARM64_RELOC_UNSIGNED",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_BR24",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_HALF",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_HALF_SECTDIFF",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_LOCAL_SECTDIFF",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_PAIR",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_PB_LA_PTR",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_SECTDIFF",
				Description: "",
			},
			constSet{
				Name:        "ARM_RELOC_VANILLA",
				Description: "",
			},
			constSet{
				Name:        "ARM_THUMB_32BIT_BRANCH",
				Description: "",
			},
			constSet{
				Name:        "ARM_THUMB_RELOC_BR22",
				Description: "",
			},
			constSet{
				Name:        "Cpu386",
				Description: "",
			},
			constSet{
				Name:        "CpuAmd64",
				Description: "",
			},
			constSet{
				Name:        "CpuArm",
				Description: "",
			},
			constSet{
				Name:        "CpuArm64",
				Description: "",
			},
			constSet{
				Name:        "CpuPpc",
				Description: "",
			},
			constSet{
				Name:        "CpuPpc64",
				Description: "",
			},
			constSet{
				Name:        "FlagAllModsBound",
				Description: "",
			},
			constSet{
				Name:        "FlagAllowStackExecution",
				Description: "",
			},
			constSet{
				Name:        "FlagAppExtensionSafe",
				Description: "",
			},
			constSet{
				Name:        "FlagBindAtLoad",
				Description: "",
			},
			constSet{
				Name:        "FlagBindsToWeak",
				Description: "",
			},
			constSet{
				Name:        "FlagCanonical",
				Description: "",
			},
			constSet{
				Name:        "FlagDeadStrippableDylib",
				Description: "",
			},
			constSet{
				Name:        "FlagDyldLink",
				Description: "",
			},
			constSet{
				Name:        "FlagForceFlat",
				Description: "",
			},
			constSet{
				Name:        "FlagHasTLVDescriptors",
				Description: "",
			},
			constSet{
				Name:        "FlagIncrLink",
				Description: "",
			},
			constSet{
				Name:        "FlagLazyInit",
				Description: "",
			},
			constSet{
				Name:        "FlagNoFixPrebinding",
				Description: "",
			},
			constSet{
				Name:        "FlagNoHeapExecution",
				Description: "",
			},
			constSet{
				Name:        "FlagNoMultiDefs",
				Description: "",
			},
			constSet{
				Name:        "FlagNoReexportedDylibs",
				Description: "",
			},
			constSet{
				Name:        "FlagNoUndefs",
				Description: "",
			},
			constSet{
				Name:        "FlagPIE",
				Description: "",
			},
			constSet{
				Name:        "FlagPrebindable",
				Description: "",
			},
			constSet{
				Name:        "FlagPrebound",
				Description: "",
			},
			constSet{
				Name:        "FlagRootSafe",
				Description: "",
			},
			constSet{
				Name:        "FlagSetuidSafe",
				Description: "",
			},
			constSet{
				Name:        "FlagSplitSegs",
				Description: "",
			},
			constSet{
				Name:        "FlagSubsectionsViaSymbols",
				Description: "",
			},
			constSet{
				Name:        "FlagTwoLevel",
				Description: "",
			},
			constSet{
				Name:        "FlagWeakDefines",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_LOCAL_SECTDIFF",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_PAIR",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_PB_LA_PTR",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_SECTDIFF",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_TLV",
				Description: "",
			},
			constSet{
				Name:        "GENERIC_RELOC_VANILLA",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdDylib",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdDylinker",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdDysymtab",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdRpath",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdSegment",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdSegment64",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdSymtab",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdThread",
				Description: "",
			},
			constSet{
				Name:        "LoadCmdUnixThread",
				Description: "",
			},
			constSet{
				Name:        "Magic32",
				Description: "",
			},
			constSet{
				Name:        "Magic64",
				Description: "",
			},
			constSet{
				Name:        "MagicFat",
				Description: "",
			},
			constSet{
				Name:        "TypeBundle",
				Description: "",
			},
			constSet{
				Name:        "TypeDylib",
				Description: "",
			},
			constSet{
				Name:        "TypeExec",
				Description: "",
			},
			constSet{
				Name:        "TypeObj",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_BRANCH",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_GOT",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_GOT_LOAD",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_SIGNED",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_SIGNED_1",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_SIGNED_2",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_SIGNED_4",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_SUBTRACTOR",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_TLV",
				Description: "",
			},
			constSet{
				Name:        "X86_64_RELOC_UNSIGNED",
				Description: "",
			},
		},
		"tracev2": []constSet{
			constSet{
				Name:        "AllocFree",
				Description: "AllocFree is the alloc-free events experiment. ",
			},
			constSet{
				Name:        "EvCPUSample",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvCPUSamples",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvClockSnapshot",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvEndOfGeneration",
				Description: "Reserved internal in-band end-of-generation signal. Must never appear in the trace. Added in Go 1.25. This could be used as an explicit in-band end-of-generation signal in the future. ",
			},
			constSet{
				Name:        "EvEventBatch",
				Description: "Structural events. ",
			},
			constSet{
				Name:        "EvExperimentalBatch",
				Description: "Batch event for an experimental batch with a custom format. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvFrequency",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCActive",
				Description: "GC events. ",
			},
			constSet{
				Name:        "EvGCBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCMarkAssistActive",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCMarkAssistBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCMarkAssistEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCSweepActive",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCSweepBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGCSweepEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoBlock",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoCreate",
				Description: "Goroutines. ",
			},
			constSet{
				Name:        "EvGoCreateBlocked",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoCreateSyscall",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoDestroy",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoDestroySyscall",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoLabel",
				Description: "Annotations. ",
			},
			constSet{
				Name:        "EvGoStart",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoStatus",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoStatusStack",
				Description: "GoStatus with stack. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvGoStop",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoSwitch",
				Description: "Coroutines. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvGoSwitchDestroy",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoSyscallBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoSyscallEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoSyscallEndBlocked",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoUnblock",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvGoroutineStack",
				Description: "Experimental goroutine stack events. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvGoroutineStackAlloc",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvGoroutineStackFree",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvHeapAlloc",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvHeapGoal",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvHeapObject",
				Description: "Experimental heap object events. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvHeapObjectAlloc",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvHeapObjectFree",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvNone",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvProcStart",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvProcStatus",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvProcSteal",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvProcStop",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvProcsChange",
				Description: "Procs. ",
			},
			constSet{
				Name:        "EvSTWBegin",
				Description: "STW. ",
			},
			constSet{
				Name:        "EvSTWEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvSpan",
				Description: "Experimental heap span events. Added in Go 1.23. ",
			},
			constSet{
				Name:        "EvSpanAlloc",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvSpanFree",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "EvStack",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvStacks",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvString",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvStrings",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvSync",
				Description: "Sync batch. Added in Go 1.25. Previously a lone EvFrequency event. ",
			},
			constSet{
				Name:        "EvUserLog",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvUserRegionBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvUserRegionEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvUserTaskBegin",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "EvUserTaskEnd",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "GoBad",
				Description: "",
			},
			constSet{
				Name:        "GoRunnable",
				Description: "",
			},
			constSet{
				Name:        "GoRunning",
				Description: "",
			},
			constSet{
				Name:        "GoSyscall",
				Description: "",
			},
			constSet{
				Name:        "GoWaiting",
				Description: "",
			},
			constSet{
				Name:        "MaxBatchSize",
				Description: "MaxBatchSize sets the maximum size that a batch can be. Directly controls the trace batch size in the runtime. NOTE: If this number decreases, the trace format version must change. ",
			},
			constSet{
				Name:        "MaxEvent",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "MaxEventTrailerDataSize",
				Description: "MaxEventTrailerDataSize controls the amount of trailer data that an event can have in bytes. Must be smaller than MaxBatchSize. Controls the maximum string size in the trace. Directly controls the maximum such value in the runtime. NOTE: If this number decreases, the trace format version must change. ",
			},
			constSet{
				Name:        "MaxExperimentalEvent",
				Description: "Experimental events. ",
			},
			constSet{
				Name:        "MaxFramesPerStack",
				Description: "Maximum number of PCs in a single stack trace. Since events contain only stack ID rather than whole stack trace, we can allow quite large values here. Directly controls the maximum number of frames per stack in the runtime. NOTE: If this number decreases, the trace format version must change. ",
			},
			constSet{
				Name:        "MaxTimedEventArgs",
				Description: "MaxTimedEventArgs is the maximum number of arguments for timed events. ",
			},
			constSet{
				Name:        "NoExperiment",
				Description: "NoExperiment is the reserved ID 0 indicating no experiment. ",
			},
			constSet{
				Name:        "NumEvents",
				Description: "Event types in the trace, args are given in square brackets. Naming scheme: - Time range event pairs have suffixes \"Begin\" and \"End\". - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes reserved for scheduling resources. NOTE: If you add an event type, make sure you also update all tables in this file! ",
			},
			constSet{
				Name:        "NumExperimentalEvents",
				Description: "",
			},
			constSet{
				Name:        "NumExperiments",
				Description: "Experiments. ",
			},
			constSet{
				Name:        "ProcBad",
				Description: "",
			},
			constSet{
				Name:        "ProcIdle",
				Description: "",
			},
			constSet{
				Name:        "ProcRunning",
				Description: "",
			},
			constSet{
				Name:        "ProcSyscall",
				Description: "",
			},
			constSet{
				Name:        "ProcSyscallAbandoned",
				Description: "ProcSyscallAbandoned is a special case of ProcSyscall. It's used in the very specific case where the first a P is mentioned in a generation is part of a ProcSteal event. If that's the first time it's mentioned, then there's no GoSyscallBegin to connect the P stealing back to at that point. This special state indicates this to the parser, so it doesn't try to find a GoSyscallEndBlocked that corresponds with the ProcSteal. ",
			},
		},
		"synctest": []constSet{
			constSet{
				Name:        "CurrentBubble",
				Description: "",
			},
			constSet{
				Name:        "OtherBubble",
				Description: "",
			},
			constSet{
				Name:        "Unbubbled",
				Description: "",
			},
		},
		"unicode": []constSet{
			constSet{
				Name:        "LowerCase",
				Description: "Indices into the Delta arrays inside CaseRanges for case mapping. ",
			},
			constSet{
				Name:        "MaxASCII",
				Description: "",
			},
			constSet{
				Name:        "MaxCase",
				Description: "Indices into the Delta arrays inside CaseRanges for case mapping. ",
			},
			constSet{
				Name:        "MaxLatin1",
				Description: "",
			},
			constSet{
				Name:        "MaxRune",
				Description: "",
			},
			constSet{
				Name:        "ReplacementChar",
				Description: "",
			},
			constSet{
				Name:        "TitleCase",
				Description: "Indices into the Delta arrays inside CaseRanges for case mapping. ",
			},
			constSet{
				Name:        "UpperCase",
				Description: "Indices into the Delta arrays inside CaseRanges for case mapping. ",
			},
			constSet{
				Name:        "UpperLower",
				Description: "If the Delta field of a [CaseRange] is UpperLower, it means this CaseRange represents a sequence of the form (say) [Upper] [Lower] [Upper] [Lower]. ",
			},
			constSet{
				Name:        "Version",
				Description: "Version is the Unicode edition from which the tables are derived. ",
			},
		},
		"adler32": []constSet{
			constSet{
				Name:        "Size",
				Description: "The size of an Adler-32 checksum in bytes. ",
			},
		},
		"crypto": []constSet{
			constSet{
				Name:        "BLAKE2b_256",
				Description: "",
			},
			constSet{
				Name:        "BLAKE2b_384",
				Description: "",
			},
			constSet{
				Name:        "BLAKE2b_512",
				Description: "",
			},
			constSet{
				Name:        "BLAKE2s_256",
				Description: "",
			},
			constSet{
				Name:        "MD4",
				Description: "",
			},
			constSet{
				Name:        "MD5",
				Description: "",
			},
			constSet{
				Name:        "MD5SHA1",
				Description: "",
			},
			constSet{
				Name:        "RIPEMD160",
				Description: "",
			},
			constSet{
				Name:        "SHA1",
				Description: "",
			},
			constSet{
				Name:        "SHA224",
				Description: "",
			},
			constSet{
				Name:        "SHA256",
				Description: "",
			},
			constSet{
				Name:        "SHA384",
				Description: "",
			},
			constSet{
				Name:        "SHA3_224",
				Description: "",
			},
			constSet{
				Name:        "SHA3_256",
				Description: "",
			},
			constSet{
				Name:        "SHA3_384",
				Description: "",
			},
			constSet{
				Name:        "SHA3_512",
				Description: "",
			},
			constSet{
				Name:        "SHA512",
				Description: "",
			},
			constSet{
				Name:        "SHA512_224",
				Description: "",
			},
			constSet{
				Name:        "SHA512_256",
				Description: "",
			},
		},
		"boring": []constSet{
			constSet{
				Name:        "Enabled",
				Description: "Enabled reports whether BoringCrypto is available. When enabled is false, all functions in this package panic. BoringCrypto is only available on linux/amd64 and linux/arm64 systems. ",
			},
			constSet{
				Name:        "RandReader",
				Description: "",
			},
		},
		"runtime": []constSet{
			constSet{
				Name:        "Compiler",
				Description: "Compiler is the name of the compiler toolchain that built the running binary. Known toolchains are: gc Also known as cmd/compile. gccgo The gccgo front end, part of the GCC compiler suite. ",
			},
			constSet{
				Name:        "GOARCH",
				Description: "GOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on. ",
			},
			constSet{
				Name:        "GOOS",
				Description: "GOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run \"go tool dist list\". ",
			},
		},
		"des": []constSet{
			constSet{
				Name:        "BlockSize",
				Description: "The DES block size in bytes. ",
			},
		},
		"pe": []constSet{
			constSet{
				Name:        "COFFSymbolSize",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_ANY",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_ASSOCIATIVE",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_EXACT_MATCH",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_LARGEST",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_NODUPLICATES",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_COMDAT_SELECT_SAME_SIZE",
				Description: "These constants make up the possible values for the 'Selection' field in an AuxFormat5. ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_ARCHITECTURE",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_BASERELOC",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_DEBUG",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_EXCEPTION",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_EXPORT",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_GLOBALPTR",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_IAT",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_IMPORT",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_RESOURCE",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_SECURITY",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DIRECTORY_ENTRY_TLS",
				Description: "IMAGE_DIRECTORY_ENTRY constants ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_APPCONTAINER",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_GUARD_CF",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_NO_BIND",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_NO_ISOLATION",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_NO_SEH",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_NX_COMPAT",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_DLLCHARACTERISTICS_WDM_DRIVER",
				Description: "OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_32BIT_MACHINE",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_AGGRESIVE_WS_TRIM",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_BYTES_REVERSED_HI",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_BYTES_REVERSED_LO",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_DEBUG_STRIPPED",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_DLL",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_EXECUTABLE_IMAGE",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_LARGE_ADDRESS_AWARE",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_LINE_NUMS_STRIPPED",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_LOCAL_SYMS_STRIPPED",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_AM33",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_AMD64",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_ARM",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_ARM64",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_ARMNT",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_EBC",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_I386",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_IA64",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_LOONGARCH32",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_LOONGARCH64",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_M32R",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_MIPS16",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_MIPSFPU",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_MIPSFPU16",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_POWERPC",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_POWERPCFP",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_R4000",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_RISCV128",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_RISCV32",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_RISCV64",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_SH3",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_SH3DSP",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_SH4",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_SH5",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_THUMB",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_UNKNOWN",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_MACHINE_WCEMIPSV2",
				Description: "",
			},
			constSet{
				Name:        "IMAGE_FILE_NET_RUN_FROM_SWAP",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_RELOCS_STRIPPED",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_SYSTEM",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_FILE_UP_SYSTEM_ONLY",
				Description: "Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together. ",
			},
			constSet{
				Name:        "IMAGE_SCN_CNT_CODE",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_CNT_INITIALIZED_DATA",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_CNT_UNINITIALIZED_DATA",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_LNK_COMDAT",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_MEM_DISCARDABLE",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_MEM_EXECUTE",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_MEM_READ",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SCN_MEM_WRITE",
				Description: "Section characteristics flags. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_EFI_APPLICATION",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_EFI_ROM",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_NATIVE",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_NATIVE_WINDOWS",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_OS2_CUI",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_POSIX_CUI",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_UNKNOWN",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_WINDOWS_CE_GUI",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_WINDOWS_CUI",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_WINDOWS_GUI",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
			constSet{
				Name:        "IMAGE_SUBSYSTEM_XBOX",
				Description: "OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values. ",
			},
		},
		"syntax": []constSet{
			constSet{
				Name:        "ClassNL",
				Description: "",
			},
			constSet{
				Name:        "DotNL",
				Description: "",
			},
			constSet{
				Name:        "EmptyBeginLine",
				Description: "",
			},
			constSet{
				Name:        "EmptyBeginText",
				Description: "",
			},
			constSet{
				Name:        "EmptyEndLine",
				Description: "",
			},
			constSet{
				Name:        "EmptyEndText",
				Description: "",
			},
			constSet{
				Name:        "EmptyNoWordBoundary",
				Description: "",
			},
			constSet{
				Name:        "EmptyWordBoundary",
				Description: "",
			},
			constSet{
				Name:        "ErrInternalError",
				Description: "Unexpected error ",
			},
			constSet{
				Name:        "ErrInvalidCharClass",
				Description: "Parse errors ",
			},
			constSet{
				Name:        "ErrInvalidCharRange",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidEscape",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidNamedCapture",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidPerlOp",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidRepeatOp",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidRepeatSize",
				Description: "",
			},
			constSet{
				Name:        "ErrInvalidUTF8",
				Description: "",
			},
			constSet{
				Name:        "ErrLarge",
				Description: "",
			},
			constSet{
				Name:        "ErrMissingBracket",
				Description: "",
			},
			constSet{
				Name:        "ErrMissingParen",
				Description: "",
			},
			constSet{
				Name:        "ErrMissingRepeatArgument",
				Description: "",
			},
			constSet{
				Name:        "ErrNestingDepth",
				Description: "",
			},
			constSet{
				Name:        "ErrTrailingBackslash",
				Description: "",
			},
			constSet{
				Name:        "ErrUnexpectedParen",
				Description: "",
			},
			constSet{
				Name:        "FoldCase",
				Description: "",
			},
			constSet{
				Name:        "InstAlt",
				Description: "",
			},
			constSet{
				Name:        "InstAltMatch",
				Description: "",
			},
			constSet{
				Name:        "InstCapture",
				Description: "",
			},
			constSet{
				Name:        "InstEmptyWidth",
				Description: "",
			},
			constSet{
				Name:        "InstFail",
				Description: "",
			},
			constSet{
				Name:        "InstMatch",
				Description: "",
			},
			constSet{
				Name:        "InstNop",
				Description: "",
			},
			constSet{
				Name:        "InstRune",
				Description: "",
			},
			constSet{
				Name:        "InstRune1",
				Description: "",
			},
			constSet{
				Name:        "InstRuneAny",
				Description: "",
			},
			constSet{
				Name:        "InstRuneAnyNotNL",
				Description: "",
			},
			constSet{
				Name:        "Literal",
				Description: "",
			},
			constSet{
				Name:        "MatchNL",
				Description: "",
			},
			constSet{
				Name:        "NonGreedy",
				Description: "",
			},
			constSet{
				Name:        "OneLine",
				Description: "",
			},
			constSet{
				Name:        "OpAlternate",
				Description: "",
			},
			constSet{
				Name:        "OpAnyChar",
				Description: "",
			},
			constSet{
				Name:        "OpAnyCharNotNL",
				Description: "",
			},
			constSet{
				Name:        "OpBeginLine",
				Description: "",
			},
			constSet{
				Name:        "OpBeginText",
				Description: "",
			},
			constSet{
				Name:        "OpCapture",
				Description: "",
			},
			constSet{
				Name:        "OpCharClass",
				Description: "",
			},
			constSet{
				Name:        "OpConcat",
				Description: "",
			},
			constSet{
				Name:        "OpEmptyMatch",
				Description: "",
			},
			constSet{
				Name:        "OpEndLine",
				Description: "",
			},
			constSet{
				Name:        "OpEndText",
				Description: "",
			},
			constSet{
				Name:        "OpLiteral",
				Description: "",
			},
			constSet{
				Name:        "OpNoMatch",
				Description: "",
			},
			constSet{
				Name:        "OpNoWordBoundary",
				Description: "",
			},
			constSet{
				Name:        "OpPlus",
				Description: "",
			},
			constSet{
				Name:        "OpQuest",
				Description: "",
			},
			constSet{
				Name:        "OpRepeat",
				Description: "",
			},
			constSet{
				Name:        "OpStar",
				Description: "",
			},
			constSet{
				Name:        "OpWordBoundary",
				Description: "",
			},
			constSet{
				Name:        "POSIX",
				Description: "",
			},
			constSet{
				Name:        "Perl",
				Description: "",
			},
			constSet{
				Name:        "PerlX",
				Description: "",
			},
			constSet{
				Name:        "Simple",
				Description: "",
			},
			constSet{
				Name:        "UnicodeGroups",
				Description: "",
			},
			constSet{
				Name:        "WasDollar",
				Description: "",
			},
		},
		"build": []constSet{
			constSet{
				Name:        "AllowBinary",
				Description: "If AllowBinary is set, Import can be satisfied by a compiled package object without corresponding sources. Deprecated: The supported way to create a compiled-only package is to write source code containing a //go:binary-only-package comment at the top of the file. Such a package will be recognized regardless of this flag setting (because it has source code) and will have BinaryOnly set to true in the returned Package. ",
			},
			constSet{
				Name:        "FindOnly",
				Description: "If FindOnly is set, Import stops after locating the directory that should contain the sources for a package. It does not read any files in the directory. ",
			},
			constSet{
				Name:        "IgnoreVendor",
				Description: "By default, Import searches vendor directories that apply in the given source directory before searching the GOROOT and GOPATH roots. If an Import finds and returns a package using a vendor directory, the resulting ImportPath is the complete path to the package, including the path elements leading up to and including \"vendor\". For example, if Import(\"y\", \"x/subdir\", 0) finds \"x/vendor/y\", the returned package's ImportPath is \"x/vendor/y\", not plain \"y\". See golang.org/s/go15vendor for more information. Setting IgnoreVendor ignores vendor directories. In contrast to the package's ImportPath, the returned package's Imports, TestImports, and XTestImports are always the exact import paths from the source files: Import makes no attempt to resolve or check those paths. ",
			},
			constSet{
				Name:        "ImportComment",
				Description: "If ImportComment is set, parse import comments on package statements. Import returns an error if it finds a comment it cannot understand or finds conflicting comments in multiple source files. See golang.org/s/go14customimport for more information. ",
			},
		},
		"jpeg": []constSet{
			constSet{
				Name:        "DefaultQuality",
				Description: "DefaultQuality is the default quality encoding parameter. ",
			},
		},
		"asmgen": []constSet{
			constSet{
				Name:        "AddCarry",
				Description: "",
			},
			constSet{
				Name:        "AltCarry",
				Description: "",
			},
			constSet{
				Name:        "HintAltCarry",
				Description: "",
			},
			constSet{
				Name:        "HintCarry",
				Description: "",
			},
			constSet{
				Name:        "HintMemOK",
				Description: "",
			},
			constSet{
				Name:        "HintMulHi",
				Description: "",
			},
			constSet{
				Name:        "HintMulSrc",
				Description: "",
			},
			constSet{
				Name:        "HintNone",
				Description: "",
			},
			constSet{
				Name:        "HintShiftCount",
				Description: "",
			},
			constSet{
				Name:        "KeepCarry",
				Description: "",
			},
			constSet{
				Name:        "OptionAltCarry",
				Description: "OptionAltCarry checks whether there is an add instruction that uses a secondary carry flag, so that two different sums can be accumulated in parallel with independent carry flags. Some architectures (MIPS, Loong64, RISC-V) provide this functionality natively, indicated by asm.Carry().Valid() being true. ",
			},
			constSet{
				Name:        "SetCarry",
				Description: "",
			},
			constSet{
				Name:        "SmashCarry",
				Description: "",
			},
			constSet{
				Name:        "SubCarry",
				Description: "",
			},
			constSet{
				Name:        "UseCarry",
				Description: "",
			},
		},
		"goarch": []constSet{
			constSet{
				Name:        "AMD64",
				Description: "",
			},
			constSet{
				Name:        "ARM",
				Description: "",
			},
			constSet{
				Name:        "ARM64",
				Description: "",
			},
			constSet{
				Name:        "ArchFamily",
				Description: "ArchFamily is the architecture family (AMD64, ARM, ...) ",
			},
			constSet{
				Name:        "BigEndian",
				Description: "BigEndian reports whether the architecture is big-endian. ",
			},
			constSet{
				Name:        "DefaultPhysPageSize",
				Description: "DefaultPhysPageSize is the default physical page size. ",
			},
			constSet{
				Name:        "GOARCH",
				Description: "",
			},
			constSet{
				Name:        "I386",
				Description: "",
			},
			constSet{
				Name:        "Int64Align",
				Description: "Int64Align is the required alignment for a 64-bit integer (4 on 32-bit systems, 8 on 64-bit). ",
			},
			constSet{
				Name:        "Is386",
				Description: "",
			},
			constSet{
				Name:        "IsAmd64",
				Description: "",
			},
			constSet{
				Name:        "IsAmd64p32",
				Description: "",
			},
			constSet{
				Name:        "IsArm",
				Description: "",
			},
			constSet{
				Name:        "IsArm64",
				Description: "",
			},
			constSet{
				Name:        "IsArm64be",
				Description: "",
			},
			constSet{
				Name:        "IsArmbe",
				Description: "",
			},
			constSet{
				Name:        "IsLoong64",
				Description: "",
			},
			constSet{
				Name:        "IsMips",
				Description: "",
			},
			constSet{
				Name:        "IsMips64",
				Description: "",
			},
			constSet{
				Name:        "IsMips64le",
				Description: "",
			},
			constSet{
				Name:        "IsMips64p32",
				Description: "",
			},
			constSet{
				Name:        "IsMips64p32le",
				Description: "",
			},
			constSet{
				Name:        "IsMipsle",
				Description: "",
			},
			constSet{
				Name:        "IsPpc",
				Description: "",
			},
			constSet{
				Name:        "IsPpc64",
				Description: "",
			},
			constSet{
				Name:        "IsPpc64le",
				Description: "",
			},
			constSet{
				Name:        "IsRiscv",
				Description: "",
			},
			constSet{
				Name:        "IsRiscv64",
				Description: "",
			},
			constSet{
				Name:        "IsS390",
				Description: "",
			},
			constSet{
				Name:        "IsS390x",
				Description: "",
			},
			constSet{
				Name:        "IsSparc",
				Description: "",
			},
			constSet{
				Name:        "IsSparc64",
				Description: "",
			},
			constSet{
				Name:        "IsWasm",
				Description: "",
			},
			constSet{
				Name:        "LOONG64",
				Description: "",
			},
			constSet{
				Name:        "MIPS",
				Description: "",
			},
			constSet{
				Name:        "MIPS64",
				Description: "",
			},
			constSet{
				Name:        "MinFrameSize",
				Description: "MinFrameSize is the size of the system-reserved words at the bottom of a frame (just above the architectural stack pointer). It is zero on x86 and PtrSize on most non-x86 (LR-based) systems. On PowerPC it is larger, to cover three more reserved words: the compiler word, the link editor word, and the TOC save word. ",
			},
			constSet{
				Name:        "PCQuantum",
				Description: "PCQuantum is the minimal unit for a program counter (1 on x86, 4 on most other systems). The various PC tables record PC deltas pre-divided by PCQuantum. ",
			},
			constSet{
				Name:        "PPC64",
				Description: "",
			},
			constSet{
				Name:        "PtrSize",
				Description: "PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant. It is also the size of the machine's native word size (that is, 4 on 32-bit systems, 8 on 64-bit). ",
			},
			constSet{
				Name:        "RISCV64",
				Description: "",
			},
			constSet{
				Name:        "S390X",
				Description: "",
			},
			constSet{
				Name:        "StackAlign",
				Description: "StackAlign is the required alignment of the SP register. The stack must be at least word aligned, but some architectures require more. ",
			},
			constSet{
				Name:        "WASM",
				Description: "",
			},
		},
		"reflectlite": []constSet{
			constSet{
				Name:        "Interface",
				Description: "Import-and-export these constants as necessary ",
			},
			constSet{
				Name:        "Ptr",
				Description: "",
			},
			constSet{
				Name:        "Slice",
				Description: "",
			},
			constSet{
				Name:        "String",
				Description: "",
			},
			constSet{
				Name:        "Struct",
				Description: "",
			},
		},
		"bufio": []constSet{
			constSet{
				Name:        "MaxScanTokenSize",
				Description: "MaxScanTokenSize is the maximum size used to buffer a token unless the user provides an explicit buffer with [Scanner.Buffer]. The actual maximum token size may be smaller as the buffer may need to include, for instance, a newline. ",
			},
		},
		"log": []constSet{
			constSet{
				Name:        "LUTC",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Ldate",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Llongfile",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Lmicroseconds",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Lmsgprefix",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Lshortfile",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "LstdFlags",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
			constSet{
				Name:        "Ltime",
				Description: "These flags define which text to prefix to each log entry generated by the [Logger]. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, 2009/01/23 01:23:23 message while flags Ldate | Ltime | Lmicroseconds | Llongfile produce, 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message ",
			},
		},
	},
	Structs: map[types.PkgName][]structSet{
		"reflect": []structSet{
			structSet{
				Name: "MapIter",
				Fields: []types.StructFieldName{
					"m",
					"hiter",
				},
				Description: "",
			},
			structSet{
				Name: "Method",
				Fields: []types.StructFieldName{
					"Name",
					"PkgPath",
					"Type",
					"Func",
					"Index",
				},
				Description: "",
			},
			structSet{
				Name: "SelectCase",
				Fields: []types.StructFieldName{
					"Dir",
					"Chan",
					"Send",
				},
				Description: "",
			},
			structSet{
				Name: "SliceHeader",
				Fields: []types.StructFieldName{
					"Data",
					"Len",
					"Cap",
				},
				Description: "",
			},
			structSet{
				Name: "StringHeader",
				Fields: []types.StructFieldName{
					"Data",
					"Len",
				},
				Description: "",
			},
			structSet{
				Name: "StructField",
				Fields: []types.StructFieldName{
					"Name",
					"PkgPath",
					"Type",
					"Tag",
					"Offset",
					"Index",
					"Anonymous",
				},
				Description: "",
			},
			structSet{
				Name: "ValueError",
				Fields: []types.StructFieldName{
					"Method",
					"Kind",
				},
				Description: "",
			},
		},
		"field": []structSet{
			structSet{
				Name: "Element",
				Fields: []types.StructFieldName{
					"l0",
					"l1",
					"l2",
					"l3",
					"l4",
				},
				Description: "",
			},
		},
		"multipart": []structSet{
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Filename",
					"Header",
					"Size",
					"content",
					"tmpfile",
					"tmpoff",
					"tmpshared",
				},
				Description: "",
			},
			structSet{
				Name: "Form",
				Fields: []types.StructFieldName{
					"Value",
					"File",
				},
				Description: "",
			},
			structSet{
				Name: "Part",
				Fields: []types.StructFieldName{
					"Header",
					"mr",
					"disposition",
					"dispositionParams",
					"r",
					"n",
					"total",
					"err",
					"readErr",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"bufReader",
					"tempDir",
					"currentPart",
					"partsRead",
					"nl",
					"nlDashBoundary",
					"dashBoundaryDash",
					"dashBoundary",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"w",
					"boundary",
					"lastpart",
				},
				Description: "",
			},
		},
		"http": []structSet{
			structSet{
				Name: "Client",
				Fields: []types.StructFieldName{
					"Transport",
					"CheckRedirect",
					"Jar",
					"Timeout",
				},
				Description: "",
			},
			structSet{
				Name: "Cookie",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
					"Quoted",
					"Path",
					"Domain",
					"Expires",
					"RawExpires",
					"MaxAge",
					"Secure",
					"HttpOnly",
					"SameSite",
					"Partitioned",
					"Raw",
					"Unparsed",
				},
				Description: "",
			},
			structSet{
				Name: "CrossOriginProtection",
				Fields: []types.StructFieldName{
					"bypass",
					"trustedMu",
					"trusted",
					"deny",
				},
				Description: "",
			},
			structSet{
				Name: "HTTP2Config",
				Fields: []types.StructFieldName{
					"MaxConcurrentStreams",
					"MaxDecoderHeaderTableSize",
					"MaxEncoderHeaderTableSize",
					"MaxReadFrameSize",
					"MaxReceiveBufferPerConnection",
					"MaxReceiveBufferPerStream",
					"SendPingTimeout",
					"PingTimeout",
					"WriteByteTimeout",
					"PermitProhibitedCipherSuites",
					"CountError",
				},
				Description: "",
			},
			structSet{
				Name: "MaxBytesError",
				Fields: []types.StructFieldName{
					"Limit",
				},
				Description: "",
			},
			structSet{
				Name: "ProtocolError",
				Fields: []types.StructFieldName{
					"ErrorString",
				},
				Description: "",
			},
			structSet{
				Name: "Protocols",
				Fields: []types.StructFieldName{
					"bits",
				},
				Description: "",
			},
			structSet{
				Name: "PushOptions",
				Fields: []types.StructFieldName{
					"Method",
					"Header",
				},
				Description: "",
			},
			structSet{
				Name: "Request",
				Fields: []types.StructFieldName{
					"Method",
					"URL",
					"Proto",
					"ProtoMajor",
					"ProtoMinor",
					"Header",
					"Body",
					"GetBody",
					"ContentLength",
					"TransferEncoding",
					"Close",
					"Host",
					"Form",
					"PostForm",
					"MultipartForm",
					"Trailer",
					"RemoteAddr",
					"RequestURI",
					"TLS",
					"Cancel",
					"Response",
					"Pattern",
					"ctx",
					"pat",
					"matches",
					"otherValues",
				},
				Description: "",
			},
			structSet{
				Name: "Response",
				Fields: []types.StructFieldName{
					"Status",
					"StatusCode",
					"Proto",
					"ProtoMajor",
					"ProtoMinor",
					"Header",
					"Body",
					"ContentLength",
					"TransferEncoding",
					"Close",
					"Uncompressed",
					"Trailer",
					"Request",
					"TLS",
				},
				Description: "",
			},
			structSet{
				Name: "ResponseController",
				Fields: []types.StructFieldName{
					"rw",
				},
				Description: "",
			},
			structSet{
				Name: "ServeMux",
				Fields: []types.StructFieldName{
					"mu",
					"tree",
					"index",
					"mux121",
				},
				Description: "",
			},
			structSet{
				Name: "Server",
				Fields: []types.StructFieldName{
					"Addr",
					"Handler",
					"DisableGeneralOptionsHandler",
					"TLSConfig",
					"ReadTimeout",
					"ReadHeaderTimeout",
					"WriteTimeout",
					"IdleTimeout",
					"MaxHeaderBytes",
					"TLSNextProto",
					"ConnState",
					"ErrorLog",
					"BaseContext",
					"ConnContext",
					"HTTP2",
					"Protocols",
					"inShutdown",
					"disableKeepAlives",
					"nextProtoOnce",
					"nextProtoErr",
					"mu",
					"listeners",
					"activeConn",
					"onShutdown",
					"listenerGroup",
				},
				Description: "",
			},
			structSet{
				Name: "Transport",
				Fields: []types.StructFieldName{
					"idleMu",
					"closeIdle",
					"idleConn",
					"idleConnWait",
					"idleLRU",
					"reqMu",
					"reqCanceler",
					"altMu",
					"altProto",
					"connsPerHostMu",
					"connsPerHost",
					"connsPerHostWait",
					"dialsInProgress",
					"Proxy",
					"OnProxyConnectResponse",
					"DialContext",
					"Dial",
					"DialTLSContext",
					"DialTLS",
					"TLSClientConfig",
					"TLSHandshakeTimeout",
					"DisableKeepAlives",
					"DisableCompression",
					"MaxIdleConns",
					"MaxIdleConnsPerHost",
					"MaxConnsPerHost",
					"IdleConnTimeout",
					"ResponseHeaderTimeout",
					"ExpectContinueTimeout",
					"TLSNextProto",
					"ProxyConnectHeader",
					"GetProxyConnectHeader",
					"MaxResponseHeaderBytes",
					"WriteBufferSize",
					"ReadBufferSize",
					"nextProtoOnce",
					"h2transport",
					"tlsNextProtoWasNil",
					"ForceAttemptHTTP2",
					"HTTP2",
					"Protocols",
				},
				Description: "",
			},
		},
		"jpeg": []structSet{
			structSet{
				Name: "Options",
				Fields: []types.StructFieldName{
					"Quality",
				},
				Description: "",
			},
		},
		"list": []structSet{
			structSet{
				Name: "Element",
				Fields: []types.StructFieldName{
					"next",
					"prev",
					"list",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "List",
				Fields: []types.StructFieldName{
					"root",
					"len",
				},
				Description: "",
			},
		},
		"gccgoimporter": []structSet{
			structSet{
				Name: "GccgoInstallation",
				Fields: []types.StructFieldName{
					"GccVersion",
					"TargetTriple",
					"LibPaths",
				},
				Description: "",
			},
			structSet{
				Name: "InitData",
				Fields: []types.StructFieldName{
					"Priority",
					"Inits",
				},
				Description: "",
			},
			structSet{
				Name: "PackageInit",
				Fields: []types.StructFieldName{
					"Name",
					"InitFunc",
					"Priority",
				},
				Description: "",
			},
		},
		"pkix": []structSet{
			structSet{
				Name: "AlgorithmIdentifier",
				Fields: []types.StructFieldName{
					"Algorithm",
					"Parameters",
				},
				Description: "",
			},
			structSet{
				Name: "AttributeTypeAndValue",
				Fields: []types.StructFieldName{
					"Type",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "AttributeTypeAndValueSET",
				Fields: []types.StructFieldName{
					"Type",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "CertificateList",
				Fields: []types.StructFieldName{
					"TBSCertList",
					"SignatureAlgorithm",
					"SignatureValue",
				},
				Description: "",
			},
			structSet{
				Name: "Extension",
				Fields: []types.StructFieldName{
					"Id",
					"Critical",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Name",
				Fields: []types.StructFieldName{
					"Country",
					"Organization",
					"OrganizationalUnit",
					"Locality",
					"Province",
					"StreetAddress",
					"PostalCode",
					"SerialNumber",
					"CommonName",
					"Names",
					"ExtraNames",
				},
				Description: "",
			},
			structSet{
				Name: "RevokedCertificate",
				Fields: []types.StructFieldName{
					"SerialNumber",
					"RevocationTime",
					"Extensions",
				},
				Description: "",
			},
			structSet{
				Name: "TBSCertificateList",
				Fields: []types.StructFieldName{
					"Raw",
					"Version",
					"Signature",
					"Issuer",
					"ThisUpdate",
					"NextUpdate",
					"RevokedCertificates",
					"Extensions",
				},
				Description: "",
			},
		},
		"plan9obj": []structSet{
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"Sections",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Magic",
					"Bss",
					"Entry",
					"PtrSize",
					"LoadAddress",
					"HdrSize",
				},
				Description: "",
			},
			structSet{
				Name: "Section",
				Fields: []types.StructFieldName{
					"SectionHeader",
					"ReaderAt",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader",
				Fields: []types.StructFieldName{
					"Name",
					"Size",
					"Offset",
				},
				Description: "",
			},
			structSet{
				Name: "Sym",
				Fields: []types.StructFieldName{
					"Value",
					"Type",
					"Name",
				},
				Description: "",
			},
		},
		"constraint": []structSet{
			structSet{
				Name: "AndExpr",
				Fields: []types.StructFieldName{
					"X",
					"Y",
				},
				Description: "",
			},
			structSet{
				Name: "NotExpr",
				Fields: []types.StructFieldName{
					"X",
				},
				Description: "",
			},
			structSet{
				Name: "OrExpr",
				Fields: []types.StructFieldName{
					"X",
					"Y",
				},
				Description: "",
			},
			structSet{
				Name: "SyntaxError",
				Fields: []types.StructFieldName{
					"Offset",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "TagExpr",
				Fields: []types.StructFieldName{
					"Tag",
				},
				Description: "",
			},
		},
		"png": []structSet{
			structSet{
				Name: "Encoder",
				Fields: []types.StructFieldName{
					"CompressionLevel",
					"BufferPool",
				},
				Description: "",
			},
			structSet{
				Name: "EncoderBuffer",
				Fields: []types.StructFieldName{
					"enc",
					"w",
					"m",
					"cb",
					"err",
					"header",
					"footer",
					"tmp",
					"cr",
					"pr",
					"zw",
					"zwLevel",
					"bw",
				},
				Description: "",
			},
		},
		"slicewriter": []structSet{
			structSet{
				Name: "WriteSeeker",
				Fields: []types.StructFieldName{
					"payload",
					"off",
				},
				Description: "",
			},
		},
		"chacha8rand": []structSet{
			structSet{
				Name: "State",
				Fields: []types.StructFieldName{
					"buf",
					"seed",
					"i",
					"n",
					"c",
				},
				Description: "",
			},
		},
		"goexperiment": []structSet{
			structSet{
				Name: "Flags",
				Fields: []types.StructFieldName{
					"FieldTrack",
					"PreemptibleLoops",
					"StaticLockRanking",
					"BoringCrypto",
					"RegabiWrappers",
					"RegabiArgs",
					"HeapMinimum512KiB",
					"Arenas",
					"CgoCheck2",
					"LoopVar",
					"CacheProg",
					"NewInliner",
					"RangeFunc",
					"AliasTypeParams",
					"SwissMap",
					"SyncHashTrieMap",
					"Synctest",
					"Dwarf5",
					"JSONv2",
					"GreenTeaGC",
				},
				Description: "",
			},
		},
		"bytes": []structSet{
			structSet{
				Name: "Buffer",
				Fields: []types.StructFieldName{
					"buf",
					"off",
					"lastRead",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"s",
					"i",
					"prevRune",
				},
				Description: "",
			},
		},
		"printer": []structSet{
			structSet{
				Name: "CommentedNode",
				Fields: []types.StructFieldName{
					"Node",
					"Comments",
				},
				Description: "",
			},
			structSet{
				Name: "Config",
				Fields: []types.StructFieldName{
					"Mode",
					"Tabwidth",
					"Indent",
				},
				Description: "",
			},
		},
		"gover": []structSet{
			structSet{
				Name: "Version",
				Fields: []types.StructFieldName{
					"Major",
					"Minor",
					"Patch",
					"Kind",
					"Pre",
				},
				Description: "",
			},
		},
		"template": []structSet{
			structSet{
				Name: "ExecError",
				Fields: []types.StructFieldName{
					"Name",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "Template",
				Fields: []types.StructFieldName{
					"name",
					"Tree",
					"common",
					"leftDelim",
					"rightDelim",
				},
				Description: "",
			},
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"ErrorCode",
					"Node",
					"Name",
					"Line",
					"Description",
				},
				Description: "",
			},
			structSet{
				Name: "Template",
				Fields: []types.StructFieldName{
					"escapeErr",
					"text",
					"Tree",
					"nameSpace",
				},
				Description: "",
			},
		},
		"traceviewer": []structSet{
			structSet{
				Name: "ArrowEvent",
				Fields: []types.StructFieldName{
					"Name",
					"Start",
					"End",
					"FromResource",
					"FromStack",
					"ToResource",
				},
				Description: "",
			},
			structSet{
				Name: "AsyncSliceEvent",
				Fields: []types.StructFieldName{
					"SliceEvent",
					"Category",
					"Scope",
					"TaskColorIndex",
				},
				Description: "",
			},
			structSet{
				Name: "Emitter",
				Fields: []types.StructFieldName{
					"c",
					"rangeStart",
					"rangeEnd",
					"heapStats",
					"prevHeapStats",
					"gstates",
					"prevGstates",
					"threadStats",
					"prevThreadStats",
					"gomaxprocs",
					"frameTree",
					"frameSeq",
					"arrowSeq",
					"filter",
					"resourceType",
					"resources",
					"focusResource",
					"tasks",
					"asyncSliceSeq",
				},
				Description: "",
			},
			structSet{
				Name: "InstantEvent",
				Fields: []types.StructFieldName{
					"Ts",
					"Name",
					"Category",
					"Resource",
					"Stack",
					"Arg",
				},
				Description: "",
			},
			structSet{
				Name: "ProfileRecord",
				Fields: []types.StructFieldName{
					"Stack",
					"Count",
					"Time",
				},
				Description: "",
			},
			structSet{
				Name: "Range",
				Fields: []types.StructFieldName{
					"Name",
					"Start",
					"End",
					"StartTime",
					"EndTime",
				},
				Description: "",
			},
			structSet{
				Name: "SliceEvent",
				Fields: []types.StructFieldName{
					"Name",
					"Ts",
					"Dur",
					"Resource",
					"Stack",
					"EndStack",
					"Arg",
				},
				Description: "",
			},
			structSet{
				Name: "TimeHistogram",
				Fields: []types.StructFieldName{
					"Count",
					"Buckets",
					"MinBucket",
					"MaxBucket",
				},
				Description: "",
			},
			structSet{
				Name: "TraceConsumer",
				Fields: []types.StructFieldName{
					"ConsumeTimeUnit",
					"ConsumeViewerEvent",
					"ConsumeViewerFrame",
					"Flush",
				},
				Description: "",
			},
			structSet{
				Name: "View",
				Fields: []types.StructFieldName{
					"Type",
					"Ranges",
				},
				Description: "",
			},
		},
		"asmgen": []structSet{
			structSet{
				Name: "Arch",
				Fields: []types.StructFieldName{
					"Name",
					"Build",
					"WordBits",
					"WordBytes",
					"CarrySafeLoop",
					"regs",
					"reg0",
					"regCarry",
					"regAltCarry",
					"regTmp",
					"regShift",
					"setup",
					"hint",
					"op3",
					"memOK",
					"maxColumns",
					"mov",
					"add",
					"adds",
					"adc",
					"adcs",
					"sub",
					"subs",
					"sbc",
					"sbcs",
					"mul",
					"mulhi",
					"lsh",
					"lshd",
					"rsh",
					"rshd",
					"and",
					"or",
					"xor",
					"neg",
					"rsb",
					"sltu",
					"sgtu",
					"lea",
					"addF",
					"subF",
					"mulWideF",
					"addWords",
					"subCarryIsBorrow",
					"jmpZero",
					"jmpNonZero",
					"loopTop",
					"loopBottom",
					"loopBottomNeg",
					"memIndex",
					"loadIncN",
					"loadDecN",
					"storeIncN",
					"storeDecN",
					"options",
				},
				Description: "",
			},
			structSet{
				Name: "Asm",
				Fields: []types.StructFieldName{
					"Arch",
					"out",
					"regavail",
					"enabled",
				},
				Description: "",
			},
			structSet{
				Name: "Func",
				Fields: []types.StructFieldName{
					"Name",
					"Asm",
					"inputs",
					"outputs",
					"args",
				},
				Description: "",
			},
			structSet{
				Name: "Pipe",
				Fields: []types.StructFieldName{
					"f",
					"label",
					"backward",
					"started",
					"loaded",
					"inPtr",
					"hints",
					"outPtr",
					"index",
					"useIndexCounter",
					"indexCounter",
					"readOff",
					"writeOff",
					"factors",
					"counts",
					"needWrite",
					"maxColumns",
					"unrollStart",
					"unrollEnd",
				},
				Description: "",
			},
			structSet{
				Name: "Reg",
				Fields: []types.StructFieldName{
					"name",
				},
				Description: "",
			},
			structSet{
				Name: "RegPtr",
				Fields: []types.StructFieldName{
					"name",
				},
				Description: "",
			},
			structSet{
				Name: "RegsUsed",
				Fields: []types.StructFieldName{
					"avail",
				},
				Description: "",
			},
		},
		"ed25519": []structSet{
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"seed",
					"pub",
					"s",
					"prefix",
				},
				Description: "",
			},
			structSet{
				Name: "Options",
				Fields: []types.StructFieldName{
					"Hash",
					"Context",
				},
				Description: "",
			},
		},
		"bcache": []structSet{
			structSet{
				Name: "Cache",
				Fields: []types.StructFieldName{
					"ptable",
				},
				Description: "",
			},
		},
		"cookiejar": []structSet{
			structSet{
				Name: "Jar",
				Fields: []types.StructFieldName{
					"psList",
					"mu",
					"entries",
					"nextSeqNum",
				},
				Description: "",
			},
			structSet{
				Name: "Options",
				Fields: []types.StructFieldName{
					"PublicSuffixList",
				},
				Description: "",
			},
		},
		"unsafeheader": []structSet{
			structSet{
				Name: "Slice",
				Fields: []types.StructFieldName{
					"Data",
					"Len",
					"Cap",
				},
				Description: "",
			},
			structSet{
				Name: "String",
				Fields: []types.StructFieldName{
					"Data",
					"Len",
				},
				Description: "",
			},
		},
		"mime": []structSet{
			structSet{
				Name: "WordDecoder",
				Fields: []types.StructFieldName{
					"CharsetReader",
				},
				Description: "",
			},
		},
		"image": []structSet{
			structSet{
				Name: "Alpha",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "Alpha16",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "CMYK",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "Config",
				Fields: []types.StructFieldName{
					"ColorModel",
					"Width",
					"Height",
				},
				Description: "",
			},
			structSet{
				Name: "Gray",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "Gray16",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "NRGBA",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "NRGBA64",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "NYCbCrA",
				Fields: []types.StructFieldName{
					"YCbCr",
					"A",
					"AStride",
				},
				Description: "",
			},
			structSet{
				Name: "Paletted",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
					"Palette",
				},
				Description: "",
			},
			structSet{
				Name: "Point",
				Fields: []types.StructFieldName{
					"X",
					"Y",
				},
				Description: "",
			},
			structSet{
				Name: "RGBA",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "RGBA64",
				Fields: []types.StructFieldName{
					"Pix",
					"Stride",
					"Rect",
				},
				Description: "",
			},
			structSet{
				Name: "Rectangle",
				Fields: []types.StructFieldName{
					"Min",
					"Max",
				},
				Description: "",
			},
			structSet{
				Name: "Uniform",
				Fields: []types.StructFieldName{
					"C",
				},
				Description: "",
			},
			structSet{
				Name: "YCbCr",
				Fields: []types.StructFieldName{
					"Y",
					"Cb",
					"Cr",
					"YStride",
					"CStride",
					"SubsampleRatio",
					"Rect",
				},
				Description: "",
			},
		},
		"pods": []structSet{
			structSet{
				Name: "Pod",
				Fields: []types.StructFieldName{
					"MetaFile",
					"CounterDataFiles",
					"Origins",
					"ProcessIDs",
				},
				Description: "",
			},
		},
		"sync": []structSet{
			structSet{
				Name: "HashTrieMap",
				Fields: []types.StructFieldName{
					"inited",
					"initMu",
					"root",
					"keyHash",
					"valEqual",
					"seed",
				},
				Description: "",
			},
			structSet{
				Name: "Mutex",
				Fields: []types.StructFieldName{
					"state",
					"sema",
				},
				Description: "",
			},
			structSet{
				Name: "Cond",
				Fields: []types.StructFieldName{
					"noCopy",
					"L",
					"notify",
					"checker",
				},
				Description: "",
			},
			structSet{
				Name: "Map",
				Fields: []types.StructFieldName{
					"_",
					"m",
				},
				Description: "",
			},
			structSet{
				Name: "Mutex",
				Fields: []types.StructFieldName{
					"_",
					"mu",
				},
				Description: "",
			},
			structSet{
				Name: "Once",
				Fields: []types.StructFieldName{
					"_",
					"done",
					"m",
				},
				Description: "",
			},
			structSet{
				Name: "Pool",
				Fields: []types.StructFieldName{
					"noCopy",
					"local",
					"localSize",
					"victim",
					"victimSize",
					"New",
				},
				Description: "",
			},
			structSet{
				Name: "RWMutex",
				Fields: []types.StructFieldName{
					"w",
					"writerSem",
					"readerSem",
					"readerCount",
					"readerWait",
				},
				Description: "",
			},
			structSet{
				Name: "WaitGroup",
				Fields: []types.StructFieldName{
					"noCopy",
					"state",
					"sema",
				},
				Description: "",
			},
		},
		"pem": []structSet{
			structSet{
				Name: "Block",
				Fields: []types.StructFieldName{
					"Type",
					"Headers",
					"Bytes",
				},
				Description: "",
			},
		},
		"zstd": []structSet{
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"sawFrameHeader",
					"hasChecksum",
					"readOneFrame",
					"frameSizeUnknown",
					"remainingFrameSize",
					"blockOffset",
					"buffer",
					"off",
					"repeatedOffset1",
					"repeatedOffset2",
					"repeatedOffset3",
					"huffmanTable",
					"huffmanTableBits",
					"window",
					"compressedBuf",
					"literals",
					"seqTables",
					"seqTableBits",
					"seqTableBuffers",
					"scratch",
					"fseScratch",
					"checksum",
				},
				Description: "",
			},
		},
		"encodecounter": []structSet{
			structSet{
				Name: "CoverageDataWriter",
				Fields: []types.StructFieldName{
					"stab",
					"w",
					"csh",
					"tmp",
					"cflavor",
					"segs",
					"debug",
				},
				Description: "",
			},
		},
		"pprof": []structSet{
			structSet{
				Name: "LabelSet",
				Fields: []types.StructFieldName{
					"list",
				},
				Description: "",
			},
			structSet{
				Name: "Profile",
				Fields: []types.StructFieldName{
					"name",
					"mu",
					"m",
					"count",
					"write",
				},
				Description: "",
			},
		},
		"fstest": []structSet{
			structSet{
				Name: "MapFile",
				Fields: []types.StructFieldName{
					"Data",
					"Mode",
					"ModTime",
					"Sys",
				},
				Description: "",
			},
		},
		"poll": []structSet{
			structSet{
				Name:        "DeadlineExceededError",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "FD",
				Fields: []types.StructFieldName{
					"fdmu",
					"Sysfd",
					"SysFile",
					"pd",
					"csema",
					"isBlocking",
					"IsStream",
					"ZeroReadIsEOF",
					"isFile",
				},
				Description: "",
			},
			structSet{
				Name: "SysFile",
				Fields: []types.StructFieldName{
					"iovecs",
				},
				Description: "",
			},
		},
		"testenv": []structSet{
			structSet{
				Name: "SpecialBuildTypes",
				Fields: []types.StructFieldName{
					"Cgo",
					"Asan",
					"Msan",
					"Race",
				},
				Description: "",
			},
		},
		"macho": []structSet{
			structSet{
				Name: "Dylib",
				Fields: []types.StructFieldName{
					"LoadBytes",
					"Name",
					"Time",
					"CurrentVersion",
					"CompatVersion",
				},
				Description: "",
			},
			structSet{
				Name: "DylibCmd",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Name",
					"Time",
					"CurrentVersion",
					"CompatVersion",
				},
				Description: "A DylibCmd is a Mach-O load dynamic library command. ",
			},
			structSet{
				Name: "Dysymtab",
				Fields: []types.StructFieldName{
					"LoadBytes",
					"DysymtabCmd",
					"IndirectSyms",
				},
				Description: "",
			},
			structSet{
				Name: "DysymtabCmd",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Ilocalsym",
					"Nlocalsym",
					"Iextdefsym",
					"Nextdefsym",
					"Iundefsym",
					"Nundefsym",
					"Tocoffset",
					"Ntoc",
					"Modtaboff",
					"Nmodtab",
					"Extrefsymoff",
					"Nextrefsyms",
					"Indirectsymoff",
					"Nindirectsyms",
					"Extreloff",
					"Nextrel",
					"Locreloff",
					"Nlocrel",
				},
				Description: "A DysymtabCmd is a Mach-O dynamic symbol table command. ",
			},
			structSet{
				Name: "FatArch",
				Fields: []types.StructFieldName{
					"FatArchHeader",
					"File",
				},
				Description: "",
			},
			structSet{
				Name: "FatArchHeader",
				Fields: []types.StructFieldName{
					"Cpu",
					"SubCpu",
					"Offset",
					"Size",
					"Align",
				},
				Description: "",
			},
			structSet{
				Name: "FatFile",
				Fields: []types.StructFieldName{
					"Magic",
					"Arches",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"ByteOrder",
					"Loads",
					"Sections",
					"Symtab",
					"Dysymtab",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Magic",
					"Cpu",
					"SubCpu",
					"Type",
					"Ncmd",
					"Cmdsz",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "FormatError",
				Fields: []types.StructFieldName{
					"off",
					"msg",
					"val",
				},
				Description: "",
			},
			structSet{
				Name: "Nlist32",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Sect",
					"Desc",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Nlist64",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Sect",
					"Desc",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Regs386",
				Fields: []types.StructFieldName{
					"AX",
					"BX",
					"CX",
					"DX",
					"DI",
					"SI",
					"BP",
					"SP",
					"SS",
					"FLAGS",
					"IP",
					"CS",
					"DS",
					"ES",
					"FS",
					"GS",
				},
				Description: "",
			},
			structSet{
				Name: "RegsAMD64",
				Fields: []types.StructFieldName{
					"AX",
					"BX",
					"CX",
					"DX",
					"DI",
					"SI",
					"BP",
					"SP",
					"R8",
					"R9",
					"R10",
					"R11",
					"R12",
					"R13",
					"R14",
					"R15",
					"IP",
					"FLAGS",
					"CS",
					"FS",
					"GS",
				},
				Description: "",
			},
			structSet{
				Name: "Reloc",
				Fields: []types.StructFieldName{
					"Addr",
					"Value",
					"Type",
					"Len",
					"Pcrel",
					"Extern",
					"Scattered",
				},
				Description: "",
			},
			structSet{
				Name: "Rpath",
				Fields: []types.StructFieldName{
					"LoadBytes",
					"Path",
				},
				Description: "",
			},
			structSet{
				Name: "RpathCmd",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Path",
				},
				Description: "A RpathCmd is a Mach-O rpath command. ",
			},
			structSet{
				Name: "Section",
				Fields: []types.StructFieldName{
					"SectionHeader",
					"Relocs",
					"ReaderAt",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "Section32",
				Fields: []types.StructFieldName{
					"Name",
					"Seg",
					"Addr",
					"Size",
					"Offset",
					"Align",
					"Reloff",
					"Nreloc",
					"Flags",
					"Reserve1",
					"Reserve2",
				},
				Description: "",
			},
			structSet{
				Name: "Section64",
				Fields: []types.StructFieldName{
					"Name",
					"Seg",
					"Addr",
					"Size",
					"Offset",
					"Align",
					"Reloff",
					"Nreloc",
					"Flags",
					"Reserve1",
					"Reserve2",
					"Reserve3",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader",
				Fields: []types.StructFieldName{
					"Name",
					"Seg",
					"Addr",
					"Size",
					"Offset",
					"Align",
					"Reloff",
					"Nreloc",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "Segment",
				Fields: []types.StructFieldName{
					"LoadBytes",
					"SegmentHeader",
					"ReaderAt",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "Segment32",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Name",
					"Addr",
					"Memsz",
					"Offset",
					"Filesz",
					"Maxprot",
					"Prot",
					"Nsect",
					"Flag",
				},
				Description: "A Segment32 is a 32-bit Mach-O segment load command. ",
			},
			structSet{
				Name: "Segment64",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Name",
					"Addr",
					"Memsz",
					"Offset",
					"Filesz",
					"Maxprot",
					"Prot",
					"Nsect",
					"Flag",
				},
				Description: "A Segment64 is a 64-bit Mach-O segment load command. ",
			},
			structSet{
				Name: "SegmentHeader",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Name",
					"Addr",
					"Memsz",
					"Offset",
					"Filesz",
					"Maxprot",
					"Prot",
					"Nsect",
					"Flag",
				},
				Description: "",
			},
			structSet{
				Name: "Symbol",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Sect",
					"Desc",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Symtab",
				Fields: []types.StructFieldName{
					"LoadBytes",
					"SymtabCmd",
					"Syms",
				},
				Description: "",
			},
			structSet{
				Name: "SymtabCmd",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Symoff",
					"Nsyms",
					"Stroff",
					"Strsize",
				},
				Description: "A SymtabCmd is a Mach-O symbol table command. ",
			},
			structSet{
				Name: "Thread",
				Fields: []types.StructFieldName{
					"Cmd",
					"Len",
					"Type",
					"Data",
				},
				Description: "A Thread is a Mach-O thread state command. ",
			},
		},
		"decodemeta": []structSet{
			structSet{
				Name: "CoverageMetaDataDecoder",
				Fields: []types.StructFieldName{
					"r",
					"hdr",
					"strtab",
					"tmp",
					"debug",
				},
				Description: "",
			},
			structSet{
				Name: "CoverageMetaFileReader",
				Fields: []types.StructFieldName{
					"f",
					"hdr",
					"tmp",
					"pkgOffsets",
					"pkgLengths",
					"strtab",
					"fileRdr",
					"fileView",
					"debug",
				},
				Description: "",
			},
		},
		"lazytemplate": []structSet{
			structSet{
				Name: "Template",
				Fields: []types.StructFieldName{
					"name",
					"text",
					"once",
					"tmpl",
				},
				Description: "",
			},
		},
		"example1": []structSet{
			structSet{
				Name: "MyStruct",
				Fields: []types.StructFieldName{
					"MyStructs",
					"MyStruct",
				},
				Description: "",
			},
		},
		"flag": []structSet{
			structSet{
				Name: "Flag",
				Fields: []types.StructFieldName{
					"Name",
					"Usage",
					"Value",
					"DefValue",
				},
				Description: "",
			},
			structSet{
				Name: "FlagSet",
				Fields: []types.StructFieldName{
					"Usage",
					"name",
					"parsed",
					"actual",
					"formal",
					"args",
					"errorHandling",
					"output",
					"undef",
				},
				Description: "",
			},
		},
		"scanner": []structSet{
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Pos",
					"Msg",
				},
				Description: "",
			},
			structSet{
				Name: "Scanner",
				Fields: []types.StructFieldName{
					"file",
					"dir",
					"src",
					"err",
					"mode",
					"ch",
					"offset",
					"rdOffset",
					"lineOffset",
					"insertSemi",
					"nlPos",
					"ErrorCount",
				},
				Description: "",
			},
			structSet{
				Name: "Position",
				Fields: []types.StructFieldName{
					"Filename",
					"Offset",
					"Line",
					"Column",
				},
				Description: "",
			},
			structSet{
				Name: "Scanner",
				Fields: []types.StructFieldName{
					"src",
					"srcBuf",
					"srcPos",
					"srcEnd",
					"srcBufOffset",
					"line",
					"column",
					"lastLineLen",
					"lastCharLen",
					"tokBuf",
					"tokPos",
					"tokEnd",
					"ch",
					"Error",
					"ErrorCount",
					"Mode",
					"Whitespace",
					"IsIdentRune",
					"Position",
				},
				Description: "",
			},
		},
		"buildcfg": []structSet{
			structSet{
				Name: "ExperimentFlags",
				Fields: []types.StructFieldName{
					"Flags",
					"baseline",
				},
				Description: "",
			},
			structSet{
				Name: "Goarm64Features",
				Fields: []types.StructFieldName{
					"Version",
					"LSE",
					"Crypto",
				},
				Description: "",
			},
			structSet{
				Name: "GoarmFeatures",
				Fields: []types.StructFieldName{
					"Version",
					"SoftFloat",
				},
				Description: "",
			},
		},
		"types": []structSet{
			structSet{
				Name: "Alias",
				Fields: []types.StructFieldName{
					"obj",
					"orig",
					"tparams",
					"targs",
					"fromRHS",
					"actual",
				},
				Description: "",
			},
			structSet{
				Name: "ArgumentError",
				Fields: []types.StructFieldName{
					"Index",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "Array",
				Fields: []types.StructFieldName{
					"len",
					"elem",
				},
				Description: "",
			},
			structSet{
				Name: "Basic",
				Fields: []types.StructFieldName{
					"kind",
					"info",
					"name",
				},
				Description: "",
			},
			structSet{
				Name: "Builtin",
				Fields: []types.StructFieldName{
					"object",
					"id",
				},
				Description: "",
			},
			structSet{
				Name: "Chan",
				Fields: []types.StructFieldName{
					"dir",
					"elem",
				},
				Description: "",
			},
			structSet{
				Name: "Checker",
				Fields: []types.StructFieldName{
					"conf",
					"ctxt",
					"fset",
					"pkg",
					"Info",
					"nextID",
					"objMap",
					"impMap",
					"pkgPathMap",
					"seenPkgMap",
					"files",
					"versions",
					"imports",
					"dotImportMap",
					"brokenAliases",
					"unionTypeSets",
					"usedVars",
					"usedPkgNames",
					"mono",
					"firstErr",
					"methods",
					"untyped",
					"delayed",
					"objPath",
					"cleaners",
					"environment",
					"posStack",
					"indent",
				},
				Description: "",
			},
			structSet{
				Name: "Config",
				Fields: []types.StructFieldName{
					"Context",
					"GoVersion",
					"IgnoreFuncBodies",
					"FakeImportC",
					"go115UsesCgo",
					"_Trace",
					"Error",
					"Importer",
					"Sizes",
					"DisableUnusedImportCheck",
					"_ErrorURL",
					"_EnableAlias",
				},
				Description: "",
			},
			structSet{
				Name: "Const",
				Fields: []types.StructFieldName{
					"object",
					"val",
				},
				Description: "",
			},
			structSet{
				Name: "Context",
				Fields: []types.StructFieldName{
					"mu",
					"typeMap",
					"nextID",
					"originIDs",
				},
				Description: "",
			},
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Fset",
					"Pos",
					"Msg",
					"Soft",
					"go116code",
					"go116start",
					"go116end",
				},
				Description: "",
			},
			structSet{
				Name: "Func",
				Fields: []types.StructFieldName{
					"object",
					"hasPtrRecv_",
					"origin",
				},
				Description: "",
			},
			structSet{
				Name: "Info",
				Fields: []types.StructFieldName{
					"Types",
					"Instances",
					"Defs",
					"Uses",
					"Implicits",
					"Selections",
					"Scopes",
					"InitOrder",
					"FileVersions",
				},
				Description: "",
			},
			structSet{
				Name: "Initializer",
				Fields: []types.StructFieldName{
					"Lhs",
					"Rhs",
				},
				Description: "",
			},
			structSet{
				Name: "Instance",
				Fields: []types.StructFieldName{
					"TypeArgs",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Interface",
				Fields: []types.StructFieldName{
					"check",
					"methods",
					"embeddeds",
					"embedPos",
					"implicit",
					"complete",
					"tset",
				},
				Description: "",
			},
			structSet{
				Name: "Label",
				Fields: []types.StructFieldName{
					"object",
					"used",
				},
				Description: "",
			},
			structSet{
				Name: "Map",
				Fields: []types.StructFieldName{
					"key",
					"elem",
				},
				Description: "",
			},
			structSet{
				Name: "MethodSet",
				Fields: []types.StructFieldName{
					"list",
				},
				Description: "",
			},
			structSet{
				Name: "Named",
				Fields: []types.StructFieldName{
					"check",
					"obj",
					"fromRHS",
					"inst",
					"mu",
					"state_",
					"underlying",
					"tparams",
					"methods",
					"loader",
				},
				Description: "",
			},
			structSet{
				Name: "Nil",
				Fields: []types.StructFieldName{
					"object",
				},
				Description: "",
			},
			structSet{
				Name: "Package",
				Fields: []types.StructFieldName{
					"path",
					"name",
					"scope",
					"imports",
					"complete",
					"fake",
					"cgo",
					"goVersion",
				},
				Description: "",
			},
			structSet{
				Name: "PkgName",
				Fields: []types.StructFieldName{
					"object",
					"imported",
				},
				Description: "",
			},
			structSet{
				Name: "Pointer",
				Fields: []types.StructFieldName{
					"base",
				},
				Description: "",
			},
			structSet{
				Name: "Selection",
				Fields: []types.StructFieldName{
					"kind",
					"recv",
					"obj",
					"index",
					"indirect",
				},
				Description: "",
			},
			structSet{
				Name: "Slice",
				Fields: []types.StructFieldName{
					"elem",
				},
				Description: "",
			},
			structSet{
				Name: "StdSizes",
				Fields: []types.StructFieldName{
					"WordSize",
					"MaxAlign",
				},
				Description: "",
			},
			structSet{
				Name: "Struct",
				Fields: []types.StructFieldName{
					"fields",
					"tags",
				},
				Description: "",
			},
			structSet{
				Name: "Tuple",
				Fields: []types.StructFieldName{
					"vars",
				},
				Description: "",
			},
			structSet{
				Name: "TypeAndValue",
				Fields: []types.StructFieldName{
					"mode",
					"Type",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "TypeList",
				Fields: []types.StructFieldName{
					"types",
				},
				Description: "",
			},
			structSet{
				Name: "TypeName",
				Fields: []types.StructFieldName{
					"object",
				},
				Description: "",
			},
			structSet{
				Name: "TypeParam",
				Fields: []types.StructFieldName{
					"check",
					"id",
					"obj",
					"index",
					"bound",
				},
				Description: "",
			},
			structSet{
				Name: "TypeParamList",
				Fields: []types.StructFieldName{
					"tparams",
				},
				Description: "",
			},
			structSet{
				Name: "Union",
				Fields: []types.StructFieldName{
					"terms",
				},
				Description: "",
			},
			structSet{
				Name: "Var",
				Fields: []types.StructFieldName{
					"object",
					"origin",
					"kind",
					"embedded",
				},
				Description: "",
			},
		},
		"tracev1": []structSet{
			structSet{
				Name: "Event",
				Fields: []types.StructFieldName{
					"Ts",
					"G",
					"Args",
					"StkID",
					"P",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Events",
				Fields: []types.StructFieldName{
					"n",
					"buckets",
					"off",
				},
				Description: "",
			},
			structSet{
				Name: "Frame",
				Fields: []types.StructFieldName{
					"PC",
					"Fn",
					"File",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "Trace",
				Fields: []types.StructFieldName{
					"Version",
					"Events",
					"Stacks",
					"PCs",
					"Strings",
					"InlineStrings",
				},
				Description: "",
			},
		},
		"quick": []structSet{
			structSet{
				Name: "CheckEqualError",
				Fields: []types.StructFieldName{
					"CheckError",
					"Out1",
					"Out2",
				},
				Description: "",
			},
			structSet{
				Name: "CheckError",
				Fields: []types.StructFieldName{
					"Count",
					"In",
				},
				Description: "",
			},
			structSet{
				Name: "Config",
				Fields: []types.StructFieldName{
					"MaxCount",
					"MaxCountScale",
					"Rand",
					"Values",
				},
				Description: "",
			},
		},
		"tls": []structSet{
			structSet{
				Name: "Certificate",
				Fields: []types.StructFieldName{
					"Certificate",
					"PrivateKey",
					"SupportedSignatureAlgorithms",
					"OCSPStaple",
					"SignedCertificateTimestamps",
					"Leaf",
				},
				Description: "",
			},
			structSet{
				Name: "CertificateRequestInfo",
				Fields: []types.StructFieldName{
					"AcceptableCAs",
					"SignatureSchemes",
					"Version",
					"ctx",
				},
				Description: "",
			},
			structSet{
				Name: "CertificateVerificationError",
				Fields: []types.StructFieldName{
					"UnverifiedCertificates",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "CipherSuite",
				Fields: []types.StructFieldName{
					"ID",
					"Name",
					"SupportedVersions",
					"Insecure",
				},
				Description: "",
			},
			structSet{
				Name: "ClientHelloInfo",
				Fields: []types.StructFieldName{
					"CipherSuites",
					"ServerName",
					"SupportedCurves",
					"SupportedPoints",
					"SignatureSchemes",
					"SupportedProtos",
					"SupportedVersions",
					"Extensions",
					"Conn",
					"config",
					"ctx",
				},
				Description: "",
			},
			structSet{
				Name: "ClientSessionState",
				Fields: []types.StructFieldName{
					"session",
				},
				Description: "",
			},
			structSet{
				Name: "Config",
				Fields: []types.StructFieldName{
					"Rand",
					"Time",
					"Certificates",
					"NameToCertificate",
					"GetCertificate",
					"GetClientCertificate",
					"GetConfigForClient",
					"VerifyPeerCertificate",
					"VerifyConnection",
					"RootCAs",
					"NextProtos",
					"ServerName",
					"ClientAuth",
					"ClientCAs",
					"InsecureSkipVerify",
					"CipherSuites",
					"PreferServerCipherSuites",
					"SessionTicketsDisabled",
					"SessionTicketKey",
					"ClientSessionCache",
					"UnwrapSession",
					"WrapSession",
					"MinVersion",
					"MaxVersion",
					"CurvePreferences",
					"DynamicRecordSizingDisabled",
					"Renegotiation",
					"KeyLogWriter",
					"EncryptedClientHelloConfigList",
					"EncryptedClientHelloRejectionVerify",
					"GetEncryptedClientHelloKeys",
					"EncryptedClientHelloKeys",
					"mutex",
					"sessionTicketKeys",
					"autoSessionTicketKeys",
				},
				Description: "",
			},
			structSet{
				Name: "Conn",
				Fields: []types.StructFieldName{
					"conn",
					"isClient",
					"handshakeFn",
					"quic",
					"isHandshakeComplete",
					"handshakeMutex",
					"handshakeErr",
					"vers",
					"haveVers",
					"config",
					"handshakes",
					"extMasterSecret",
					"didResume",
					"didHRR",
					"cipherSuite",
					"curveID",
					"peerSigAlg",
					"ocspResponse",
					"scts",
					"peerCertificates",
					"verifiedChains",
					"serverName",
					"secureRenegotiation",
					"ekm",
					"resumptionSecret",
					"echAccepted",
					"ticketKeys",
					"clientFinishedIsFirst",
					"closeNotifyErr",
					"closeNotifySent",
					"clientFinished",
					"serverFinished",
					"clientProtocol",
					"in",
					"out",
					"rawInput",
					"input",
					"hand",
					"buffering",
					"sendBuf",
					"bytesSent",
					"packetsSent",
					"retryCount",
					"activeCall",
					"tmp",
				},
				Description: "",
			},
			structSet{
				Name: "ConnectionState",
				Fields: []types.StructFieldName{
					"Version",
					"HandshakeComplete",
					"DidResume",
					"CipherSuite",
					"CurveID",
					"NegotiatedProtocol",
					"NegotiatedProtocolIsMutual",
					"ServerName",
					"PeerCertificates",
					"VerifiedChains",
					"SignedCertificateTimestamps",
					"OCSPResponse",
					"TLSUnique",
					"ECHAccepted",
					"ekm",
					"testingOnlyDidHRR",
					"testingOnlyPeerSignatureAlgorithm",
				},
				Description: "",
			},
			structSet{
				Name: "Dialer",
				Fields: []types.StructFieldName{
					"NetDialer",
					"Config",
				},
				Description: "",
			},
			structSet{
				Name: "ECHRejectionError",
				Fields: []types.StructFieldName{
					"RetryConfigList",
				},
				Description: "",
			},
			structSet{
				Name: "EncryptedClientHelloKey",
				Fields: []types.StructFieldName{
					"Config",
					"PrivateKey",
					"SendAsRetry",
				},
				Description: "",
			},
			structSet{
				Name: "QUICConfig",
				Fields: []types.StructFieldName{
					"TLSConfig",
					"EnableSessionEvents",
				},
				Description: "",
			},
			structSet{
				Name: "QUICConn",
				Fields: []types.StructFieldName{
					"conn",
					"sessionTicketSent",
				},
				Description: "",
			},
			structSet{
				Name: "QUICEvent",
				Fields: []types.StructFieldName{
					"Kind",
					"Level",
					"Data",
					"Suite",
					"SessionState",
				},
				Description: "",
			},
			structSet{
				Name: "QUICSessionTicketOptions",
				Fields: []types.StructFieldName{
					"EarlyData",
					"Extra",
				},
				Description: "",
			},
			structSet{
				Name: "RecordHeaderError",
				Fields: []types.StructFieldName{
					"Msg",
					"RecordHeader",
					"Conn",
				},
				Description: "",
			},
			structSet{
				Name: "SessionState",
				Fields: []types.StructFieldName{
					"Extra",
					"EarlyData",
					"version",
					"isClient",
					"cipherSuite",
					"createdAt",
					"secret",
					"extMasterSecret",
					"peerCertificates",
					"ocspResponse",
					"scts",
					"verifiedChains",
					"alpnProtocol",
					"useBy",
					"ageAdd",
					"ticket",
					"curveID",
				},
				Description: "",
			},
		},
		"io": []structSet{
			structSet{
				Name: "LimitedReader",
				Fields: []types.StructFieldName{
					"R",
					"N",
				},
				Description: "",
			},
			structSet{
				Name: "OffsetWriter",
				Fields: []types.StructFieldName{
					"w",
					"base",
					"off",
				},
				Description: "",
			},
			structSet{
				Name: "PipeReader",
				Fields: []types.StructFieldName{
					"pipe",
				},
				Description: "",
			},
			structSet{
				Name: "PipeWriter",
				Fields: []types.StructFieldName{
					"r",
				},
				Description: "",
			},
			structSet{
				Name: "SectionReader",
				Fields: []types.StructFieldName{
					"r",
					"base",
					"off",
					"limit",
					"n",
				},
				Description: "",
			},
		},
		"drbg": []structSet{
			structSet{
				Name: "Counter",
				Fields: []types.StructFieldName{
					"c",
					"reseedCounter",
				},
				Description: "",
			},
		},
		"sql": []structSet{
			structSet{
				Name: "ColumnType",
				Fields: []types.StructFieldName{
					"name",
					"hasNullable",
					"hasLength",
					"hasPrecisionScale",
					"nullable",
					"length",
					"databaseType",
					"precision",
					"scale",
					"scanType",
				},
				Description: "",
			},
			structSet{
				Name: "DB",
				Fields: []types.StructFieldName{
					"waitDuration",
					"connector",
					"numClosed",
					"mu",
					"freeConn",
					"connRequests",
					"numOpen",
					"openerCh",
					"closed",
					"dep",
					"lastPut",
					"maxIdleCount",
					"maxOpen",
					"maxLifetime",
					"maxIdleTime",
					"cleanerCh",
					"waitCount",
					"maxIdleClosed",
					"maxIdleTimeClosed",
					"maxLifetimeClosed",
					"stop",
				},
				Description: "",
			},
			structSet{
				Name: "DBStats",
				Fields: []types.StructFieldName{
					"MaxOpenConnections",
					"OpenConnections",
					"InUse",
					"Idle",
					"WaitCount",
					"WaitDuration",
					"MaxIdleClosed",
					"MaxIdleTimeClosed",
					"MaxLifetimeClosed",
				},
				Description: "",
			},
			structSet{
				Name: "NamedArg",
				Fields: []types.StructFieldName{
					"_NamedFieldsRequired",
					"Name",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Null",
				Fields: []types.StructFieldName{
					"V",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullBool",
				Fields: []types.StructFieldName{
					"Bool",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullByte",
				Fields: []types.StructFieldName{
					"Byte",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullFloat64",
				Fields: []types.StructFieldName{
					"Float64",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullInt16",
				Fields: []types.StructFieldName{
					"Int16",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullInt32",
				Fields: []types.StructFieldName{
					"Int32",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullInt64",
				Fields: []types.StructFieldName{
					"Int64",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullString",
				Fields: []types.StructFieldName{
					"String",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "NullTime",
				Fields: []types.StructFieldName{
					"Time",
					"Valid",
				},
				Description: "",
			},
			structSet{
				Name: "Out",
				Fields: []types.StructFieldName{
					"_NamedFieldsRequired",
					"Dest",
					"In",
				},
				Description: "",
			},
			structSet{
				Name: "Row",
				Fields: []types.StructFieldName{
					"err",
					"rows",
				},
				Description: "",
			},
			structSet{
				Name: "Rows",
				Fields: []types.StructFieldName{
					"dc",
					"releaseConn",
					"rowsi",
					"cancel",
					"closeStmt",
					"contextDone",
					"closemu",
					"lasterr",
					"closed",
					"closemuScanHold",
					"hitEOF",
					"lastcols",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "Tx",
				Fields: []types.StructFieldName{
					"db",
					"closemu",
					"dc",
					"txi",
					"releaseConn",
					"done",
					"keepConnOnRollback",
					"stmts",
					"cancel",
					"ctx",
				},
				Description: "",
			},
			structSet{
				Name: "TxOptions",
				Fields: []types.StructFieldName{
					"Isolation",
					"ReadOnly",
				},
				Description: "",
			},
		},
		"syscall": []structSet{
			structSet{
				Name: "BpfHdr",
				Fields: []types.StructFieldName{
					"Tstamp",
					"Caplen",
					"Datalen",
					"Hdrlen",
					"Pad_cgo_0",
				},
				Description: "",
			},
			structSet{
				Name: "BpfInsn",
				Fields: []types.StructFieldName{
					"Code",
					"Jt",
					"Jf",
					"K",
				},
				Description: "",
			},
			structSet{
				Name: "BpfProgram",
				Fields: []types.StructFieldName{
					"Len",
					"Pad_cgo_0",
					"Insns",
				},
				Description: "",
			},
			structSet{
				Name: "BpfStat",
				Fields: []types.StructFieldName{
					"Recv",
					"Drop",
				},
				Description: "",
			},
			structSet{
				Name: "BpfVersion",
				Fields: []types.StructFieldName{
					"Major",
					"Minor",
				},
				Description: "",
			},
			structSet{
				Name: "Cmsghdr",
				Fields: []types.StructFieldName{
					"Len",
					"Level",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Credential",
				Fields: []types.StructFieldName{
					"Uid",
					"Gid",
					"Groups",
					"NoSetGroups",
				},
				Description: "",
			},
			structSet{
				Name: "Dirent",
				Fields: []types.StructFieldName{
					"Ino",
					"Seekoff",
					"Reclen",
					"Namlen",
					"Type",
					"Name",
					"Pad_cgo_0",
				},
				Description: "",
			},
			structSet{
				Name: "Fbootstraptransfer_t",
				Fields: []types.StructFieldName{
					"Offset",
					"Length",
					"Buffer",
				},
				Description: "",
			},
			structSet{
				Name: "FdSet",
				Fields: []types.StructFieldName{
					"Bits",
				},
				Description: "",
			},
			structSet{
				Name: "Flock_t",
				Fields: []types.StructFieldName{
					"Start",
					"Len",
					"Pid",
					"Type",
					"Whence",
				},
				Description: "",
			},
			structSet{
				Name: "Fsid",
				Fields: []types.StructFieldName{
					"Val",
				},
				Description: "",
			},
			structSet{
				Name: "Fstore_t",
				Fields: []types.StructFieldName{
					"Flags",
					"Posmode",
					"Offset",
					"Length",
					"Bytesalloc",
				},
				Description: "",
			},
			structSet{
				Name: "ICMPv6Filter",
				Fields: []types.StructFieldName{
					"Filt",
				},
				Description: "",
			},
			structSet{
				Name: "IPMreq",
				Fields: []types.StructFieldName{
					"Multiaddr",
					"Interface",
				},
				Description: "",
			},
			structSet{
				Name: "IPv6MTUInfo",
				Fields: []types.StructFieldName{
					"Addr",
					"Mtu",
				},
				Description: "",
			},
			structSet{
				Name: "IPv6Mreq",
				Fields: []types.StructFieldName{
					"Multiaddr",
					"Interface",
				},
				Description: "",
			},
			structSet{
				Name: "IfData",
				Fields: []types.StructFieldName{
					"Type",
					"Typelen",
					"Physical",
					"Addrlen",
					"Hdrlen",
					"Recvquota",
					"Xmitquota",
					"Unused1",
					"Mtu",
					"Metric",
					"Baudrate",
					"Ipackets",
					"Ierrors",
					"Opackets",
					"Oerrors",
					"Collisions",
					"Ibytes",
					"Obytes",
					"Imcasts",
					"Omcasts",
					"Iqdrops",
					"Noproto",
					"Recvtiming",
					"Xmittiming",
					"Lastchange",
					"Unused2",
					"Hwassist",
					"Reserved1",
					"Reserved2",
				},
				Description: "",
			},
			structSet{
				Name: "IfMsghdr",
				Fields: []types.StructFieldName{
					"Msglen",
					"Version",
					"Type",
					"Addrs",
					"Flags",
					"Index",
					"Pad_cgo_0",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "IfaMsghdr",
				Fields: []types.StructFieldName{
					"Msglen",
					"Version",
					"Type",
					"Addrs",
					"Flags",
					"Index",
					"Pad_cgo_0",
					"Metric",
				},
				Description: "",
			},
			structSet{
				Name: "IfmaMsghdr",
				Fields: []types.StructFieldName{
					"Msglen",
					"Version",
					"Type",
					"Addrs",
					"Flags",
					"Index",
					"Pad_cgo_0",
				},
				Description: "",
			},
			structSet{
				Name: "IfmaMsghdr2",
				Fields: []types.StructFieldName{
					"Msglen",
					"Version",
					"Type",
					"Addrs",
					"Flags",
					"Index",
					"Pad_cgo_0",
					"Refcount",
				},
				Description: "",
			},
			structSet{
				Name: "Inet4Pktinfo",
				Fields: []types.StructFieldName{
					"Ifindex",
					"Spec_dst",
					"Addr",
				},
				Description: "",
			},
			structSet{
				Name: "Inet6Pktinfo",
				Fields: []types.StructFieldName{
					"Addr",
					"Ifindex",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceAddrMessage",
				Fields: []types.StructFieldName{
					"Header",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceMessage",
				Fields: []types.StructFieldName{
					"Header",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceMulticastAddrMessage",
				Fields: []types.StructFieldName{
					"Header",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "Iovec",
				Fields: []types.StructFieldName{
					"Base",
					"Len",
				},
				Description: "",
			},
			structSet{
				Name: "Kevent_t",
				Fields: []types.StructFieldName{
					"Ident",
					"Filter",
					"Flags",
					"Fflags",
					"Data",
					"Udata",
				},
				Description: "",
			},
			structSet{
				Name: "Linger",
				Fields: []types.StructFieldName{
					"Onoff",
					"Linger",
				},
				Description: "",
			},
			structSet{
				Name: "Log2phys_t",
				Fields: []types.StructFieldName{
					"Flags",
					"Contigbytes",
					"Devoffset",
				},
				Description: "",
			},
			structSet{
				Name: "Msghdr",
				Fields: []types.StructFieldName{
					"Name",
					"Namelen",
					"Pad_cgo_0",
					"Iov",
					"Iovlen",
					"Pad_cgo_1",
					"Control",
					"Controllen",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "ProcAttr",
				Fields: []types.StructFieldName{
					"Dir",
					"Env",
					"Files",
					"Sys",
				},
				Description: "",
			},
			structSet{
				Name: "Radvisory_t",
				Fields: []types.StructFieldName{
					"Offset",
					"Count",
					"Pad_cgo_0",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddr",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddrAny",
				Fields: []types.StructFieldName{
					"Addr",
					"Pad",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddrDatalink",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Index",
					"Type",
					"Nlen",
					"Alen",
					"Slen",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddrInet4",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Port",
					"Addr",
					"Zero",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddrInet6",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Port",
					"Flowinfo",
					"Addr",
					"Scope_id",
				},
				Description: "",
			},
			structSet{
				Name: "RawSockaddrUnix",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Path",
				},
				Description: "",
			},
			structSet{
				Name: "Rlimit",
				Fields: []types.StructFieldName{
					"Cur",
					"Max",
				},
				Description: "",
			},
			structSet{
				Name: "RouteMessage",
				Fields: []types.StructFieldName{
					"Header",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "RtMetrics",
				Fields: []types.StructFieldName{
					"Locks",
					"Mtu",
					"Hopcount",
					"Expire",
					"Recvpipe",
					"Sendpipe",
					"Ssthresh",
					"Rtt",
					"Rttvar",
					"Pksent",
					"Filler",
				},
				Description: "",
			},
			structSet{
				Name: "RtMsghdr",
				Fields: []types.StructFieldName{
					"Msglen",
					"Version",
					"Type",
					"Index",
					"Pad_cgo_0",
					"Flags",
					"Addrs",
					"Pid",
					"Seq",
					"Errno",
					"Use",
					"Inits",
					"Rmx",
				},
				Description: "",
			},
			structSet{
				Name: "Rusage",
				Fields: []types.StructFieldName{
					"Utime",
					"Stime",
					"Maxrss",
					"Ixrss",
					"Idrss",
					"Isrss",
					"Minflt",
					"Majflt",
					"Nswap",
					"Inblock",
					"Oublock",
					"Msgsnd",
					"Msgrcv",
					"Nsignals",
					"Nvcsw",
					"Nivcsw",
				},
				Description: "",
			},
			structSet{
				Name: "SockaddrDatalink",
				Fields: []types.StructFieldName{
					"Len",
					"Family",
					"Index",
					"Type",
					"Nlen",
					"Alen",
					"Slen",
					"Data",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "SockaddrInet4",
				Fields: []types.StructFieldName{
					"Port",
					"Addr",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "SockaddrInet6",
				Fields: []types.StructFieldName{
					"Port",
					"ZoneId",
					"Addr",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "SockaddrUnix",
				Fields: []types.StructFieldName{
					"Name",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "SocketControlMessage",
				Fields: []types.StructFieldName{
					"Header",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "Stat_t",
				Fields: []types.StructFieldName{
					"Dev",
					"Mode",
					"Nlink",
					"Ino",
					"Uid",
					"Gid",
					"Rdev",
					"Pad_cgo_0",
					"Atimespec",
					"Mtimespec",
					"Ctimespec",
					"Birthtimespec",
					"Size",
					"Blocks",
					"Blksize",
					"Flags",
					"Gen",
					"Lspare",
					"Qspare",
				},
				Description: "",
			},
			structSet{
				Name: "Statfs_t",
				Fields: []types.StructFieldName{
					"Bsize",
					"Iosize",
					"Blocks",
					"Bfree",
					"Bavail",
					"Files",
					"Ffree",
					"Fsid",
					"Owner",
					"Type",
					"Flags",
					"Fssubtype",
					"Fstypename",
					"Mntonname",
					"Mntfromname",
					"Reserved",
				},
				Description: "",
			},
			structSet{
				Name: "SysProcAttr",
				Fields: []types.StructFieldName{
					"Chroot",
					"Credential",
					"Ptrace",
					"Setsid",
					"Setpgid",
					"Setctty",
					"Noctty",
					"Ctty",
					"Foreground",
					"Pgid",
				},
				Description: "",
			},
			structSet{
				Name: "Termios",
				Fields: []types.StructFieldName{
					"Iflag",
					"Oflag",
					"Cflag",
					"Lflag",
					"Cc",
					"Pad_cgo_0",
					"Ispeed",
					"Ospeed",
				},
				Description: "",
			},
			structSet{
				Name: "Timespec",
				Fields: []types.StructFieldName{
					"Sec",
					"Nsec",
				},
				Description: "",
			},
			structSet{
				Name: "Timeval",
				Fields: []types.StructFieldName{
					"Sec",
					"Usec",
					"Pad_cgo_0",
				},
				Description: "",
			},
			structSet{
				Name: "Timeval32",
				Fields: []types.StructFieldName{
					"Sec",
					"Usec",
				},
				Description: "",
			},
		},
		"zlib": []structSet{
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"w",
					"level",
					"dict",
					"compressor",
					"digest",
					"err",
					"scratch",
					"wroteHeader",
				},
				Description: "",
			},
		},
		"testing": []structSet{
			structSet{
				Name: "B",
				Fields: []types.StructFieldName{
					"common",
					"importPath",
					"bstate",
					"N",
					"previousN",
					"previousDuration",
					"benchFunc",
					"benchTime",
					"bytes",
					"missingBytes",
					"timerOn",
					"showAllocResult",
					"result",
					"parallelism",
					"startAllocs",
					"startBytes",
					"netAllocs",
					"netBytes",
					"extra",
					"loop",
				},
				Description: "",
			},
			structSet{
				Name: "BenchmarkResult",
				Fields: []types.StructFieldName{
					"N",
					"T",
					"Bytes",
					"MemAllocs",
					"MemBytes",
					"Extra",
				},
				Description: "",
			},
			structSet{
				Name: "Cover",
				Fields: []types.StructFieldName{
					"Mode",
					"Counters",
					"Blocks",
					"CoveredPackages",
				},
				Description: "",
			},
			structSet{
				Name: "CoverBlock",
				Fields: []types.StructFieldName{
					"Line0",
					"Col0",
					"Line1",
					"Col1",
					"Stmts",
				},
				Description: "",
			},
			structSet{
				Name: "F",
				Fields: []types.StructFieldName{
					"common",
					"fstate",
					"tstate",
					"inFuzzFn",
					"corpus",
					"result",
					"fuzzCalled",
				},
				Description: "",
			},
			structSet{
				Name: "InternalBenchmark",
				Fields: []types.StructFieldName{
					"Name",
					"F",
				},
				Description: "",
			},
			structSet{
				Name: "InternalExample",
				Fields: []types.StructFieldName{
					"Name",
					"F",
					"Output",
					"Unordered",
				},
				Description: "",
			},
			structSet{
				Name: "InternalFuzzTarget",
				Fields: []types.StructFieldName{
					"Name",
					"Fn",
				},
				Description: "",
			},
			structSet{
				Name: "InternalTest",
				Fields: []types.StructFieldName{
					"Name",
					"F",
				},
				Description: "",
			},
			structSet{
				Name: "M",
				Fields: []types.StructFieldName{
					"deps",
					"tests",
					"benchmarks",
					"fuzzTargets",
					"examples",
					"timer",
					"afterOnce",
					"numRun",
					"exitCode",
				},
				Description: "",
			},
			structSet{
				Name: "PB",
				Fields: []types.StructFieldName{
					"globalN",
					"grain",
					"cache",
					"bN",
				},
				Description: "",
			},
			structSet{
				Name: "T",
				Fields: []types.StructFieldName{
					"common",
					"denyParallel",
					"tstate",
				},
				Description: "",
			},
		},
		"hpke": []structSet{
			structSet{
				Name: "Recipient",
				Fields: []types.StructFieldName{
					"context",
				},
				Description: "",
			},
			structSet{
				Name: "Sender",
				Fields: []types.StructFieldName{
					"context",
				},
				Description: "",
			},
		},
		"fiat": []structSet{
			structSet{
				Name: "P224Element",
				Fields: []types.StructFieldName{
					"x",
				},
				Description: "",
			},
			structSet{
				Name: "P256Element",
				Fields: []types.StructFieldName{
					"x",
				},
				Description: "",
			},
			structSet{
				Name: "P384Element",
				Fields: []types.StructFieldName{
					"x",
				},
				Description: "",
			},
			structSet{
				Name: "P521Element",
				Fields: []types.StructFieldName{
					"x",
				},
				Description: "",
			},
		},
		"zip": []structSet{
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"zip",
					"zipr",
					"headerOffset",
					"zip64",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Name",
					"Comment",
					"NonUTF8",
					"CreatorVersion",
					"ReaderVersion",
					"Flags",
					"Method",
					"Modified",
					"ModifiedTime",
					"ModifiedDate",
					"CRC32",
					"CompressedSize",
					"UncompressedSize",
					"CompressedSize64",
					"UncompressedSize64",
					"Extra",
					"ExternalAttrs",
				},
				Description: "",
			},
			structSet{
				Name: "ReadCloser",
				Fields: []types.StructFieldName{
					"f",
					"Reader",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"File",
					"Comment",
					"decompressors",
					"baseOffset",
					"fileListOnce",
					"fileList",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"cw",
					"dir",
					"last",
					"closed",
					"compressors",
					"comment",
					"testHookCloseSizeOffset",
				},
				Description: "",
			},
		},
		"lzw": []structSet{
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"bits",
					"nBits",
					"width",
					"read",
					"litWidth",
					"err",
					"clear",
					"eof",
					"hi",
					"overflow",
					"last",
					"suffix",
					"prefix",
					"output",
					"o",
					"toRead",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"w",
					"litWidth",
					"order",
					"write",
					"nBits",
					"width",
					"bits",
					"hi",
					"overflow",
					"savedCode",
					"err",
					"table",
				},
				Description: "",
			},
		},
		"exec": []structSet{
			structSet{
				Name: "Cmd",
				Fields: []types.StructFieldName{
					"Path",
					"Args",
					"Env",
					"Dir",
					"Stdin",
					"Stdout",
					"Stderr",
					"ExtraFiles",
					"SysProcAttr",
					"Process",
					"ProcessState",
					"ctx",
					"Err",
					"Cancel",
					"WaitDelay",
					"childIOFiles",
					"parentIOPipes",
					"goroutine",
					"goroutineErr",
					"ctxResult",
					"createdByStack",
					"lookPathErr",
					"cachedLookExtensions",
				},
				Description: "",
			},
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Name",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "ExitError",
				Fields: []types.StructFieldName{
					"ProcessState",
					"Stderr",
				},
				Description: "",
			},
		},
		"csv": []structSet{
			structSet{
				Name: "ParseError",
				Fields: []types.StructFieldName{
					"StartLine",
					"Line",
					"Column",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"Comma",
					"Comment",
					"FieldsPerRecord",
					"LazyQuotes",
					"TrimLeadingSpace",
					"ReuseRecord",
					"TrailingComma",
					"r",
					"numLine",
					"offset",
					"rawBuffer",
					"recordBuffer",
					"fieldIndexes",
					"fieldPositions",
					"lastRecord",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"Comma",
					"UseCRLF",
					"w",
				},
				Description: "",
			},
		},
		"syslog": []structSet{
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"priority",
					"tag",
					"hostname",
					"network",
					"raddr",
					"mu",
					"conn",
				},
				Description: "",
			},
		},
		"dsa": []structSet{
			structSet{
				Name: "Parameters",
				Fields: []types.StructFieldName{
					"P",
					"Q",
					"G",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"PublicKey",
					"X",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKey",
				Fields: []types.StructFieldName{
					"Parameters",
					"Y",
				},
				Description: "",
			},
		},
		"tracev2": []structSet{
			structSet{
				Name: "EventSpec",
				Fields: []types.StructFieldName{
					"Name",
					"Args",
					"StringIDs",
					"StackIDs",
					"StartEv",
					"IsTimedEvent",
					"HasData",
					"IsStack",
					"Experiment",
				},
				Description: "",
			},
		},
		"fmtsort": []structSet{
			structSet{
				Name: "KeyValue",
				Fields: []types.StructFieldName{
					"Key",
					"Value",
				},
				Description: "",
			},
		},
		"flate": []structSet{
			structSet{
				Name: "ReadError",
				Fields: []types.StructFieldName{
					"Offset",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "WriteError",
				Fields: []types.StructFieldName{
					"Offset",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"d",
					"dict",
				},
				Description: "",
			},
		},
		"fips140cache": []structSet{
			structSet{
				Name: "Cache",
				Fields: []types.StructFieldName{
					"m",
				},
				Description: "",
			},
		},
		"debug": []structSet{
			structSet{
				Name: "BuildInfo",
				Fields: []types.StructFieldName{
					"GoVersion",
					"Path",
					"Main",
					"Deps",
					"Settings",
				},
				Description: "",
			},
			structSet{
				Name: "BuildSetting",
				Fields: []types.StructFieldName{
					"Key",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name:        "CrashOptions",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "GCStats",
				Fields: []types.StructFieldName{
					"LastGC",
					"NumGC",
					"PauseTotal",
					"Pause",
					"PauseEnd",
					"PauseQuantiles",
				},
				Description: "",
			},
			structSet{
				Name: "Module",
				Fields: []types.StructFieldName{
					"Path",
					"Version",
					"Sum",
					"Replace",
				},
				Description: "",
			},
		},
		"xcoff": []structSet{
			structSet{
				Name: "Archive",
				Fields: []types.StructFieldName{
					"ArchiveHeader",
					"Members",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "ArchiveHeader",
				Fields: []types.StructFieldName{
					"magic",
				},
				Description: "",
			},
			structSet{
				Name: "AuxCSect32",
				Fields: []types.StructFieldName{
					"Xscnlen",
					"Xparmhash",
					"Xsnhash",
					"Xsmtyp",
					"Xsmclas",
					"Xstab",
					"Xsnstab",
				},
				Description: "",
			},
			structSet{
				Name: "AuxCSect64",
				Fields: []types.StructFieldName{
					"Xscnlenlo",
					"Xparmhash",
					"Xsnhash",
					"Xsmtyp",
					"Xsmclas",
					"Xscnlenhi",
					"Xpad",
					"Xauxtype",
				},
				Description: "",
			},
			structSet{
				Name: "AuxFcn32",
				Fields: []types.StructFieldName{
					"Xexptr",
					"Xfsize",
					"Xlnnoptr",
					"Xendndx",
					"Xpad",
				},
				Description: "",
			},
			structSet{
				Name: "AuxFcn64",
				Fields: []types.StructFieldName{
					"Xlnnoptr",
					"Xfsize",
					"Xendndx",
					"Xpad",
					"Xauxtype",
				},
				Description: "",
			},
			structSet{
				Name: "AuxFile64",
				Fields: []types.StructFieldName{
					"Xfname",
					"Xftype",
					"Xauxtype",
				},
				Description: "",
			},
			structSet{
				Name: "AuxSect64",
				Fields: []types.StructFieldName{
					"Xscnlen",
					"Xnreloc",
					"pad",
					"Xauxtype",
				},
				Description: "",
			},
			structSet{
				Name: "AuxiliaryCSect",
				Fields: []types.StructFieldName{
					"Length",
					"StorageMappingClass",
					"SymbolType",
				},
				Description: "",
			},
			structSet{
				Name: "AuxiliaryFcn",
				Fields: []types.StructFieldName{
					"Size",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"Sections",
					"Symbols",
					"StringTable",
					"LibraryPaths",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"TargetMachine",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader32",
				Fields: []types.StructFieldName{
					"Fmagic",
					"Fnscns",
					"Ftimedat",
					"Fsymptr",
					"Fnsyms",
					"Fopthdr",
					"Fflags",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader64",
				Fields: []types.StructFieldName{
					"Fmagic",
					"Fnscns",
					"Ftimedat",
					"Fsymptr",
					"Fopthdr",
					"Fflags",
					"Fnsyms",
				},
				Description: "",
			},
			structSet{
				Name: "ImportedSymbol",
				Fields: []types.StructFieldName{
					"Name",
					"Library",
				},
				Description: "",
			},
			structSet{
				Name: "LoaderHeader32",
				Fields: []types.StructFieldName{
					"Lversion",
					"Lnsyms",
					"Lnreloc",
					"Listlen",
					"Lnimpid",
					"Limpoff",
					"Lstlen",
					"Lstoff",
				},
				Description: "",
			},
			structSet{
				Name: "LoaderHeader64",
				Fields: []types.StructFieldName{
					"Lversion",
					"Lnsyms",
					"Lnreloc",
					"Listlen",
					"Lnimpid",
					"Lstlen",
					"Limpoff",
					"Lstoff",
					"Lsymoff",
					"Lrldoff",
				},
				Description: "",
			},
			structSet{
				Name: "LoaderSymbol32",
				Fields: []types.StructFieldName{
					"Lname",
					"Lvalue",
					"Lscnum",
					"Lsmtype",
					"Lsmclas",
					"Lifile",
					"Lparm",
				},
				Description: "",
			},
			structSet{
				Name: "LoaderSymbol64",
				Fields: []types.StructFieldName{
					"Lvalue",
					"Loffset",
					"Lscnum",
					"Lsmtype",
					"Lsmclas",
					"Lifile",
					"Lparm",
				},
				Description: "",
			},
			structSet{
				Name: "Member",
				Fields: []types.StructFieldName{
					"MemberHeader",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "MemberHeader",
				Fields: []types.StructFieldName{
					"Name",
					"Size",
				},
				Description: "",
			},
			structSet{
				Name: "Reloc",
				Fields: []types.StructFieldName{
					"VirtualAddress",
					"Symbol",
					"Signed",
					"InstructionFixed",
					"Length",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Reloc32",
				Fields: []types.StructFieldName{
					"Rvaddr",
					"Rsymndx",
					"Rsize",
					"Rtype",
				},
				Description: "",
			},
			structSet{
				Name: "Reloc64",
				Fields: []types.StructFieldName{
					"Rvaddr",
					"Rsymndx",
					"Rsize",
					"Rtype",
				},
				Description: "",
			},
			structSet{
				Name: "Section",
				Fields: []types.StructFieldName{
					"SectionHeader",
					"Relocs",
					"ReaderAt",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader",
				Fields: []types.StructFieldName{
					"Name",
					"VirtualAddress",
					"Size",
					"Type",
					"Relptr",
					"Nreloc",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader32",
				Fields: []types.StructFieldName{
					"Sname",
					"Spaddr",
					"Svaddr",
					"Ssize",
					"Sscnptr",
					"Srelptr",
					"Slnnoptr",
					"Snreloc",
					"Snlnno",
					"Sflags",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader64",
				Fields: []types.StructFieldName{
					"Sname",
					"Spaddr",
					"Svaddr",
					"Ssize",
					"Sscnptr",
					"Srelptr",
					"Slnnoptr",
					"Snreloc",
					"Snlnno",
					"Sflags",
					"Spad",
				},
				Description: "",
			},
			structSet{
				Name: "SymEnt32",
				Fields: []types.StructFieldName{
					"Nname",
					"Nvalue",
					"Nscnum",
					"Ntype",
					"Nsclass",
					"Nnumaux",
				},
				Description: "",
			},
			structSet{
				Name: "SymEnt64",
				Fields: []types.StructFieldName{
					"Nvalue",
					"Noffset",
					"Nscnum",
					"Ntype",
					"Nsclass",
					"Nnumaux",
				},
				Description: "",
			},
			structSet{
				Name: "Symbol",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
					"SectionNumber",
					"StorageClass",
					"AuxFcn",
					"AuxCSect",
				},
				Description: "",
			},
		},
		"tabwriter": []structSet{
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"output",
					"minwidth",
					"tabwidth",
					"padding",
					"padbytes",
					"flags",
					"buf",
					"pos",
					"cell",
					"endChar",
					"lines",
					"widths",
				},
				Description: "",
			},
		},
		"ring": []structSet{
			structSet{
				Name: "Ring",
				Fields: []types.StructFieldName{
					"next",
					"prev",
					"Value",
				},
				Description: "",
			},
		},
		"tls13": []structSet{
			structSet{
				Name: "EarlySecret",
				Fields: []types.StructFieldName{
					"secret",
					"hash",
				},
				Description: "",
			},
			structSet{
				Name: "ExporterMasterSecret",
				Fields: []types.StructFieldName{
					"secret",
					"hash",
				},
				Description: "",
			},
			structSet{
				Name: "HandshakeSecret",
				Fields: []types.StructFieldName{
					"secret",
					"hash",
				},
				Description: "",
			},
			structSet{
				Name: "MasterSecret",
				Fields: []types.StructFieldName{
					"secret",
					"hash",
				},
				Description: "",
			},
		},
		"singleflight": []structSet{
			structSet{
				Name: "Group",
				Fields: []types.StructFieldName{
					"mu",
					"m",
				},
				Description: "",
			},
			structSet{
				Name: "Result",
				Fields: []types.StructFieldName{
					"Val",
					"Err",
					"Shared",
				},
				Description: "",
			},
		},
		"pe": []structSet{
			structSet{
				Name: "COFFSymbol",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
					"SectionNumber",
					"Type",
					"StorageClass",
					"NumberOfAuxSymbols",
				},
				Description: "",
			},
			structSet{
				Name: "COFFSymbolAuxFormat5",
				Fields: []types.StructFieldName{
					"Size",
					"NumRelocs",
					"NumLineNumbers",
					"Checksum",
					"SecNum",
					"Selection",
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "DataDirectory",
				Fields: []types.StructFieldName{
					"VirtualAddress",
					"Size",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"OptionalHeader",
					"Sections",
					"Symbols",
					"COFFSymbols",
					"StringTable",
					"closer",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Machine",
					"NumberOfSections",
					"TimeDateStamp",
					"PointerToSymbolTable",
					"NumberOfSymbols",
					"SizeOfOptionalHeader",
					"Characteristics",
				},
				Description: "",
			},
			structSet{
				Name:        "FormatError",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "ImportDirectory",
				Fields: []types.StructFieldName{
					"OriginalFirstThunk",
					"TimeDateStamp",
					"ForwarderChain",
					"Name",
					"FirstThunk",
					"dll",
				},
				Description: "",
			},
			structSet{
				Name: "OptionalHeader32",
				Fields: []types.StructFieldName{
					"Magic",
					"MajorLinkerVersion",
					"MinorLinkerVersion",
					"SizeOfCode",
					"SizeOfInitializedData",
					"SizeOfUninitializedData",
					"AddressOfEntryPoint",
					"BaseOfCode",
					"BaseOfData",
					"ImageBase",
					"SectionAlignment",
					"FileAlignment",
					"MajorOperatingSystemVersion",
					"MinorOperatingSystemVersion",
					"MajorImageVersion",
					"MinorImageVersion",
					"MajorSubsystemVersion",
					"MinorSubsystemVersion",
					"Win32VersionValue",
					"SizeOfImage",
					"SizeOfHeaders",
					"CheckSum",
					"Subsystem",
					"DllCharacteristics",
					"SizeOfStackReserve",
					"SizeOfStackCommit",
					"SizeOfHeapReserve",
					"SizeOfHeapCommit",
					"LoaderFlags",
					"NumberOfRvaAndSizes",
					"DataDirectory",
				},
				Description: "",
			},
			structSet{
				Name: "OptionalHeader64",
				Fields: []types.StructFieldName{
					"Magic",
					"MajorLinkerVersion",
					"MinorLinkerVersion",
					"SizeOfCode",
					"SizeOfInitializedData",
					"SizeOfUninitializedData",
					"AddressOfEntryPoint",
					"BaseOfCode",
					"ImageBase",
					"SectionAlignment",
					"FileAlignment",
					"MajorOperatingSystemVersion",
					"MinorOperatingSystemVersion",
					"MajorImageVersion",
					"MinorImageVersion",
					"MajorSubsystemVersion",
					"MinorSubsystemVersion",
					"Win32VersionValue",
					"SizeOfImage",
					"SizeOfHeaders",
					"CheckSum",
					"Subsystem",
					"DllCharacteristics",
					"SizeOfStackReserve",
					"SizeOfStackCommit",
					"SizeOfHeapReserve",
					"SizeOfHeapCommit",
					"LoaderFlags",
					"NumberOfRvaAndSizes",
					"DataDirectory",
				},
				Description: "",
			},
			structSet{
				Name: "Reloc",
				Fields: []types.StructFieldName{
					"VirtualAddress",
					"SymbolTableIndex",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader",
				Fields: []types.StructFieldName{
					"Name",
					"VirtualSize",
					"VirtualAddress",
					"Size",
					"Offset",
					"PointerToRelocations",
					"PointerToLineNumbers",
					"NumberOfRelocations",
					"NumberOfLineNumbers",
					"Characteristics",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader32",
				Fields: []types.StructFieldName{
					"Name",
					"VirtualSize",
					"VirtualAddress",
					"SizeOfRawData",
					"PointerToRawData",
					"PointerToRelocations",
					"PointerToLineNumbers",
					"NumberOfRelocations",
					"NumberOfLineNumbers",
					"Characteristics",
				},
				Description: "",
			},
			structSet{
				Name: "Symbol",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
					"SectionNumber",
					"Type",
					"StorageClass",
				},
				Description: "",
			},
		},
		"calloc": []structSet{
			structSet{
				Name: "BatchCounterAlloc",
				Fields: []types.StructFieldName{
					"pool",
				},
				Description: "",
			},
		},
		"testtrace": []structSet{
			structSet{
				Name: "Expectation",
				Fields: []types.StructFieldName{
					"failure",
					"errorMatcher",
				},
				Description: "",
			},
			structSet{
				Name: "Validator",
				Fields: []types.StructFieldName{
					"lastTs",
					"gs",
					"ps",
					"ms",
					"ranges",
					"tasks",
					"lastSync",
					"GoVersion",
					"skipClockSnapshotChecks",
				},
				Description: "",
			},
		},
		"format": []structSet{
			structSet{
				Name: "BlockedArg",
				Fields: []types.StructFieldName{
					"Blocked",
				},
				Description: "",
			},
			structSet{
				Name: "Data",
				Fields: []types.StructFieldName{
					"Events",
					"Frames",
					"TimeUnit",
				},
				Description: "",
			},
			structSet{
				Name: "Event",
				Fields: []types.StructFieldName{
					"Name",
					"Phase",
					"Scope",
					"Time",
					"Dur",
					"PID",
					"TID",
					"ID",
					"BindPoint",
					"Stack",
					"EndStack",
					"Arg",
					"Cname",
					"Category",
				},
				Description: "",
			},
			structSet{
				Name: "Frame",
				Fields: []types.StructFieldName{
					"Name",
					"Parent",
				},
				Description: "",
			},
			structSet{
				Name: "GoroutineCountersArg",
				Fields: []types.StructFieldName{
					"Running",
					"Runnable",
					"GCWaiting",
				},
				Description: "",
			},
			structSet{
				Name: "HeapCountersArg",
				Fields: []types.StructFieldName{
					"Allocated",
					"NextGC",
				},
				Description: "",
			},
			structSet{
				Name: "NameArg",
				Fields: []types.StructFieldName{
					"Name",
				},
				Description: "",
			},
			structSet{
				Name: "SortIndexArg",
				Fields: []types.StructFieldName{
					"Index",
				},
				Description: "",
			},
			structSet{
				Name: "ThreadCountersArg",
				Fields: []types.StructFieldName{
					"Running",
					"InSyscall",
				},
				Description: "",
			},
			structSet{
				Name: "ThreadIDArg",
				Fields: []types.StructFieldName{
					"ThreadID",
				},
				Description: "",
			},
		},
		"testdeps": []structSet{
			structSet{
				Name:        "TestDeps",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
		},
		"reflectlite": []structSet{
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"typ_",
					"ptr",
					"flag",
				},
				Description: "",
			},
			structSet{
				Name: "ValueError",
				Fields: []types.StructFieldName{
					"Method",
					"Kind",
				},
				Description: "",
			},
		},
		"gzip": []structSet{
			structSet{
				Name: "Header",
				Fields: []types.StructFieldName{
					"Comment",
					"Extra",
					"ModTime",
					"Name",
					"OS",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"Header",
					"r",
					"decompressor",
					"digest",
					"size",
					"buf",
					"err",
					"multistream",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"Header",
					"w",
					"level",
					"wroteHeader",
					"closed",
					"buf",
					"compressor",
					"digest",
					"size",
					"err",
				},
				Description: "",
			},
		},
		"sha3": []structSet{
			structSet{
				Name: "Digest",
				Fields: []types.StructFieldName{
					"a",
					"n",
					"rate",
					"dsbyte",
					"outputLen",
					"state",
				},
				Description: "",
			},
			structSet{
				Name: "SHAKE",
				Fields: []types.StructFieldName{
					"d",
					"initBlock",
				},
				Description: "",
			},
			structSet{
				Name: "SHA3",
				Fields: []types.StructFieldName{
					"s",
				},
				Description: "",
			},
			structSet{
				Name: "SHAKE",
				Fields: []types.StructFieldName{
					"s",
				},
				Description: "",
			},
		},
		"platform": []structSet{
			structSet{
				Name: "OSArch",
				Fields: []types.StructFieldName{
					"GOOS",
					"GOARCH",
				},
				Description: "",
			},
		},
		"net": []structSet{
			structSet{
				Name: "AddrError",
				Fields: []types.StructFieldName{
					"Err",
					"Addr",
				},
				Description: "",
			},
			structSet{
				Name: "DNSConfigError",
				Fields: []types.StructFieldName{
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "DNSError",
				Fields: []types.StructFieldName{
					"UnwrapErr",
					"Err",
					"Name",
					"Server",
					"IsTimeout",
					"IsTemporary",
					"IsNotFound",
				},
				Description: "",
			},
			structSet{
				Name: "Dialer",
				Fields: []types.StructFieldName{
					"Timeout",
					"Deadline",
					"LocalAddr",
					"DualStack",
					"FallbackDelay",
					"KeepAlive",
					"KeepAliveConfig",
					"Resolver",
					"Cancel",
					"Control",
					"ControlContext",
					"mptcpStatus",
				},
				Description: "",
			},
			structSet{
				Name: "IPAddr",
				Fields: []types.StructFieldName{
					"IP",
					"Zone",
				},
				Description: "",
			},
			structSet{
				Name: "IPConn",
				Fields: []types.StructFieldName{
					"conn",
				},
				Description: "",
			},
			structSet{
				Name: "IPNet",
				Fields: []types.StructFieldName{
					"IP",
					"Mask",
				},
				Description: "",
			},
			structSet{
				Name: "Interface",
				Fields: []types.StructFieldName{
					"Index",
					"MTU",
					"Name",
					"HardwareAddr",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "KeepAliveConfig",
				Fields: []types.StructFieldName{
					"Enable",
					"Idle",
					"Interval",
					"Count",
				},
				Description: "",
			},
			structSet{
				Name: "ListenConfig",
				Fields: []types.StructFieldName{
					"Control",
					"KeepAlive",
					"KeepAliveConfig",
					"mptcpStatus",
				},
				Description: "",
			},
			structSet{
				Name: "MX",
				Fields: []types.StructFieldName{
					"Host",
					"Pref",
				},
				Description: "",
			},
			structSet{
				Name: "NS",
				Fields: []types.StructFieldName{
					"Host",
				},
				Description: "",
			},
			structSet{
				Name: "OpError",
				Fields: []types.StructFieldName{
					"Op",
					"Net",
					"Source",
					"Addr",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "ParseError",
				Fields: []types.StructFieldName{
					"Type",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "Resolver",
				Fields: []types.StructFieldName{
					"PreferGo",
					"StrictErrors",
					"Dial",
					"lookupGroup",
				},
				Description: "",
			},
			structSet{
				Name: "SRV",
				Fields: []types.StructFieldName{
					"Target",
					"Port",
					"Priority",
					"Weight",
				},
				Description: "",
			},
			structSet{
				Name: "TCPAddr",
				Fields: []types.StructFieldName{
					"IP",
					"Port",
					"Zone",
				},
				Description: "",
			},
			structSet{
				Name: "TCPConn",
				Fields: []types.StructFieldName{
					"conn",
				},
				Description: "",
			},
			structSet{
				Name: "TCPListener",
				Fields: []types.StructFieldName{
					"fd",
					"lc",
				},
				Description: "",
			},
			structSet{
				Name: "UDPAddr",
				Fields: []types.StructFieldName{
					"IP",
					"Port",
					"Zone",
				},
				Description: "",
			},
			structSet{
				Name: "UDPConn",
				Fields: []types.StructFieldName{
					"conn",
				},
				Description: "",
			},
			structSet{
				Name: "UnixAddr",
				Fields: []types.StructFieldName{
					"Name",
					"Net",
				},
				Description: "",
			},
			structSet{
				Name: "UnixConn",
				Fields: []types.StructFieldName{
					"conn",
				},
				Description: "",
			},
			structSet{
				Name: "UnixListener",
				Fields: []types.StructFieldName{
					"fd",
					"path",
					"unlink",
					"unlinkOnce",
				},
				Description: "",
			},
		},
		"log": []structSet{
			structSet{
				Name: "Logger",
				Fields: []types.StructFieldName{
					"outMu",
					"out",
					"prefix",
					"flag",
					"isDiscard",
				},
				Description: "",
			},
		},
		"coverage": []structSet{
			structSet{
				Name: "CounterFileFooter",
				Fields: []types.StructFieldName{
					"Magic",
					"_",
					"NumSegments",
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "CounterFileHeader",
				Fields: []types.StructFieldName{
					"Magic",
					"Version",
					"MetaHash",
					"CFlavor",
					"BigEndian",
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "CounterSegmentHeader",
				Fields: []types.StructFieldName{
					"FcnEntries",
					"StrTabLen",
					"ArgsLen",
				},
				Description: "",
			},
			structSet{
				Name: "CoverableUnit",
				Fields: []types.StructFieldName{
					"StLine",
					"StCol",
					"EnLine",
					"EnCol",
					"NxStmts",
					"Parent",
				},
				Description: "",
			},
			structSet{
				Name: "FuncDesc",
				Fields: []types.StructFieldName{
					"Funcname",
					"Srcfile",
					"Units",
					"Lit",
				},
				Description: "",
			},
			structSet{
				Name: "MetaFileCollection",
				Fields: []types.StructFieldName{
					"ImportPaths",
					"MetaFileFragments",
				},
				Description: "",
			},
			structSet{
				Name: "MetaFileHeader",
				Fields: []types.StructFieldName{
					"Magic",
					"Version",
					"TotalLength",
					"Entries",
					"MetaFileHash",
					"StrTabOffset",
					"StrTabLength",
					"CMode",
					"CGranularity",
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "MetaSymbolHeader",
				Fields: []types.StructFieldName{
					"Length",
					"PkgName",
					"PkgPath",
					"ModulePath",
					"MetaHash",
					"_",
					"_",
					"NumFiles",
					"NumFuncs",
				},
				Description: "",
			},
		},
		"cformat": []structSet{
			structSet{
				Name: "Formatter",
				Fields: []types.StructFieldName{
					"pm",
					"pkg",
					"p",
					"cm",
				},
				Description: "",
			},
		},
		"runtime": []structSet{
			structSet{
				Name: "BlockProfileRecord",
				Fields: []types.StructFieldName{
					"Count",
					"Cycles",
					"StackRecord",
				},
				Description: "",
			},
			structSet{
				Name: "Cleanup",
				Fields: []types.StructFieldName{
					"id",
					"ptr",
				},
				Description: "",
			},
			structSet{
				Name: "Frame",
				Fields: []types.StructFieldName{
					"PC",
					"Func",
					"Function",
					"File",
					"Line",
					"startLine",
					"Entry",
					"funcInfo",
				},
				Description: "",
			},
			structSet{
				Name: "Frames",
				Fields: []types.StructFieldName{
					"callers",
					"nextPC",
					"frames",
					"frameStore",
				},
				Description: "",
			},
			structSet{
				Name: "Func",
				Fields: []types.StructFieldName{
					"opaque",
				},
				Description: "",
			},
			structSet{
				Name: "MemProfileRecord",
				Fields: []types.StructFieldName{
					"AllocBytes",
					"FreeBytes",
					"AllocObjects",
					"FreeObjects",
					"Stack0",
				},
				Description: "",
			},
			structSet{
				Name: "MemStats",
				Fields: []types.StructFieldName{
					"Alloc",
					"TotalAlloc",
					"Sys",
					"Lookups",
					"Mallocs",
					"Frees",
					"HeapAlloc",
					"HeapSys",
					"HeapIdle",
					"HeapInuse",
					"HeapReleased",
					"HeapObjects",
					"StackInuse",
					"StackSys",
					"MSpanInuse",
					"MSpanSys",
					"MCacheInuse",
					"MCacheSys",
					"BuckHashSys",
					"GCSys",
					"OtherSys",
					"NextGC",
					"LastGC",
					"PauseTotalNs",
					"PauseNs",
					"PauseEnd",
					"NumGC",
					"NumForcedGC",
					"GCCPUFraction",
					"EnableGC",
					"DebugGC",
					"BySize",
				},
				Description: "",
			},
			structSet{
				Name: "PanicNilError",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "Pinner",
				Fields: []types.StructFieldName{
					"pinner",
				},
				Description: "",
			},
			structSet{
				Name: "StackRecord",
				Fields: []types.StructFieldName{
					"Stack0",
				},
				Description: "",
			},
			structSet{
				Name: "TypeAssertionError",
				Fields: []types.StructFieldName{
					"_interface",
					"concrete",
					"asserted",
					"missingMethod",
				},
				Description: "",
			},
		},
		"big": []structSet{
			structSet{
				Name: "ErrNaN",
				Fields: []types.StructFieldName{
					"msg",
				},
				Description: "",
			},
			structSet{
				Name: "Float",
				Fields: []types.StructFieldName{
					"prec",
					"mode",
					"acc",
					"form",
					"neg",
					"mant",
					"exp",
				},
				Description: "",
			},
		},
		"netip": []structSet{
			structSet{
				Name: "Addr",
				Fields: []types.StructFieldName{
					"addr",
					"z",
				},
				Description: "",
			},
			structSet{
				Name: "AddrPort",
				Fields: []types.StructFieldName{
					"ip",
					"port",
				},
				Description: "",
			},
		},
		"driver": []structSet{
			structSet{
				Name: "NamedValue",
				Fields: []types.StructFieldName{
					"Name",
					"Ordinal",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "NotNull",
				Fields: []types.StructFieldName{
					"Converter",
				},
				Description: "",
			},
			structSet{
				Name: "Null",
				Fields: []types.StructFieldName{
					"Converter",
				},
				Description: "",
			},
			structSet{
				Name: "TxOptions",
				Fields: []types.StructFieldName{
					"Isolation",
					"ReadOnly",
				},
				Description: "",
			},
		},
		"comment": []structSet{
			structSet{
				Name: "Code",
				Fields: []types.StructFieldName{
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "Doc",
				Fields: []types.StructFieldName{
					"Content",
					"Links",
				},
				Description: "",
			},
			structSet{
				Name: "DocLink",
				Fields: []types.StructFieldName{
					"Text",
					"ImportPath",
					"Recv",
					"Name",
				},
				Description: "",
			},
			structSet{
				Name: "Heading",
				Fields: []types.StructFieldName{
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "Link",
				Fields: []types.StructFieldName{
					"Auto",
					"Text",
					"URL",
				},
				Description: "",
			},
			structSet{
				Name: "LinkDef",
				Fields: []types.StructFieldName{
					"Text",
					"URL",
					"Used",
				},
				Description: "",
			},
			structSet{
				Name: "List",
				Fields: []types.StructFieldName{
					"Items",
					"ForceBlankBefore",
					"ForceBlankBetween",
				},
				Description: "",
			},
			structSet{
				Name: "ListItem",
				Fields: []types.StructFieldName{
					"Number",
					"Content",
				},
				Description: "",
			},
			structSet{
				Name: "Paragraph",
				Fields: []types.StructFieldName{
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "Parser",
				Fields: []types.StructFieldName{
					"Words",
					"LookupPackage",
					"LookupSym",
				},
				Description: "",
			},
			structSet{
				Name: "Printer",
				Fields: []types.StructFieldName{
					"HeadingLevel",
					"HeadingID",
					"DocLinkURL",
					"DocLinkBaseURL",
					"TextPrefix",
					"TextCodePrefix",
					"TextWidth",
				},
				Description: "",
			},
		},
		"decodecounter": []structSet{
			structSet{
				Name: "CounterDataReader",
				Fields: []types.StructFieldName{
					"stab",
					"args",
					"osargs",
					"goarch",
					"goos",
					"mr",
					"hdr",
					"ftr",
					"shdr",
					"u32b",
					"u8b",
					"fcnCount",
					"segCount",
					"debug",
				},
				Description: "",
			},
			structSet{
				Name: "FuncPayload",
				Fields: []types.StructFieldName{
					"PkgIdx",
					"FuncIdx",
					"Counters",
				},
				Description: "",
			},
		},
		"dag": []structSet{
			structSet{
				Name: "Graph",
				Fields: []types.StructFieldName{
					"Nodes",
					"byLabel",
					"edges",
				},
				Description: "",
			},
		},
		"fuzz": []structSet{
			structSet{
				Name: "CoordinateFuzzingOpts",
				Fields: []types.StructFieldName{
					"Log",
					"Timeout",
					"Limit",
					"MinimizeTimeout",
					"MinimizeLimit",
					"Parallel",
					"Seed",
					"Types",
					"CorpusDir",
					"CacheDir",
				},
				Description: "",
			},
			structSet{
				Name: "CorpusEntry",
				Fields: []types.StructFieldName{
					"Parent",
					"Path",
					"Data",
					"Values",
					"Generation",
					"IsSeed",
				},
				Description: "",
			},
			structSet{
				Name: "MalformedCorpusError",
				Fields: []types.StructFieldName{
					"errs",
				},
				Description: "",
			},
		},
		"abi": []structSet{
			structSet{
				Name: "ArrayType",
				Fields: []types.StructFieldName{
					"Type",
					"Elem",
					"Slice",
					"Len",
				},
				Description: "",
			},
			structSet{
				Name: "ChanType",
				Fields: []types.StructFieldName{
					"Type",
					"Elem",
					"Dir",
				},
				Description: "",
			},
			structSet{
				Name: "EmptyInterface",
				Fields: []types.StructFieldName{
					"Type",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "ITab",
				Fields: []types.StructFieldName{
					"Inter",
					"Type",
					"Hash",
					"Fun",
				},
				Description: "",
			},
			structSet{
				Name: "Imethod",
				Fields: []types.StructFieldName{
					"Name",
					"Typ",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceSwitch",
				Fields: []types.StructFieldName{
					"Cache",
					"NCases",
					"Cases",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceSwitchCache",
				Fields: []types.StructFieldName{
					"Mask",
					"Entries",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceSwitchCacheEntry",
				Fields: []types.StructFieldName{
					"Typ",
					"Case",
					"Itab",
				},
				Description: "",
			},
			structSet{
				Name: "Method",
				Fields: []types.StructFieldName{
					"Name",
					"Mtyp",
					"Ifn",
					"Tfn",
				},
				Description: "",
			},
			structSet{
				Name: "Name",
				Fields: []types.StructFieldName{
					"Bytes",
				},
				Description: "",
			},
			structSet{
				Name: "NonEmptyInterface",
				Fields: []types.StructFieldName{
					"ITab",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "OldMapType",
				Fields: []types.StructFieldName{
					"Type",
					"Key",
					"Elem",
					"Bucket",
					"Hasher",
					"KeySize",
					"ValueSize",
					"BucketSize",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "PtrType",
				Fields: []types.StructFieldName{
					"Type",
					"Elem",
				},
				Description: "",
			},
			structSet{
				Name: "RegArgs",
				Fields: []types.StructFieldName{
					"Ints",
					"Floats",
					"Ptrs",
					"ReturnIsPtr",
				},
				Description: "",
			},
			structSet{
				Name: "SliceType",
				Fields: []types.StructFieldName{
					"Type",
					"Elem",
				},
				Description: "",
			},
			structSet{
				Name: "StructField",
				Fields: []types.StructFieldName{
					"Name",
					"Typ",
					"Offset",
				},
				Description: "",
			},
			structSet{
				Name: "SwissMapType",
				Fields: []types.StructFieldName{
					"Type",
					"Key",
					"Elem",
					"Group",
					"Hasher",
					"GroupSize",
					"SlotSize",
					"ElemOff",
					"Flags",
				},
				Description: "",
			},
			structSet{
				Name: "Type",
				Fields: []types.StructFieldName{
					"Size_",
					"PtrBytes",
					"Hash",
					"TFlag",
					"Align_",
					"FieldAlign_",
					"Kind_",
					"Equal",
					"GCData",
					"Str",
					"PtrToThis",
				},
				Description: "",
			},
			structSet{
				Name: "TypeAssert",
				Fields: []types.StructFieldName{
					"Cache",
					"Inter",
					"CanFail",
				},
				Description: "",
			},
			structSet{
				Name: "TypeAssertCache",
				Fields: []types.StructFieldName{
					"Mask",
					"Entries",
				},
				Description: "",
			},
			structSet{
				Name: "TypeAssertCacheEntry",
				Fields: []types.StructFieldName{
					"Typ",
					"Itab",
				},
				Description: "",
			},
			structSet{
				Name: "UncommonType",
				Fields: []types.StructFieldName{
					"PkgPath",
					"Mcount",
					"Xcount",
					"Moff",
					"_",
				},
				Description: "",
			},
		},
		"macOS": []structSet{
			structSet{
				Name: "OSStatus",
				Fields: []types.StructFieldName{
					"call",
					"status",
				},
				Description: "",
			},
		},
		"suffixarray": []structSet{
			structSet{
				Name: "Index",
				Fields: []types.StructFieldName{
					"data",
					"sa",
				},
				Description: "",
			},
		},
		"testgen": []structSet{
			structSet{
				Name: "Trace",
				Fields: []types.StructFieldName{
					"ver",
					"names",
					"specs",
					"events",
					"gens",
					"validTimestamps",
					"lastTs",
					"bad",
					"badMatch",
				},
				Description: "",
			},
		},
		"godebugs": []structSet{
			structSet{
				Name: "Info",
				Fields: []types.StructFieldName{
					"Name",
					"Package",
					"Changed",
					"Old",
					"Opaque",
					"Immutable",
				},
				Description: "",
			},
		},
		"fs": []structSet{
			structSet{
				Name: "PathError",
				Fields: []types.StructFieldName{
					"Op",
					"Path",
					"Err",
				},
				Description: "",
			},
		},
		"boring": []structSet{
			structSet{
				Name:        "PrivateKeyECDH",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "PrivateKeyECDSA",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKeyRSA",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
			structSet{
				Name:        "PublicKeyECDH",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "PublicKeyECDSA",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKeyRSA",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
		},
		"rc4": []structSet{
			structSet{
				Name: "Cipher",
				Fields: []types.StructFieldName{
					"s",
					"i",
					"j",
				},
				Description: "",
			},
		},
		"quotedprintable": []structSet{
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"br",
					"rerr",
					"line",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"Binary",
					"w",
					"i",
					"line",
					"cr",
				},
				Description: "",
			},
		},
		"regexp": []structSet{
			structSet{
				Name: "Regexp",
				Fields: []types.StructFieldName{
					"expr",
					"prog",
					"onepass",
					"numSubexp",
					"maxBitStateLen",
					"subexpNames",
					"prefix",
					"prefixBytes",
					"prefixRune",
					"prefixEnd",
					"mpool",
					"matchcap",
					"prefixComplete",
					"cond",
					"minInputLen",
					"longest",
				},
				Description: "",
			},
		},
		"encodemeta": []structSet{
			structSet{
				Name: "CoverageMetaDataBuilder",
				Fields: []types.StructFieldName{
					"stab",
					"funcs",
					"tmp",
					"h",
					"pkgpath",
					"pkgname",
					"modpath",
					"debug",
					"werr",
				},
				Description: "",
			},
			structSet{
				Name: "CoverageMetaFileWriter",
				Fields: []types.StructFieldName{
					"stab",
					"mfname",
					"w",
					"tmp",
					"debug",
				},
				Description: "",
			},
		},
		"httptest": []structSet{
			structSet{
				Name: "ResponseRecorder",
				Fields: []types.StructFieldName{
					"Code",
					"HeaderMap",
					"Body",
					"Flushed",
					"result",
					"snapHeader",
					"wroteHeader",
				},
				Description: "",
			},
			structSet{
				Name: "Server",
				Fields: []types.StructFieldName{
					"URL",
					"Listener",
					"EnableHTTP2",
					"TLS",
					"Config",
					"certificate",
					"wg",
					"mu",
					"closed",
					"conns",
					"client",
				},
				Description: "",
			},
		},
		"bisect": []structSet{
			structSet{
				Name: "Matcher",
				Fields: []types.StructFieldName{
					"verbose",
					"quiet",
					"enable",
					"list",
					"dedup",
				},
				Description: "",
			},
		},
		"asn1": []structSet{
			structSet{
				Name: "BitString",
				Fields: []types.StructFieldName{
					"Bytes",
					"BitLength",
				},
				Description: "",
			},
			structSet{
				Name: "RawValue",
				Fields: []types.StructFieldName{
					"Class",
					"Tag",
					"IsCompound",
					"Bytes",
					"FullBytes",
				},
				Description: "",
			},
			structSet{
				Name: "StructuralError",
				Fields: []types.StructFieldName{
					"Msg",
				},
				Description: "",
			},
			structSet{
				Name: "SyntaxError",
				Fields: []types.StructFieldName{
					"Msg",
				},
				Description: "",
			},
		},
		"gosym": []structSet{
			structSet{
				Name: "DecodingError",
				Fields: []types.StructFieldName{
					"off",
					"msg",
					"val",
				},
				Description: "",
			},
			structSet{
				Name: "Func",
				Fields: []types.StructFieldName{
					"Entry",
					"Sym",
					"End",
					"Params",
					"Locals",
					"FrameSize",
					"LineTable",
					"Obj",
				},
				Description: "",
			},
			structSet{
				Name: "LineTable",
				Fields: []types.StructFieldName{
					"Data",
					"PC",
					"Line",
					"mu",
					"version",
					"binary",
					"quantum",
					"ptrsize",
					"textStart",
					"funcnametab",
					"cutab",
					"funcdata",
					"functab",
					"nfunctab",
					"filetab",
					"pctab",
					"nfiletab",
					"funcNames",
					"strings",
					"fileMap",
				},
				Description: "",
			},
			structSet{
				Name: "Obj",
				Fields: []types.StructFieldName{
					"Funcs",
					"Paths",
				},
				Description: "",
			},
			structSet{
				Name: "Sym",
				Fields: []types.StructFieldName{
					"Value",
					"Type",
					"Name",
					"GoType",
					"Func",
					"goVersion",
				},
				Description: "",
			},
			structSet{
				Name: "Table",
				Fields: []types.StructFieldName{
					"Syms",
					"Funcs",
					"Files",
					"Objs",
					"go12line",
				},
				Description: "",
			},
			structSet{
				Name: "UnknownLineError",
				Fields: []types.StructFieldName{
					"File",
					"Line",
				},
				Description: "",
			},
		},
		"maphash": []structSet{
			structSet{
				Name: "Hash",
				Fields: []types.StructFieldName{
					"_",
					"seed",
					"state",
					"buf",
					"n",
				},
				Description: "",
			},
			structSet{
				Name: "Seed",
				Fields: []types.StructFieldName{
					"s",
				},
				Description: "",
			},
		},
		"profile": []structSet{
			structSet{
				Name: "Edge",
				Fields: []types.StructFieldName{
					"Src",
					"Dest",
					"Weight",
					"WeightDiv",
					"Residual",
					"Inline",
				},
				Description: "",
			},
			structSet{
				Name: "Function",
				Fields: []types.StructFieldName{
					"ID",
					"Name",
					"SystemName",
					"Filename",
					"StartLine",
					"nameX",
					"systemNameX",
					"filenameX",
				},
				Description: "",
			},
			structSet{
				Name: "Graph",
				Fields: []types.StructFieldName{
					"Nodes",
				},
				Description: "",
			},
			structSet{
				Name: "Label",
				Fields: []types.StructFieldName{
					"keyX",
					"strX",
					"numX",
				},
				Description: "",
			},
			structSet{
				Name: "Line",
				Fields: []types.StructFieldName{
					"Function",
					"Line",
					"functionIDX",
				},
				Description: "",
			},
			structSet{
				Name: "Location",
				Fields: []types.StructFieldName{
					"ID",
					"Mapping",
					"Address",
					"Line",
					"IsFolded",
					"mappingIDX",
				},
				Description: "",
			},
			structSet{
				Name: "Mapping",
				Fields: []types.StructFieldName{
					"ID",
					"Start",
					"Limit",
					"Offset",
					"File",
					"BuildID",
					"HasFunctions",
					"HasFilenames",
					"HasLineNumbers",
					"HasInlineFrames",
					"fileX",
					"buildIDX",
				},
				Description: "",
			},
			structSet{
				Name: "Node",
				Fields: []types.StructFieldName{
					"Info",
					"Function",
					"Flat",
					"FlatDiv",
					"Cum",
					"CumDiv",
					"In",
					"Out",
				},
				Description: "",
			},
			structSet{
				Name: "NodeInfo",
				Fields: []types.StructFieldName{
					"Name",
					"Address",
					"StartLine",
					"Lineno",
				},
				Description: "",
			},
			structSet{
				Name: "Options",
				Fields: []types.StructFieldName{
					"SampleValue",
					"SampleMeanDivisor",
					"DropNegative",
					"KeptNodes",
				},
				Description: "",
			},
			structSet{
				Name: "Profile",
				Fields: []types.StructFieldName{
					"SampleType",
					"DefaultSampleType",
					"Sample",
					"Mapping",
					"Location",
					"Function",
					"Comments",
					"DropFrames",
					"KeepFrames",
					"TimeNanos",
					"DurationNanos",
					"PeriodType",
					"Period",
					"commentX",
					"dropFramesX",
					"keepFramesX",
					"stringTable",
					"defaultSampleTypeX",
				},
				Description: "",
			},
			structSet{
				Name: "Sample",
				Fields: []types.StructFieldName{
					"Location",
					"Value",
					"Label",
					"NumLabel",
					"NumUnit",
					"locationIDX",
					"labelX",
				},
				Description: "",
			},
			structSet{
				Name: "ValueType",
				Fields: []types.StructFieldName{
					"Type",
					"Unit",
					"typeX",
					"unitX",
				},
				Description: "",
			},
		},
		"cgi": []structSet{
			structSet{
				Name: "Handler",
				Fields: []types.StructFieldName{
					"Path",
					"Root",
					"Dir",
					"Env",
					"InheritEnv",
					"Logger",
					"Args",
					"Stderr",
					"PathLocationHandler",
				},
				Description: "",
			},
		},
		"nistec": []structSet{
			structSet{
				Name: "P224Point",
				Fields: []types.StructFieldName{
					"x",
					"y",
					"z",
				},
				Description: "",
			},
			structSet{
				Name: "P256Point",
				Fields: []types.StructFieldName{
					"x",
					"y",
					"z",
				},
				Description: "",
			},
			structSet{
				Name: "P384Point",
				Fields: []types.StructFieldName{
					"x",
					"y",
					"z",
				},
				Description: "",
			},
			structSet{
				Name: "P521Point",
				Fields: []types.StructFieldName{
					"x",
					"y",
					"z",
				},
				Description: "",
			},
		},
		"atomic": []structSet{
			structSet{
				Name: "Bool",
				Fields: []types.StructFieldName{
					"u",
				},
				Description: "",
			},
			structSet{
				Name: "Float64",
				Fields: []types.StructFieldName{
					"u",
				},
				Description: "",
			},
			structSet{
				Name: "Int32",
				Fields: []types.StructFieldName{
					"noCopy",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Int64",
				Fields: []types.StructFieldName{
					"noCopy",
					"_",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Pointer",
				Fields: []types.StructFieldName{
					"u",
				},
				Description: "",
			},
			structSet{
				Name: "Uint32",
				Fields: []types.StructFieldName{
					"noCopy",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Uint64",
				Fields: []types.StructFieldName{
					"noCopy",
					"_",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Uint8",
				Fields: []types.StructFieldName{
					"noCopy",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Uintptr",
				Fields: []types.StructFieldName{
					"noCopy",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "UnsafePointer",
				Fields: []types.StructFieldName{
					"noCopy",
					"value",
				},
				Description: "",
			},
			structSet{
				Name: "Bool",
				Fields: []types.StructFieldName{
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Int32",
				Fields: []types.StructFieldName{
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Int64",
				Fields: []types.StructFieldName{
					"_",
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Pointer",
				Fields: []types.StructFieldName{
					"_",
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Uint32",
				Fields: []types.StructFieldName{
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Uint64",
				Fields: []types.StructFieldName{
					"_",
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Uintptr",
				Fields: []types.StructFieldName{
					"_",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"v",
				},
				Description: "",
			},
		},
		"maps": []structSet{
			structSet{
				Name: "Iter",
				Fields: []types.StructFieldName{
					"key",
					"elem",
					"typ",
					"m",
					"entryOffset",
					"dirOffset",
					"clearSeq",
					"globalDepth",
					"dirIdx",
					"tab",
					"group",
					"entryIdx",
				},
				Description: "",
			},
			structSet{
				Name: "Map",
				Fields: []types.StructFieldName{
					"used",
					"seed",
					"dirPtr",
					"dirLen",
					"globalDepth",
					"globalShift",
					"writing",
					"tombstonePossible",
					"clearSeq",
				},
				Description: "",
			},
		},
		"synctest": []structSet{
			structSet{
				Name: "Bubble",
				Fields: []types.StructFieldName{
					"b",
				},
				Description: "",
			},
		},
		"godebug": []structSet{
			structSet{
				Name: "Setting",
				Fields: []types.StructFieldName{
					"name",
					"once",
					"setting",
				},
				Description: "",
			},
			structSet{
				Name: "Setting",
				Fields: []types.StructFieldName{
					"name",
					"once",
					"setting",
				},
				Description: "",
			},
		},
		"bufio": []structSet{
			structSet{
				Name: "ReadWriter",
				Fields: []types.StructFieldName{
					"Reader",
					"Writer",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"buf",
					"rd",
					"r",
					"w",
					"err",
					"lastByte",
					"lastRuneSize",
				},
				Description: "",
			},
			structSet{
				Name: "Scanner",
				Fields: []types.StructFieldName{
					"r",
					"split",
					"maxTokenSize",
					"token",
					"buf",
					"start",
					"end",
					"err",
					"empties",
					"scanCalled",
					"done",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"err",
					"buf",
					"n",
					"wr",
				},
				Description: "",
			},
		},
		"bigmod": []structSet{
			structSet{
				Name: "Modulus",
				Fields: []types.StructFieldName{
					"nat",
					"odd",
					"m0inv",
					"rr",
				},
				Description: "",
			},
			structSet{
				Name: "Nat",
				Fields: []types.StructFieldName{
					"limbs",
				},
				Description: "",
			},
		},
		"internal": []structSet{
			structSet{
				Name: "FlushAfterChunkWriter",
				Fields: []types.StructFieldName{
					"Writer",
				},
				Description: "",
			},
		},
		"gcm": []structSet{
			structSet{
				Name: "CMAC",
				Fields: []types.StructFieldName{
					"b",
					"k1",
					"k2",
				},
				Description: "",
			},
			structSet{
				Name: "CounterKDF",
				Fields: []types.StructFieldName{
					"mac",
				},
				Description: "",
			},
			structSet{
				Name: "GCM",
				Fields: []types.StructFieldName{
					"cipher",
					"nonceSize",
					"tagSize",
					"gcmPlatformData",
				},
				Description: "",
			},
			structSet{
				Name: "GCMForSSH",
				Fields: []types.StructFieldName{
					"g",
					"ready",
					"start",
					"next",
				},
				Description: "",
			},
			structSet{
				Name: "GCMForTLS12",
				Fields: []types.StructFieldName{
					"g",
					"next",
				},
				Description: "",
			},
			structSet{
				Name: "GCMForTLS13",
				Fields: []types.StructFieldName{
					"g",
					"ready",
					"mask",
					"next",
				},
				Description: "",
			},
			structSet{
				Name: "GCMWithCounterNonce",
				Fields: []types.StructFieldName{
					"g",
					"ready",
					"fixedName",
					"start",
					"next",
				},
				Description: "",
			},
		},
		"os": []structSet{
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"file",
				},
				Description: "",
			},
			structSet{
				Name: "LinkError",
				Fields: []types.StructFieldName{
					"Op",
					"Old",
					"New",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "PathError",
				Fields: []types.StructFieldName{
					"Op",
					"Path",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "ProcAttr",
				Fields: []types.StructFieldName{
					"Dir",
					"Env",
					"Files",
					"Sys",
				},
				Description: "",
			},
			structSet{
				Name: "Process",
				Fields: []types.StructFieldName{
					"Pid",
					"state",
					"sigMu",
					"handle",
					"cleanup",
				},
				Description: "",
			},
			structSet{
				Name: "ProcessState",
				Fields: []types.StructFieldName{
					"pid",
					"status",
					"rusage",
				},
				Description: "",
			},
			structSet{
				Name: "Root",
				Fields: []types.StructFieldName{
					"root",
				},
				Description: "",
			},
			structSet{
				Name: "SyscallError",
				Fields: []types.StructFieldName{
					"Syscall",
					"Err",
				},
				Description: "",
			},
		},
		"url": []structSet{
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Op",
					"URL",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "URL",
				Fields: []types.StructFieldName{
					"Scheme",
					"Opaque",
					"User",
					"Host",
					"Path",
					"RawPath",
					"OmitHost",
					"ForceQuery",
					"RawQuery",
					"Fragment",
					"RawFragment",
				},
				Description: "",
			},
			structSet{
				Name: "Userinfo",
				Fields: []types.StructFieldName{
					"username",
					"password",
					"passwordSet",
				},
				Description: "",
			},
		},
		"httpcommon": []structSet{
			structSet{
				Name: "EncodeHeadersParam",
				Fields: []types.StructFieldName{
					"Request",
					"AddGzipHeader",
					"PeerMaxHeaderListSize",
					"DefaultUserAgent",
				},
				Description: "",
			},
			structSet{
				Name: "EncodeHeadersResult",
				Fields: []types.StructFieldName{
					"HasBody",
					"HasTrailers",
				},
				Description: "",
			},
			structSet{
				Name: "Request",
				Fields: []types.StructFieldName{
					"URL",
					"Method",
					"Host",
					"Header",
					"Trailer",
					"ActualContentLength",
				},
				Description: "",
			},
			structSet{
				Name: "ServerRequestParam",
				Fields: []types.StructFieldName{
					"Method",
					"Scheme",
					"Authority",
					"Path",
					"Protocol",
					"Header",
				},
				Description: "",
			},
			structSet{
				Name: "ServerRequestResult",
				Fields: []types.StructFieldName{
					"URL",
					"RequestURI",
					"Trailer",
					"NeedsContinue",
					"InvalidReason",
				},
				Description: "",
			},
		},
		"expvar": []structSet{
			structSet{
				Name: "Float",
				Fields: []types.StructFieldName{
					"f",
				},
				Description: "",
			},
			structSet{
				Name: "Int",
				Fields: []types.StructFieldName{
					"i",
				},
				Description: "",
			},
			structSet{
				Name: "KeyValue",
				Fields: []types.StructFieldName{
					"Key",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Map",
				Fields: []types.StructFieldName{
					"m",
					"keysMu",
					"keys",
				},
				Description: "",
			},
		},
		"token": []structSet{
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"name",
					"base",
					"size",
					"mutex",
					"lines",
					"infos",
				},
				Description: "",
			},
			structSet{
				Name: "FileSet",
				Fields: []types.StructFieldName{
					"mutex",
					"base",
					"tree",
					"last",
				},
				Description: "",
			},
			structSet{
				Name: "Position",
				Fields: []types.StructFieldName{
					"Filename",
					"Offset",
					"Line",
					"Column",
				},
				Description: "",
			},
		},
		"syntax": []structSet{
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Code",
					"Expr",
				},
				Description: "",
			},
			structSet{
				Name: "Inst",
				Fields: []types.StructFieldName{
					"Op",
					"Out",
					"Arg",
					"Rune",
				},
				Description: "",
			},
			structSet{
				Name: "Prog",
				Fields: []types.StructFieldName{
					"Inst",
					"Start",
					"NumCap",
				},
				Description: "",
			},
			structSet{
				Name: "Regexp",
				Fields: []types.StructFieldName{
					"Op",
					"Flags",
					"Sub",
					"Sub0",
					"Rune",
					"Rune0",
					"Min",
					"Max",
					"Cap",
					"Name",
				},
				Description: "",
			},
		},
		"lazyregexp": []structSet{
			structSet{
				Name: "Regexp",
				Fields: []types.StructFieldName{
					"str",
					"once",
					"rx",
				},
				Description: "",
			},
		},
		"sys": []structSet{
			structSet{
				Name: "NotInHeap",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
		},
		"unix": []structSet{
			structSet{
				Name: "Addrinfo",
				Fields: []types.StructFieldName{
					"Flags",
					"Family",
					"Socktype",
					"Protocol",
					"Addrlen",
					"Canonname",
					"Addr",
					"Next",
				},
				Description: "",
			},
			structSet{
				Name: "Group",
				Fields: []types.StructFieldName{
					"Name",
					"Passwd",
					"Gid",
					"Mem",
				},
				Description: "",
			},
			structSet{
				Name: "Passwd",
				Fields: []types.StructFieldName{
					"Name",
					"Passwd",
					"Uid",
					"Gid",
					"Change",
					"Class",
					"Gecos",
					"Dir",
					"Shell",
					"Expire",
				},
				Description: "",
			},
			structSet{
				Name: "ResState",
				Fields: []types.StructFieldName{
					"unexported",
				},
				Description: "",
			},
		},
		"buildinfo": []structSet{
			structSet{
				Name: "BuildInfo",
				Fields: []types.StructFieldName{
					"GoVersion",
					"Path",
					"Main",
					"Deps",
					"Settings",
				},
				Description: "",
			},
		},
		"base32": []structSet{
			structSet{
				Name: "Encoding",
				Fields: []types.StructFieldName{
					"encode",
					"decodeMap",
					"padChar",
				},
				Description: "",
			},
		},
		"gob": []structSet{
			structSet{
				Name: "CommonType",
				Fields: []types.StructFieldName{
					"Name",
					"Id",
				},
				Description: "",
			},
			structSet{
				Name: "Decoder",
				Fields: []types.StructFieldName{
					"mutex",
					"r",
					"buf",
					"wireType",
					"decoderCache",
					"ignorerCache",
					"freeList",
					"countBuf",
					"err",
					"ignoreDepth",
				},
				Description: "",
			},
			structSet{
				Name: "Encoder",
				Fields: []types.StructFieldName{
					"mutex",
					"w",
					"sent",
					"countState",
					"freeList",
					"byteBuf",
					"err",
				},
				Description: "",
			},
		},
		"ast": []structSet{
			structSet{
				Name: "ArrayType",
				Fields: []types.StructFieldName{
					"Lbrack",
					"Len",
					"Elt",
				},
				Description: "An ArrayType node represents an array or slice type. ",
			},
			structSet{
				Name: "AssignStmt",
				Fields: []types.StructFieldName{
					"Lhs",
					"TokPos",
					"Tok",
					"Rhs",
				},
				Description: "An AssignStmt node represents an assignment or a short variable declaration. ",
			},
			structSet{
				Name: "BadDecl",
				Fields: []types.StructFieldName{
					"From",
					"To",
				},
				Description: "A BadDecl node is a placeholder for a declaration containing syntax errors for which a correct declaration node cannot be created. ",
			},
			structSet{
				Name: "BadExpr",
				Fields: []types.StructFieldName{
					"From",
					"To",
				},
				Description: "A BadExpr node is a placeholder for an expression containing syntax errors for which a correct expression node cannot be created. ",
			},
			structSet{
				Name: "BadStmt",
				Fields: []types.StructFieldName{
					"From",
					"To",
				},
				Description: "A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created. ",
			},
			structSet{
				Name: "BasicLit",
				Fields: []types.StructFieldName{
					"ValuePos",
					"Kind",
					"Value",
				},
				Description: "A BasicLit node represents a literal of basic type. Note that for the CHAR and STRING kinds, the literal is stored with its quotes. For example, for a double-quoted STRING, the first and the last rune in the Value field will be \". The [strconv.Unquote] and [strconv.UnquoteChar] functions can be used to unquote STRING and CHAR values, respectively. For raw string literals (Kind == token.STRING && Value[0] == '`'), the Value field contains the string text without carriage returns (\\r) that may have been present in the source. Because the end position is computed using len(Value), the position reported by [BasicLit.End] does not match the true source end position for raw string literals containing carriage returns. ",
			},
			structSet{
				Name: "BinaryExpr",
				Fields: []types.StructFieldName{
					"X",
					"OpPos",
					"Op",
					"Y",
				},
				Description: "A BinaryExpr node represents a binary expression. ",
			},
			structSet{
				Name: "BlockStmt",
				Fields: []types.StructFieldName{
					"Lbrace",
					"List",
					"Rbrace",
				},
				Description: "A BlockStmt node represents a braced statement list. ",
			},
			structSet{
				Name: "BranchStmt",
				Fields: []types.StructFieldName{
					"TokPos",
					"Tok",
					"Label",
				},
				Description: "A BranchStmt node represents a break, continue, goto, or fallthrough statement. ",
			},
			structSet{
				Name: "CallExpr",
				Fields: []types.StructFieldName{
					"Fun",
					"Lparen",
					"Args",
					"Ellipsis",
					"Rparen",
				},
				Description: "A CallExpr node represents an expression followed by an argument list. ",
			},
			structSet{
				Name: "CaseClause",
				Fields: []types.StructFieldName{
					"Case",
					"List",
					"Colon",
					"Body",
				},
				Description: "A CaseClause represents a case of an expression or type switch statement. ",
			},
			structSet{
				Name: "ChanType",
				Fields: []types.StructFieldName{
					"Begin",
					"Arrow",
					"Dir",
					"Value",
				},
				Description: "A ChanType node represents a channel type. ",
			},
			structSet{
				Name: "CommClause",
				Fields: []types.StructFieldName{
					"Case",
					"Comm",
					"Colon",
					"Body",
				},
				Description: "A CommClause node represents a case of a select statement. ",
			},
			structSet{
				Name: "Comment",
				Fields: []types.StructFieldName{
					"Slash",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "CommentGroup",
				Fields: []types.StructFieldName{
					"List",
				},
				Description: "",
			},
			structSet{
				Name: "CompositeLit",
				Fields: []types.StructFieldName{
					"Type",
					"Lbrace",
					"Elts",
					"Rbrace",
					"Incomplete",
				},
				Description: "A CompositeLit node represents a composite literal. ",
			},
			structSet{
				Name: "DeclStmt",
				Fields: []types.StructFieldName{
					"Decl",
				},
				Description: "A DeclStmt node represents a declaration in a statement list. ",
			},
			structSet{
				Name: "DeferStmt",
				Fields: []types.StructFieldName{
					"Defer",
					"Call",
				},
				Description: "A DeferStmt node represents a defer statement. ",
			},
			structSet{
				Name: "Ellipsis",
				Fields: []types.StructFieldName{
					"Ellipsis",
					"Elt",
				},
				Description: "An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\" length in an array type. ",
			},
			structSet{
				Name: "EmptyStmt",
				Fields: []types.StructFieldName{
					"Semicolon",
					"Implicit",
				},
				Description: "An EmptyStmt node represents an empty statement. The \"position\" of the empty statement is the position of the immediately following (explicit or implicit) semicolon. ",
			},
			structSet{
				Name: "ExprStmt",
				Fields: []types.StructFieldName{
					"X",
				},
				Description: "An ExprStmt node represents a (stand-alone) expression in a statement list. ",
			},
			structSet{
				Name: "Field",
				Fields: []types.StructFieldName{
					"Doc",
					"Names",
					"Type",
					"Tag",
					"Comment",
				},
				Description: "",
			},
			structSet{
				Name: "FieldList",
				Fields: []types.StructFieldName{
					"Opening",
					"List",
					"Closing",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"Doc",
					"Package",
					"Name",
					"Decls",
					"FileStart",
					"FileEnd",
					"Scope",
					"Imports",
					"Unresolved",
					"Comments",
					"GoVersion",
				},
				Description: "",
			},
			structSet{
				Name: "ForStmt",
				Fields: []types.StructFieldName{
					"For",
					"Init",
					"Cond",
					"Post",
					"Body",
				},
				Description: "A ForStmt represents a for statement. ",
			},
			structSet{
				Name: "FuncDecl",
				Fields: []types.StructFieldName{
					"Doc",
					"Recv",
					"Name",
					"Type",
					"Body",
				},
				Description: "A FuncDecl node represents a function declaration. ",
			},
			structSet{
				Name: "FuncLit",
				Fields: []types.StructFieldName{
					"Type",
					"Body",
				},
				Description: "A FuncLit node represents a function literal. ",
			},
			structSet{
				Name: "FuncType",
				Fields: []types.StructFieldName{
					"Func",
					"TypeParams",
					"Params",
					"Results",
				},
				Description: "A FuncType node represents a function type. ",
			},
			structSet{
				Name: "GenDecl",
				Fields: []types.StructFieldName{
					"Doc",
					"TokPos",
					"Tok",
					"Lparen",
					"Specs",
					"Rparen",
				},
				Description: "A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration. Relationship between Tok value and Specs element type: token.IMPORT *ImportSpec token.CONST *ValueSpec token.TYPE *TypeSpec token.VAR *ValueSpec ",
			},
			structSet{
				Name: "GoStmt",
				Fields: []types.StructFieldName{
					"Go",
					"Call",
				},
				Description: "A GoStmt node represents a go statement. ",
			},
			structSet{
				Name: "Ident",
				Fields: []types.StructFieldName{
					"NamePos",
					"Name",
					"Obj",
				},
				Description: "An Ident node represents an identifier. ",
			},
			structSet{
				Name: "IfStmt",
				Fields: []types.StructFieldName{
					"If",
					"Init",
					"Cond",
					"Body",
					"Else",
				},
				Description: "An IfStmt node represents an if statement. ",
			},
			structSet{
				Name: "ImportSpec",
				Fields: []types.StructFieldName{
					"Doc",
					"Name",
					"Path",
					"Comment",
					"EndPos",
				},
				Description: "An ImportSpec node represents a single package import. ",
			},
			structSet{
				Name: "IncDecStmt",
				Fields: []types.StructFieldName{
					"X",
					"TokPos",
					"Tok",
				},
				Description: "An IncDecStmt node represents an increment or decrement statement. ",
			},
			structSet{
				Name: "IndexExpr",
				Fields: []types.StructFieldName{
					"X",
					"Lbrack",
					"Index",
					"Rbrack",
				},
				Description: "An IndexExpr node represents an expression followed by an index. ",
			},
			structSet{
				Name: "IndexListExpr",
				Fields: []types.StructFieldName{
					"X",
					"Lbrack",
					"Indices",
					"Rbrack",
				},
				Description: "An IndexListExpr node represents an expression followed by multiple indices. ",
			},
			structSet{
				Name: "InterfaceType",
				Fields: []types.StructFieldName{
					"Interface",
					"Methods",
					"Incomplete",
				},
				Description: "An InterfaceType node represents an interface type. ",
			},
			structSet{
				Name: "KeyValueExpr",
				Fields: []types.StructFieldName{
					"Key",
					"Colon",
					"Value",
				},
				Description: "A KeyValueExpr node represents (key : value) pairs in composite literals. ",
			},
			structSet{
				Name: "LabeledStmt",
				Fields: []types.StructFieldName{
					"Label",
					"Colon",
					"Stmt",
				},
				Description: "A LabeledStmt node represents a labeled statement. ",
			},
			structSet{
				Name: "MapType",
				Fields: []types.StructFieldName{
					"Map",
					"Key",
					"Value",
				},
				Description: "A MapType node represents a map type. ",
			},
			structSet{
				Name: "Object",
				Fields: []types.StructFieldName{
					"Kind",
					"Name",
					"Decl",
					"Data",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Package",
				Fields: []types.StructFieldName{
					"Name",
					"Scope",
					"Imports",
					"Files",
				},
				Description: "",
			},
			structSet{
				Name: "ParenExpr",
				Fields: []types.StructFieldName{
					"Lparen",
					"X",
					"Rparen",
				},
				Description: "A ParenExpr node represents a parenthesized expression. ",
			},
			structSet{
				Name: "RangeStmt",
				Fields: []types.StructFieldName{
					"For",
					"Key",
					"Value",
					"TokPos",
					"Tok",
					"Range",
					"X",
					"Body",
				},
				Description: "A RangeStmt represents a for statement with a range clause. ",
			},
			structSet{
				Name: "ReturnStmt",
				Fields: []types.StructFieldName{
					"Return",
					"Results",
				},
				Description: "A ReturnStmt node represents a return statement. ",
			},
			structSet{
				Name: "Scope",
				Fields: []types.StructFieldName{
					"Outer",
					"Objects",
				},
				Description: "",
			},
			structSet{
				Name: "SelectStmt",
				Fields: []types.StructFieldName{
					"Select",
					"Body",
				},
				Description: "A SelectStmt node represents a select statement. ",
			},
			structSet{
				Name: "SelectorExpr",
				Fields: []types.StructFieldName{
					"X",
					"Sel",
				},
				Description: "A SelectorExpr node represents an expression followed by a selector. ",
			},
			structSet{
				Name: "SendStmt",
				Fields: []types.StructFieldName{
					"Chan",
					"Arrow",
					"Value",
				},
				Description: "A SendStmt node represents a send statement. ",
			},
			structSet{
				Name: "SliceExpr",
				Fields: []types.StructFieldName{
					"X",
					"Lbrack",
					"Low",
					"High",
					"Max",
					"Slice3",
					"Rbrack",
				},
				Description: "A SliceExpr node represents an expression followed by slice indices. ",
			},
			structSet{
				Name: "StarExpr",
				Fields: []types.StructFieldName{
					"Star",
					"X",
				},
				Description: "A StarExpr node represents an expression of the form \"*\" Expression. Semantically it could be a unary \"*\" expression, or a pointer type. ",
			},
			structSet{
				Name: "StructType",
				Fields: []types.StructFieldName{
					"Struct",
					"Fields",
					"Incomplete",
				},
				Description: "A StructType node represents a struct type. ",
			},
			structSet{
				Name: "SwitchStmt",
				Fields: []types.StructFieldName{
					"Switch",
					"Init",
					"Tag",
					"Body",
				},
				Description: "A SwitchStmt node represents an expression switch statement. ",
			},
			structSet{
				Name: "TypeAssertExpr",
				Fields: []types.StructFieldName{
					"X",
					"Lparen",
					"Type",
					"Rparen",
				},
				Description: "A TypeAssertExpr node represents an expression followed by a type assertion. ",
			},
			structSet{
				Name: "TypeSpec",
				Fields: []types.StructFieldName{
					"Doc",
					"Name",
					"TypeParams",
					"Assign",
					"Type",
					"Comment",
				},
				Description: "A TypeSpec node represents a type declaration (TypeSpec production). ",
			},
			structSet{
				Name: "TypeSwitchStmt",
				Fields: []types.StructFieldName{
					"Switch",
					"Init",
					"Assign",
					"Body",
				},
				Description: "A TypeSwitchStmt node represents a type switch statement. ",
			},
			structSet{
				Name: "UnaryExpr",
				Fields: []types.StructFieldName{
					"OpPos",
					"Op",
					"X",
				},
				Description: "A UnaryExpr node represents a unary expression. Unary \"*\" expressions are represented via StarExpr nodes. ",
			},
			structSet{
				Name: "ValueSpec",
				Fields: []types.StructFieldName{
					"Doc",
					"Names",
					"Type",
					"Values",
					"Comment",
				},
				Description: "A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production). ",
			},
		},
		"pkgbits": []structSet{
			structSet{
				Name: "Decoder",
				Fields: []types.StructFieldName{
					"common",
					"Relocs",
					"Data",
					"k",
					"Idx",
				},
				Description: "",
			},
			structSet{
				Name: "Encoder",
				Fields: []types.StructFieldName{
					"p",
					"Relocs",
					"RelocMap",
					"Data",
					"encodingRelocHeader",
					"k",
					"Idx",
				},
				Description: "",
			},
			structSet{
				Name: "PkgDecoder",
				Fields: []types.StructFieldName{
					"version",
					"sync",
					"pkgPath",
					"elemData",
					"elemEnds",
					"elemEndsEnds",
					"scratchRelocEnt",
				},
				Description: "",
			},
			structSet{
				Name: "PkgEncoder",
				Fields: []types.StructFieldName{
					"version",
					"elems",
					"stringsIdx",
					"syncFrames",
				},
				Description: "",
			},
			structSet{
				Name: "RefTableEntry",
				Fields: []types.StructFieldName{
					"Kind",
					"Idx",
				},
				Description: "",
			},
		},
		"cmerge": []structSet{
			structSet{
				Name: "Merger",
				Fields: []types.StructFieldName{
					"cmode",
					"cgran",
					"policy",
					"overflow",
				},
				Description: "",
			},
		},
		"exithook": []structSet{
			structSet{
				Name: "Hook",
				Fields: []types.StructFieldName{
					"F",
					"RunOnFailure",
				},
				Description: "",
			},
		},
		"unicode": []structSet{
			structSet{
				Name: "CaseRange",
				Fields: []types.StructFieldName{
					"Lo",
					"Hi",
					"Delta",
				},
				Description: "",
			},
			structSet{
				Name: "Range16",
				Fields: []types.StructFieldName{
					"Lo",
					"Hi",
					"Stride",
				},
				Description: "",
			},
			structSet{
				Name: "Range32",
				Fields: []types.StructFieldName{
					"Lo",
					"Hi",
					"Stride",
				},
				Description: "",
			},
			structSet{
				Name: "RangeTable",
				Fields: []types.StructFieldName{
					"R16",
					"R32",
					"LatinOffset",
				},
				Description: "",
			},
		},
		"unique": []structSet{
			structSet{
				Name: "Handle",
				Fields: []types.StructFieldName{
					"value",
				},
				Description: "",
			},
		},
		"build": []structSet{
			structSet{
				Name: "Context",
				Fields: []types.StructFieldName{
					"GOARCH",
					"GOOS",
					"GOROOT",
					"GOPATH",
					"Dir",
					"CgoEnabled",
					"UseAllFiles",
					"Compiler",
					"BuildTags",
					"ToolTags",
					"ReleaseTags",
					"InstallSuffix",
					"JoinPath",
					"SplitPathList",
					"IsAbsPath",
					"IsDir",
					"HasSubdir",
					"ReadDir",
					"OpenFile",
				},
				Description: "",
			},
			structSet{
				Name: "Directive",
				Fields: []types.StructFieldName{
					"Text",
					"Pos",
				},
				Description: "",
			},
			structSet{
				Name: "MultiplePackageError",
				Fields: []types.StructFieldName{
					"Dir",
					"Packages",
					"Files",
				},
				Description: "",
			},
			structSet{
				Name: "NoGoError",
				Fields: []types.StructFieldName{
					"Dir",
				},
				Description: "",
			},
			structSet{
				Name: "Package",
				Fields: []types.StructFieldName{
					"Dir",
					"Name",
					"ImportComment",
					"Doc",
					"ImportPath",
					"Root",
					"SrcRoot",
					"PkgRoot",
					"PkgTargetRoot",
					"BinDir",
					"Goroot",
					"PkgObj",
					"AllTags",
					"ConflictDir",
					"BinaryOnly",
					"GoFiles",
					"CgoFiles",
					"IgnoredGoFiles",
					"InvalidGoFiles",
					"IgnoredOtherFiles",
					"CFiles",
					"CXXFiles",
					"MFiles",
					"HFiles",
					"FFiles",
					"SFiles",
					"SwigFiles",
					"SwigCXXFiles",
					"SysoFiles",
					"CgoCFLAGS",
					"CgoCPPFLAGS",
					"CgoCXXFLAGS",
					"CgoFFLAGS",
					"CgoLDFLAGS",
					"CgoPkgConfig",
					"TestGoFiles",
					"XTestGoFiles",
					"Directives",
					"TestDirectives",
					"XTestDirectives",
					"Imports",
					"ImportPos",
					"TestImports",
					"TestImportPos",
					"XTestImports",
					"XTestImportPos",
					"EmbedPatterns",
					"EmbedPatternPos",
					"TestEmbedPatterns",
					"TestEmbedPatternPos",
					"XTestEmbedPatterns",
					"XTestEmbedPatternPos",
				},
				Description: "",
			},
		},
		"parse": []structSet{
			structSet{
				Name: "ActionNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Line",
					"Pipe",
				},
				Description: "",
			},
			structSet{
				Name: "BoolNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"True",
				},
				Description: "",
			},
			structSet{
				Name: "BranchNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Line",
					"Pipe",
					"List",
					"ElseList",
				},
				Description: "",
			},
			structSet{
				Name: "BreakNode",
				Fields: []types.StructFieldName{
					"tr",
					"NodeType",
					"Pos",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "ChainNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Node",
					"Field",
				},
				Description: "",
			},
			structSet{
				Name: "CommandNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Args",
				},
				Description: "",
			},
			structSet{
				Name: "CommentNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "ContinueNode",
				Fields: []types.StructFieldName{
					"tr",
					"NodeType",
					"Pos",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "DotNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
				},
				Description: "",
			},
			structSet{
				Name: "FieldNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Ident",
				},
				Description: "",
			},
			structSet{
				Name: "IdentifierNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Ident",
				},
				Description: "",
			},
			structSet{
				Name: "IfNode",
				Fields: []types.StructFieldName{
					"BranchNode",
				},
				Description: "",
			},
			structSet{
				Name: "ListNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Nodes",
				},
				Description: "",
			},
			structSet{
				Name: "NilNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
				},
				Description: "",
			},
			structSet{
				Name: "NumberNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"IsInt",
					"IsUint",
					"IsFloat",
					"IsComplex",
					"Int64",
					"Uint64",
					"Float64",
					"Complex128",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "PipeNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Line",
					"IsAssign",
					"Decl",
					"Cmds",
				},
				Description: "",
			},
			structSet{
				Name: "RangeNode",
				Fields: []types.StructFieldName{
					"BranchNode",
				},
				Description: "",
			},
			structSet{
				Name: "StringNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Quoted",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "TemplateNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Line",
					"Name",
					"Pipe",
				},
				Description: "",
			},
			structSet{
				Name: "TextNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Text",
				},
				Description: "",
			},
			structSet{
				Name: "Tree",
				Fields: []types.StructFieldName{
					"Name",
					"ParseName",
					"Root",
					"Mode",
					"text",
					"funcs",
					"lex",
					"token",
					"peekCount",
					"vars",
					"treeSet",
					"actionLine",
					"rangeDepth",
					"stackDepth",
				},
				Description: "",
			},
			structSet{
				Name: "VariableNode",
				Fields: []types.StructFieldName{
					"NodeType",
					"Pos",
					"tr",
					"Ident",
				},
				Description: "",
			},
			structSet{
				Name: "WithNode",
				Fields: []types.StructFieldName{
					"BranchNode",
				},
				Description: "",
			},
		},
		"color": []structSet{
			structSet{
				Name: "Alpha",
				Fields: []types.StructFieldName{
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "Alpha16",
				Fields: []types.StructFieldName{
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "CMYK",
				Fields: []types.StructFieldName{
					"C",
					"M",
					"Y",
					"K",
				},
				Description: "",
			},
			structSet{
				Name: "Gray",
				Fields: []types.StructFieldName{
					"Y",
				},
				Description: "",
			},
			structSet{
				Name: "Gray16",
				Fields: []types.StructFieldName{
					"Y",
				},
				Description: "",
			},
			structSet{
				Name: "NRGBA",
				Fields: []types.StructFieldName{
					"R",
					"G",
					"B",
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "NRGBA64",
				Fields: []types.StructFieldName{
					"R",
					"G",
					"B",
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "NYCbCrA",
				Fields: []types.StructFieldName{
					"YCbCr",
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "RGBA",
				Fields: []types.StructFieldName{
					"R",
					"G",
					"B",
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "RGBA64",
				Fields: []types.StructFieldName{
					"R",
					"G",
					"B",
					"A",
				},
				Description: "",
			},
			structSet{
				Name: "YCbCr",
				Fields: []types.StructFieldName{
					"Y",
					"Cb",
					"Cr",
				},
				Description: "",
			},
		},
		"slicereader": []structSet{
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"b",
					"readonly",
					"off",
				},
				Description: "",
			},
		},
		"stringtab": []structSet{
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"strs",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"stab",
					"strs",
					"tmp",
					"frozen",
				},
				Description: "",
			},
		},
		"sha256": []structSet{
			structSet{
				Name: "Digest",
				Fields: []types.StructFieldName{
					"h",
					"x",
					"nx",
					"len",
					"is224",
				},
				Description: "",
			},
		},
		"mlkem": []structSet{
			structSet{
				Name: "DecapsulationKey1024",
				Fields: []types.StructFieldName{
					"d",
					"z",
					"Ï",
					"h",
					"encryptionKey1024",
					"decryptionKey1024",
				},
				Description: "",
			},
			structSet{
				Name: "DecapsulationKey768",
				Fields: []types.StructFieldName{
					"d",
					"z",
					"Ï",
					"h",
					"encryptionKey",
					"decryptionKey",
				},
				Description: "",
			},
			structSet{
				Name: "EncapsulationKey1024",
				Fields: []types.StructFieldName{
					"Ï",
					"h",
					"encryptionKey1024",
				},
				Description: "",
			},
			structSet{
				Name: "EncapsulationKey768",
				Fields: []types.StructFieldName{
					"Ï",
					"h",
					"encryptionKey",
				},
				Description: "",
			},
			structSet{
				Name: "DecapsulationKey1024",
				Fields: []types.StructFieldName{
					"key",
				},
				Description: "",
			},
			structSet{
				Name: "DecapsulationKey768",
				Fields: []types.StructFieldName{
					"key",
				},
				Description: "",
			},
			structSet{
				Name: "EncapsulationKey1024",
				Fields: []types.StructFieldName{
					"key",
				},
				Description: "",
			},
			structSet{
				Name: "EncapsulationKey768",
				Fields: []types.StructFieldName{
					"key",
				},
				Description: "",
			},
		},
		"rsa": []structSet{
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"pub",
					"d",
					"p",
					"q",
					"dP",
					"dQ",
					"qInv",
					"fipsApproved",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKey",
				Fields: []types.StructFieldName{
					"N",
					"E",
				},
				Description: "",
			},
			structSet{
				Name: "CRTValue",
				Fields: []types.StructFieldName{
					"Exp",
					"Coeff",
					"R",
				},
				Description: "",
			},
			structSet{
				Name: "OAEPOptions",
				Fields: []types.StructFieldName{
					"Hash",
					"MGFHash",
					"Label",
				},
				Description: "",
			},
			structSet{
				Name: "PKCS1v15DecryptOptions",
				Fields: []types.StructFieldName{
					"SessionKeyLen",
				},
				Description: "",
			},
			structSet{
				Name: "PSSOptions",
				Fields: []types.StructFieldName{
					"SaltLength",
					"Hash",
				},
				Description: "",
			},
			structSet{
				Name: "PrecomputedValues",
				Fields: []types.StructFieldName{
					"Dp",
					"Dq",
					"Qinv",
					"CRTValues",
					"fips",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"PublicKey",
					"D",
					"Primes",
					"Precomputed",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKey",
				Fields: []types.StructFieldName{
					"N",
					"E",
				},
				Description: "",
			},
		},
		"dwarf": []structSet{
			structSet{
				Name: "AddrType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "ArrayType",
				Fields: []types.StructFieldName{
					"CommonType",
					"Type",
					"StrideBitSize",
					"Count",
				},
				Description: "",
			},
			structSet{
				Name: "BasicType",
				Fields: []types.StructFieldName{
					"CommonType",
					"BitSize",
					"BitOffset",
					"DataBitOffset",
				},
				Description: "",
			},
			structSet{
				Name: "BoolType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "CharType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "CommonType",
				Fields: []types.StructFieldName{
					"ByteSize",
					"Name",
				},
				Description: "",
			},
			structSet{
				Name: "ComplexType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "Data",
				Fields: []types.StructFieldName{
					"abbrev",
					"aranges",
					"frame",
					"info",
					"line",
					"pubnames",
					"ranges",
					"str",
					"addr",
					"lineStr",
					"strOffsets",
					"rngLists",
					"abbrevCache",
					"bigEndian",
					"order",
					"typeCache",
					"typeSigs",
					"unit",
				},
				Description: "",
			},
			structSet{
				Name: "DecodeError",
				Fields: []types.StructFieldName{
					"Name",
					"Offset",
					"Err",
				},
				Description: "",
			},
			structSet{
				Name: "DotDotDotType",
				Fields: []types.StructFieldName{
					"CommonType",
				},
				Description: "",
			},
			structSet{
				Name: "Entry",
				Fields: []types.StructFieldName{
					"Offset",
					"Tag",
					"Children",
					"Field",
				},
				Description: "",
			},
			structSet{
				Name: "EnumType",
				Fields: []types.StructFieldName{
					"CommonType",
					"EnumName",
					"Val",
				},
				Description: "",
			},
			structSet{
				Name: "EnumValue",
				Fields: []types.StructFieldName{
					"Name",
					"Val",
				},
				Description: "",
			},
			structSet{
				Name: "Field",
				Fields: []types.StructFieldName{
					"Attr",
					"Val",
					"Class",
				},
				Description: "",
			},
			structSet{
				Name: "FloatType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "FuncType",
				Fields: []types.StructFieldName{
					"CommonType",
					"ReturnType",
					"ParamType",
				},
				Description: "",
			},
			structSet{
				Name: "IntType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "LineEntry",
				Fields: []types.StructFieldName{
					"Address",
					"OpIndex",
					"File",
					"Line",
					"Column",
					"IsStmt",
					"BasicBlock",
					"PrologueEnd",
					"EpilogueBegin",
					"ISA",
					"Discriminator",
					"EndSequence",
				},
				Description: "",
			},
			structSet{
				Name: "LineFile",
				Fields: []types.StructFieldName{
					"Name",
					"Mtime",
					"Length",
				},
				Description: "",
			},
			structSet{
				Name: "LineReader",
				Fields: []types.StructFieldName{
					"buf",
					"section",
					"str",
					"lineStr",
					"version",
					"addrsize",
					"segmentSelectorSize",
					"minInstructionLength",
					"maxOpsPerInstruction",
					"defaultIsStmt",
					"lineBase",
					"lineRange",
					"opcodeBase",
					"opcodeLengths",
					"directories",
					"fileEntries",
					"programOffset",
					"endOffset",
					"initialFileEntries",
					"state",
					"fileIndex",
				},
				Description: "",
			},
			structSet{
				Name: "LineReaderPos",
				Fields: []types.StructFieldName{
					"off",
					"numFileEntries",
					"state",
					"fileIndex",
				},
				Description: "",
			},
			structSet{
				Name: "PtrType",
				Fields: []types.StructFieldName{
					"CommonType",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "QualType",
				Fields: []types.StructFieldName{
					"CommonType",
					"Qual",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"b",
					"d",
					"err",
					"unit",
					"lastUnit",
					"lastChildren",
					"lastSibling",
					"cu",
				},
				Description: "",
			},
			structSet{
				Name: "StructField",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"ByteOffset",
					"ByteSize",
					"BitOffset",
					"DataBitOffset",
					"BitSize",
				},
				Description: "",
			},
			structSet{
				Name: "StructType",
				Fields: []types.StructFieldName{
					"CommonType",
					"StructName",
					"Kind",
					"Field",
					"Incomplete",
				},
				Description: "",
			},
			structSet{
				Name: "TypedefType",
				Fields: []types.StructFieldName{
					"CommonType",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "UcharType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "UintType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "UnspecifiedType",
				Fields: []types.StructFieldName{
					"BasicType",
				},
				Description: "",
			},
			structSet{
				Name: "UnsupportedType",
				Fields: []types.StructFieldName{
					"CommonType",
					"Tag",
				},
				Description: "",
			},
			structSet{
				Name: "VoidType",
				Fields: []types.StructFieldName{
					"CommonType",
				},
				Description: "",
			},
		},
		"testpty": []structSet{
			structSet{
				Name: "PtyError",
				Fields: []types.StructFieldName{
					"FuncName",
					"ErrorString",
					"Errno",
				},
				Description: "",
			},
		},
		"slog": []structSet{
			structSet{
				Name: "Attr",
				Fields: []types.StructFieldName{
					"Key",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "HandlerOptions",
				Fields: []types.StructFieldName{
					"AddSource",
					"Level",
					"ReplaceAttr",
				},
				Description: "",
			},
			structSet{
				Name: "JSONHandler",
				Fields: []types.StructFieldName{
					"commonHandler",
				},
				Description: "",
			},
			structSet{
				Name: "LevelVar",
				Fields: []types.StructFieldName{
					"val",
				},
				Description: "",
			},
			structSet{
				Name: "Logger",
				Fields: []types.StructFieldName{
					"handler",
				},
				Description: "",
			},
			structSet{
				Name: "Record",
				Fields: []types.StructFieldName{
					"Time",
					"Message",
					"Level",
					"PC",
					"front",
					"nFront",
					"back",
				},
				Description: "",
			},
			structSet{
				Name: "Source",
				Fields: []types.StructFieldName{
					"Function",
					"File",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "TextHandler",
				Fields: []types.StructFieldName{
					"commonHandler",
				},
				Description: "",
			},
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"_",
					"num",
					"any",
				},
				Description: "",
			},
		},
		"metrics": []structSet{
			structSet{
				Name: "Description",
				Fields: []types.StructFieldName{
					"Name",
					"Description",
					"Kind",
					"Cumulative",
				},
				Description: "",
			},
			structSet{
				Name: "Float64Histogram",
				Fields: []types.StructFieldName{
					"Counts",
					"Buckets",
				},
				Description: "",
			},
			structSet{
				Name: "Sample",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"kind",
					"scalar",
					"pointer",
				},
				Description: "",
			},
		},
		"strconv": []structSet{
			structSet{
				Name: "NumError",
				Fields: []types.StructFieldName{
					"Func",
					"Num",
					"Err",
				},
				Description: "",
			},
		},
		"time": []structSet{
			structSet{
				Name: "ParseError",
				Fields: []types.StructFieldName{
					"Layout",
					"Value",
					"LayoutElem",
					"ValueElem",
					"Message",
				},
				Description: "",
			},
			structSet{
				Name: "Ticker",
				Fields: []types.StructFieldName{
					"C",
					"initTicker",
				},
				Description: "",
			},
			structSet{
				Name: "Time",
				Fields: []types.StructFieldName{
					"wall",
					"ext",
					"loc",
				},
				Description: "",
			},
			structSet{
				Name: "Timer",
				Fields: []types.StructFieldName{
					"C",
					"initTimer",
				},
				Description: "",
			},
		},
		"strings": []structSet{
			structSet{
				Name: "Builder",
				Fields: []types.StructFieldName{
					"addr",
					"buf",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"s",
					"i",
					"prevRune",
				},
				Description: "",
			},
			structSet{
				Name: "Replacer",
				Fields: []types.StructFieldName{
					"once",
					"r",
					"oldnew",
				},
				Description: "",
			},
		},
		"aes": []structSet{
			structSet{
				Name: "Block",
				Fields: []types.StructFieldName{
					"block",
				},
				Description: "",
			},
			structSet{
				Name: "CBCDecrypter",
				Fields: []types.StructFieldName{
					"b",
					"iv",
				},
				Description: "",
			},
			structSet{
				Name: "CBCEncrypter",
				Fields: []types.StructFieldName{
					"b",
					"iv",
				},
				Description: "",
			},
			structSet{
				Name: "CTR",
				Fields: []types.StructFieldName{
					"b",
					"ivlo",
					"ivhi",
					"offset",
				},
				Description: "",
			},
		},
		"cipher": []structSet{
			structSet{
				Name: "StreamReader",
				Fields: []types.StructFieldName{
					"S",
					"R",
				},
				Description: "",
			},
			structSet{
				Name: "StreamWriter",
				Fields: []types.StructFieldName{
					"S",
					"W",
					"Err",
				},
				Description: "",
			},
		},
		"ecdsa": []structSet{
			structSet{
				Name: "Curve",
				Fields: []types.StructFieldName{
					"curve",
					"newPoint",
					"ordInverse",
					"N",
					"nMinus2",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"pub",
					"d",
				},
				Description: "",
			},
			structSet{
				Name: "Signature",
				Fields: []types.StructFieldName{
					"R",
					"S",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"PublicKey",
					"D",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKey",
				Fields: []types.StructFieldName{
					"Curve",
					"X",
					"Y",
				},
				Description: "",
			},
		},
		"x509": []structSet{
			structSet{
				Name: "CertPool",
				Fields: []types.StructFieldName{
					"byName",
					"lazyCerts",
					"haveSum",
					"systemPool",
				},
				Description: "",
			},
			structSet{
				Name: "Certificate",
				Fields: []types.StructFieldName{
					"Raw",
					"RawTBSCertificate",
					"RawSubjectPublicKeyInfo",
					"RawSubject",
					"RawIssuer",
					"Signature",
					"SignatureAlgorithm",
					"PublicKeyAlgorithm",
					"PublicKey",
					"Version",
					"SerialNumber",
					"Issuer",
					"Subject",
					"NotBefore",
					"NotAfter",
					"KeyUsage",
					"Extensions",
					"ExtraExtensions",
					"UnhandledCriticalExtensions",
					"ExtKeyUsage",
					"UnknownExtKeyUsage",
					"BasicConstraintsValid",
					"IsCA",
					"MaxPathLen",
					"MaxPathLenZero",
					"SubjectKeyId",
					"AuthorityKeyId",
					"OCSPServer",
					"IssuingCertificateURL",
					"DNSNames",
					"EmailAddresses",
					"IPAddresses",
					"URIs",
					"PermittedDNSDomainsCritical",
					"PermittedDNSDomains",
					"ExcludedDNSDomains",
					"PermittedIPRanges",
					"ExcludedIPRanges",
					"PermittedEmailAddresses",
					"ExcludedEmailAddresses",
					"PermittedURIDomains",
					"ExcludedURIDomains",
					"CRLDistributionPoints",
					"PolicyIdentifiers",
					"Policies",
					"InhibitAnyPolicy",
					"InhibitAnyPolicyZero",
					"InhibitPolicyMapping",
					"InhibitPolicyMappingZero",
					"RequireExplicitPolicy",
					"RequireExplicitPolicyZero",
					"PolicyMappings",
				},
				Description: "",
			},
			structSet{
				Name: "CertificateInvalidError",
				Fields: []types.StructFieldName{
					"Cert",
					"Reason",
					"Detail",
				},
				Description: "",
			},
			structSet{
				Name: "CertificateRequest",
				Fields: []types.StructFieldName{
					"Raw",
					"RawTBSCertificateRequest",
					"RawSubjectPublicKeyInfo",
					"RawSubject",
					"Version",
					"Signature",
					"SignatureAlgorithm",
					"PublicKeyAlgorithm",
					"PublicKey",
					"Subject",
					"Attributes",
					"Extensions",
					"ExtraExtensions",
					"DNSNames",
					"EmailAddresses",
					"IPAddresses",
					"URIs",
				},
				Description: "",
			},
			structSet{
				Name:        "ConstraintViolationError",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "HostnameError",
				Fields: []types.StructFieldName{
					"Certificate",
					"Host",
				},
				Description: "",
			},
			structSet{
				Name: "OID",
				Fields: []types.StructFieldName{
					"der",
				},
				Description: "",
			},
			structSet{
				Name: "PolicyMapping",
				Fields: []types.StructFieldName{
					"IssuerDomainPolicy",
					"SubjectDomainPolicy",
				},
				Description: "",
			},
			structSet{
				Name: "RevocationList",
				Fields: []types.StructFieldName{
					"Raw",
					"RawTBSRevocationList",
					"RawIssuer",
					"Issuer",
					"AuthorityKeyId",
					"Signature",
					"SignatureAlgorithm",
					"RevokedCertificateEntries",
					"RevokedCertificates",
					"Number",
					"ThisUpdate",
					"NextUpdate",
					"Extensions",
					"ExtraExtensions",
				},
				Description: "",
			},
			structSet{
				Name: "RevocationListEntry",
				Fields: []types.StructFieldName{
					"Raw",
					"SerialNumber",
					"RevocationTime",
					"ReasonCode",
					"Extensions",
					"ExtraExtensions",
				},
				Description: "",
			},
			structSet{
				Name: "SystemRootsError",
				Fields: []types.StructFieldName{
					"Err",
				},
				Description: "",
			},
			structSet{
				Name:        "UnhandledCriticalExtension",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "UnknownAuthorityError",
				Fields: []types.StructFieldName{
					"Cert",
					"hintErr",
					"hintCert",
				},
				Description: "",
			},
			structSet{
				Name: "VerifyOptions",
				Fields: []types.StructFieldName{
					"DNSName",
					"Intermediates",
					"Roots",
					"CurrentTime",
					"KeyUsages",
					"MaxConstraintComparisions",
					"CertificatePolicies",
					"inhibitPolicyMapping",
					"requireExplicitPolicy",
					"inhibitAnyPolicy",
				},
				Description: "",
			},
		},
		"embed": []structSet{
			structSet{
				Name: "FS",
				Fields: []types.StructFieldName{
					"files",
				},
				Description: "",
			},
		},
		"cpu": []structSet{
			structSet{
				Name: "CacheLinePad",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
		},
		"raw": []structSet{
			structSet{
				Name: "Event",
				Fields: []types.StructFieldName{
					"Version",
					"Ev",
					"Args",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"v",
					"specs",
				},
				Description: "",
			},
			structSet{
				Name: "TextReader",
				Fields: []types.StructFieldName{
					"v",
					"specs",
					"names",
					"s",
				},
				Description: "",
			},
			structSet{
				Name: "TextWriter",
				Fields: []types.StructFieldName{
					"w",
					"v",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"w",
					"buf",
					"v",
					"specs",
				},
				Description: "",
			},
		},
		"txtar": []structSet{
			structSet{
				Name: "Archive",
				Fields: []types.StructFieldName{
					"Comment",
					"Files",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"Name",
					"Data",
				},
				Description: "",
			},
		},
		"httputil": []structSet{
			structSet{
				Name: "ClientConn",
				Fields: []types.StructFieldName{
					"mu",
					"c",
					"r",
					"re",
					"we",
					"lastbody",
					"nread",
					"nwritten",
					"pipereq",
					"pipe",
					"writeReq",
				},
				Description: "",
			},
			structSet{
				Name: "ProxyRequest",
				Fields: []types.StructFieldName{
					"In",
					"Out",
				},
				Description: "",
			},
			structSet{
				Name: "ReverseProxy",
				Fields: []types.StructFieldName{
					"Rewrite",
					"Director",
					"Transport",
					"FlushInterval",
					"ErrorLog",
					"BufferPool",
					"ModifyResponse",
					"ErrorHandler",
				},
				Description: "",
			},
			structSet{
				Name: "ServerConn",
				Fields: []types.StructFieldName{
					"mu",
					"c",
					"r",
					"re",
					"we",
					"lastbody",
					"nread",
					"nwritten",
					"pipereq",
					"pipe",
				},
				Description: "",
			},
		},
		"cgo": []structSet{
			structSet{
				Name: "Incomplete",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
		},
		"socktest": []structSet{
			structSet{
				Name: "Stat",
				Fields: []types.StructFieldName{
					"Family",
					"Type",
					"Protocol",
					"Opened",
					"Connected",
					"Listened",
					"Accepted",
					"Closed",
					"OpenFailed",
					"ConnectFailed",
					"ListenFailed",
					"AcceptFailed",
					"CloseFailed",
				},
				Description: "",
			},
			structSet{
				Name: "Status",
				Fields: []types.StructFieldName{
					"Cookie",
					"Err",
					"SocketErr",
				},
				Description: "",
			},
			structSet{
				Name: "Switch",
				Fields: []types.StructFieldName{
					"once",
					"fmu",
					"fltab",
					"smu",
					"sotab",
					"stats",
				},
				Description: "",
			},
		},
		"structs": []structSet{
			structSet{
				Name: "HostLayout",
				Fields: []types.StructFieldName{
					"_",
				},
				Description: "",
			},
		},
		"rand": []structSet{
			structSet{
				Name: "ChaCha8",
				Fields: []types.StructFieldName{
					"state",
					"readBuf",
					"readLen",
				},
				Description: "",
			},
			structSet{
				Name: "PCG",
				Fields: []types.StructFieldName{
					"hi",
					"lo",
				},
				Description: "",
			},
			structSet{
				Name: "Rand",
				Fields: []types.StructFieldName{
					"src",
				},
				Description: "",
			},
			structSet{
				Name: "Zipf",
				Fields: []types.StructFieldName{
					"r",
					"imax",
					"v",
					"q",
					"s",
					"oneminusQ",
					"oneminusQinv",
					"hxm",
					"hx0minusHxm",
				},
				Description: "",
			},
			structSet{
				Name: "Rand",
				Fields: []types.StructFieldName{
					"src",
					"s64",
					"readVal",
					"readPos",
				},
				Description: "",
			},
			structSet{
				Name: "Zipf",
				Fields: []types.StructFieldName{
					"r",
					"imax",
					"v",
					"q",
					"s",
					"oneminusQ",
					"oneminusQinv",
					"hxm",
					"hx0minusHxm",
				},
				Description: "",
			},
		},
		"weak": []structSet{
			structSet{
				Name: "Pointer",
				Fields: []types.StructFieldName{
					"_",
					"u",
				},
				Description: "",
			},
		},
		"json": []structSet{
			structSet{
				Name: "Decoder",
				Fields: []types.StructFieldName{
					"r",
					"buf",
					"d",
					"scanp",
					"scanned",
					"scan",
					"err",
					"tokenState",
					"tokenStack",
				},
				Description: "",
			},
			structSet{
				Name: "Encoder",
				Fields: []types.StructFieldName{
					"w",
					"err",
					"escapeHTML",
					"indentBuf",
					"indentPrefix",
					"indentValue",
				},
				Description: "",
			},
			structSet{
				Name: "InvalidUTF8Error",
				Fields: []types.StructFieldName{
					"S",
				},
				Description: "",
			},
			structSet{
				Name: "InvalidUnmarshalError",
				Fields: []types.StructFieldName{
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "MarshalerError",
				Fields: []types.StructFieldName{
					"Type",
					"Err",
					"sourceFunc",
				},
				Description: "",
			},
			structSet{
				Name: "SyntaxError",
				Fields: []types.StructFieldName{
					"msg",
					"Offset",
				},
				Description: "",
			},
			structSet{
				Name: "UnmarshalFieldError",
				Fields: []types.StructFieldName{
					"Key",
					"Type",
					"Field",
				},
				Description: "",
			},
			structSet{
				Name: "UnmarshalTypeError",
				Fields: []types.StructFieldName{
					"Value",
					"Type",
					"Offset",
					"Struct",
					"Field",
				},
				Description: "",
			},
			structSet{
				Name: "UnsupportedTypeError",
				Fields: []types.StructFieldName{
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "UnsupportedValueError",
				Fields: []types.StructFieldName{
					"Value",
					"Str",
				},
				Description: "",
			},
		},
		"trace": []structSet{
			structSet{
				Name: "FlightRecorder",
				Fields: []types.StructFieldName{
					"err",
					"header",
					"active",
					"ringMu",
					"ring",
					"freq",
					"targetSize",
					"targetPeriod",
					"enabled",
					"writing",
					"wantSize",
					"wantDur",
				},
				Description: "",
			},
			structSet{
				Name: "FlightRecorderConfig",
				Fields: []types.StructFieldName{
					"MinAge",
					"MaxBytes",
				},
				Description: "",
			},
			structSet{
				Name: "Region",
				Fields: []types.StructFieldName{
					"id",
					"regionType",
				},
				Description: "",
			},
			structSet{
				Name: "Task",
				Fields: []types.StructFieldName{
					"id",
				},
				Description: "",
			},
			structSet{
				Name: "ClockSnapshot",
				Fields: []types.StructFieldName{
					"Trace",
					"Wall",
					"Mono",
				},
				Description: "",
			},
			structSet{
				Name: "Event",
				Fields: []types.StructFieldName{
					"table",
					"ctx",
					"base",
				},
				Description: "",
			},
			structSet{
				Name: "ExperimentalBatch",
				Fields: []types.StructFieldName{
					"Thread",
					"Data",
				},
				Description: "",
			},
			structSet{
				Name: "ExperimentalEvent",
				Fields: []types.StructFieldName{
					"Name",
					"Experiment",
					"Args",
					"table",
					"argValues",
				},
				Description: "",
			},
			structSet{
				Name: "GoroutineExecStats",
				Fields: []types.StructFieldName{
					"ExecTime",
					"SchedWaitTime",
					"BlockTimeByReason",
					"SyscallTime",
					"SyscallBlockTime",
					"TotalTime",
					"RangeTime",
				},
				Description: "",
			},
			structSet{
				Name: "GoroutineSummary",
				Fields: []types.StructFieldName{
					"ID",
					"Name",
					"PC",
					"CreationTime",
					"StartTime",
					"EndTime",
					"Regions",
					"GoroutineExecStats",
					"goroutineSummary",
				},
				Description: "",
			},
			structSet{
				Name: "Label",
				Fields: []types.StructFieldName{
					"Label",
					"Resource",
				},
				Description: "",
			},
			structSet{
				Name: "Log",
				Fields: []types.StructFieldName{
					"Task",
					"Category",
					"Message",
				},
				Description: "",
			},
			structSet{
				Name: "MMUCurve",
				Fields: []types.StructFieldName{
					"series",
				},
				Description: "",
			},
			structSet{
				Name: "Metric",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "MutatorUtil",
				Fields: []types.StructFieldName{
					"Time",
					"Util",
				},
				Description: "",
			},
			structSet{
				Name: "Range",
				Fields: []types.StructFieldName{
					"Name",
					"Scope",
				},
				Description: "",
			},
			structSet{
				Name: "RangeAttribute",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"version",
					"r",
					"lastTs",
					"gen",
					"spill",
					"spillErr",
					"spillErrSync",
					"frontier",
					"cpuSamples",
					"order",
					"syncs",
					"done",
					"v1Events",
				},
				Description: "",
			},
			structSet{
				Name: "Region",
				Fields: []types.StructFieldName{
					"Task",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "ResourceID",
				Fields: []types.StructFieldName{
					"Kind",
					"id",
				},
				Description: "",
			},
			structSet{
				Name: "Stack",
				Fields: []types.StructFieldName{
					"table",
					"id",
				},
				Description: "",
			},
			structSet{
				Name: "StackFrame",
				Fields: []types.StructFieldName{
					"PC",
					"Func",
					"File",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "Summarizer",
				Fields: []types.StructFieldName{
					"gs",
					"tasks",
					"syscallingP",
					"syscallingG",
					"rangesP",
					"lastTs",
					"syncTs",
				},
				Description: "",
			},
			structSet{
				Name: "Summary",
				Fields: []types.StructFieldName{
					"Goroutines",
					"Tasks",
				},
				Description: "",
			},
			structSet{
				Name: "Task",
				Fields: []types.StructFieldName{
					"ID",
					"Parent",
					"Type",
				},
				Description: "",
			},
			structSet{
				Name: "UserRegionSummary",
				Fields: []types.StructFieldName{
					"TaskID",
					"Name",
					"Start",
					"End",
					"GoroutineExecStats",
				},
				Description: "",
			},
			structSet{
				Name: "UserTaskSummary",
				Fields: []types.StructFieldName{
					"ID",
					"Name",
					"Parent",
					"Children",
					"Start",
					"End",
					"Logs",
					"Regions",
					"Goroutines",
				},
				Description: "",
			},
			structSet{
				Name: "UtilWindow",
				Fields: []types.StructFieldName{
					"Time",
					"MutatorUtil",
				},
				Description: "",
			},
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"kind",
					"pointer",
					"scalar",
				},
				Description: "",
			},
		},
		"elf": []structSet{
			structSet{
				Name: "Chdr32",
				Fields: []types.StructFieldName{
					"Type",
					"Size",
					"Addralign",
				},
				Description: "",
			},
			structSet{
				Name: "Chdr64",
				Fields: []types.StructFieldName{
					"Type",
					"_",
					"Size",
					"Addralign",
				},
				Description: "",
			},
			structSet{
				Name: "Dyn32",
				Fields: []types.StructFieldName{
					"Tag",
					"Val",
				},
				Description: "",
			},
			structSet{
				Name: "Dyn64",
				Fields: []types.StructFieldName{
					"Tag",
					"Val",
				},
				Description: "",
			},
			structSet{
				Name: "DynamicVersion",
				Fields: []types.StructFieldName{
					"Name",
					"Index",
					"Flags",
					"Deps",
				},
				Description: "",
			},
			structSet{
				Name: "DynamicVersionDep",
				Fields: []types.StructFieldName{
					"Flags",
					"Index",
					"Dep",
				},
				Description: "",
			},
			structSet{
				Name: "DynamicVersionNeed",
				Fields: []types.StructFieldName{
					"Name",
					"Needs",
				},
				Description: "",
			},
			structSet{
				Name: "File",
				Fields: []types.StructFieldName{
					"FileHeader",
					"Sections",
					"Progs",
					"closer",
					"dynVers",
					"dynVerNeeds",
					"gnuVersym",
				},
				Description: "",
			},
			structSet{
				Name: "FileHeader",
				Fields: []types.StructFieldName{
					"Class",
					"Data",
					"Version",
					"OSABI",
					"ABIVersion",
					"ByteOrder",
					"Type",
					"Machine",
					"Entry",
				},
				Description: "",
			},
			structSet{
				Name: "FormatError",
				Fields: []types.StructFieldName{
					"off",
					"msg",
					"val",
				},
				Description: "",
			},
			structSet{
				Name: "Header32",
				Fields: []types.StructFieldName{
					"Ident",
					"Type",
					"Machine",
					"Version",
					"Entry",
					"Phoff",
					"Shoff",
					"Flags",
					"Ehsize",
					"Phentsize",
					"Phnum",
					"Shentsize",
					"Shnum",
					"Shstrndx",
				},
				Description: "",
			},
			structSet{
				Name: "Header64",
				Fields: []types.StructFieldName{
					"Ident",
					"Type",
					"Machine",
					"Version",
					"Entry",
					"Phoff",
					"Shoff",
					"Flags",
					"Ehsize",
					"Phentsize",
					"Phnum",
					"Shentsize",
					"Shnum",
					"Shstrndx",
				},
				Description: "",
			},
			structSet{
				Name: "ImportedSymbol",
				Fields: []types.StructFieldName{
					"Name",
					"Version",
					"Library",
				},
				Description: "",
			},
			structSet{
				Name: "Prog",
				Fields: []types.StructFieldName{
					"ProgHeader",
					"ReaderAt",
					"sr",
				},
				Description: "",
			},
			structSet{
				Name: "Prog32",
				Fields: []types.StructFieldName{
					"Type",
					"Off",
					"Vaddr",
					"Paddr",
					"Filesz",
					"Memsz",
					"Flags",
					"Align",
				},
				Description: "",
			},
			structSet{
				Name: "Prog64",
				Fields: []types.StructFieldName{
					"Type",
					"Flags",
					"Off",
					"Vaddr",
					"Paddr",
					"Filesz",
					"Memsz",
					"Align",
				},
				Description: "",
			},
			structSet{
				Name: "ProgHeader",
				Fields: []types.StructFieldName{
					"Type",
					"Flags",
					"Off",
					"Vaddr",
					"Paddr",
					"Filesz",
					"Memsz",
					"Align",
				},
				Description: "",
			},
			structSet{
				Name: "Rel32",
				Fields: []types.StructFieldName{
					"Off",
					"Info",
				},
				Description: "",
			},
			structSet{
				Name: "Rel64",
				Fields: []types.StructFieldName{
					"Off",
					"Info",
				},
				Description: "",
			},
			structSet{
				Name: "Rela32",
				Fields: []types.StructFieldName{
					"Off",
					"Info",
					"Addend",
				},
				Description: "",
			},
			structSet{
				Name: "Rela64",
				Fields: []types.StructFieldName{
					"Off",
					"Info",
					"Addend",
				},
				Description: "",
			},
			structSet{
				Name: "Section",
				Fields: []types.StructFieldName{
					"SectionHeader",
					"ReaderAt",
					"sr",
					"compressionType",
					"compressionOffset",
				},
				Description: "",
			},
			structSet{
				Name: "Section32",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Flags",
					"Addr",
					"Off",
					"Size",
					"Link",
					"Info",
					"Addralign",
					"Entsize",
				},
				Description: "",
			},
			structSet{
				Name: "Section64",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Flags",
					"Addr",
					"Off",
					"Size",
					"Link",
					"Info",
					"Addralign",
					"Entsize",
				},
				Description: "",
			},
			structSet{
				Name: "SectionHeader",
				Fields: []types.StructFieldName{
					"Name",
					"Type",
					"Flags",
					"Addr",
					"Offset",
					"Size",
					"Link",
					"Info",
					"Addralign",
					"Entsize",
					"FileSize",
				},
				Description: "",
			},
			structSet{
				Name: "Sym32",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
					"Size",
					"Info",
					"Other",
					"Shndx",
				},
				Description: "",
			},
			structSet{
				Name: "Sym64",
				Fields: []types.StructFieldName{
					"Name",
					"Info",
					"Other",
					"Shndx",
					"Value",
					"Size",
				},
				Description: "",
			},
			structSet{
				Name: "Symbol",
				Fields: []types.StructFieldName{
					"Name",
					"Info",
					"Other",
					"HasVersion",
					"VersionIndex",
					"Section",
					"Value",
					"Size",
					"Version",
					"Library",
				},
				Description: "",
			},
		},
		"textproto": []structSet{
			structSet{
				Name: "Conn",
				Fields: []types.StructFieldName{
					"Reader",
					"Writer",
					"Pipeline",
					"conn",
				},
				Description: "",
			},
			structSet{
				Name: "Error",
				Fields: []types.StructFieldName{
					"Code",
					"Msg",
				},
				Description: "",
			},
			structSet{
				Name: "Pipeline",
				Fields: []types.StructFieldName{
					"mu",
					"id",
					"request",
					"response",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"R",
					"dot",
					"buf",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"W",
					"dot",
				},
				Description: "",
			},
		},
		"profilerecord": []structSet{
			structSet{
				Name: "BlockProfileRecord",
				Fields: []types.StructFieldName{
					"Count",
					"Cycles",
					"Stack",
				},
				Description: "",
			},
			structSet{
				Name: "MemProfileRecord",
				Fields: []types.StructFieldName{
					"AllocBytes",
					"FreeBytes",
					"AllocObjects",
					"FreeObjects",
					"Stack",
				},
				Description: "",
			},
			structSet{
				Name: "StackRecord",
				Fields: []types.StructFieldName{
					"Stack",
				},
				Description: "",
			},
		},
		"user": []structSet{
			structSet{
				Name: "Group",
				Fields: []types.StructFieldName{
					"Gid",
					"Name",
				},
				Description: "",
			},
			structSet{
				Name: "User",
				Fields: []types.StructFieldName{
					"Uid",
					"Gid",
					"Username",
					"Name",
					"HomeDir",
				},
				Description: "",
			},
		},
		"edwards25519": []structSet{
			structSet{
				Name: "Point",
				Fields: []types.StructFieldName{
					"_",
					"x",
					"y",
					"z",
					"t",
				},
				Description: "",
			},
			structSet{
				Name: "Scalar",
				Fields: []types.StructFieldName{
					"s",
				},
				Description: "",
			},
		},
		"ssh": []structSet{
			structSet{
				Name: "Direction",
				Fields: []types.StructFieldName{
					"ivTag",
					"keyTag",
					"macKeyTag",
				},
				Description: "",
			},
		},
		"routebsd": []structSet{
			structSet{
				Name: "InetAddr",
				Fields: []types.StructFieldName{
					"IP",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceAddrMessage",
				Fields: []types.StructFieldName{
					"Version",
					"Type",
					"Flags",
					"Index",
					"Addrs",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceMessage",
				Fields: []types.StructFieldName{
					"Version",
					"Type",
					"Flags",
					"Index",
					"Name",
					"Addrs",
					"extOff",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "InterfaceMulticastAddrMessage",
				Fields: []types.StructFieldName{
					"Version",
					"Type",
					"Flags",
					"Index",
					"Addrs",
					"raw",
				},
				Description: "",
			},
			structSet{
				Name: "LinkAddr",
				Fields: []types.StructFieldName{
					"Index",
					"Name",
					"Addr",
				},
				Description: "",
			},
		},
		"rtcov": []structSet{
			structSet{
				Name: "CovCounterBlob",
				Fields: []types.StructFieldName{
					"Counters",
					"Len",
				},
				Description: "",
			},
			structSet{
				Name: "CovMetaBlob",
				Fields: []types.StructFieldName{
					"P",
					"Len",
					"Hash",
					"PkgPath",
					"PkgID",
					"CounterMode",
					"CounterGranularity",
				},
				Description: "",
			},
		},
		"sha512": []structSet{
			structSet{
				Name: "Digest",
				Fields: []types.StructFieldName{
					"h",
					"x",
					"nx",
					"len",
					"size",
				},
				Description: "",
			},
		},
		"doc": []structSet{
			structSet{
				Name: "Example",
				Fields: []types.StructFieldName{
					"Name",
					"Suffix",
					"Doc",
					"Code",
					"Play",
					"Comments",
					"Output",
					"Unordered",
					"EmptyOutput",
					"Order",
				},
				Description: "",
			},
			structSet{
				Name: "Func",
				Fields: []types.StructFieldName{
					"Doc",
					"Name",
					"Decl",
					"Recv",
					"Orig",
					"Level",
					"Examples",
				},
				Description: "",
			},
			structSet{
				Name: "Note",
				Fields: []types.StructFieldName{
					"Pos",
					"End",
					"UID",
					"Body",
				},
				Description: "",
			},
			structSet{
				Name: "Package",
				Fields: []types.StructFieldName{
					"Doc",
					"Name",
					"ImportPath",
					"Imports",
					"Filenames",
					"Notes",
					"Bugs",
					"Consts",
					"Types",
					"Vars",
					"Funcs",
					"Examples",
					"importByName",
					"syms",
				},
				Description: "",
			},
			structSet{
				Name: "Type",
				Fields: []types.StructFieldName{
					"Doc",
					"Name",
					"Decl",
					"Consts",
					"Vars",
					"Funcs",
					"Methods",
					"Examples",
				},
				Description: "",
			},
			structSet{
				Name: "Value",
				Fields: []types.StructFieldName{
					"Doc",
					"Names",
					"Decl",
					"order",
				},
				Description: "",
			},
		},
		"rpc": []structSet{
			structSet{
				Name: "Call",
				Fields: []types.StructFieldName{
					"ServiceMethod",
					"Args",
					"Reply",
					"Error",
					"Done",
				},
				Description: "",
			},
			structSet{
				Name: "Client",
				Fields: []types.StructFieldName{
					"codec",
					"reqMutex",
					"request",
					"mutex",
					"seq",
					"pending",
					"closing",
					"shutdown",
				},
				Description: "",
			},
			structSet{
				Name: "Request",
				Fields: []types.StructFieldName{
					"ServiceMethod",
					"Seq",
					"next",
				},
				Description: "",
			},
			structSet{
				Name: "Response",
				Fields: []types.StructFieldName{
					"ServiceMethod",
					"Seq",
					"Error",
					"next",
				},
				Description: "",
			},
			structSet{
				Name: "Server",
				Fields: []types.StructFieldName{
					"serviceMap",
					"reqLock",
					"freeReq",
					"respLock",
					"freeResp",
				},
				Description: "",
			},
		},
		"example2": []structSet{
			structSet{
				Name: "MyStruct",
				Fields: []types.StructFieldName{
					"MyStructs",
					"MyStruct",
				},
				Description: "",
			},
		},
		"hmac": []structSet{
			structSet{
				Name: "HMAC",
				Fields: []types.StructFieldName{
					"opad",
					"ipad",
					"outer",
					"inner",
					"marshaled",
					"forHKDF",
					"keyLen",
				},
				Description: "",
			},
		},
		"nettrace": []structSet{
			structSet{
				Name:        "LookupIPAltResolverKey",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
			structSet{
				Name: "Trace",
				Fields: []types.StructFieldName{
					"DNSStart",
					"DNSDone",
					"ConnectStart",
					"ConnectDone",
				},
				Description: "",
			},
			structSet{
				Name:        "TraceKey",
				Fields:      []types.StructFieldName{},
				Description: "",
			},
		},
		"srcimporter": []structSet{
			structSet{
				Name: "Importer",
				Fields: []types.StructFieldName{
					"ctxt",
					"fset",
					"sizes",
					"packages",
				},
				Description: "",
			},
		},
		"gif": []structSet{
			structSet{
				Name: "GIF",
				Fields: []types.StructFieldName{
					"Image",
					"Delay",
					"LoopCount",
					"Disposal",
					"Config",
					"BackgroundIndex",
				},
				Description: "",
			},
			structSet{
				Name: "Options",
				Fields: []types.StructFieldName{
					"NumColors",
					"Quantizer",
					"Drawer",
				},
				Description: "",
			},
		},
		"mail": []structSet{
			structSet{
				Name: "Address",
				Fields: []types.StructFieldName{
					"Name",
					"Address",
				},
				Description: "",
			},
			structSet{
				Name: "AddressParser",
				Fields: []types.StructFieldName{
					"WordDecoder",
				},
				Description: "",
			},
			structSet{
				Name: "Message",
				Fields: []types.StructFieldName{
					"Header",
					"Body",
				},
				Description: "",
			},
		},
		"smtp": []structSet{
			structSet{
				Name: "Client",
				Fields: []types.StructFieldName{
					"Text",
					"conn",
					"tls",
					"serverName",
					"ext",
					"auth",
					"localName",
					"didHello",
					"helloError",
				},
				Description: "",
			},
			structSet{
				Name: "ServerInfo",
				Fields: []types.StructFieldName{
					"Name",
					"TLS",
					"Auth",
				},
				Description: "",
			},
		},
		"plugin": []structSet{
			structSet{
				Name: "Plugin",
				Fields: []types.StructFieldName{
					"pluginpath",
					"err",
					"loaded",
					"syms",
				},
				Description: "",
			},
		},
		"tar": []structSet{
			structSet{
				Name: "Header",
				Fields: []types.StructFieldName{
					"Typeflag",
					"Name",
					"Linkname",
					"Size",
					"Mode",
					"Uid",
					"Gid",
					"Uname",
					"Gname",
					"ModTime",
					"AccessTime",
					"ChangeTime",
					"Devmajor",
					"Devminor",
					"Xattrs",
					"PAXRecords",
					"Format",
				},
				Description: "",
			},
			structSet{
				Name: "Reader",
				Fields: []types.StructFieldName{
					"r",
					"pad",
					"curr",
					"blk",
					"err",
				},
				Description: "",
			},
			structSet{
				Name: "Writer",
				Fields: []types.StructFieldName{
					"w",
					"pad",
					"curr",
					"hdr",
					"blk",
					"err",
				},
				Description: "",
			},
		},
		"ecdh": []structSet{
			structSet{
				Name: "Curve",
				Fields: []types.StructFieldName{
					"curve",
					"newPoint",
					"N",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"pub",
					"d",
				},
				Description: "",
			},
			structSet{
				Name: "PrivateKey",
				Fields: []types.StructFieldName{
					"curve",
					"privateKey",
					"publicKey",
					"boring",
					"fips",
				},
				Description: "",
			},
			structSet{
				Name: "PublicKey",
				Fields: []types.StructFieldName{
					"curve",
					"publicKey",
					"boring",
					"fips",
				},
				Description: "",
			},
		},
		"elliptic": []structSet{
			structSet{
				Name: "CurveParams",
				Fields: []types.StructFieldName{
					"P",
					"N",
					"B",
					"Gx",
					"Gy",
					"BitSize",
					"Name",
				},
				Description: "",
			},
		},
		"base64": []structSet{
			structSet{
				Name: "Encoding",
				Fields: []types.StructFieldName{
					"encode",
					"decodeMap",
					"padChar",
					"strict",
				},
				Description: "",
			},
		},
		"xml": []structSet{
			structSet{
				Name: "Attr",
				Fields: []types.StructFieldName{
					"Name",
					"Value",
				},
				Description: "",
			},
			structSet{
				Name: "Decoder",
				Fields: []types.StructFieldName{
					"Strict",
					"AutoClose",
					"Entity",
					"CharsetReader",
					"DefaultSpace",
					"r",
					"t",
					"buf",
					"saved",
					"stk",
					"free",
					"needClose",
					"toClose",
					"nextToken",
					"nextByte",
					"ns",
					"err",
					"line",
					"linestart",
					"offset",
					"unmarshalDepth",
				},
				Description: "",
			},
			structSet{
				Name: "Encoder",
				Fields: []types.StructFieldName{
					"p",
				},
				Description: "",
			},
			structSet{
				Name: "EndElement",
				Fields: []types.StructFieldName{
					"Name",
				},
				Description: "",
			},
			structSet{
				Name: "Name",
				Fields: []types.StructFieldName{
					"Space",
					"Local",
				},
				Description: "",
			},
			structSet{
				Name: "ProcInst",
				Fields: []types.StructFieldName{
					"Target",
					"Inst",
				},
				Description: "",
			},
			structSet{
				Name: "StartElement",
				Fields: []types.StructFieldName{
					"Name",
					"Attr",
				},
				Description: "",
			},
			structSet{
				Name: "SyntaxError",
				Fields: []types.StructFieldName{
					"Msg",
					"Line",
				},
				Description: "",
			},
			structSet{
				Name: "TagPathError",
				Fields: []types.StructFieldName{
					"Struct",
					"Field1",
					"Tag1",
					"Field2",
					"Tag2",
				},
				Description: "",
			},
			structSet{
				Name: "UnsupportedTypeError",
				Fields: []types.StructFieldName{
					"Type",
				},
				Description: "",
			},
		},
		"httptrace": []structSet{
			structSet{
				Name: "ClientTrace",
				Fields: []types.StructFieldName{
					"GetConn",
					"GotConn",
					"PutIdleConn",
					"GotFirstResponseByte",
					"Got100Continue",
					"Got1xxResponse",
					"DNSStart",
					"DNSDone",
					"ConnectStart",
					"ConnectDone",
					"TLSHandshakeStart",
					"TLSHandshakeDone",
					"WroteHeaderField",
					"WroteHeaders",
					"Wait100Continue",
					"WroteRequest",
				},
				Description: "",
			},
			structSet{
				Name: "DNSDoneInfo",
				Fields: []types.StructFieldName{
					"Addrs",
					"Err",
					"Coalesced",
				},
				Description: "",
			},
			structSet{
				Name: "DNSStartInfo",
				Fields: []types.StructFieldName{
					"Host",
				},
				Description: "",
			},
			structSet{
				Name: "GotConnInfo",
				Fields: []types.StructFieldName{
					"Conn",
					"Reused",
					"WasIdle",
					"IdleTime",
				},
				Description: "",
			},
			structSet{
				Name: "WroteRequestInfo",
				Fields: []types.StructFieldName{
					"Err",
				},
				Description: "",
			},
		},
	},
	Interfaces: map[types.PkgName][]interfaceSet{
		"bisect": []interfaceSet{
			interfaceSet{
				Name: "Writer",
				Methods: []types.DeclName{
					"Write",
				},
				Descriptions: []string{},
			},
		},
		"testlog": []interfaceSet{
			interfaceSet{
				Name: "Interface",
				Methods: []types.DeclName{
					"Chdir",
					"Getenv",
					"Open",
					"Stat",
				},
				Descriptions: []string{},
			},
		},
		"crypto": []interfaceSet{
			interfaceSet{
				Name: "Decrypter",
				Methods: []types.DeclName{
					"Decrypt",
					"Public",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "DecrypterOpts",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "MessageSigner",
				Methods: []types.DeclName{
					"Public",
					"Sign",
					"SignMessage",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "PrivateKey",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "PublicKey",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Signer",
				Methods: []types.DeclName{
					"Public",
					"Sign",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "SignerOpts",
				Methods: []types.DeclName{
					"HashFunc",
				},
				Descriptions: []string{},
			},
		},
		"slog": []interfaceSet{
			interfaceSet{
				Name: "Handler",
				Methods: []types.DeclName{
					"Enabled",
					"Handle",
					"WithAttrs",
					"WithGroup",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Leveler",
				Methods: []types.DeclName{
					"Level",
				},
				Descriptions: []string{},
			},
		},
		"smtp": []interfaceSet{
			interfaceSet{
				Name: "Auth",
				Methods: []types.DeclName{
					"Next",
					"Start",
				},
				Descriptions: []string{},
			},
		},
		"ecdsa": []interfaceSet{
			interfaceSet{
				Name: "Point",
				Methods: []types.DeclName{
					"Add",
					"Bytes",
					"BytesX",
					"ScalarBaseMult",
					"ScalarMult",
					"SetBytes",
				},
				Descriptions: []string{},
			},
		},
		"sql": []interfaceSet{
			interfaceSet{
				Name: "Result",
				Methods: []types.DeclName{
					"LastInsertId",
					"RowsAffected",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Scanner",
				Methods: []types.DeclName{
					"Scan",
				},
				Descriptions: []string{},
			},
		},
		"multipart": []interfaceSet{
			interfaceSet{
				Name: "File",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"ReadAt",
					"Seek",
				},
				Descriptions: []string{},
			},
		},
		"jpeg": []interfaceSet{
			interfaceSet{
				Name: "Reader",
				Methods: []types.DeclName{
					"Read",
					"ReadByte",
				},
				Descriptions: []string{},
			},
		},
		"reflect": []interfaceSet{
			interfaceSet{
				Name: "Type",
				Methods: []types.DeclName{
					"Align",
					"AssignableTo",
					"Bits",
					"CanSeq",
					"CanSeq2",
					"ChanDir",
					"Comparable",
					"ConvertibleTo",
					"Elem",
					"Field",
					"FieldAlign",
					"FieldByIndex",
					"FieldByName",
					"FieldByNameFunc",
					"Implements",
					"In",
					"IsVariadic",
					"Key",
					"Kind",
					"Len",
					"Method",
					"MethodByName",
					"Name",
					"NumField",
					"NumIn",
					"NumMethod",
					"NumOut",
					"Out",
					"OverflowComplex",
					"OverflowFloat",
					"OverflowInt",
					"OverflowUint",
					"PkgPath",
					"Size",
					"String",
					"common",
					"uncommon",
				},
				Descriptions: []string{},
			},
		},
		"zlib": []interfaceSet{
			interfaceSet{
				Name: "Resetter",
				Methods: []types.DeclName{
					"Reset",
				},
				Descriptions: []string{},
			},
		},
		"elliptic": []interfaceSet{
			interfaceSet{
				Name: "Curve",
				Methods: []types.DeclName{
					"Add",
					"Double",
					"IsOnCurve",
					"Params",
					"ScalarBaseMult",
					"ScalarMult",
				},
				Descriptions: []string{},
			},
		},
		"flag": []interfaceSet{
			interfaceSet{
				Name: "Getter",
				Methods: []types.DeclName{
					"Get",
					"Set",
					"String",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Value",
				Methods: []types.DeclName{
					"Set",
					"String",
				},
				Descriptions: []string{},
			},
		},
		"testing": []interfaceSet{
			interfaceSet{
				Name: "TB",
				Methods: []types.DeclName{
					"Attr",
					"Chdir",
					"Cleanup",
					"Context",
					"Error",
					"Errorf",
					"Fail",
					"FailNow",
					"Failed",
					"Fatal",
					"Fatalf",
					"Helper",
					"Log",
					"Logf",
					"Name",
					"Output",
					"Setenv",
					"Skip",
					"SkipNow",
					"Skipf",
					"Skipped",
					"TempDir",
					"private",
				},
				Descriptions: []string{},
			},
		},
		"plugin": []interfaceSet{
			interfaceSet{
				Name:         "Symbol",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
		},
		"hash": []interfaceSet{
			interfaceSet{
				Name: "Cloner",
				Methods: []types.DeclName{
					"BlockSize",
					"Clone",
					"Reset",
					"Size",
					"Sum",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Hash",
				Methods: []types.DeclName{
					"BlockSize",
					"Reset",
					"Size",
					"Sum",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Hash32",
				Methods: []types.DeclName{
					"BlockSize",
					"Reset",
					"Size",
					"Sum",
					"Sum32",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Hash64",
				Methods: []types.DeclName{
					"BlockSize",
					"Reset",
					"Size",
					"Sum",
					"Sum64",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "XOF",
				Methods: []types.DeclName{
					"BlockSize",
					"Read",
					"Reset",
					"Write",
				},
				Descriptions: []string{},
			},
		},
		"json": []interfaceSet{
			interfaceSet{
				Name: "Marshaler",
				Methods: []types.DeclName{
					"MarshalJSON",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "Token",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Unmarshaler",
				Methods: []types.DeclName{
					"UnmarshalJSON",
				},
				Descriptions: []string{},
			},
		},
		"tls": []interfaceSet{
			interfaceSet{
				Name: "ClientSessionCache",
				Methods: []types.DeclName{
					"Get",
					"Put",
				},
				Descriptions: []string{},
			},
		},
		"gob": []interfaceSet{
			interfaceSet{
				Name: "GobDecoder",
				Methods: []types.DeclName{
					"GobDecode",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "GobEncoder",
				Methods: []types.DeclName{
					"GobEncode",
				},
				Descriptions: []string{},
			},
		},
		"draw": []interfaceSet{
			interfaceSet{
				Name: "Drawer",
				Methods: []types.DeclName{
					"Draw",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Image",
				Methods: []types.DeclName{
					"At",
					"Bounds",
					"ColorModel",
					"Set",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Quantizer",
				Methods: []types.DeclName{
					"Quantize",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RGBA64Image",
				Methods: []types.DeclName{
					"At",
					"Bounds",
					"ColorModel",
					"RGBA64At",
					"Set",
					"SetRGBA64",
				},
				Descriptions: []string{},
			},
		},
		"ecdh": []interfaceSet{
			interfaceSet{
				Name: "Point",
				Methods: []types.DeclName{
					"Bytes",
					"BytesX",
					"ScalarBaseMult",
					"ScalarMult",
					"SetBytes",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Curve",
				Methods: []types.DeclName{
					"GenerateKey",
					"NewPrivateKey",
					"NewPublicKey",
					"ecdh",
				},
				Descriptions: []string{},
			},
		},
		"os": []interfaceSet{
			interfaceSet{
				Name: "DirEntry",
				Methods: []types.DeclName{
					"Info",
					"IsDir",
					"Name",
					"Type",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "FileInfo",
				Methods: []types.DeclName{
					"IsDir",
					"ModTime",
					"Mode",
					"Name",
					"Size",
					"Sys",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Signal",
				Methods: []types.DeclName{
					"Signal",
					"String",
				},
				Descriptions: []string{},
			},
		},
		"syscall": []interfaceSet{
			interfaceSet{
				Name: "Conn",
				Methods: []types.DeclName{
					"SyscallConn",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RawConn",
				Methods: []types.DeclName{
					"Control",
					"Read",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RoutingMessage",
				Methods: []types.DeclName{
					"sockaddr",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Sockaddr",
				Methods: []types.DeclName{
					"sockaddr",
				},
				Descriptions: []string{},
			},
		},
		"encoding": []interfaceSet{
			interfaceSet{
				Name: "BinaryAppender",
				Methods: []types.DeclName{
					"AppendBinary",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "BinaryMarshaler",
				Methods: []types.DeclName{
					"MarshalBinary",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "BinaryUnmarshaler",
				Methods: []types.DeclName{
					"UnmarshalBinary",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "TextAppender",
				Methods: []types.DeclName{
					"AppendText",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "TextMarshaler",
				Methods: []types.DeclName{
					"MarshalText",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "TextUnmarshaler",
				Methods: []types.DeclName{
					"UnmarshalText",
				},
				Descriptions: []string{},
			},
		},
		"image": []interfaceSet{
			interfaceSet{
				Name: "Image",
				Methods: []types.DeclName{
					"At",
					"Bounds",
					"ColorModel",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "PalettedImage",
				Methods: []types.DeclName{
					"At",
					"Bounds",
					"ColorIndexAt",
					"ColorModel",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RGBA64Image",
				Methods: []types.DeclName{
					"At",
					"Bounds",
					"ColorModel",
					"RGBA64At",
				},
				Descriptions: []string{},
			},
		},
		"tar": []interfaceSet{
			interfaceSet{
				Name: "FileInfoNames",
				Methods: []types.DeclName{
					"Gname",
					"IsDir",
					"ModTime",
					"Mode",
					"Name",
					"Size",
					"Sys",
					"Uname",
				},
				Descriptions: []string{},
			},
		},
		"routebsd": []interfaceSet{
			interfaceSet{
				Name: "Addr",
				Methods: []types.DeclName{
					"Family",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Message",
				Methods: []types.DeclName{
					"message",
				},
				Descriptions: []string{},
			},
		},
		"macho": []interfaceSet{
			interfaceSet{
				Name: "Load",
				Methods: []types.DeclName{
					"Raw",
				},
				Descriptions: []string{},
			},
		},
		"cipher": []interfaceSet{
			interfaceSet{
				Name: "AEAD",
				Methods: []types.DeclName{
					"NonceSize",
					"Open",
					"Overhead",
					"Seal",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Block",
				Methods: []types.DeclName{
					"BlockSize",
					"Decrypt",
					"Encrypt",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "BlockMode",
				Methods: []types.DeclName{
					"BlockSize",
					"CryptBlocks",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Stream",
				Methods: []types.DeclName{
					"XORKeyStream",
				},
				Descriptions: []string{},
			},
		},
		"parse": []interfaceSet{
			interfaceSet{
				Name: "Node",
				Methods: []types.DeclName{
					"Copy",
					"Position",
					"String",
					"Type",
					"tree",
					"writeTo",
				},
				Descriptions: []string{},
			},
		},
		"httputil": []interfaceSet{
			interfaceSet{
				Name: "BufferPool",
				Methods: []types.DeclName{
					"Get",
					"Put",
				},
				Descriptions: []string{},
			},
		},
		"quick": []interfaceSet{
			interfaceSet{
				Name: "Generator",
				Methods: []types.DeclName{
					"Generate",
				},
				Descriptions: []string{},
			},
		},
		"binary": []interfaceSet{
			interfaceSet{
				Name: "AppendByteOrder",
				Methods: []types.DeclName{
					"AppendUint16",
					"AppendUint32",
					"AppendUint64",
					"String",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ByteOrder",
				Methods: []types.DeclName{
					"PutUint16",
					"PutUint32",
					"PutUint64",
					"String",
					"Uint16",
					"Uint32",
					"Uint64",
				},
				Descriptions: []string{},
			},
		},
		"heap": []interfaceSet{
			interfaceSet{
				Name: "Interface",
				Methods: []types.DeclName{
					"Len",
					"Less",
					"Pop",
					"Push",
					"Swap",
				},
				Descriptions: []string{},
			},
		},
		"context": []interfaceSet{
			interfaceSet{
				Name: "Context",
				Methods: []types.DeclName{
					"Deadline",
					"Done",
					"Err",
					"Value",
				},
				Descriptions: []string{},
			},
		},
		"cmp": []interfaceSet{
			interfaceSet{
				Name:         "Ordered",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
		},
		"net": []interfaceSet{
			interfaceSet{
				Name: "Addr",
				Methods: []types.DeclName{
					"Network",
					"String",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Conn",
				Methods: []types.DeclName{
					"Close",
					"LocalAddr",
					"Read",
					"RemoteAddr",
					"SetDeadline",
					"SetReadDeadline",
					"SetWriteDeadline",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Listener",
				Methods: []types.DeclName{
					"Accept",
					"Addr",
					"Close",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "PacketConn",
				Methods: []types.DeclName{
					"Close",
					"LocalAddr",
					"ReadFrom",
					"SetDeadline",
					"SetReadDeadline",
					"SetWriteDeadline",
					"WriteTo",
				},
				Descriptions: []string{},
			},
		},
		"encodecounter": []interfaceSet{
			interfaceSet{
				Name: "CounterVisitor",
				Methods: []types.DeclName{
					"VisitFuncs",
				},
				Descriptions: []string{},
			},
		},
		"dwarf": []interfaceSet{
			interfaceSet{
				Name: "Type",
				Methods: []types.DeclName{
					"Common",
					"Size",
					"String",
				},
				Descriptions: []string{},
			},
		},
		"xml": []interfaceSet{
			interfaceSet{
				Name: "Marshaler",
				Methods: []types.DeclName{
					"MarshalXML",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "MarshalerAttr",
				Methods: []types.DeclName{
					"MarshalXMLAttr",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "Token",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "TokenReader",
				Methods: []types.DeclName{
					"Token",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Unmarshaler",
				Methods: []types.DeclName{
					"UnmarshalXML",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "UnmarshalerAttr",
				Methods: []types.DeclName{
					"UnmarshalXMLAttr",
				},
				Descriptions: []string{},
			},
		},
		"ast": []interfaceSet{
			interfaceSet{
				Name: "Decl",
				Methods: []types.DeclName{
					"End",
					"Pos",
					"declNode",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Expr",
				Methods: []types.DeclName{
					"End",
					"Pos",
					"exprNode",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Node",
				Methods: []types.DeclName{
					"End",
					"Pos",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Spec",
				Methods: []types.DeclName{
					"End",
					"Pos",
					"specNode",
				},
				Descriptions: []string{
					"The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec. ",
				},
			},
			interfaceSet{
				Name: "Stmt",
				Methods: []types.DeclName{
					"End",
					"Pos",
					"stmtNode",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Visitor",
				Methods: []types.DeclName{
					"Visit",
				},
				Descriptions: []string{},
			},
		},
		"constraint": []interfaceSet{
			interfaceSet{
				Name: "Expr",
				Methods: []types.DeclName{
					"Eval",
					"String",
					"isExpr",
				},
				Descriptions: []string{},
			},
		},
		"color": []interfaceSet{
			interfaceSet{
				Name: "Color",
				Methods: []types.DeclName{
					"RGBA",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Model",
				Methods: []types.DeclName{
					"Convert",
				},
				Descriptions: []string{},
			},
		},
		"png": []interfaceSet{
			interfaceSet{
				Name: "EncoderBufferPool",
				Methods: []types.DeclName{
					"Get",
					"Put",
				},
				Descriptions: []string{},
			},
		},
		"reflectlite": []interfaceSet{
			interfaceSet{
				Name: "Type",
				Methods: []types.DeclName{
					"AssignableTo",
					"Comparable",
					"Elem",
					"Implements",
					"Kind",
					"Name",
					"PkgPath",
					"Size",
					"String",
					"common",
					"uncommon",
				},
				Descriptions: []string{},
			},
		},
		"fs": []interfaceSet{
			interfaceSet{
				Name: "DirEntry",
				Methods: []types.DeclName{
					"Info",
					"IsDir",
					"Name",
					"Type",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "FS",
				Methods: []types.DeclName{
					"Open",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "File",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"Stat",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "FileInfo",
				Methods: []types.DeclName{
					"IsDir",
					"ModTime",
					"Mode",
					"Name",
					"Size",
					"Sys",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "GlobFS",
				Methods: []types.DeclName{
					"Glob",
					"Open",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadDirFS",
				Methods: []types.DeclName{
					"Open",
					"ReadDir",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadDirFile",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"ReadDir",
					"Stat",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadFileFS",
				Methods: []types.DeclName{
					"Open",
					"ReadFile",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadLinkFS",
				Methods: []types.DeclName{
					"Lstat",
					"Open",
					"ReadLink",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "StatFS",
				Methods: []types.DeclName{
					"Open",
					"Stat",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "SubFS",
				Methods: []types.DeclName{
					"Open",
					"Sub",
				},
				Descriptions: []string{},
			},
		},
		"fips140": []interfaceSet{
			interfaceSet{
				Name: "Hash",
				Methods: []types.DeclName{
					"BlockSize",
					"Reset",
					"Size",
					"Sum",
					"Write",
				},
				Descriptions: []string{},
			},
		},
		"rand": []interfaceSet{
			interfaceSet{
				Name: "Source",
				Methods: []types.DeclName{
					"Uint64",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Source",
				Methods: []types.DeclName{
					"Int63",
					"Seed",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Source64",
				Methods: []types.DeclName{
					"Int63",
					"Seed",
					"Uint64",
				},
				Descriptions: []string{},
			},
		},
		"constant": []interfaceSet{
			interfaceSet{
				Name: "Value",
				Methods: []types.DeclName{
					"ExactString",
					"Kind",
					"String",
					"implementsValue",
				},
				Descriptions: []string{},
			},
		},
		"io": []interfaceSet{
			interfaceSet{
				Name: "ByteReader",
				Methods: []types.DeclName{
					"ReadByte",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ByteScanner",
				Methods: []types.DeclName{
					"ReadByte",
					"UnreadByte",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ByteWriter",
				Methods: []types.DeclName{
					"WriteByte",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Closer",
				Methods: []types.DeclName{
					"Close",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadCloser",
				Methods: []types.DeclName{
					"Close",
					"Read",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadSeekCloser",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"Seek",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadSeeker",
				Methods: []types.DeclName{
					"Read",
					"Seek",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadWriteCloser",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadWriteSeeker",
				Methods: []types.DeclName{
					"Read",
					"Seek",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReadWriter",
				Methods: []types.DeclName{
					"Read",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Reader",
				Methods: []types.DeclName{
					"Read",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReaderAt",
				Methods: []types.DeclName{
					"ReadAt",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ReaderFrom",
				Methods: []types.DeclName{
					"ReadFrom",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RuneReader",
				Methods: []types.DeclName{
					"ReadRune",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RuneScanner",
				Methods: []types.DeclName{
					"ReadRune",
					"UnreadRune",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Seeker",
				Methods: []types.DeclName{
					"Seek",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "StringWriter",
				Methods: []types.DeclName{
					"WriteString",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "WriteCloser",
				Methods: []types.DeclName{
					"Close",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "WriteSeeker",
				Methods: []types.DeclName{
					"Seek",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Writer",
				Methods: []types.DeclName{
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "WriterAt",
				Methods: []types.DeclName{
					"WriteAt",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "WriterTo",
				Methods: []types.DeclName{
					"WriteTo",
				},
				Descriptions: []string{},
			},
		},
		"drbg": []interfaceSet{
			interfaceSet{
				Name: "DefaultReader",
				Methods: []types.DeclName{
					"defaultReader",
				},
				Descriptions: []string{},
			},
		},
		"comment": []interfaceSet{
			interfaceSet{
				Name: "Block",
				Methods: []types.DeclName{
					"block",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Text",
				Methods: []types.DeclName{
					"text",
				},
				Descriptions: []string{},
			},
		},
		"cookiejar": []interfaceSet{
			interfaceSet{
				Name: "PublicSuffixList",
				Methods: []types.DeclName{
					"PublicSuffix",
					"String",
				},
				Descriptions: []string{},
			},
		},
		"rpc": []interfaceSet{
			interfaceSet{
				Name: "ClientCodec",
				Methods: []types.DeclName{
					"Close",
					"ReadResponseBody",
					"ReadResponseHeader",
					"WriteRequest",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ServerCodec",
				Methods: []types.DeclName{
					"Close",
					"ReadRequestBody",
					"ReadRequestHeader",
					"WriteResponse",
				},
				Descriptions: []string{},
			},
		},
		"flate": []interfaceSet{
			interfaceSet{
				Name: "Reader",
				Methods: []types.DeclName{
					"Read",
					"ReadByte",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Resetter",
				Methods: []types.DeclName{
					"Reset",
				},
				Descriptions: []string{},
			},
		},
		"http": []interfaceSet{
			interfaceSet{
				Name: "CloseNotifier",
				Methods: []types.DeclName{
					"CloseNotify",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "CookieJar",
				Methods: []types.DeclName{
					"Cookies",
					"SetCookies",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "File",
				Methods: []types.DeclName{
					"Close",
					"Read",
					"Readdir",
					"Seek",
					"Stat",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "FileSystem",
				Methods: []types.DeclName{
					"Open",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Flusher",
				Methods: []types.DeclName{
					"Flush",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Hijacker",
				Methods: []types.DeclName{
					"Hijack",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Pusher",
				Methods: []types.DeclName{
					"Push",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ResponseWriter",
				Methods: []types.DeclName{
					"Header",
					"Write",
					"WriteHeader",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RoundTripper",
				Methods: []types.DeclName{
					"RoundTrip",
				},
				Descriptions: []string{},
			},
		},
		"types": []interfaceSet{
			interfaceSet{
				Name: "Importer",
				Methods: []types.DeclName{
					"Import",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ImporterFrom",
				Methods: []types.DeclName{
					"Import",
					"ImportFrom",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Object",
				Methods: []types.DeclName{
					"Exported",
					"Id",
					"Name",
					"Parent",
					"Pkg",
					"Pos",
					"String",
					"Type",
					"color",
					"order",
					"sameId",
					"scopePos",
					"setColor",
					"setOrder",
					"setParent",
					"setScopePos",
					"setType",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Sizes",
				Methods: []types.DeclName{
					"Alignof",
					"Offsetsof",
					"Sizeof",
				},
				Descriptions: []string{},
			},
		},
		"fmt": []interfaceSet{
			interfaceSet{
				Name: "Formatter",
				Methods: []types.DeclName{
					"Format",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "GoStringer",
				Methods: []types.DeclName{
					"GoString",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ScanState",
				Methods: []types.DeclName{
					"Read",
					"ReadRune",
					"SkipSpace",
					"Token",
					"UnreadRune",
					"Width",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Scanner",
				Methods: []types.DeclName{
					"Scan",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "State",
				Methods: []types.DeclName{
					"Flag",
					"Precision",
					"Width",
					"Write",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Stringer",
				Methods: []types.DeclName{
					"String",
				},
				Descriptions: []string{},
			},
		},
		"sort": []interfaceSet{
			interfaceSet{
				Name: "Interface",
				Methods: []types.DeclName{
					"Len",
					"Less",
					"Swap",
				},
				Descriptions: []string{},
			},
		},
		"runtime": []interfaceSet{
			interfaceSet{
				Name: "Error",
				Methods: []types.DeclName{
					"Error",
					"RuntimeError",
				},
				Descriptions: []string{},
			},
		},
		"sync": []interfaceSet{
			interfaceSet{
				Name: "Locker",
				Methods: []types.DeclName{
					"Lock",
					"Unlock",
				},
				Descriptions: []string{},
			},
		},
		"expvar": []interfaceSet{
			interfaceSet{
				Name: "Var",
				Methods: []types.DeclName{
					"String",
				},
				Descriptions: []string{},
			},
		},
		"pkgbits": []interfaceSet{
			interfaceSet{
				Name: "Code",
				Methods: []types.DeclName{
					"Marker",
					"Value",
				},
				Descriptions: []string{},
			},
		},
		"driver": []interfaceSet{
			interfaceSet{
				Name: "ColumnConverter",
				Methods: []types.DeclName{
					"ColumnConverter",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Conn",
				Methods: []types.DeclName{
					"Begin",
					"Close",
					"Prepare",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ConnBeginTx",
				Methods: []types.DeclName{
					"BeginTx",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ConnPrepareContext",
				Methods: []types.DeclName{
					"PrepareContext",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Connector",
				Methods: []types.DeclName{
					"Connect",
					"Driver",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Driver",
				Methods: []types.DeclName{
					"Open",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "DriverContext",
				Methods: []types.DeclName{
					"OpenConnector",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Execer",
				Methods: []types.DeclName{
					"Exec",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ExecerContext",
				Methods: []types.DeclName{
					"ExecContext",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "NamedValueChecker",
				Methods: []types.DeclName{
					"CheckNamedValue",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Pinger",
				Methods: []types.DeclName{
					"Ping",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Queryer",
				Methods: []types.DeclName{
					"Query",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "QueryerContext",
				Methods: []types.DeclName{
					"QueryContext",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Result",
				Methods: []types.DeclName{
					"LastInsertId",
					"RowsAffected",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Rows",
				Methods: []types.DeclName{
					"Close",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsColumnTypeDatabaseTypeName",
				Methods: []types.DeclName{
					"Close",
					"ColumnTypeDatabaseTypeName",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsColumnTypeLength",
				Methods: []types.DeclName{
					"Close",
					"ColumnTypeLength",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsColumnTypeNullable",
				Methods: []types.DeclName{
					"Close",
					"ColumnTypeNullable",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsColumnTypePrecisionScale",
				Methods: []types.DeclName{
					"Close",
					"ColumnTypePrecisionScale",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsColumnTypeScanType",
				Methods: []types.DeclName{
					"Close",
					"ColumnTypeScanType",
					"Columns",
					"Next",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "RowsNextResultSet",
				Methods: []types.DeclName{
					"Close",
					"Columns",
					"HasNextResultSet",
					"Next",
					"NextResultSet",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "SessionResetter",
				Methods: []types.DeclName{
					"ResetSession",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Stmt",
				Methods: []types.DeclName{
					"Close",
					"Exec",
					"NumInput",
					"Query",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "StmtExecContext",
				Methods: []types.DeclName{
					"ExecContext",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "StmtQueryContext",
				Methods: []types.DeclName{
					"QueryContext",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Tx",
				Methods: []types.DeclName{
					"Commit",
					"Rollback",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Validator",
				Methods: []types.DeclName{
					"IsValid",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name:         "Value",
				Methods:      []types.DeclName{},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "ValueConverter",
				Methods: []types.DeclName{
					"ConvertValue",
				},
				Descriptions: []string{},
			},
			interfaceSet{
				Name: "Valuer",
				Methods: []types.DeclName{
					"Value",
				},
				Descriptions: []string{},
			},
		},
	},
}
