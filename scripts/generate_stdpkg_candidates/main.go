package main

import (
	"bytes"
	"fmt"
	"go/build"
	"go/format"
	"os"
	"reflect"
	"runtime"
	"strings"

	"github.com/kakkky/gonsole/completer"
)

//go:generate go run scripts/generate_stdpkg_candidates/main.go
func main() {
	goSrcRoot := build.Default.GOROOT + "/src"
	completer.BuildStdPkgCandidatesMode = true
	defer func() { completer.BuildStdPkgCandidatesMode = false }()
	c, err := completer.NewCandidates(goSrcRoot)
	if err != nil {
		panic(err)
	}
	builtGoVersion := runtime.Version()

	var buf bytes.Buffer
	buf.WriteString("package completer\n\n")
	buf.WriteString("import \"github.com/kakkky/gonsole/types\"\n\n")
	buf.WriteString("var stdPkgCandidates = ")
	formatValue(&buf, reflect.ValueOf(c), 0)
	buf.WriteString("\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	f, err := os.Create("completer/gen_stdpkg_candidates.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err := fmt.Fprintf(f, "// Code generated by scripts/generate_stdpkg_candidates/main.go; DO NOT EDIT.\n"); err != nil {
		panic(err)
	}
	if _, err := fmt.Fprintf(f, "// Version: %s\n\n", builtGoVersion); err != nil {
		panic(err)
	}
	if _, err := f.Write(formatted); err != nil {
		panic(err)
	}
}

func formatValue(buf *bytes.Buffer, v reflect.Value, indent int) {
	if !v.IsValid() {
		buf.WriteString("nil")
		return
	}

	// ポインタの場合はデリファレンス
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			buf.WriteString("nil")
			return
		}
		buf.WriteString("&")
		formatValue(buf, v.Elem(), indent)
		return
	}

	switch v.Kind() {
	case reflect.Struct:
		buf.WriteString(v.Type().Name())
		buf.WriteString("{\n")
		for i := 0; i < v.NumField(); i++ {
			field := v.Type().Field(i)
			if !field.IsExported() {
				continue
			}
			buf.WriteString(strings.Repeat("\t", indent+1))
			buf.WriteString(field.Name)
			buf.WriteString(": ")
			formatValue(buf, v.Field(i), indent+1)
			buf.WriteString(",\n")
		}
		buf.WriteString(strings.Repeat("\t", indent))
		buf.WriteString("}")

	case reflect.Slice:
		if v.Len() == 0 {
			buf.WriteString(typeNameWithoutPkg(v.Type()))
			buf.WriteString("{}")
			return
		}
		buf.WriteString(typeNameWithoutPkg(v.Type()))
		buf.WriteString("{\n")
		for i := 0; i < v.Len(); i++ {
			buf.WriteString(strings.Repeat("\t", indent+1))
			formatValue(buf, v.Index(i), indent+1)
			buf.WriteString(",\n")
		}
		buf.WriteString(strings.Repeat("\t", indent))
		buf.WriteString("}")

	case reflect.Map:
		if v.Len() == 0 {
			buf.WriteString(typeNameWithoutPkg(v.Type()))
			buf.WriteString("{}")
			return
		}
		buf.WriteString(typeNameWithoutPkg(v.Type()))
		buf.WriteString("{\n")
		for _, key := range v.MapKeys() {
			buf.WriteString(strings.Repeat("\t", indent+1))
			formatValue(buf, key, indent+1)
			buf.WriteString(": ")
			formatValue(buf, v.MapIndex(key), indent+1)
			buf.WriteString(",\n")
		}
		buf.WriteString(strings.Repeat("\t", indent))
		buf.WriteString("}")

	case reflect.String:
		s := v.String()
		// タブや改行を空白に置き換え
		s = strings.ReplaceAll(s, "\t", " ")
		s = strings.ReplaceAll(s, "\n", " ")
		s = strings.ReplaceAll(s, "\r", " ")
		// 連続する空白を1つにまとめる
		for strings.Contains(s, "  ") {
			s = strings.ReplaceAll(s, "  ", " ")
		}
		fmt.Fprintf(buf, "%q", s)

	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		fmt.Fprintf(buf, "%d", v.Int())

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		fmt.Fprintf(buf, "%d", v.Uint())

	case reflect.Float32, reflect.Float64:
		buf.WriteString(fmt.Sprintf("%g", v.Float()))

	case reflect.Bool:
		buf.WriteString(fmt.Sprintf("%t", v.Bool()))

	default:
		buf.WriteString(fmt.Sprintf("%#v", v.Interface()))
	}
}

// typeNameWithoutPkg はパッケージ名を除いた型名を返す
func typeNameWithoutPkg(t reflect.Type) string {
	fullName := t.String()
	// "[]completer.funcSet" -> "[]funcSet"
	// "map[types.PkgName][]completer.funcSet" -> "map[types.PkgName][]funcSet"
	// パッケージ名の部分を削除
	result := strings.ReplaceAll(fullName, "completer.", "")
	return result
}
